/*eslint-disable block-scoped-var, id-length, no-control-regex, no-magic-numbers, no-prototype-builtins, no-redeclare, no-shadow, no-var, sort-vars*/
"use strict";

var $protobuf = require("protobufjs/minimal");

// Common aliases
var $Reader = $protobuf.Reader, $Writer = $protobuf.Writer, $util = $protobuf.util;

// Exported root namespace
var $root = $protobuf.roots["default"] || ($protobuf.roots["default"] = {});

$root.AndroidAppDeliveryData = (function() {

    /**
     * Properties of an AndroidAppDeliveryData.
     * @exports IAndroidAppDeliveryData
     * @interface IAndroidAppDeliveryData
     * @property {number|Long|null} [downloadSize] AndroidAppDeliveryData downloadSize
     * @property {string|null} [sha1] AndroidAppDeliveryData sha1
     * @property {string|null} [downloadUrl] AndroidAppDeliveryData downloadUrl
     * @property {Array.<IAppFileMetadata>|null} [additionalFile] AndroidAppDeliveryData additionalFile
     * @property {Array.<IHttpCookie>|null} [downloadAuthCookie] AndroidAppDeliveryData downloadAuthCookie
     * @property {boolean|null} [forwardLocked] AndroidAppDeliveryData forwardLocked
     * @property {number|Long|null} [refundTimeout] AndroidAppDeliveryData refundTimeout
     * @property {boolean|null} [serverInitiated] AndroidAppDeliveryData serverInitiated
     * @property {number|Long|null} [postInstallRefundWindowMillis] AndroidAppDeliveryData postInstallRefundWindowMillis
     * @property {boolean|null} [immediateStartNeeded] AndroidAppDeliveryData immediateStartNeeded
     * @property {IAndroidAppPatchData|null} [patchData] AndroidAppDeliveryData patchData
     * @property {IEncryptionParams|null} [encryptionParams] AndroidAppDeliveryData encryptionParams
     * @property {string|null} [compressedDownloadUrl] AndroidAppDeliveryData compressedDownloadUrl
     * @property {number|Long|null} [compressedSize] AndroidAppDeliveryData compressedSize
     * @property {Array.<ISplitDeliveryData>|null} [splitDeliveryData] AndroidAppDeliveryData splitDeliveryData
     * @property {number|null} [installLocation] AndroidAppDeliveryData installLocation
     * @property {number|Long|null} [type] AndroidAppDeliveryData type
     * @property {ICompressedAppData|null} [compressedAppData] AndroidAppDeliveryData compressedAppData
     * @property {string|null} [sha256] AndroidAppDeliveryData sha256
     */

    /**
     * Constructs a new AndroidAppDeliveryData.
     * @exports AndroidAppDeliveryData
     * @classdesc Represents an AndroidAppDeliveryData.
     * @implements IAndroidAppDeliveryData
     * @constructor
     * @param {IAndroidAppDeliveryData=} [properties] Properties to set
     */
    function AndroidAppDeliveryData(properties) {
        this.additionalFile = [];
        this.downloadAuthCookie = [];
        this.splitDeliveryData = [];
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * AndroidAppDeliveryData downloadSize.
     * @member {number|Long} downloadSize
     * @memberof AndroidAppDeliveryData
     * @instance
     */
    AndroidAppDeliveryData.prototype.downloadSize = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

    /**
     * AndroidAppDeliveryData sha1.
     * @member {string} sha1
     * @memberof AndroidAppDeliveryData
     * @instance
     */
    AndroidAppDeliveryData.prototype.sha1 = "";

    /**
     * AndroidAppDeliveryData downloadUrl.
     * @member {string} downloadUrl
     * @memberof AndroidAppDeliveryData
     * @instance
     */
    AndroidAppDeliveryData.prototype.downloadUrl = "";

    /**
     * AndroidAppDeliveryData additionalFile.
     * @member {Array.<IAppFileMetadata>} additionalFile
     * @memberof AndroidAppDeliveryData
     * @instance
     */
    AndroidAppDeliveryData.prototype.additionalFile = $util.emptyArray;

    /**
     * AndroidAppDeliveryData downloadAuthCookie.
     * @member {Array.<IHttpCookie>} downloadAuthCookie
     * @memberof AndroidAppDeliveryData
     * @instance
     */
    AndroidAppDeliveryData.prototype.downloadAuthCookie = $util.emptyArray;

    /**
     * AndroidAppDeliveryData forwardLocked.
     * @member {boolean} forwardLocked
     * @memberof AndroidAppDeliveryData
     * @instance
     */
    AndroidAppDeliveryData.prototype.forwardLocked = false;

    /**
     * AndroidAppDeliveryData refundTimeout.
     * @member {number|Long} refundTimeout
     * @memberof AndroidAppDeliveryData
     * @instance
     */
    AndroidAppDeliveryData.prototype.refundTimeout = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

    /**
     * AndroidAppDeliveryData serverInitiated.
     * @member {boolean} serverInitiated
     * @memberof AndroidAppDeliveryData
     * @instance
     */
    AndroidAppDeliveryData.prototype.serverInitiated = true;

    /**
     * AndroidAppDeliveryData postInstallRefundWindowMillis.
     * @member {number|Long} postInstallRefundWindowMillis
     * @memberof AndroidAppDeliveryData
     * @instance
     */
    AndroidAppDeliveryData.prototype.postInstallRefundWindowMillis = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

    /**
     * AndroidAppDeliveryData immediateStartNeeded.
     * @member {boolean} immediateStartNeeded
     * @memberof AndroidAppDeliveryData
     * @instance
     */
    AndroidAppDeliveryData.prototype.immediateStartNeeded = false;

    /**
     * AndroidAppDeliveryData patchData.
     * @member {IAndroidAppPatchData|null|undefined} patchData
     * @memberof AndroidAppDeliveryData
     * @instance
     */
    AndroidAppDeliveryData.prototype.patchData = null;

    /**
     * AndroidAppDeliveryData encryptionParams.
     * @member {IEncryptionParams|null|undefined} encryptionParams
     * @memberof AndroidAppDeliveryData
     * @instance
     */
    AndroidAppDeliveryData.prototype.encryptionParams = null;

    /**
     * AndroidAppDeliveryData compressedDownloadUrl.
     * @member {string} compressedDownloadUrl
     * @memberof AndroidAppDeliveryData
     * @instance
     */
    AndroidAppDeliveryData.prototype.compressedDownloadUrl = "";

    /**
     * AndroidAppDeliveryData compressedSize.
     * @member {number|Long} compressedSize
     * @memberof AndroidAppDeliveryData
     * @instance
     */
    AndroidAppDeliveryData.prototype.compressedSize = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

    /**
     * AndroidAppDeliveryData splitDeliveryData.
     * @member {Array.<ISplitDeliveryData>} splitDeliveryData
     * @memberof AndroidAppDeliveryData
     * @instance
     */
    AndroidAppDeliveryData.prototype.splitDeliveryData = $util.emptyArray;

    /**
     * AndroidAppDeliveryData installLocation.
     * @member {number} installLocation
     * @memberof AndroidAppDeliveryData
     * @instance
     */
    AndroidAppDeliveryData.prototype.installLocation = 0;

    /**
     * AndroidAppDeliveryData type.
     * @member {number|Long} type
     * @memberof AndroidAppDeliveryData
     * @instance
     */
    AndroidAppDeliveryData.prototype.type = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

    /**
     * AndroidAppDeliveryData compressedAppData.
     * @member {ICompressedAppData|null|undefined} compressedAppData
     * @memberof AndroidAppDeliveryData
     * @instance
     */
    AndroidAppDeliveryData.prototype.compressedAppData = null;

    /**
     * AndroidAppDeliveryData sha256.
     * @member {string} sha256
     * @memberof AndroidAppDeliveryData
     * @instance
     */
    AndroidAppDeliveryData.prototype.sha256 = "";

    /**
     * Creates a new AndroidAppDeliveryData instance using the specified properties.
     * @function create
     * @memberof AndroidAppDeliveryData
     * @static
     * @param {IAndroidAppDeliveryData=} [properties] Properties to set
     * @returns {AndroidAppDeliveryData} AndroidAppDeliveryData instance
     */
    AndroidAppDeliveryData.create = function create(properties) {
        return new AndroidAppDeliveryData(properties);
    };

    /**
     * Encodes the specified AndroidAppDeliveryData message. Does not implicitly {@link AndroidAppDeliveryData.verify|verify} messages.
     * @function encode
     * @memberof AndroidAppDeliveryData
     * @static
     * @param {IAndroidAppDeliveryData} message AndroidAppDeliveryData message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    AndroidAppDeliveryData.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.downloadSize != null && Object.hasOwnProperty.call(message, "downloadSize"))
            writer.uint32(/* id 1, wireType 0 =*/8).int64(message.downloadSize);
        if (message.sha1 != null && Object.hasOwnProperty.call(message, "sha1"))
            writer.uint32(/* id 2, wireType 2 =*/18).string(message.sha1);
        if (message.downloadUrl != null && Object.hasOwnProperty.call(message, "downloadUrl"))
            writer.uint32(/* id 3, wireType 2 =*/26).string(message.downloadUrl);
        if (message.additionalFile != null && message.additionalFile.length)
            for (var i = 0; i < message.additionalFile.length; ++i)
                $root.AppFileMetadata.encode(message.additionalFile[i], writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
        if (message.downloadAuthCookie != null && message.downloadAuthCookie.length)
            for (var i = 0; i < message.downloadAuthCookie.length; ++i)
                $root.HttpCookie.encode(message.downloadAuthCookie[i], writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
        if (message.forwardLocked != null && Object.hasOwnProperty.call(message, "forwardLocked"))
            writer.uint32(/* id 6, wireType 0 =*/48).bool(message.forwardLocked);
        if (message.refundTimeout != null && Object.hasOwnProperty.call(message, "refundTimeout"))
            writer.uint32(/* id 7, wireType 0 =*/56).int64(message.refundTimeout);
        if (message.serverInitiated != null && Object.hasOwnProperty.call(message, "serverInitiated"))
            writer.uint32(/* id 8, wireType 0 =*/64).bool(message.serverInitiated);
        if (message.postInstallRefundWindowMillis != null && Object.hasOwnProperty.call(message, "postInstallRefundWindowMillis"))
            writer.uint32(/* id 9, wireType 0 =*/72).int64(message.postInstallRefundWindowMillis);
        if (message.immediateStartNeeded != null && Object.hasOwnProperty.call(message, "immediateStartNeeded"))
            writer.uint32(/* id 10, wireType 0 =*/80).bool(message.immediateStartNeeded);
        if (message.patchData != null && Object.hasOwnProperty.call(message, "patchData"))
            $root.AndroidAppPatchData.encode(message.patchData, writer.uint32(/* id 11, wireType 2 =*/90).fork()).ldelim();
        if (message.encryptionParams != null && Object.hasOwnProperty.call(message, "encryptionParams"))
            $root.EncryptionParams.encode(message.encryptionParams, writer.uint32(/* id 12, wireType 2 =*/98).fork()).ldelim();
        if (message.compressedDownloadUrl != null && Object.hasOwnProperty.call(message, "compressedDownloadUrl"))
            writer.uint32(/* id 13, wireType 2 =*/106).string(message.compressedDownloadUrl);
        if (message.compressedSize != null && Object.hasOwnProperty.call(message, "compressedSize"))
            writer.uint32(/* id 14, wireType 0 =*/112).int64(message.compressedSize);
        if (message.splitDeliveryData != null && message.splitDeliveryData.length)
            for (var i = 0; i < message.splitDeliveryData.length; ++i)
                $root.SplitDeliveryData.encode(message.splitDeliveryData[i], writer.uint32(/* id 15, wireType 2 =*/122).fork()).ldelim();
        if (message.installLocation != null && Object.hasOwnProperty.call(message, "installLocation"))
            writer.uint32(/* id 16, wireType 0 =*/128).int32(message.installLocation);
        if (message.type != null && Object.hasOwnProperty.call(message, "type"))
            writer.uint32(/* id 17, wireType 0 =*/136).int64(message.type);
        if (message.compressedAppData != null && Object.hasOwnProperty.call(message, "compressedAppData"))
            $root.CompressedAppData.encode(message.compressedAppData, writer.uint32(/* id 18, wireType 2 =*/146).fork()).ldelim();
        if (message.sha256 != null && Object.hasOwnProperty.call(message, "sha256"))
            writer.uint32(/* id 19, wireType 2 =*/154).string(message.sha256);
        return writer;
    };

    /**
     * Encodes the specified AndroidAppDeliveryData message, length delimited. Does not implicitly {@link AndroidAppDeliveryData.verify|verify} messages.
     * @function encodeDelimited
     * @memberof AndroidAppDeliveryData
     * @static
     * @param {IAndroidAppDeliveryData} message AndroidAppDeliveryData message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    AndroidAppDeliveryData.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes an AndroidAppDeliveryData message from the specified reader or buffer.
     * @function decode
     * @memberof AndroidAppDeliveryData
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {AndroidAppDeliveryData} AndroidAppDeliveryData
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    AndroidAppDeliveryData.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.AndroidAppDeliveryData();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.downloadSize = reader.int64();
                break;
            case 2:
                message.sha1 = reader.string();
                break;
            case 3:
                message.downloadUrl = reader.string();
                break;
            case 4:
                if (!(message.additionalFile && message.additionalFile.length))
                    message.additionalFile = [];
                message.additionalFile.push($root.AppFileMetadata.decode(reader, reader.uint32()));
                break;
            case 5:
                if (!(message.downloadAuthCookie && message.downloadAuthCookie.length))
                    message.downloadAuthCookie = [];
                message.downloadAuthCookie.push($root.HttpCookie.decode(reader, reader.uint32()));
                break;
            case 6:
                message.forwardLocked = reader.bool();
                break;
            case 7:
                message.refundTimeout = reader.int64();
                break;
            case 8:
                message.serverInitiated = reader.bool();
                break;
            case 9:
                message.postInstallRefundWindowMillis = reader.int64();
                break;
            case 10:
                message.immediateStartNeeded = reader.bool();
                break;
            case 11:
                message.patchData = $root.AndroidAppPatchData.decode(reader, reader.uint32());
                break;
            case 12:
                message.encryptionParams = $root.EncryptionParams.decode(reader, reader.uint32());
                break;
            case 13:
                message.compressedDownloadUrl = reader.string();
                break;
            case 14:
                message.compressedSize = reader.int64();
                break;
            case 15:
                if (!(message.splitDeliveryData && message.splitDeliveryData.length))
                    message.splitDeliveryData = [];
                message.splitDeliveryData.push($root.SplitDeliveryData.decode(reader, reader.uint32()));
                break;
            case 16:
                message.installLocation = reader.int32();
                break;
            case 17:
                message.type = reader.int64();
                break;
            case 18:
                message.compressedAppData = $root.CompressedAppData.decode(reader, reader.uint32());
                break;
            case 19:
                message.sha256 = reader.string();
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes an AndroidAppDeliveryData message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof AndroidAppDeliveryData
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {AndroidAppDeliveryData} AndroidAppDeliveryData
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    AndroidAppDeliveryData.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies an AndroidAppDeliveryData message.
     * @function verify
     * @memberof AndroidAppDeliveryData
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    AndroidAppDeliveryData.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.downloadSize != null && message.hasOwnProperty("downloadSize"))
            if (!$util.isInteger(message.downloadSize) && !(message.downloadSize && $util.isInteger(message.downloadSize.low) && $util.isInteger(message.downloadSize.high)))
                return "downloadSize: integer|Long expected";
        if (message.sha1 != null && message.hasOwnProperty("sha1"))
            if (!$util.isString(message.sha1))
                return "sha1: string expected";
        if (message.downloadUrl != null && message.hasOwnProperty("downloadUrl"))
            if (!$util.isString(message.downloadUrl))
                return "downloadUrl: string expected";
        if (message.additionalFile != null && message.hasOwnProperty("additionalFile")) {
            if (!Array.isArray(message.additionalFile))
                return "additionalFile: array expected";
            for (var i = 0; i < message.additionalFile.length; ++i) {
                var error = $root.AppFileMetadata.verify(message.additionalFile[i]);
                if (error)
                    return "additionalFile." + error;
            }
        }
        if (message.downloadAuthCookie != null && message.hasOwnProperty("downloadAuthCookie")) {
            if (!Array.isArray(message.downloadAuthCookie))
                return "downloadAuthCookie: array expected";
            for (var i = 0; i < message.downloadAuthCookie.length; ++i) {
                var error = $root.HttpCookie.verify(message.downloadAuthCookie[i]);
                if (error)
                    return "downloadAuthCookie." + error;
            }
        }
        if (message.forwardLocked != null && message.hasOwnProperty("forwardLocked"))
            if (typeof message.forwardLocked !== "boolean")
                return "forwardLocked: boolean expected";
        if (message.refundTimeout != null && message.hasOwnProperty("refundTimeout"))
            if (!$util.isInteger(message.refundTimeout) && !(message.refundTimeout && $util.isInteger(message.refundTimeout.low) && $util.isInteger(message.refundTimeout.high)))
                return "refundTimeout: integer|Long expected";
        if (message.serverInitiated != null && message.hasOwnProperty("serverInitiated"))
            if (typeof message.serverInitiated !== "boolean")
                return "serverInitiated: boolean expected";
        if (message.postInstallRefundWindowMillis != null && message.hasOwnProperty("postInstallRefundWindowMillis"))
            if (!$util.isInteger(message.postInstallRefundWindowMillis) && !(message.postInstallRefundWindowMillis && $util.isInteger(message.postInstallRefundWindowMillis.low) && $util.isInteger(message.postInstallRefundWindowMillis.high)))
                return "postInstallRefundWindowMillis: integer|Long expected";
        if (message.immediateStartNeeded != null && message.hasOwnProperty("immediateStartNeeded"))
            if (typeof message.immediateStartNeeded !== "boolean")
                return "immediateStartNeeded: boolean expected";
        if (message.patchData != null && message.hasOwnProperty("patchData")) {
            var error = $root.AndroidAppPatchData.verify(message.patchData);
            if (error)
                return "patchData." + error;
        }
        if (message.encryptionParams != null && message.hasOwnProperty("encryptionParams")) {
            var error = $root.EncryptionParams.verify(message.encryptionParams);
            if (error)
                return "encryptionParams." + error;
        }
        if (message.compressedDownloadUrl != null && message.hasOwnProperty("compressedDownloadUrl"))
            if (!$util.isString(message.compressedDownloadUrl))
                return "compressedDownloadUrl: string expected";
        if (message.compressedSize != null && message.hasOwnProperty("compressedSize"))
            if (!$util.isInteger(message.compressedSize) && !(message.compressedSize && $util.isInteger(message.compressedSize.low) && $util.isInteger(message.compressedSize.high)))
                return "compressedSize: integer|Long expected";
        if (message.splitDeliveryData != null && message.hasOwnProperty("splitDeliveryData")) {
            if (!Array.isArray(message.splitDeliveryData))
                return "splitDeliveryData: array expected";
            for (var i = 0; i < message.splitDeliveryData.length; ++i) {
                var error = $root.SplitDeliveryData.verify(message.splitDeliveryData[i]);
                if (error)
                    return "splitDeliveryData." + error;
            }
        }
        if (message.installLocation != null && message.hasOwnProperty("installLocation"))
            if (!$util.isInteger(message.installLocation))
                return "installLocation: integer expected";
        if (message.type != null && message.hasOwnProperty("type"))
            if (!$util.isInteger(message.type) && !(message.type && $util.isInteger(message.type.low) && $util.isInteger(message.type.high)))
                return "type: integer|Long expected";
        if (message.compressedAppData != null && message.hasOwnProperty("compressedAppData")) {
            var error = $root.CompressedAppData.verify(message.compressedAppData);
            if (error)
                return "compressedAppData." + error;
        }
        if (message.sha256 != null && message.hasOwnProperty("sha256"))
            if (!$util.isString(message.sha256))
                return "sha256: string expected";
        return null;
    };

    /**
     * Creates an AndroidAppDeliveryData message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof AndroidAppDeliveryData
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {AndroidAppDeliveryData} AndroidAppDeliveryData
     */
    AndroidAppDeliveryData.fromObject = function fromObject(object) {
        if (object instanceof $root.AndroidAppDeliveryData)
            return object;
        var message = new $root.AndroidAppDeliveryData();
        if (object.downloadSize != null)
            if ($util.Long)
                (message.downloadSize = $util.Long.fromValue(object.downloadSize)).unsigned = false;
            else if (typeof object.downloadSize === "string")
                message.downloadSize = parseInt(object.downloadSize, 10);
            else if (typeof object.downloadSize === "number")
                message.downloadSize = object.downloadSize;
            else if (typeof object.downloadSize === "object")
                message.downloadSize = new $util.LongBits(object.downloadSize.low >>> 0, object.downloadSize.high >>> 0).toNumber();
        if (object.sha1 != null)
            message.sha1 = String(object.sha1);
        if (object.downloadUrl != null)
            message.downloadUrl = String(object.downloadUrl);
        if (object.additionalFile) {
            if (!Array.isArray(object.additionalFile))
                throw TypeError(".AndroidAppDeliveryData.additionalFile: array expected");
            message.additionalFile = [];
            for (var i = 0; i < object.additionalFile.length; ++i) {
                if (typeof object.additionalFile[i] !== "object")
                    throw TypeError(".AndroidAppDeliveryData.additionalFile: object expected");
                message.additionalFile[i] = $root.AppFileMetadata.fromObject(object.additionalFile[i]);
            }
        }
        if (object.downloadAuthCookie) {
            if (!Array.isArray(object.downloadAuthCookie))
                throw TypeError(".AndroidAppDeliveryData.downloadAuthCookie: array expected");
            message.downloadAuthCookie = [];
            for (var i = 0; i < object.downloadAuthCookie.length; ++i) {
                if (typeof object.downloadAuthCookie[i] !== "object")
                    throw TypeError(".AndroidAppDeliveryData.downloadAuthCookie: object expected");
                message.downloadAuthCookie[i] = $root.HttpCookie.fromObject(object.downloadAuthCookie[i]);
            }
        }
        if (object.forwardLocked != null)
            message.forwardLocked = Boolean(object.forwardLocked);
        if (object.refundTimeout != null)
            if ($util.Long)
                (message.refundTimeout = $util.Long.fromValue(object.refundTimeout)).unsigned = false;
            else if (typeof object.refundTimeout === "string")
                message.refundTimeout = parseInt(object.refundTimeout, 10);
            else if (typeof object.refundTimeout === "number")
                message.refundTimeout = object.refundTimeout;
            else if (typeof object.refundTimeout === "object")
                message.refundTimeout = new $util.LongBits(object.refundTimeout.low >>> 0, object.refundTimeout.high >>> 0).toNumber();
        if (object.serverInitiated != null)
            message.serverInitiated = Boolean(object.serverInitiated);
        if (object.postInstallRefundWindowMillis != null)
            if ($util.Long)
                (message.postInstallRefundWindowMillis = $util.Long.fromValue(object.postInstallRefundWindowMillis)).unsigned = false;
            else if (typeof object.postInstallRefundWindowMillis === "string")
                message.postInstallRefundWindowMillis = parseInt(object.postInstallRefundWindowMillis, 10);
            else if (typeof object.postInstallRefundWindowMillis === "number")
                message.postInstallRefundWindowMillis = object.postInstallRefundWindowMillis;
            else if (typeof object.postInstallRefundWindowMillis === "object")
                message.postInstallRefundWindowMillis = new $util.LongBits(object.postInstallRefundWindowMillis.low >>> 0, object.postInstallRefundWindowMillis.high >>> 0).toNumber();
        if (object.immediateStartNeeded != null)
            message.immediateStartNeeded = Boolean(object.immediateStartNeeded);
        if (object.patchData != null) {
            if (typeof object.patchData !== "object")
                throw TypeError(".AndroidAppDeliveryData.patchData: object expected");
            message.patchData = $root.AndroidAppPatchData.fromObject(object.patchData);
        }
        if (object.encryptionParams != null) {
            if (typeof object.encryptionParams !== "object")
                throw TypeError(".AndroidAppDeliveryData.encryptionParams: object expected");
            message.encryptionParams = $root.EncryptionParams.fromObject(object.encryptionParams);
        }
        if (object.compressedDownloadUrl != null)
            message.compressedDownloadUrl = String(object.compressedDownloadUrl);
        if (object.compressedSize != null)
            if ($util.Long)
                (message.compressedSize = $util.Long.fromValue(object.compressedSize)).unsigned = false;
            else if (typeof object.compressedSize === "string")
                message.compressedSize = parseInt(object.compressedSize, 10);
            else if (typeof object.compressedSize === "number")
                message.compressedSize = object.compressedSize;
            else if (typeof object.compressedSize === "object")
                message.compressedSize = new $util.LongBits(object.compressedSize.low >>> 0, object.compressedSize.high >>> 0).toNumber();
        if (object.splitDeliveryData) {
            if (!Array.isArray(object.splitDeliveryData))
                throw TypeError(".AndroidAppDeliveryData.splitDeliveryData: array expected");
            message.splitDeliveryData = [];
            for (var i = 0; i < object.splitDeliveryData.length; ++i) {
                if (typeof object.splitDeliveryData[i] !== "object")
                    throw TypeError(".AndroidAppDeliveryData.splitDeliveryData: object expected");
                message.splitDeliveryData[i] = $root.SplitDeliveryData.fromObject(object.splitDeliveryData[i]);
            }
        }
        if (object.installLocation != null)
            message.installLocation = object.installLocation | 0;
        if (object.type != null)
            if ($util.Long)
                (message.type = $util.Long.fromValue(object.type)).unsigned = false;
            else if (typeof object.type === "string")
                message.type = parseInt(object.type, 10);
            else if (typeof object.type === "number")
                message.type = object.type;
            else if (typeof object.type === "object")
                message.type = new $util.LongBits(object.type.low >>> 0, object.type.high >>> 0).toNumber();
        if (object.compressedAppData != null) {
            if (typeof object.compressedAppData !== "object")
                throw TypeError(".AndroidAppDeliveryData.compressedAppData: object expected");
            message.compressedAppData = $root.CompressedAppData.fromObject(object.compressedAppData);
        }
        if (object.sha256 != null)
            message.sha256 = String(object.sha256);
        return message;
    };

    /**
     * Creates a plain object from an AndroidAppDeliveryData message. Also converts values to other types if specified.
     * @function toObject
     * @memberof AndroidAppDeliveryData
     * @static
     * @param {AndroidAppDeliveryData} message AndroidAppDeliveryData
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    AndroidAppDeliveryData.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        var object = {};
        if (options.arrays || options.defaults) {
            object.additionalFile = [];
            object.downloadAuthCookie = [];
            object.splitDeliveryData = [];
        }
        if (options.defaults) {
            if ($util.Long) {
                var long = new $util.Long(0, 0, false);
                object.downloadSize = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
            } else
                object.downloadSize = options.longs === String ? "0" : 0;
            object.sha1 = "";
            object.downloadUrl = "";
            object.forwardLocked = false;
            if ($util.Long) {
                var long = new $util.Long(0, 0, false);
                object.refundTimeout = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
            } else
                object.refundTimeout = options.longs === String ? "0" : 0;
            object.serverInitiated = true;
            if ($util.Long) {
                var long = new $util.Long(0, 0, false);
                object.postInstallRefundWindowMillis = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
            } else
                object.postInstallRefundWindowMillis = options.longs === String ? "0" : 0;
            object.immediateStartNeeded = false;
            object.patchData = null;
            object.encryptionParams = null;
            object.compressedDownloadUrl = "";
            if ($util.Long) {
                var long = new $util.Long(0, 0, false);
                object.compressedSize = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
            } else
                object.compressedSize = options.longs === String ? "0" : 0;
            object.installLocation = 0;
            if ($util.Long) {
                var long = new $util.Long(0, 0, false);
                object.type = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
            } else
                object.type = options.longs === String ? "0" : 0;
            object.compressedAppData = null;
            object.sha256 = "";
        }
        if (message.downloadSize != null && message.hasOwnProperty("downloadSize"))
            if (typeof message.downloadSize === "number")
                object.downloadSize = options.longs === String ? String(message.downloadSize) : message.downloadSize;
            else
                object.downloadSize = options.longs === String ? $util.Long.prototype.toString.call(message.downloadSize) : options.longs === Number ? new $util.LongBits(message.downloadSize.low >>> 0, message.downloadSize.high >>> 0).toNumber() : message.downloadSize;
        if (message.sha1 != null && message.hasOwnProperty("sha1"))
            object.sha1 = message.sha1;
        if (message.downloadUrl != null && message.hasOwnProperty("downloadUrl"))
            object.downloadUrl = message.downloadUrl;
        if (message.additionalFile && message.additionalFile.length) {
            object.additionalFile = [];
            for (var j = 0; j < message.additionalFile.length; ++j)
                object.additionalFile[j] = $root.AppFileMetadata.toObject(message.additionalFile[j], options);
        }
        if (message.downloadAuthCookie && message.downloadAuthCookie.length) {
            object.downloadAuthCookie = [];
            for (var j = 0; j < message.downloadAuthCookie.length; ++j)
                object.downloadAuthCookie[j] = $root.HttpCookie.toObject(message.downloadAuthCookie[j], options);
        }
        if (message.forwardLocked != null && message.hasOwnProperty("forwardLocked"))
            object.forwardLocked = message.forwardLocked;
        if (message.refundTimeout != null && message.hasOwnProperty("refundTimeout"))
            if (typeof message.refundTimeout === "number")
                object.refundTimeout = options.longs === String ? String(message.refundTimeout) : message.refundTimeout;
            else
                object.refundTimeout = options.longs === String ? $util.Long.prototype.toString.call(message.refundTimeout) : options.longs === Number ? new $util.LongBits(message.refundTimeout.low >>> 0, message.refundTimeout.high >>> 0).toNumber() : message.refundTimeout;
        if (message.serverInitiated != null && message.hasOwnProperty("serverInitiated"))
            object.serverInitiated = message.serverInitiated;
        if (message.postInstallRefundWindowMillis != null && message.hasOwnProperty("postInstallRefundWindowMillis"))
            if (typeof message.postInstallRefundWindowMillis === "number")
                object.postInstallRefundWindowMillis = options.longs === String ? String(message.postInstallRefundWindowMillis) : message.postInstallRefundWindowMillis;
            else
                object.postInstallRefundWindowMillis = options.longs === String ? $util.Long.prototype.toString.call(message.postInstallRefundWindowMillis) : options.longs === Number ? new $util.LongBits(message.postInstallRefundWindowMillis.low >>> 0, message.postInstallRefundWindowMillis.high >>> 0).toNumber() : message.postInstallRefundWindowMillis;
        if (message.immediateStartNeeded != null && message.hasOwnProperty("immediateStartNeeded"))
            object.immediateStartNeeded = message.immediateStartNeeded;
        if (message.patchData != null && message.hasOwnProperty("patchData"))
            object.patchData = $root.AndroidAppPatchData.toObject(message.patchData, options);
        if (message.encryptionParams != null && message.hasOwnProperty("encryptionParams"))
            object.encryptionParams = $root.EncryptionParams.toObject(message.encryptionParams, options);
        if (message.compressedDownloadUrl != null && message.hasOwnProperty("compressedDownloadUrl"))
            object.compressedDownloadUrl = message.compressedDownloadUrl;
        if (message.compressedSize != null && message.hasOwnProperty("compressedSize"))
            if (typeof message.compressedSize === "number")
                object.compressedSize = options.longs === String ? String(message.compressedSize) : message.compressedSize;
            else
                object.compressedSize = options.longs === String ? $util.Long.prototype.toString.call(message.compressedSize) : options.longs === Number ? new $util.LongBits(message.compressedSize.low >>> 0, message.compressedSize.high >>> 0).toNumber() : message.compressedSize;
        if (message.splitDeliveryData && message.splitDeliveryData.length) {
            object.splitDeliveryData = [];
            for (var j = 0; j < message.splitDeliveryData.length; ++j)
                object.splitDeliveryData[j] = $root.SplitDeliveryData.toObject(message.splitDeliveryData[j], options);
        }
        if (message.installLocation != null && message.hasOwnProperty("installLocation"))
            object.installLocation = message.installLocation;
        if (message.type != null && message.hasOwnProperty("type"))
            if (typeof message.type === "number")
                object.type = options.longs === String ? String(message.type) : message.type;
            else
                object.type = options.longs === String ? $util.Long.prototype.toString.call(message.type) : options.longs === Number ? new $util.LongBits(message.type.low >>> 0, message.type.high >>> 0).toNumber() : message.type;
        if (message.compressedAppData != null && message.hasOwnProperty("compressedAppData"))
            object.compressedAppData = $root.CompressedAppData.toObject(message.compressedAppData, options);
        if (message.sha256 != null && message.hasOwnProperty("sha256"))
            object.sha256 = message.sha256;
        return object;
    };

    /**
     * Converts this AndroidAppDeliveryData to JSON.
     * @function toJSON
     * @memberof AndroidAppDeliveryData
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    AndroidAppDeliveryData.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return AndroidAppDeliveryData;
})();

$root.SplitDeliveryData = (function() {

    /**
     * Properties of a SplitDeliveryData.
     * @exports ISplitDeliveryData
     * @interface ISplitDeliveryData
     * @property {string|null} [name] SplitDeliveryData name
     * @property {number|Long|null} [downloadSize] SplitDeliveryData downloadSize
     * @property {number|Long|null} [compressedSize] SplitDeliveryData compressedSize
     * @property {string|null} [sha1] SplitDeliveryData sha1
     * @property {string|null} [downloadUrl] SplitDeliveryData downloadUrl
     * @property {string|null} [compressedDownloadUrl] SplitDeliveryData compressedDownloadUrl
     * @property {IAndroidAppPatchData|null} [patchData] SplitDeliveryData patchData
     * @property {ICompressedAppData|null} [compressedAppData] SplitDeliveryData compressedAppData
     * @property {string|null} [sha256] SplitDeliveryData sha256
     */

    /**
     * Constructs a new SplitDeliveryData.
     * @exports SplitDeliveryData
     * @classdesc Represents a SplitDeliveryData.
     * @implements ISplitDeliveryData
     * @constructor
     * @param {ISplitDeliveryData=} [properties] Properties to set
     */
    function SplitDeliveryData(properties) {
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * SplitDeliveryData name.
     * @member {string} name
     * @memberof SplitDeliveryData
     * @instance
     */
    SplitDeliveryData.prototype.name = "";

    /**
     * SplitDeliveryData downloadSize.
     * @member {number|Long} downloadSize
     * @memberof SplitDeliveryData
     * @instance
     */
    SplitDeliveryData.prototype.downloadSize = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

    /**
     * SplitDeliveryData compressedSize.
     * @member {number|Long} compressedSize
     * @memberof SplitDeliveryData
     * @instance
     */
    SplitDeliveryData.prototype.compressedSize = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

    /**
     * SplitDeliveryData sha1.
     * @member {string} sha1
     * @memberof SplitDeliveryData
     * @instance
     */
    SplitDeliveryData.prototype.sha1 = "";

    /**
     * SplitDeliveryData downloadUrl.
     * @member {string} downloadUrl
     * @memberof SplitDeliveryData
     * @instance
     */
    SplitDeliveryData.prototype.downloadUrl = "";

    /**
     * SplitDeliveryData compressedDownloadUrl.
     * @member {string} compressedDownloadUrl
     * @memberof SplitDeliveryData
     * @instance
     */
    SplitDeliveryData.prototype.compressedDownloadUrl = "";

    /**
     * SplitDeliveryData patchData.
     * @member {IAndroidAppPatchData|null|undefined} patchData
     * @memberof SplitDeliveryData
     * @instance
     */
    SplitDeliveryData.prototype.patchData = null;

    /**
     * SplitDeliveryData compressedAppData.
     * @member {ICompressedAppData|null|undefined} compressedAppData
     * @memberof SplitDeliveryData
     * @instance
     */
    SplitDeliveryData.prototype.compressedAppData = null;

    /**
     * SplitDeliveryData sha256.
     * @member {string} sha256
     * @memberof SplitDeliveryData
     * @instance
     */
    SplitDeliveryData.prototype.sha256 = "";

    /**
     * Creates a new SplitDeliveryData instance using the specified properties.
     * @function create
     * @memberof SplitDeliveryData
     * @static
     * @param {ISplitDeliveryData=} [properties] Properties to set
     * @returns {SplitDeliveryData} SplitDeliveryData instance
     */
    SplitDeliveryData.create = function create(properties) {
        return new SplitDeliveryData(properties);
    };

    /**
     * Encodes the specified SplitDeliveryData message. Does not implicitly {@link SplitDeliveryData.verify|verify} messages.
     * @function encode
     * @memberof SplitDeliveryData
     * @static
     * @param {ISplitDeliveryData} message SplitDeliveryData message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    SplitDeliveryData.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.name != null && Object.hasOwnProperty.call(message, "name"))
            writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
        if (message.downloadSize != null && Object.hasOwnProperty.call(message, "downloadSize"))
            writer.uint32(/* id 2, wireType 0 =*/16).int64(message.downloadSize);
        if (message.compressedSize != null && Object.hasOwnProperty.call(message, "compressedSize"))
            writer.uint32(/* id 3, wireType 0 =*/24).int64(message.compressedSize);
        if (message.sha1 != null && Object.hasOwnProperty.call(message, "sha1"))
            writer.uint32(/* id 4, wireType 2 =*/34).string(message.sha1);
        if (message.downloadUrl != null && Object.hasOwnProperty.call(message, "downloadUrl"))
            writer.uint32(/* id 5, wireType 2 =*/42).string(message.downloadUrl);
        if (message.compressedDownloadUrl != null && Object.hasOwnProperty.call(message, "compressedDownloadUrl"))
            writer.uint32(/* id 6, wireType 2 =*/50).string(message.compressedDownloadUrl);
        if (message.patchData != null && Object.hasOwnProperty.call(message, "patchData"))
            $root.AndroidAppPatchData.encode(message.patchData, writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
        if (message.compressedAppData != null && Object.hasOwnProperty.call(message, "compressedAppData"))
            $root.CompressedAppData.encode(message.compressedAppData, writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();
        if (message.sha256 != null && Object.hasOwnProperty.call(message, "sha256"))
            writer.uint32(/* id 9, wireType 2 =*/74).string(message.sha256);
        return writer;
    };

    /**
     * Encodes the specified SplitDeliveryData message, length delimited. Does not implicitly {@link SplitDeliveryData.verify|verify} messages.
     * @function encodeDelimited
     * @memberof SplitDeliveryData
     * @static
     * @param {ISplitDeliveryData} message SplitDeliveryData message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    SplitDeliveryData.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a SplitDeliveryData message from the specified reader or buffer.
     * @function decode
     * @memberof SplitDeliveryData
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {SplitDeliveryData} SplitDeliveryData
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    SplitDeliveryData.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.SplitDeliveryData();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.name = reader.string();
                break;
            case 2:
                message.downloadSize = reader.int64();
                break;
            case 3:
                message.compressedSize = reader.int64();
                break;
            case 4:
                message.sha1 = reader.string();
                break;
            case 5:
                message.downloadUrl = reader.string();
                break;
            case 6:
                message.compressedDownloadUrl = reader.string();
                break;
            case 7:
                message.patchData = $root.AndroidAppPatchData.decode(reader, reader.uint32());
                break;
            case 8:
                message.compressedAppData = $root.CompressedAppData.decode(reader, reader.uint32());
                break;
            case 9:
                message.sha256 = reader.string();
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a SplitDeliveryData message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof SplitDeliveryData
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {SplitDeliveryData} SplitDeliveryData
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    SplitDeliveryData.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a SplitDeliveryData message.
     * @function verify
     * @memberof SplitDeliveryData
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    SplitDeliveryData.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.name != null && message.hasOwnProperty("name"))
            if (!$util.isString(message.name))
                return "name: string expected";
        if (message.downloadSize != null && message.hasOwnProperty("downloadSize"))
            if (!$util.isInteger(message.downloadSize) && !(message.downloadSize && $util.isInteger(message.downloadSize.low) && $util.isInteger(message.downloadSize.high)))
                return "downloadSize: integer|Long expected";
        if (message.compressedSize != null && message.hasOwnProperty("compressedSize"))
            if (!$util.isInteger(message.compressedSize) && !(message.compressedSize && $util.isInteger(message.compressedSize.low) && $util.isInteger(message.compressedSize.high)))
                return "compressedSize: integer|Long expected";
        if (message.sha1 != null && message.hasOwnProperty("sha1"))
            if (!$util.isString(message.sha1))
                return "sha1: string expected";
        if (message.downloadUrl != null && message.hasOwnProperty("downloadUrl"))
            if (!$util.isString(message.downloadUrl))
                return "downloadUrl: string expected";
        if (message.compressedDownloadUrl != null && message.hasOwnProperty("compressedDownloadUrl"))
            if (!$util.isString(message.compressedDownloadUrl))
                return "compressedDownloadUrl: string expected";
        if (message.patchData != null && message.hasOwnProperty("patchData")) {
            var error = $root.AndroidAppPatchData.verify(message.patchData);
            if (error)
                return "patchData." + error;
        }
        if (message.compressedAppData != null && message.hasOwnProperty("compressedAppData")) {
            var error = $root.CompressedAppData.verify(message.compressedAppData);
            if (error)
                return "compressedAppData." + error;
        }
        if (message.sha256 != null && message.hasOwnProperty("sha256"))
            if (!$util.isString(message.sha256))
                return "sha256: string expected";
        return null;
    };

    /**
     * Creates a SplitDeliveryData message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof SplitDeliveryData
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {SplitDeliveryData} SplitDeliveryData
     */
    SplitDeliveryData.fromObject = function fromObject(object) {
        if (object instanceof $root.SplitDeliveryData)
            return object;
        var message = new $root.SplitDeliveryData();
        if (object.name != null)
            message.name = String(object.name);
        if (object.downloadSize != null)
            if ($util.Long)
                (message.downloadSize = $util.Long.fromValue(object.downloadSize)).unsigned = false;
            else if (typeof object.downloadSize === "string")
                message.downloadSize = parseInt(object.downloadSize, 10);
            else if (typeof object.downloadSize === "number")
                message.downloadSize = object.downloadSize;
            else if (typeof object.downloadSize === "object")
                message.downloadSize = new $util.LongBits(object.downloadSize.low >>> 0, object.downloadSize.high >>> 0).toNumber();
        if (object.compressedSize != null)
            if ($util.Long)
                (message.compressedSize = $util.Long.fromValue(object.compressedSize)).unsigned = false;
            else if (typeof object.compressedSize === "string")
                message.compressedSize = parseInt(object.compressedSize, 10);
            else if (typeof object.compressedSize === "number")
                message.compressedSize = object.compressedSize;
            else if (typeof object.compressedSize === "object")
                message.compressedSize = new $util.LongBits(object.compressedSize.low >>> 0, object.compressedSize.high >>> 0).toNumber();
        if (object.sha1 != null)
            message.sha1 = String(object.sha1);
        if (object.downloadUrl != null)
            message.downloadUrl = String(object.downloadUrl);
        if (object.compressedDownloadUrl != null)
            message.compressedDownloadUrl = String(object.compressedDownloadUrl);
        if (object.patchData != null) {
            if (typeof object.patchData !== "object")
                throw TypeError(".SplitDeliveryData.patchData: object expected");
            message.patchData = $root.AndroidAppPatchData.fromObject(object.patchData);
        }
        if (object.compressedAppData != null) {
            if (typeof object.compressedAppData !== "object")
                throw TypeError(".SplitDeliveryData.compressedAppData: object expected");
            message.compressedAppData = $root.CompressedAppData.fromObject(object.compressedAppData);
        }
        if (object.sha256 != null)
            message.sha256 = String(object.sha256);
        return message;
    };

    /**
     * Creates a plain object from a SplitDeliveryData message. Also converts values to other types if specified.
     * @function toObject
     * @memberof SplitDeliveryData
     * @static
     * @param {SplitDeliveryData} message SplitDeliveryData
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    SplitDeliveryData.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        var object = {};
        if (options.defaults) {
            object.name = "";
            if ($util.Long) {
                var long = new $util.Long(0, 0, false);
                object.downloadSize = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
            } else
                object.downloadSize = options.longs === String ? "0" : 0;
            if ($util.Long) {
                var long = new $util.Long(0, 0, false);
                object.compressedSize = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
            } else
                object.compressedSize = options.longs === String ? "0" : 0;
            object.sha1 = "";
            object.downloadUrl = "";
            object.compressedDownloadUrl = "";
            object.patchData = null;
            object.compressedAppData = null;
            object.sha256 = "";
        }
        if (message.name != null && message.hasOwnProperty("name"))
            object.name = message.name;
        if (message.downloadSize != null && message.hasOwnProperty("downloadSize"))
            if (typeof message.downloadSize === "number")
                object.downloadSize = options.longs === String ? String(message.downloadSize) : message.downloadSize;
            else
                object.downloadSize = options.longs === String ? $util.Long.prototype.toString.call(message.downloadSize) : options.longs === Number ? new $util.LongBits(message.downloadSize.low >>> 0, message.downloadSize.high >>> 0).toNumber() : message.downloadSize;
        if (message.compressedSize != null && message.hasOwnProperty("compressedSize"))
            if (typeof message.compressedSize === "number")
                object.compressedSize = options.longs === String ? String(message.compressedSize) : message.compressedSize;
            else
                object.compressedSize = options.longs === String ? $util.Long.prototype.toString.call(message.compressedSize) : options.longs === Number ? new $util.LongBits(message.compressedSize.low >>> 0, message.compressedSize.high >>> 0).toNumber() : message.compressedSize;
        if (message.sha1 != null && message.hasOwnProperty("sha1"))
            object.sha1 = message.sha1;
        if (message.downloadUrl != null && message.hasOwnProperty("downloadUrl"))
            object.downloadUrl = message.downloadUrl;
        if (message.compressedDownloadUrl != null && message.hasOwnProperty("compressedDownloadUrl"))
            object.compressedDownloadUrl = message.compressedDownloadUrl;
        if (message.patchData != null && message.hasOwnProperty("patchData"))
            object.patchData = $root.AndroidAppPatchData.toObject(message.patchData, options);
        if (message.compressedAppData != null && message.hasOwnProperty("compressedAppData"))
            object.compressedAppData = $root.CompressedAppData.toObject(message.compressedAppData, options);
        if (message.sha256 != null && message.hasOwnProperty("sha256"))
            object.sha256 = message.sha256;
        return object;
    };

    /**
     * Converts this SplitDeliveryData to JSON.
     * @function toJSON
     * @memberof SplitDeliveryData
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    SplitDeliveryData.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return SplitDeliveryData;
})();

$root.AndroidAppPatchData = (function() {

    /**
     * Properties of an AndroidAppPatchData.
     * @exports IAndroidAppPatchData
     * @interface IAndroidAppPatchData
     * @property {number|null} [baseVersionCode] AndroidAppPatchData baseVersionCode
     * @property {string|null} [baseSha1] AndroidAppPatchData baseSha1
     * @property {string|null} [downloadUrl] AndroidAppPatchData downloadUrl
     * @property {number|null} [patchFormat] AndroidAppPatchData patchFormat
     * @property {number|Long|null} [maxPatchSize] AndroidAppPatchData maxPatchSize
     */

    /**
     * Constructs a new AndroidAppPatchData.
     * @exports AndroidAppPatchData
     * @classdesc Represents an AndroidAppPatchData.
     * @implements IAndroidAppPatchData
     * @constructor
     * @param {IAndroidAppPatchData=} [properties] Properties to set
     */
    function AndroidAppPatchData(properties) {
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * AndroidAppPatchData baseVersionCode.
     * @member {number} baseVersionCode
     * @memberof AndroidAppPatchData
     * @instance
     */
    AndroidAppPatchData.prototype.baseVersionCode = 0;

    /**
     * AndroidAppPatchData baseSha1.
     * @member {string} baseSha1
     * @memberof AndroidAppPatchData
     * @instance
     */
    AndroidAppPatchData.prototype.baseSha1 = "";

    /**
     * AndroidAppPatchData downloadUrl.
     * @member {string} downloadUrl
     * @memberof AndroidAppPatchData
     * @instance
     */
    AndroidAppPatchData.prototype.downloadUrl = "";

    /**
     * AndroidAppPatchData patchFormat.
     * @member {number} patchFormat
     * @memberof AndroidAppPatchData
     * @instance
     */
    AndroidAppPatchData.prototype.patchFormat = 1;

    /**
     * AndroidAppPatchData maxPatchSize.
     * @member {number|Long} maxPatchSize
     * @memberof AndroidAppPatchData
     * @instance
     */
    AndroidAppPatchData.prototype.maxPatchSize = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

    /**
     * Creates a new AndroidAppPatchData instance using the specified properties.
     * @function create
     * @memberof AndroidAppPatchData
     * @static
     * @param {IAndroidAppPatchData=} [properties] Properties to set
     * @returns {AndroidAppPatchData} AndroidAppPatchData instance
     */
    AndroidAppPatchData.create = function create(properties) {
        return new AndroidAppPatchData(properties);
    };

    /**
     * Encodes the specified AndroidAppPatchData message. Does not implicitly {@link AndroidAppPatchData.verify|verify} messages.
     * @function encode
     * @memberof AndroidAppPatchData
     * @static
     * @param {IAndroidAppPatchData} message AndroidAppPatchData message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    AndroidAppPatchData.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.baseVersionCode != null && Object.hasOwnProperty.call(message, "baseVersionCode"))
            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.baseVersionCode);
        if (message.baseSha1 != null && Object.hasOwnProperty.call(message, "baseSha1"))
            writer.uint32(/* id 2, wireType 2 =*/18).string(message.baseSha1);
        if (message.downloadUrl != null && Object.hasOwnProperty.call(message, "downloadUrl"))
            writer.uint32(/* id 3, wireType 2 =*/26).string(message.downloadUrl);
        if (message.patchFormat != null && Object.hasOwnProperty.call(message, "patchFormat"))
            writer.uint32(/* id 4, wireType 0 =*/32).int32(message.patchFormat);
        if (message.maxPatchSize != null && Object.hasOwnProperty.call(message, "maxPatchSize"))
            writer.uint32(/* id 5, wireType 0 =*/40).int64(message.maxPatchSize);
        return writer;
    };

    /**
     * Encodes the specified AndroidAppPatchData message, length delimited. Does not implicitly {@link AndroidAppPatchData.verify|verify} messages.
     * @function encodeDelimited
     * @memberof AndroidAppPatchData
     * @static
     * @param {IAndroidAppPatchData} message AndroidAppPatchData message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    AndroidAppPatchData.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes an AndroidAppPatchData message from the specified reader or buffer.
     * @function decode
     * @memberof AndroidAppPatchData
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {AndroidAppPatchData} AndroidAppPatchData
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    AndroidAppPatchData.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.AndroidAppPatchData();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.baseVersionCode = reader.int32();
                break;
            case 2:
                message.baseSha1 = reader.string();
                break;
            case 3:
                message.downloadUrl = reader.string();
                break;
            case 4:
                message.patchFormat = reader.int32();
                break;
            case 5:
                message.maxPatchSize = reader.int64();
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes an AndroidAppPatchData message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof AndroidAppPatchData
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {AndroidAppPatchData} AndroidAppPatchData
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    AndroidAppPatchData.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies an AndroidAppPatchData message.
     * @function verify
     * @memberof AndroidAppPatchData
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    AndroidAppPatchData.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.baseVersionCode != null && message.hasOwnProperty("baseVersionCode"))
            if (!$util.isInteger(message.baseVersionCode))
                return "baseVersionCode: integer expected";
        if (message.baseSha1 != null && message.hasOwnProperty("baseSha1"))
            if (!$util.isString(message.baseSha1))
                return "baseSha1: string expected";
        if (message.downloadUrl != null && message.hasOwnProperty("downloadUrl"))
            if (!$util.isString(message.downloadUrl))
                return "downloadUrl: string expected";
        if (message.patchFormat != null && message.hasOwnProperty("patchFormat"))
            if (!$util.isInteger(message.patchFormat))
                return "patchFormat: integer expected";
        if (message.maxPatchSize != null && message.hasOwnProperty("maxPatchSize"))
            if (!$util.isInteger(message.maxPatchSize) && !(message.maxPatchSize && $util.isInteger(message.maxPatchSize.low) && $util.isInteger(message.maxPatchSize.high)))
                return "maxPatchSize: integer|Long expected";
        return null;
    };

    /**
     * Creates an AndroidAppPatchData message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof AndroidAppPatchData
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {AndroidAppPatchData} AndroidAppPatchData
     */
    AndroidAppPatchData.fromObject = function fromObject(object) {
        if (object instanceof $root.AndroidAppPatchData)
            return object;
        var message = new $root.AndroidAppPatchData();
        if (object.baseVersionCode != null)
            message.baseVersionCode = object.baseVersionCode | 0;
        if (object.baseSha1 != null)
            message.baseSha1 = String(object.baseSha1);
        if (object.downloadUrl != null)
            message.downloadUrl = String(object.downloadUrl);
        if (object.patchFormat != null)
            message.patchFormat = object.patchFormat | 0;
        if (object.maxPatchSize != null)
            if ($util.Long)
                (message.maxPatchSize = $util.Long.fromValue(object.maxPatchSize)).unsigned = false;
            else if (typeof object.maxPatchSize === "string")
                message.maxPatchSize = parseInt(object.maxPatchSize, 10);
            else if (typeof object.maxPatchSize === "number")
                message.maxPatchSize = object.maxPatchSize;
            else if (typeof object.maxPatchSize === "object")
                message.maxPatchSize = new $util.LongBits(object.maxPatchSize.low >>> 0, object.maxPatchSize.high >>> 0).toNumber();
        return message;
    };

    /**
     * Creates a plain object from an AndroidAppPatchData message. Also converts values to other types if specified.
     * @function toObject
     * @memberof AndroidAppPatchData
     * @static
     * @param {AndroidAppPatchData} message AndroidAppPatchData
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    AndroidAppPatchData.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        var object = {};
        if (options.defaults) {
            object.baseVersionCode = 0;
            object.baseSha1 = "";
            object.downloadUrl = "";
            object.patchFormat = 1;
            if ($util.Long) {
                var long = new $util.Long(0, 0, false);
                object.maxPatchSize = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
            } else
                object.maxPatchSize = options.longs === String ? "0" : 0;
        }
        if (message.baseVersionCode != null && message.hasOwnProperty("baseVersionCode"))
            object.baseVersionCode = message.baseVersionCode;
        if (message.baseSha1 != null && message.hasOwnProperty("baseSha1"))
            object.baseSha1 = message.baseSha1;
        if (message.downloadUrl != null && message.hasOwnProperty("downloadUrl"))
            object.downloadUrl = message.downloadUrl;
        if (message.patchFormat != null && message.hasOwnProperty("patchFormat"))
            object.patchFormat = message.patchFormat;
        if (message.maxPatchSize != null && message.hasOwnProperty("maxPatchSize"))
            if (typeof message.maxPatchSize === "number")
                object.maxPatchSize = options.longs === String ? String(message.maxPatchSize) : message.maxPatchSize;
            else
                object.maxPatchSize = options.longs === String ? $util.Long.prototype.toString.call(message.maxPatchSize) : options.longs === Number ? new $util.LongBits(message.maxPatchSize.low >>> 0, message.maxPatchSize.high >>> 0).toNumber() : message.maxPatchSize;
        return object;
    };

    /**
     * Converts this AndroidAppPatchData to JSON.
     * @function toJSON
     * @memberof AndroidAppPatchData
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    AndroidAppPatchData.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return AndroidAppPatchData;
})();

$root.CompressedAppData = (function() {

    /**
     * Properties of a CompressedAppData.
     * @exports ICompressedAppData
     * @interface ICompressedAppData
     * @property {number|Long|null} [type] CompressedAppData type
     * @property {number|Long|null} [size] CompressedAppData size
     * @property {string|null} [downloadUrl] CompressedAppData downloadUrl
     */

    /**
     * Constructs a new CompressedAppData.
     * @exports CompressedAppData
     * @classdesc Represents a CompressedAppData.
     * @implements ICompressedAppData
     * @constructor
     * @param {ICompressedAppData=} [properties] Properties to set
     */
    function CompressedAppData(properties) {
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * CompressedAppData type.
     * @member {number|Long} type
     * @memberof CompressedAppData
     * @instance
     */
    CompressedAppData.prototype.type = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

    /**
     * CompressedAppData size.
     * @member {number|Long} size
     * @memberof CompressedAppData
     * @instance
     */
    CompressedAppData.prototype.size = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

    /**
     * CompressedAppData downloadUrl.
     * @member {string} downloadUrl
     * @memberof CompressedAppData
     * @instance
     */
    CompressedAppData.prototype.downloadUrl = "";

    /**
     * Creates a new CompressedAppData instance using the specified properties.
     * @function create
     * @memberof CompressedAppData
     * @static
     * @param {ICompressedAppData=} [properties] Properties to set
     * @returns {CompressedAppData} CompressedAppData instance
     */
    CompressedAppData.create = function create(properties) {
        return new CompressedAppData(properties);
    };

    /**
     * Encodes the specified CompressedAppData message. Does not implicitly {@link CompressedAppData.verify|verify} messages.
     * @function encode
     * @memberof CompressedAppData
     * @static
     * @param {ICompressedAppData} message CompressedAppData message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    CompressedAppData.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.type != null && Object.hasOwnProperty.call(message, "type"))
            writer.uint32(/* id 1, wireType 0 =*/8).int64(message.type);
        if (message.size != null && Object.hasOwnProperty.call(message, "size"))
            writer.uint32(/* id 2, wireType 0 =*/16).int64(message.size);
        if (message.downloadUrl != null && Object.hasOwnProperty.call(message, "downloadUrl"))
            writer.uint32(/* id 3, wireType 2 =*/26).string(message.downloadUrl);
        return writer;
    };

    /**
     * Encodes the specified CompressedAppData message, length delimited. Does not implicitly {@link CompressedAppData.verify|verify} messages.
     * @function encodeDelimited
     * @memberof CompressedAppData
     * @static
     * @param {ICompressedAppData} message CompressedAppData message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    CompressedAppData.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a CompressedAppData message from the specified reader or buffer.
     * @function decode
     * @memberof CompressedAppData
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CompressedAppData} CompressedAppData
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CompressedAppData.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CompressedAppData();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.type = reader.int64();
                break;
            case 2:
                message.size = reader.int64();
                break;
            case 3:
                message.downloadUrl = reader.string();
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a CompressedAppData message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof CompressedAppData
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {CompressedAppData} CompressedAppData
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CompressedAppData.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a CompressedAppData message.
     * @function verify
     * @memberof CompressedAppData
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    CompressedAppData.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.type != null && message.hasOwnProperty("type"))
            if (!$util.isInteger(message.type) && !(message.type && $util.isInteger(message.type.low) && $util.isInteger(message.type.high)))
                return "type: integer|Long expected";
        if (message.size != null && message.hasOwnProperty("size"))
            if (!$util.isInteger(message.size) && !(message.size && $util.isInteger(message.size.low) && $util.isInteger(message.size.high)))
                return "size: integer|Long expected";
        if (message.downloadUrl != null && message.hasOwnProperty("downloadUrl"))
            if (!$util.isString(message.downloadUrl))
                return "downloadUrl: string expected";
        return null;
    };

    /**
     * Creates a CompressedAppData message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof CompressedAppData
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {CompressedAppData} CompressedAppData
     */
    CompressedAppData.fromObject = function fromObject(object) {
        if (object instanceof $root.CompressedAppData)
            return object;
        var message = new $root.CompressedAppData();
        if (object.type != null)
            if ($util.Long)
                (message.type = $util.Long.fromValue(object.type)).unsigned = false;
            else if (typeof object.type === "string")
                message.type = parseInt(object.type, 10);
            else if (typeof object.type === "number")
                message.type = object.type;
            else if (typeof object.type === "object")
                message.type = new $util.LongBits(object.type.low >>> 0, object.type.high >>> 0).toNumber();
        if (object.size != null)
            if ($util.Long)
                (message.size = $util.Long.fromValue(object.size)).unsigned = false;
            else if (typeof object.size === "string")
                message.size = parseInt(object.size, 10);
            else if (typeof object.size === "number")
                message.size = object.size;
            else if (typeof object.size === "object")
                message.size = new $util.LongBits(object.size.low >>> 0, object.size.high >>> 0).toNumber();
        if (object.downloadUrl != null)
            message.downloadUrl = String(object.downloadUrl);
        return message;
    };

    /**
     * Creates a plain object from a CompressedAppData message. Also converts values to other types if specified.
     * @function toObject
     * @memberof CompressedAppData
     * @static
     * @param {CompressedAppData} message CompressedAppData
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    CompressedAppData.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        var object = {};
        if (options.defaults) {
            if ($util.Long) {
                var long = new $util.Long(0, 0, false);
                object.type = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
            } else
                object.type = options.longs === String ? "0" : 0;
            if ($util.Long) {
                var long = new $util.Long(0, 0, false);
                object.size = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
            } else
                object.size = options.longs === String ? "0" : 0;
            object.downloadUrl = "";
        }
        if (message.type != null && message.hasOwnProperty("type"))
            if (typeof message.type === "number")
                object.type = options.longs === String ? String(message.type) : message.type;
            else
                object.type = options.longs === String ? $util.Long.prototype.toString.call(message.type) : options.longs === Number ? new $util.LongBits(message.type.low >>> 0, message.type.high >>> 0).toNumber() : message.type;
        if (message.size != null && message.hasOwnProperty("size"))
            if (typeof message.size === "number")
                object.size = options.longs === String ? String(message.size) : message.size;
            else
                object.size = options.longs === String ? $util.Long.prototype.toString.call(message.size) : options.longs === Number ? new $util.LongBits(message.size.low >>> 0, message.size.high >>> 0).toNumber() : message.size;
        if (message.downloadUrl != null && message.hasOwnProperty("downloadUrl"))
            object.downloadUrl = message.downloadUrl;
        return object;
    };

    /**
     * Converts this CompressedAppData to JSON.
     * @function toJSON
     * @memberof CompressedAppData
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    CompressedAppData.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return CompressedAppData;
})();

$root.AppFileMetadata = (function() {

    /**
     * Properties of an AppFileMetadata.
     * @exports IAppFileMetadata
     * @interface IAppFileMetadata
     * @property {number|null} [fileType] AppFileMetadata fileType
     * @property {number|null} [versionCode] AppFileMetadata versionCode
     * @property {number|Long|null} [size] AppFileMetadata size
     * @property {string|null} [downloadUrl] AppFileMetadata downloadUrl
     * @property {IAndroidAppPatchData|null} [patchData] AppFileMetadata patchData
     * @property {number|Long|null} [compressedSize] AppFileMetadata compressedSize
     * @property {string|null} [compressedDownloadUrl] AppFileMetadata compressedDownloadUrl
     * @property {string|null} [sha1] AppFileMetadata sha1
     */

    /**
     * Constructs a new AppFileMetadata.
     * @exports AppFileMetadata
     * @classdesc Represents an AppFileMetadata.
     * @implements IAppFileMetadata
     * @constructor
     * @param {IAppFileMetadata=} [properties] Properties to set
     */
    function AppFileMetadata(properties) {
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * AppFileMetadata fileType.
     * @member {number} fileType
     * @memberof AppFileMetadata
     * @instance
     */
    AppFileMetadata.prototype.fileType = 0;

    /**
     * AppFileMetadata versionCode.
     * @member {number} versionCode
     * @memberof AppFileMetadata
     * @instance
     */
    AppFileMetadata.prototype.versionCode = 0;

    /**
     * AppFileMetadata size.
     * @member {number|Long} size
     * @memberof AppFileMetadata
     * @instance
     */
    AppFileMetadata.prototype.size = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

    /**
     * AppFileMetadata downloadUrl.
     * @member {string} downloadUrl
     * @memberof AppFileMetadata
     * @instance
     */
    AppFileMetadata.prototype.downloadUrl = "";

    /**
     * AppFileMetadata patchData.
     * @member {IAndroidAppPatchData|null|undefined} patchData
     * @memberof AppFileMetadata
     * @instance
     */
    AppFileMetadata.prototype.patchData = null;

    /**
     * AppFileMetadata compressedSize.
     * @member {number|Long} compressedSize
     * @memberof AppFileMetadata
     * @instance
     */
    AppFileMetadata.prototype.compressedSize = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

    /**
     * AppFileMetadata compressedDownloadUrl.
     * @member {string} compressedDownloadUrl
     * @memberof AppFileMetadata
     * @instance
     */
    AppFileMetadata.prototype.compressedDownloadUrl = "";

    /**
     * AppFileMetadata sha1.
     * @member {string} sha1
     * @memberof AppFileMetadata
     * @instance
     */
    AppFileMetadata.prototype.sha1 = "";

    /**
     * Creates a new AppFileMetadata instance using the specified properties.
     * @function create
     * @memberof AppFileMetadata
     * @static
     * @param {IAppFileMetadata=} [properties] Properties to set
     * @returns {AppFileMetadata} AppFileMetadata instance
     */
    AppFileMetadata.create = function create(properties) {
        return new AppFileMetadata(properties);
    };

    /**
     * Encodes the specified AppFileMetadata message. Does not implicitly {@link AppFileMetadata.verify|verify} messages.
     * @function encode
     * @memberof AppFileMetadata
     * @static
     * @param {IAppFileMetadata} message AppFileMetadata message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    AppFileMetadata.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.fileType != null && Object.hasOwnProperty.call(message, "fileType"))
            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.fileType);
        if (message.versionCode != null && Object.hasOwnProperty.call(message, "versionCode"))
            writer.uint32(/* id 2, wireType 0 =*/16).int32(message.versionCode);
        if (message.size != null && Object.hasOwnProperty.call(message, "size"))
            writer.uint32(/* id 3, wireType 0 =*/24).int64(message.size);
        if (message.downloadUrl != null && Object.hasOwnProperty.call(message, "downloadUrl"))
            writer.uint32(/* id 4, wireType 2 =*/34).string(message.downloadUrl);
        if (message.patchData != null && Object.hasOwnProperty.call(message, "patchData"))
            $root.AndroidAppPatchData.encode(message.patchData, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
        if (message.compressedSize != null && Object.hasOwnProperty.call(message, "compressedSize"))
            writer.uint32(/* id 6, wireType 0 =*/48).int64(message.compressedSize);
        if (message.compressedDownloadUrl != null && Object.hasOwnProperty.call(message, "compressedDownloadUrl"))
            writer.uint32(/* id 7, wireType 2 =*/58).string(message.compressedDownloadUrl);
        if (message.sha1 != null && Object.hasOwnProperty.call(message, "sha1"))
            writer.uint32(/* id 8, wireType 2 =*/66).string(message.sha1);
        return writer;
    };

    /**
     * Encodes the specified AppFileMetadata message, length delimited. Does not implicitly {@link AppFileMetadata.verify|verify} messages.
     * @function encodeDelimited
     * @memberof AppFileMetadata
     * @static
     * @param {IAppFileMetadata} message AppFileMetadata message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    AppFileMetadata.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes an AppFileMetadata message from the specified reader or buffer.
     * @function decode
     * @memberof AppFileMetadata
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {AppFileMetadata} AppFileMetadata
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    AppFileMetadata.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.AppFileMetadata();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.fileType = reader.int32();
                break;
            case 2:
                message.versionCode = reader.int32();
                break;
            case 3:
                message.size = reader.int64();
                break;
            case 4:
                message.downloadUrl = reader.string();
                break;
            case 5:
                message.patchData = $root.AndroidAppPatchData.decode(reader, reader.uint32());
                break;
            case 6:
                message.compressedSize = reader.int64();
                break;
            case 7:
                message.compressedDownloadUrl = reader.string();
                break;
            case 8:
                message.sha1 = reader.string();
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes an AppFileMetadata message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof AppFileMetadata
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {AppFileMetadata} AppFileMetadata
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    AppFileMetadata.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies an AppFileMetadata message.
     * @function verify
     * @memberof AppFileMetadata
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    AppFileMetadata.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.fileType != null && message.hasOwnProperty("fileType"))
            if (!$util.isInteger(message.fileType))
                return "fileType: integer expected";
        if (message.versionCode != null && message.hasOwnProperty("versionCode"))
            if (!$util.isInteger(message.versionCode))
                return "versionCode: integer expected";
        if (message.size != null && message.hasOwnProperty("size"))
            if (!$util.isInteger(message.size) && !(message.size && $util.isInteger(message.size.low) && $util.isInteger(message.size.high)))
                return "size: integer|Long expected";
        if (message.downloadUrl != null && message.hasOwnProperty("downloadUrl"))
            if (!$util.isString(message.downloadUrl))
                return "downloadUrl: string expected";
        if (message.patchData != null && message.hasOwnProperty("patchData")) {
            var error = $root.AndroidAppPatchData.verify(message.patchData);
            if (error)
                return "patchData." + error;
        }
        if (message.compressedSize != null && message.hasOwnProperty("compressedSize"))
            if (!$util.isInteger(message.compressedSize) && !(message.compressedSize && $util.isInteger(message.compressedSize.low) && $util.isInteger(message.compressedSize.high)))
                return "compressedSize: integer|Long expected";
        if (message.compressedDownloadUrl != null && message.hasOwnProperty("compressedDownloadUrl"))
            if (!$util.isString(message.compressedDownloadUrl))
                return "compressedDownloadUrl: string expected";
        if (message.sha1 != null && message.hasOwnProperty("sha1"))
            if (!$util.isString(message.sha1))
                return "sha1: string expected";
        return null;
    };

    /**
     * Creates an AppFileMetadata message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof AppFileMetadata
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {AppFileMetadata} AppFileMetadata
     */
    AppFileMetadata.fromObject = function fromObject(object) {
        if (object instanceof $root.AppFileMetadata)
            return object;
        var message = new $root.AppFileMetadata();
        if (object.fileType != null)
            message.fileType = object.fileType | 0;
        if (object.versionCode != null)
            message.versionCode = object.versionCode | 0;
        if (object.size != null)
            if ($util.Long)
                (message.size = $util.Long.fromValue(object.size)).unsigned = false;
            else if (typeof object.size === "string")
                message.size = parseInt(object.size, 10);
            else if (typeof object.size === "number")
                message.size = object.size;
            else if (typeof object.size === "object")
                message.size = new $util.LongBits(object.size.low >>> 0, object.size.high >>> 0).toNumber();
        if (object.downloadUrl != null)
            message.downloadUrl = String(object.downloadUrl);
        if (object.patchData != null) {
            if (typeof object.patchData !== "object")
                throw TypeError(".AppFileMetadata.patchData: object expected");
            message.patchData = $root.AndroidAppPatchData.fromObject(object.patchData);
        }
        if (object.compressedSize != null)
            if ($util.Long)
                (message.compressedSize = $util.Long.fromValue(object.compressedSize)).unsigned = false;
            else if (typeof object.compressedSize === "string")
                message.compressedSize = parseInt(object.compressedSize, 10);
            else if (typeof object.compressedSize === "number")
                message.compressedSize = object.compressedSize;
            else if (typeof object.compressedSize === "object")
                message.compressedSize = new $util.LongBits(object.compressedSize.low >>> 0, object.compressedSize.high >>> 0).toNumber();
        if (object.compressedDownloadUrl != null)
            message.compressedDownloadUrl = String(object.compressedDownloadUrl);
        if (object.sha1 != null)
            message.sha1 = String(object.sha1);
        return message;
    };

    /**
     * Creates a plain object from an AppFileMetadata message. Also converts values to other types if specified.
     * @function toObject
     * @memberof AppFileMetadata
     * @static
     * @param {AppFileMetadata} message AppFileMetadata
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    AppFileMetadata.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        var object = {};
        if (options.defaults) {
            object.fileType = 0;
            object.versionCode = 0;
            if ($util.Long) {
                var long = new $util.Long(0, 0, false);
                object.size = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
            } else
                object.size = options.longs === String ? "0" : 0;
            object.downloadUrl = "";
            object.patchData = null;
            if ($util.Long) {
                var long = new $util.Long(0, 0, false);
                object.compressedSize = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
            } else
                object.compressedSize = options.longs === String ? "0" : 0;
            object.compressedDownloadUrl = "";
            object.sha1 = "";
        }
        if (message.fileType != null && message.hasOwnProperty("fileType"))
            object.fileType = message.fileType;
        if (message.versionCode != null && message.hasOwnProperty("versionCode"))
            object.versionCode = message.versionCode;
        if (message.size != null && message.hasOwnProperty("size"))
            if (typeof message.size === "number")
                object.size = options.longs === String ? String(message.size) : message.size;
            else
                object.size = options.longs === String ? $util.Long.prototype.toString.call(message.size) : options.longs === Number ? new $util.LongBits(message.size.low >>> 0, message.size.high >>> 0).toNumber() : message.size;
        if (message.downloadUrl != null && message.hasOwnProperty("downloadUrl"))
            object.downloadUrl = message.downloadUrl;
        if (message.patchData != null && message.hasOwnProperty("patchData"))
            object.patchData = $root.AndroidAppPatchData.toObject(message.patchData, options);
        if (message.compressedSize != null && message.hasOwnProperty("compressedSize"))
            if (typeof message.compressedSize === "number")
                object.compressedSize = options.longs === String ? String(message.compressedSize) : message.compressedSize;
            else
                object.compressedSize = options.longs === String ? $util.Long.prototype.toString.call(message.compressedSize) : options.longs === Number ? new $util.LongBits(message.compressedSize.low >>> 0, message.compressedSize.high >>> 0).toNumber() : message.compressedSize;
        if (message.compressedDownloadUrl != null && message.hasOwnProperty("compressedDownloadUrl"))
            object.compressedDownloadUrl = message.compressedDownloadUrl;
        if (message.sha1 != null && message.hasOwnProperty("sha1"))
            object.sha1 = message.sha1;
        return object;
    };

    /**
     * Converts this AppFileMetadata to JSON.
     * @function toJSON
     * @memberof AppFileMetadata
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    AppFileMetadata.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return AppFileMetadata;
})();

$root.EncryptionParams = (function() {

    /**
     * Properties of an EncryptionParams.
     * @exports IEncryptionParams
     * @interface IEncryptionParams
     * @property {number|null} [version] EncryptionParams version
     * @property {string|null} [encryptionKey] EncryptionParams encryptionKey
     * @property {string|null} [hMacKey] EncryptionParams hMacKey
     */

    /**
     * Constructs a new EncryptionParams.
     * @exports EncryptionParams
     * @classdesc Represents an EncryptionParams.
     * @implements IEncryptionParams
     * @constructor
     * @param {IEncryptionParams=} [properties] Properties to set
     */
    function EncryptionParams(properties) {
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * EncryptionParams version.
     * @member {number} version
     * @memberof EncryptionParams
     * @instance
     */
    EncryptionParams.prototype.version = 0;

    /**
     * EncryptionParams encryptionKey.
     * @member {string} encryptionKey
     * @memberof EncryptionParams
     * @instance
     */
    EncryptionParams.prototype.encryptionKey = "";

    /**
     * EncryptionParams hMacKey.
     * @member {string} hMacKey
     * @memberof EncryptionParams
     * @instance
     */
    EncryptionParams.prototype.hMacKey = "";

    /**
     * Creates a new EncryptionParams instance using the specified properties.
     * @function create
     * @memberof EncryptionParams
     * @static
     * @param {IEncryptionParams=} [properties] Properties to set
     * @returns {EncryptionParams} EncryptionParams instance
     */
    EncryptionParams.create = function create(properties) {
        return new EncryptionParams(properties);
    };

    /**
     * Encodes the specified EncryptionParams message. Does not implicitly {@link EncryptionParams.verify|verify} messages.
     * @function encode
     * @memberof EncryptionParams
     * @static
     * @param {IEncryptionParams} message EncryptionParams message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    EncryptionParams.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.version != null && Object.hasOwnProperty.call(message, "version"))
            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.version);
        if (message.encryptionKey != null && Object.hasOwnProperty.call(message, "encryptionKey"))
            writer.uint32(/* id 2, wireType 2 =*/18).string(message.encryptionKey);
        if (message.hMacKey != null && Object.hasOwnProperty.call(message, "hMacKey"))
            writer.uint32(/* id 3, wireType 2 =*/26).string(message.hMacKey);
        return writer;
    };

    /**
     * Encodes the specified EncryptionParams message, length delimited. Does not implicitly {@link EncryptionParams.verify|verify} messages.
     * @function encodeDelimited
     * @memberof EncryptionParams
     * @static
     * @param {IEncryptionParams} message EncryptionParams message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    EncryptionParams.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes an EncryptionParams message from the specified reader or buffer.
     * @function decode
     * @memberof EncryptionParams
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {EncryptionParams} EncryptionParams
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    EncryptionParams.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.EncryptionParams();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.version = reader.int32();
                break;
            case 2:
                message.encryptionKey = reader.string();
                break;
            case 3:
                message.hMacKey = reader.string();
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes an EncryptionParams message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof EncryptionParams
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {EncryptionParams} EncryptionParams
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    EncryptionParams.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies an EncryptionParams message.
     * @function verify
     * @memberof EncryptionParams
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    EncryptionParams.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.version != null && message.hasOwnProperty("version"))
            if (!$util.isInteger(message.version))
                return "version: integer expected";
        if (message.encryptionKey != null && message.hasOwnProperty("encryptionKey"))
            if (!$util.isString(message.encryptionKey))
                return "encryptionKey: string expected";
        if (message.hMacKey != null && message.hasOwnProperty("hMacKey"))
            if (!$util.isString(message.hMacKey))
                return "hMacKey: string expected";
        return null;
    };

    /**
     * Creates an EncryptionParams message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof EncryptionParams
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {EncryptionParams} EncryptionParams
     */
    EncryptionParams.fromObject = function fromObject(object) {
        if (object instanceof $root.EncryptionParams)
            return object;
        var message = new $root.EncryptionParams();
        if (object.version != null)
            message.version = object.version | 0;
        if (object.encryptionKey != null)
            message.encryptionKey = String(object.encryptionKey);
        if (object.hMacKey != null)
            message.hMacKey = String(object.hMacKey);
        return message;
    };

    /**
     * Creates a plain object from an EncryptionParams message. Also converts values to other types if specified.
     * @function toObject
     * @memberof EncryptionParams
     * @static
     * @param {EncryptionParams} message EncryptionParams
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    EncryptionParams.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        var object = {};
        if (options.defaults) {
            object.version = 0;
            object.encryptionKey = "";
            object.hMacKey = "";
        }
        if (message.version != null && message.hasOwnProperty("version"))
            object.version = message.version;
        if (message.encryptionKey != null && message.hasOwnProperty("encryptionKey"))
            object.encryptionKey = message.encryptionKey;
        if (message.hMacKey != null && message.hasOwnProperty("hMacKey"))
            object.hMacKey = message.hMacKey;
        return object;
    };

    /**
     * Converts this EncryptionParams to JSON.
     * @function toJSON
     * @memberof EncryptionParams
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    EncryptionParams.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return EncryptionParams;
})();

$root.HttpCookie = (function() {

    /**
     * Properties of a HttpCookie.
     * @exports IHttpCookie
     * @interface IHttpCookie
     * @property {string|null} [name] HttpCookie name
     * @property {string|null} [value] HttpCookie value
     */

    /**
     * Constructs a new HttpCookie.
     * @exports HttpCookie
     * @classdesc Represents a HttpCookie.
     * @implements IHttpCookie
     * @constructor
     * @param {IHttpCookie=} [properties] Properties to set
     */
    function HttpCookie(properties) {
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * HttpCookie name.
     * @member {string} name
     * @memberof HttpCookie
     * @instance
     */
    HttpCookie.prototype.name = "";

    /**
     * HttpCookie value.
     * @member {string} value
     * @memberof HttpCookie
     * @instance
     */
    HttpCookie.prototype.value = "";

    /**
     * Creates a new HttpCookie instance using the specified properties.
     * @function create
     * @memberof HttpCookie
     * @static
     * @param {IHttpCookie=} [properties] Properties to set
     * @returns {HttpCookie} HttpCookie instance
     */
    HttpCookie.create = function create(properties) {
        return new HttpCookie(properties);
    };

    /**
     * Encodes the specified HttpCookie message. Does not implicitly {@link HttpCookie.verify|verify} messages.
     * @function encode
     * @memberof HttpCookie
     * @static
     * @param {IHttpCookie} message HttpCookie message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    HttpCookie.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.name != null && Object.hasOwnProperty.call(message, "name"))
            writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
        if (message.value != null && Object.hasOwnProperty.call(message, "value"))
            writer.uint32(/* id 2, wireType 2 =*/18).string(message.value);
        return writer;
    };

    /**
     * Encodes the specified HttpCookie message, length delimited. Does not implicitly {@link HttpCookie.verify|verify} messages.
     * @function encodeDelimited
     * @memberof HttpCookie
     * @static
     * @param {IHttpCookie} message HttpCookie message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    HttpCookie.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a HttpCookie message from the specified reader or buffer.
     * @function decode
     * @memberof HttpCookie
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {HttpCookie} HttpCookie
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    HttpCookie.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.HttpCookie();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.name = reader.string();
                break;
            case 2:
                message.value = reader.string();
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a HttpCookie message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof HttpCookie
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {HttpCookie} HttpCookie
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    HttpCookie.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a HttpCookie message.
     * @function verify
     * @memberof HttpCookie
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    HttpCookie.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.name != null && message.hasOwnProperty("name"))
            if (!$util.isString(message.name))
                return "name: string expected";
        if (message.value != null && message.hasOwnProperty("value"))
            if (!$util.isString(message.value))
                return "value: string expected";
        return null;
    };

    /**
     * Creates a HttpCookie message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof HttpCookie
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {HttpCookie} HttpCookie
     */
    HttpCookie.fromObject = function fromObject(object) {
        if (object instanceof $root.HttpCookie)
            return object;
        var message = new $root.HttpCookie();
        if (object.name != null)
            message.name = String(object.name);
        if (object.value != null)
            message.value = String(object.value);
        return message;
    };

    /**
     * Creates a plain object from a HttpCookie message. Also converts values to other types if specified.
     * @function toObject
     * @memberof HttpCookie
     * @static
     * @param {HttpCookie} message HttpCookie
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    HttpCookie.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        var object = {};
        if (options.defaults) {
            object.name = "";
            object.value = "";
        }
        if (message.name != null && message.hasOwnProperty("name"))
            object.name = message.name;
        if (message.value != null && message.hasOwnProperty("value"))
            object.value = message.value;
        return object;
    };

    /**
     * Converts this HttpCookie to JSON.
     * @function toJSON
     * @memberof HttpCookie
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    HttpCookie.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return HttpCookie;
})();

$root.Address = (function() {

    /**
     * Properties of an Address.
     * @exports IAddress
     * @interface IAddress
     * @property {string|null} [name] Address name
     * @property {string|null} [addressLine1] Address addressLine1
     * @property {string|null} [addressLine2] Address addressLine2
     * @property {string|null} [city] Address city
     * @property {string|null} [state] Address state
     * @property {string|null} [postalCode] Address postalCode
     * @property {string|null} [postalCountry] Address postalCountry
     * @property {string|null} [dependentLocality] Address dependentLocality
     * @property {string|null} [sortingCode] Address sortingCode
     * @property {string|null} [languageCode] Address languageCode
     * @property {string|null} [phoneNumber] Address phoneNumber
     * @property {boolean|null} [deprecatedIsReduced] Address deprecatedIsReduced
     * @property {string|null} [firstName] Address firstName
     * @property {string|null} [lastName] Address lastName
     * @property {string|null} [email] Address email
     */

    /**
     * Constructs a new Address.
     * @exports Address
     * @classdesc Represents an Address.
     * @implements IAddress
     * @constructor
     * @param {IAddress=} [properties] Properties to set
     */
    function Address(properties) {
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * Address name.
     * @member {string} name
     * @memberof Address
     * @instance
     */
    Address.prototype.name = "";

    /**
     * Address addressLine1.
     * @member {string} addressLine1
     * @memberof Address
     * @instance
     */
    Address.prototype.addressLine1 = "";

    /**
     * Address addressLine2.
     * @member {string} addressLine2
     * @memberof Address
     * @instance
     */
    Address.prototype.addressLine2 = "";

    /**
     * Address city.
     * @member {string} city
     * @memberof Address
     * @instance
     */
    Address.prototype.city = "";

    /**
     * Address state.
     * @member {string} state
     * @memberof Address
     * @instance
     */
    Address.prototype.state = "";

    /**
     * Address postalCode.
     * @member {string} postalCode
     * @memberof Address
     * @instance
     */
    Address.prototype.postalCode = "";

    /**
     * Address postalCountry.
     * @member {string} postalCountry
     * @memberof Address
     * @instance
     */
    Address.prototype.postalCountry = "";

    /**
     * Address dependentLocality.
     * @member {string} dependentLocality
     * @memberof Address
     * @instance
     */
    Address.prototype.dependentLocality = "";

    /**
     * Address sortingCode.
     * @member {string} sortingCode
     * @memberof Address
     * @instance
     */
    Address.prototype.sortingCode = "";

    /**
     * Address languageCode.
     * @member {string} languageCode
     * @memberof Address
     * @instance
     */
    Address.prototype.languageCode = "";

    /**
     * Address phoneNumber.
     * @member {string} phoneNumber
     * @memberof Address
     * @instance
     */
    Address.prototype.phoneNumber = "";

    /**
     * Address deprecatedIsReduced.
     * @member {boolean} deprecatedIsReduced
     * @memberof Address
     * @instance
     */
    Address.prototype.deprecatedIsReduced = false;

    /**
     * Address firstName.
     * @member {string} firstName
     * @memberof Address
     * @instance
     */
    Address.prototype.firstName = "";

    /**
     * Address lastName.
     * @member {string} lastName
     * @memberof Address
     * @instance
     */
    Address.prototype.lastName = "";

    /**
     * Address email.
     * @member {string} email
     * @memberof Address
     * @instance
     */
    Address.prototype.email = "";

    /**
     * Creates a new Address instance using the specified properties.
     * @function create
     * @memberof Address
     * @static
     * @param {IAddress=} [properties] Properties to set
     * @returns {Address} Address instance
     */
    Address.create = function create(properties) {
        return new Address(properties);
    };

    /**
     * Encodes the specified Address message. Does not implicitly {@link Address.verify|verify} messages.
     * @function encode
     * @memberof Address
     * @static
     * @param {IAddress} message Address message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    Address.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.name != null && Object.hasOwnProperty.call(message, "name"))
            writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
        if (message.addressLine1 != null && Object.hasOwnProperty.call(message, "addressLine1"))
            writer.uint32(/* id 2, wireType 2 =*/18).string(message.addressLine1);
        if (message.addressLine2 != null && Object.hasOwnProperty.call(message, "addressLine2"))
            writer.uint32(/* id 3, wireType 2 =*/26).string(message.addressLine2);
        if (message.city != null && Object.hasOwnProperty.call(message, "city"))
            writer.uint32(/* id 4, wireType 2 =*/34).string(message.city);
        if (message.state != null && Object.hasOwnProperty.call(message, "state"))
            writer.uint32(/* id 5, wireType 2 =*/42).string(message.state);
        if (message.postalCode != null && Object.hasOwnProperty.call(message, "postalCode"))
            writer.uint32(/* id 6, wireType 2 =*/50).string(message.postalCode);
        if (message.postalCountry != null && Object.hasOwnProperty.call(message, "postalCountry"))
            writer.uint32(/* id 7, wireType 2 =*/58).string(message.postalCountry);
        if (message.dependentLocality != null && Object.hasOwnProperty.call(message, "dependentLocality"))
            writer.uint32(/* id 8, wireType 2 =*/66).string(message.dependentLocality);
        if (message.sortingCode != null && Object.hasOwnProperty.call(message, "sortingCode"))
            writer.uint32(/* id 9, wireType 2 =*/74).string(message.sortingCode);
        if (message.languageCode != null && Object.hasOwnProperty.call(message, "languageCode"))
            writer.uint32(/* id 10, wireType 2 =*/82).string(message.languageCode);
        if (message.phoneNumber != null && Object.hasOwnProperty.call(message, "phoneNumber"))
            writer.uint32(/* id 11, wireType 2 =*/90).string(message.phoneNumber);
        if (message.deprecatedIsReduced != null && Object.hasOwnProperty.call(message, "deprecatedIsReduced"))
            writer.uint32(/* id 12, wireType 0 =*/96).bool(message.deprecatedIsReduced);
        if (message.firstName != null && Object.hasOwnProperty.call(message, "firstName"))
            writer.uint32(/* id 13, wireType 2 =*/106).string(message.firstName);
        if (message.lastName != null && Object.hasOwnProperty.call(message, "lastName"))
            writer.uint32(/* id 14, wireType 2 =*/114).string(message.lastName);
        if (message.email != null && Object.hasOwnProperty.call(message, "email"))
            writer.uint32(/* id 15, wireType 2 =*/122).string(message.email);
        return writer;
    };

    /**
     * Encodes the specified Address message, length delimited. Does not implicitly {@link Address.verify|verify} messages.
     * @function encodeDelimited
     * @memberof Address
     * @static
     * @param {IAddress} message Address message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    Address.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes an Address message from the specified reader or buffer.
     * @function decode
     * @memberof Address
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {Address} Address
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    Address.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Address();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.name = reader.string();
                break;
            case 2:
                message.addressLine1 = reader.string();
                break;
            case 3:
                message.addressLine2 = reader.string();
                break;
            case 4:
                message.city = reader.string();
                break;
            case 5:
                message.state = reader.string();
                break;
            case 6:
                message.postalCode = reader.string();
                break;
            case 7:
                message.postalCountry = reader.string();
                break;
            case 8:
                message.dependentLocality = reader.string();
                break;
            case 9:
                message.sortingCode = reader.string();
                break;
            case 10:
                message.languageCode = reader.string();
                break;
            case 11:
                message.phoneNumber = reader.string();
                break;
            case 12:
                message.deprecatedIsReduced = reader.bool();
                break;
            case 13:
                message.firstName = reader.string();
                break;
            case 14:
                message.lastName = reader.string();
                break;
            case 15:
                message.email = reader.string();
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes an Address message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof Address
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {Address} Address
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    Address.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies an Address message.
     * @function verify
     * @memberof Address
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    Address.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.name != null && message.hasOwnProperty("name"))
            if (!$util.isString(message.name))
                return "name: string expected";
        if (message.addressLine1 != null && message.hasOwnProperty("addressLine1"))
            if (!$util.isString(message.addressLine1))
                return "addressLine1: string expected";
        if (message.addressLine2 != null && message.hasOwnProperty("addressLine2"))
            if (!$util.isString(message.addressLine2))
                return "addressLine2: string expected";
        if (message.city != null && message.hasOwnProperty("city"))
            if (!$util.isString(message.city))
                return "city: string expected";
        if (message.state != null && message.hasOwnProperty("state"))
            if (!$util.isString(message.state))
                return "state: string expected";
        if (message.postalCode != null && message.hasOwnProperty("postalCode"))
            if (!$util.isString(message.postalCode))
                return "postalCode: string expected";
        if (message.postalCountry != null && message.hasOwnProperty("postalCountry"))
            if (!$util.isString(message.postalCountry))
                return "postalCountry: string expected";
        if (message.dependentLocality != null && message.hasOwnProperty("dependentLocality"))
            if (!$util.isString(message.dependentLocality))
                return "dependentLocality: string expected";
        if (message.sortingCode != null && message.hasOwnProperty("sortingCode"))
            if (!$util.isString(message.sortingCode))
                return "sortingCode: string expected";
        if (message.languageCode != null && message.hasOwnProperty("languageCode"))
            if (!$util.isString(message.languageCode))
                return "languageCode: string expected";
        if (message.phoneNumber != null && message.hasOwnProperty("phoneNumber"))
            if (!$util.isString(message.phoneNumber))
                return "phoneNumber: string expected";
        if (message.deprecatedIsReduced != null && message.hasOwnProperty("deprecatedIsReduced"))
            if (typeof message.deprecatedIsReduced !== "boolean")
                return "deprecatedIsReduced: boolean expected";
        if (message.firstName != null && message.hasOwnProperty("firstName"))
            if (!$util.isString(message.firstName))
                return "firstName: string expected";
        if (message.lastName != null && message.hasOwnProperty("lastName"))
            if (!$util.isString(message.lastName))
                return "lastName: string expected";
        if (message.email != null && message.hasOwnProperty("email"))
            if (!$util.isString(message.email))
                return "email: string expected";
        return null;
    };

    /**
     * Creates an Address message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof Address
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {Address} Address
     */
    Address.fromObject = function fromObject(object) {
        if (object instanceof $root.Address)
            return object;
        var message = new $root.Address();
        if (object.name != null)
            message.name = String(object.name);
        if (object.addressLine1 != null)
            message.addressLine1 = String(object.addressLine1);
        if (object.addressLine2 != null)
            message.addressLine2 = String(object.addressLine2);
        if (object.city != null)
            message.city = String(object.city);
        if (object.state != null)
            message.state = String(object.state);
        if (object.postalCode != null)
            message.postalCode = String(object.postalCode);
        if (object.postalCountry != null)
            message.postalCountry = String(object.postalCountry);
        if (object.dependentLocality != null)
            message.dependentLocality = String(object.dependentLocality);
        if (object.sortingCode != null)
            message.sortingCode = String(object.sortingCode);
        if (object.languageCode != null)
            message.languageCode = String(object.languageCode);
        if (object.phoneNumber != null)
            message.phoneNumber = String(object.phoneNumber);
        if (object.deprecatedIsReduced != null)
            message.deprecatedIsReduced = Boolean(object.deprecatedIsReduced);
        if (object.firstName != null)
            message.firstName = String(object.firstName);
        if (object.lastName != null)
            message.lastName = String(object.lastName);
        if (object.email != null)
            message.email = String(object.email);
        return message;
    };

    /**
     * Creates a plain object from an Address message. Also converts values to other types if specified.
     * @function toObject
     * @memberof Address
     * @static
     * @param {Address} message Address
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    Address.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        var object = {};
        if (options.defaults) {
            object.name = "";
            object.addressLine1 = "";
            object.addressLine2 = "";
            object.city = "";
            object.state = "";
            object.postalCode = "";
            object.postalCountry = "";
            object.dependentLocality = "";
            object.sortingCode = "";
            object.languageCode = "";
            object.phoneNumber = "";
            object.deprecatedIsReduced = false;
            object.firstName = "";
            object.lastName = "";
            object.email = "";
        }
        if (message.name != null && message.hasOwnProperty("name"))
            object.name = message.name;
        if (message.addressLine1 != null && message.hasOwnProperty("addressLine1"))
            object.addressLine1 = message.addressLine1;
        if (message.addressLine2 != null && message.hasOwnProperty("addressLine2"))
            object.addressLine2 = message.addressLine2;
        if (message.city != null && message.hasOwnProperty("city"))
            object.city = message.city;
        if (message.state != null && message.hasOwnProperty("state"))
            object.state = message.state;
        if (message.postalCode != null && message.hasOwnProperty("postalCode"))
            object.postalCode = message.postalCode;
        if (message.postalCountry != null && message.hasOwnProperty("postalCountry"))
            object.postalCountry = message.postalCountry;
        if (message.dependentLocality != null && message.hasOwnProperty("dependentLocality"))
            object.dependentLocality = message.dependentLocality;
        if (message.sortingCode != null && message.hasOwnProperty("sortingCode"))
            object.sortingCode = message.sortingCode;
        if (message.languageCode != null && message.hasOwnProperty("languageCode"))
            object.languageCode = message.languageCode;
        if (message.phoneNumber != null && message.hasOwnProperty("phoneNumber"))
            object.phoneNumber = message.phoneNumber;
        if (message.deprecatedIsReduced != null && message.hasOwnProperty("deprecatedIsReduced"))
            object.deprecatedIsReduced = message.deprecatedIsReduced;
        if (message.firstName != null && message.hasOwnProperty("firstName"))
            object.firstName = message.firstName;
        if (message.lastName != null && message.hasOwnProperty("lastName"))
            object.lastName = message.lastName;
        if (message.email != null && message.hasOwnProperty("email"))
            object.email = message.email;
        return object;
    };

    /**
     * Converts this Address to JSON.
     * @function toJSON
     * @memberof Address
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    Address.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return Address;
})();

$root.BrowseLink = (function() {

    /**
     * Properties of a BrowseLink.
     * @exports IBrowseLink
     * @interface IBrowseLink
     * @property {string|null} [name] BrowseLink name
     * @property {string|null} [dataUrl] BrowseLink dataUrl
     * @property {Uint8Array|null} [serverLogsCookie] BrowseLink serverLogsCookie
     * @property {IImage|null} [icon] BrowseLink icon
     */

    /**
     * Constructs a new BrowseLink.
     * @exports BrowseLink
     * @classdesc Represents a BrowseLink.
     * @implements IBrowseLink
     * @constructor
     * @param {IBrowseLink=} [properties] Properties to set
     */
    function BrowseLink(properties) {
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * BrowseLink name.
     * @member {string} name
     * @memberof BrowseLink
     * @instance
     */
    BrowseLink.prototype.name = "";

    /**
     * BrowseLink dataUrl.
     * @member {string} dataUrl
     * @memberof BrowseLink
     * @instance
     */
    BrowseLink.prototype.dataUrl = "";

    /**
     * BrowseLink serverLogsCookie.
     * @member {Uint8Array} serverLogsCookie
     * @memberof BrowseLink
     * @instance
     */
    BrowseLink.prototype.serverLogsCookie = $util.newBuffer([]);

    /**
     * BrowseLink icon.
     * @member {IImage|null|undefined} icon
     * @memberof BrowseLink
     * @instance
     */
    BrowseLink.prototype.icon = null;

    /**
     * Creates a new BrowseLink instance using the specified properties.
     * @function create
     * @memberof BrowseLink
     * @static
     * @param {IBrowseLink=} [properties] Properties to set
     * @returns {BrowseLink} BrowseLink instance
     */
    BrowseLink.create = function create(properties) {
        return new BrowseLink(properties);
    };

    /**
     * Encodes the specified BrowseLink message. Does not implicitly {@link BrowseLink.verify|verify} messages.
     * @function encode
     * @memberof BrowseLink
     * @static
     * @param {IBrowseLink} message BrowseLink message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    BrowseLink.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.name != null && Object.hasOwnProperty.call(message, "name"))
            writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
        if (message.dataUrl != null && Object.hasOwnProperty.call(message, "dataUrl"))
            writer.uint32(/* id 3, wireType 2 =*/26).string(message.dataUrl);
        if (message.serverLogsCookie != null && Object.hasOwnProperty.call(message, "serverLogsCookie"))
            writer.uint32(/* id 4, wireType 2 =*/34).bytes(message.serverLogsCookie);
        if (message.icon != null && Object.hasOwnProperty.call(message, "icon"))
            $root.Image.encode(message.icon, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
        return writer;
    };

    /**
     * Encodes the specified BrowseLink message, length delimited. Does not implicitly {@link BrowseLink.verify|verify} messages.
     * @function encodeDelimited
     * @memberof BrowseLink
     * @static
     * @param {IBrowseLink} message BrowseLink message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    BrowseLink.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a BrowseLink message from the specified reader or buffer.
     * @function decode
     * @memberof BrowseLink
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {BrowseLink} BrowseLink
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    BrowseLink.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.BrowseLink();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.name = reader.string();
                break;
            case 3:
                message.dataUrl = reader.string();
                break;
            case 4:
                message.serverLogsCookie = reader.bytes();
                break;
            case 5:
                message.icon = $root.Image.decode(reader, reader.uint32());
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a BrowseLink message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof BrowseLink
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {BrowseLink} BrowseLink
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    BrowseLink.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a BrowseLink message.
     * @function verify
     * @memberof BrowseLink
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    BrowseLink.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.name != null && message.hasOwnProperty("name"))
            if (!$util.isString(message.name))
                return "name: string expected";
        if (message.dataUrl != null && message.hasOwnProperty("dataUrl"))
            if (!$util.isString(message.dataUrl))
                return "dataUrl: string expected";
        if (message.serverLogsCookie != null && message.hasOwnProperty("serverLogsCookie"))
            if (!(message.serverLogsCookie && typeof message.serverLogsCookie.length === "number" || $util.isString(message.serverLogsCookie)))
                return "serverLogsCookie: buffer expected";
        if (message.icon != null && message.hasOwnProperty("icon")) {
            var error = $root.Image.verify(message.icon);
            if (error)
                return "icon." + error;
        }
        return null;
    };

    /**
     * Creates a BrowseLink message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof BrowseLink
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {BrowseLink} BrowseLink
     */
    BrowseLink.fromObject = function fromObject(object) {
        if (object instanceof $root.BrowseLink)
            return object;
        var message = new $root.BrowseLink();
        if (object.name != null)
            message.name = String(object.name);
        if (object.dataUrl != null)
            message.dataUrl = String(object.dataUrl);
        if (object.serverLogsCookie != null)
            if (typeof object.serverLogsCookie === "string")
                $util.base64.decode(object.serverLogsCookie, message.serverLogsCookie = $util.newBuffer($util.base64.length(object.serverLogsCookie)), 0);
            else if (object.serverLogsCookie.length)
                message.serverLogsCookie = object.serverLogsCookie;
        if (object.icon != null) {
            if (typeof object.icon !== "object")
                throw TypeError(".BrowseLink.icon: object expected");
            message.icon = $root.Image.fromObject(object.icon);
        }
        return message;
    };

    /**
     * Creates a plain object from a BrowseLink message. Also converts values to other types if specified.
     * @function toObject
     * @memberof BrowseLink
     * @static
     * @param {BrowseLink} message BrowseLink
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    BrowseLink.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        var object = {};
        if (options.defaults) {
            object.name = "";
            object.dataUrl = "";
            if (options.bytes === String)
                object.serverLogsCookie = "";
            else {
                object.serverLogsCookie = [];
                if (options.bytes !== Array)
                    object.serverLogsCookie = $util.newBuffer(object.serverLogsCookie);
            }
            object.icon = null;
        }
        if (message.name != null && message.hasOwnProperty("name"))
            object.name = message.name;
        if (message.dataUrl != null && message.hasOwnProperty("dataUrl"))
            object.dataUrl = message.dataUrl;
        if (message.serverLogsCookie != null && message.hasOwnProperty("serverLogsCookie"))
            object.serverLogsCookie = options.bytes === String ? $util.base64.encode(message.serverLogsCookie, 0, message.serverLogsCookie.length) : options.bytes === Array ? Array.prototype.slice.call(message.serverLogsCookie) : message.serverLogsCookie;
        if (message.icon != null && message.hasOwnProperty("icon"))
            object.icon = $root.Image.toObject(message.icon, options);
        return object;
    };

    /**
     * Converts this BrowseLink to JSON.
     * @function toJSON
     * @memberof BrowseLink
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    BrowseLink.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return BrowseLink;
})();

$root.BrowseResponse = (function() {

    /**
     * Properties of a BrowseResponse.
     * @exports IBrowseResponse
     * @interface IBrowseResponse
     * @property {string|null} [contentsUrl] BrowseResponse contentsUrl
     * @property {string|null} [promoUrl] BrowseResponse promoUrl
     * @property {Array.<IBrowseLink>|null} [category] BrowseResponse category
     * @property {Array.<IBrowseLink>|null} [breadcrumb] BrowseResponse breadcrumb
     * @property {Array.<IQuickLink>|null} [quickLink] BrowseResponse quickLink
     * @property {Uint8Array|null} [serverLogsCookie] BrowseResponse serverLogsCookie
     * @property {string|null} [title] BrowseResponse title
     * @property {number|null} [backendId] BrowseResponse backendId
     * @property {IBrowseTab|null} [browseTab] BrowseResponse browseTab
     * @property {number|null} [landingTabIndex] BrowseResponse landingTabIndex
     * @property {number|null} [quickLinkTabIndex] BrowseResponse quickLinkTabIndex
     * @property {number|null} [quickLinkFallbackTabIndex] BrowseResponse quickLinkFallbackTabIndex
     * @property {boolean|null} [isFamilySafe] BrowseResponse isFamilySafe
     * @property {string|null} [shareUrl] BrowseResponse shareUrl
     */

    /**
     * Constructs a new BrowseResponse.
     * @exports BrowseResponse
     * @classdesc Represents a BrowseResponse.
     * @implements IBrowseResponse
     * @constructor
     * @param {IBrowseResponse=} [properties] Properties to set
     */
    function BrowseResponse(properties) {
        this.category = [];
        this.breadcrumb = [];
        this.quickLink = [];
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * BrowseResponse contentsUrl.
     * @member {string} contentsUrl
     * @memberof BrowseResponse
     * @instance
     */
    BrowseResponse.prototype.contentsUrl = "";

    /**
     * BrowseResponse promoUrl.
     * @member {string} promoUrl
     * @memberof BrowseResponse
     * @instance
     */
    BrowseResponse.prototype.promoUrl = "";

    /**
     * BrowseResponse category.
     * @member {Array.<IBrowseLink>} category
     * @memberof BrowseResponse
     * @instance
     */
    BrowseResponse.prototype.category = $util.emptyArray;

    /**
     * BrowseResponse breadcrumb.
     * @member {Array.<IBrowseLink>} breadcrumb
     * @memberof BrowseResponse
     * @instance
     */
    BrowseResponse.prototype.breadcrumb = $util.emptyArray;

    /**
     * BrowseResponse quickLink.
     * @member {Array.<IQuickLink>} quickLink
     * @memberof BrowseResponse
     * @instance
     */
    BrowseResponse.prototype.quickLink = $util.emptyArray;

    /**
     * BrowseResponse serverLogsCookie.
     * @member {Uint8Array} serverLogsCookie
     * @memberof BrowseResponse
     * @instance
     */
    BrowseResponse.prototype.serverLogsCookie = $util.newBuffer([]);

    /**
     * BrowseResponse title.
     * @member {string} title
     * @memberof BrowseResponse
     * @instance
     */
    BrowseResponse.prototype.title = "";

    /**
     * BrowseResponse backendId.
     * @member {number} backendId
     * @memberof BrowseResponse
     * @instance
     */
    BrowseResponse.prototype.backendId = 0;

    /**
     * BrowseResponse browseTab.
     * @member {IBrowseTab|null|undefined} browseTab
     * @memberof BrowseResponse
     * @instance
     */
    BrowseResponse.prototype.browseTab = null;

    /**
     * BrowseResponse landingTabIndex.
     * @member {number} landingTabIndex
     * @memberof BrowseResponse
     * @instance
     */
    BrowseResponse.prototype.landingTabIndex = 0;

    /**
     * BrowseResponse quickLinkTabIndex.
     * @member {number} quickLinkTabIndex
     * @memberof BrowseResponse
     * @instance
     */
    BrowseResponse.prototype.quickLinkTabIndex = 0;

    /**
     * BrowseResponse quickLinkFallbackTabIndex.
     * @member {number} quickLinkFallbackTabIndex
     * @memberof BrowseResponse
     * @instance
     */
    BrowseResponse.prototype.quickLinkFallbackTabIndex = 0;

    /**
     * BrowseResponse isFamilySafe.
     * @member {boolean} isFamilySafe
     * @memberof BrowseResponse
     * @instance
     */
    BrowseResponse.prototype.isFamilySafe = false;

    /**
     * BrowseResponse shareUrl.
     * @member {string} shareUrl
     * @memberof BrowseResponse
     * @instance
     */
    BrowseResponse.prototype.shareUrl = "";

    /**
     * Creates a new BrowseResponse instance using the specified properties.
     * @function create
     * @memberof BrowseResponse
     * @static
     * @param {IBrowseResponse=} [properties] Properties to set
     * @returns {BrowseResponse} BrowseResponse instance
     */
    BrowseResponse.create = function create(properties) {
        return new BrowseResponse(properties);
    };

    /**
     * Encodes the specified BrowseResponse message. Does not implicitly {@link BrowseResponse.verify|verify} messages.
     * @function encode
     * @memberof BrowseResponse
     * @static
     * @param {IBrowseResponse} message BrowseResponse message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    BrowseResponse.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.contentsUrl != null && Object.hasOwnProperty.call(message, "contentsUrl"))
            writer.uint32(/* id 1, wireType 2 =*/10).string(message.contentsUrl);
        if (message.promoUrl != null && Object.hasOwnProperty.call(message, "promoUrl"))
            writer.uint32(/* id 2, wireType 2 =*/18).string(message.promoUrl);
        if (message.category != null && message.category.length)
            for (var i = 0; i < message.category.length; ++i)
                $root.BrowseLink.encode(message.category[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
        if (message.breadcrumb != null && message.breadcrumb.length)
            for (var i = 0; i < message.breadcrumb.length; ++i)
                $root.BrowseLink.encode(message.breadcrumb[i], writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
        if (message.quickLink != null && message.quickLink.length)
            for (var i = 0; i < message.quickLink.length; ++i)
                $root.QuickLink.encode(message.quickLink[i], writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
        if (message.serverLogsCookie != null && Object.hasOwnProperty.call(message, "serverLogsCookie"))
            writer.uint32(/* id 6, wireType 2 =*/50).bytes(message.serverLogsCookie);
        if (message.title != null && Object.hasOwnProperty.call(message, "title"))
            writer.uint32(/* id 7, wireType 2 =*/58).string(message.title);
        if (message.backendId != null && Object.hasOwnProperty.call(message, "backendId"))
            writer.uint32(/* id 8, wireType 0 =*/64).int32(message.backendId);
        if (message.browseTab != null && Object.hasOwnProperty.call(message, "browseTab"))
            $root.BrowseTab.encode(message.browseTab, writer.uint32(/* id 9, wireType 2 =*/74).fork()).ldelim();
        if (message.landingTabIndex != null && Object.hasOwnProperty.call(message, "landingTabIndex"))
            writer.uint32(/* id 10, wireType 0 =*/80).int32(message.landingTabIndex);
        if (message.quickLinkTabIndex != null && Object.hasOwnProperty.call(message, "quickLinkTabIndex"))
            writer.uint32(/* id 11, wireType 0 =*/88).int32(message.quickLinkTabIndex);
        if (message.quickLinkFallbackTabIndex != null && Object.hasOwnProperty.call(message, "quickLinkFallbackTabIndex"))
            writer.uint32(/* id 12, wireType 0 =*/96).int32(message.quickLinkFallbackTabIndex);
        if (message.isFamilySafe != null && Object.hasOwnProperty.call(message, "isFamilySafe"))
            writer.uint32(/* id 14, wireType 0 =*/112).bool(message.isFamilySafe);
        if (message.shareUrl != null && Object.hasOwnProperty.call(message, "shareUrl"))
            writer.uint32(/* id 18, wireType 2 =*/146).string(message.shareUrl);
        return writer;
    };

    /**
     * Encodes the specified BrowseResponse message, length delimited. Does not implicitly {@link BrowseResponse.verify|verify} messages.
     * @function encodeDelimited
     * @memberof BrowseResponse
     * @static
     * @param {IBrowseResponse} message BrowseResponse message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    BrowseResponse.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a BrowseResponse message from the specified reader or buffer.
     * @function decode
     * @memberof BrowseResponse
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {BrowseResponse} BrowseResponse
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    BrowseResponse.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.BrowseResponse();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.contentsUrl = reader.string();
                break;
            case 2:
                message.promoUrl = reader.string();
                break;
            case 3:
                if (!(message.category && message.category.length))
                    message.category = [];
                message.category.push($root.BrowseLink.decode(reader, reader.uint32()));
                break;
            case 4:
                if (!(message.breadcrumb && message.breadcrumb.length))
                    message.breadcrumb = [];
                message.breadcrumb.push($root.BrowseLink.decode(reader, reader.uint32()));
                break;
            case 5:
                if (!(message.quickLink && message.quickLink.length))
                    message.quickLink = [];
                message.quickLink.push($root.QuickLink.decode(reader, reader.uint32()));
                break;
            case 6:
                message.serverLogsCookie = reader.bytes();
                break;
            case 7:
                message.title = reader.string();
                break;
            case 8:
                message.backendId = reader.int32();
                break;
            case 9:
                message.browseTab = $root.BrowseTab.decode(reader, reader.uint32());
                break;
            case 10:
                message.landingTabIndex = reader.int32();
                break;
            case 11:
                message.quickLinkTabIndex = reader.int32();
                break;
            case 12:
                message.quickLinkFallbackTabIndex = reader.int32();
                break;
            case 14:
                message.isFamilySafe = reader.bool();
                break;
            case 18:
                message.shareUrl = reader.string();
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a BrowseResponse message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof BrowseResponse
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {BrowseResponse} BrowseResponse
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    BrowseResponse.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a BrowseResponse message.
     * @function verify
     * @memberof BrowseResponse
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    BrowseResponse.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.contentsUrl != null && message.hasOwnProperty("contentsUrl"))
            if (!$util.isString(message.contentsUrl))
                return "contentsUrl: string expected";
        if (message.promoUrl != null && message.hasOwnProperty("promoUrl"))
            if (!$util.isString(message.promoUrl))
                return "promoUrl: string expected";
        if (message.category != null && message.hasOwnProperty("category")) {
            if (!Array.isArray(message.category))
                return "category: array expected";
            for (var i = 0; i < message.category.length; ++i) {
                var error = $root.BrowseLink.verify(message.category[i]);
                if (error)
                    return "category." + error;
            }
        }
        if (message.breadcrumb != null && message.hasOwnProperty("breadcrumb")) {
            if (!Array.isArray(message.breadcrumb))
                return "breadcrumb: array expected";
            for (var i = 0; i < message.breadcrumb.length; ++i) {
                var error = $root.BrowseLink.verify(message.breadcrumb[i]);
                if (error)
                    return "breadcrumb." + error;
            }
        }
        if (message.quickLink != null && message.hasOwnProperty("quickLink")) {
            if (!Array.isArray(message.quickLink))
                return "quickLink: array expected";
            for (var i = 0; i < message.quickLink.length; ++i) {
                var error = $root.QuickLink.verify(message.quickLink[i]);
                if (error)
                    return "quickLink." + error;
            }
        }
        if (message.serverLogsCookie != null && message.hasOwnProperty("serverLogsCookie"))
            if (!(message.serverLogsCookie && typeof message.serverLogsCookie.length === "number" || $util.isString(message.serverLogsCookie)))
                return "serverLogsCookie: buffer expected";
        if (message.title != null && message.hasOwnProperty("title"))
            if (!$util.isString(message.title))
                return "title: string expected";
        if (message.backendId != null && message.hasOwnProperty("backendId"))
            if (!$util.isInteger(message.backendId))
                return "backendId: integer expected";
        if (message.browseTab != null && message.hasOwnProperty("browseTab")) {
            var error = $root.BrowseTab.verify(message.browseTab);
            if (error)
                return "browseTab." + error;
        }
        if (message.landingTabIndex != null && message.hasOwnProperty("landingTabIndex"))
            if (!$util.isInteger(message.landingTabIndex))
                return "landingTabIndex: integer expected";
        if (message.quickLinkTabIndex != null && message.hasOwnProperty("quickLinkTabIndex"))
            if (!$util.isInteger(message.quickLinkTabIndex))
                return "quickLinkTabIndex: integer expected";
        if (message.quickLinkFallbackTabIndex != null && message.hasOwnProperty("quickLinkFallbackTabIndex"))
            if (!$util.isInteger(message.quickLinkFallbackTabIndex))
                return "quickLinkFallbackTabIndex: integer expected";
        if (message.isFamilySafe != null && message.hasOwnProperty("isFamilySafe"))
            if (typeof message.isFamilySafe !== "boolean")
                return "isFamilySafe: boolean expected";
        if (message.shareUrl != null && message.hasOwnProperty("shareUrl"))
            if (!$util.isString(message.shareUrl))
                return "shareUrl: string expected";
        return null;
    };

    /**
     * Creates a BrowseResponse message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof BrowseResponse
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {BrowseResponse} BrowseResponse
     */
    BrowseResponse.fromObject = function fromObject(object) {
        if (object instanceof $root.BrowseResponse)
            return object;
        var message = new $root.BrowseResponse();
        if (object.contentsUrl != null)
            message.contentsUrl = String(object.contentsUrl);
        if (object.promoUrl != null)
            message.promoUrl = String(object.promoUrl);
        if (object.category) {
            if (!Array.isArray(object.category))
                throw TypeError(".BrowseResponse.category: array expected");
            message.category = [];
            for (var i = 0; i < object.category.length; ++i) {
                if (typeof object.category[i] !== "object")
                    throw TypeError(".BrowseResponse.category: object expected");
                message.category[i] = $root.BrowseLink.fromObject(object.category[i]);
            }
        }
        if (object.breadcrumb) {
            if (!Array.isArray(object.breadcrumb))
                throw TypeError(".BrowseResponse.breadcrumb: array expected");
            message.breadcrumb = [];
            for (var i = 0; i < object.breadcrumb.length; ++i) {
                if (typeof object.breadcrumb[i] !== "object")
                    throw TypeError(".BrowseResponse.breadcrumb: object expected");
                message.breadcrumb[i] = $root.BrowseLink.fromObject(object.breadcrumb[i]);
            }
        }
        if (object.quickLink) {
            if (!Array.isArray(object.quickLink))
                throw TypeError(".BrowseResponse.quickLink: array expected");
            message.quickLink = [];
            for (var i = 0; i < object.quickLink.length; ++i) {
                if (typeof object.quickLink[i] !== "object")
                    throw TypeError(".BrowseResponse.quickLink: object expected");
                message.quickLink[i] = $root.QuickLink.fromObject(object.quickLink[i]);
            }
        }
        if (object.serverLogsCookie != null)
            if (typeof object.serverLogsCookie === "string")
                $util.base64.decode(object.serverLogsCookie, message.serverLogsCookie = $util.newBuffer($util.base64.length(object.serverLogsCookie)), 0);
            else if (object.serverLogsCookie.length)
                message.serverLogsCookie = object.serverLogsCookie;
        if (object.title != null)
            message.title = String(object.title);
        if (object.backendId != null)
            message.backendId = object.backendId | 0;
        if (object.browseTab != null) {
            if (typeof object.browseTab !== "object")
                throw TypeError(".BrowseResponse.browseTab: object expected");
            message.browseTab = $root.BrowseTab.fromObject(object.browseTab);
        }
        if (object.landingTabIndex != null)
            message.landingTabIndex = object.landingTabIndex | 0;
        if (object.quickLinkTabIndex != null)
            message.quickLinkTabIndex = object.quickLinkTabIndex | 0;
        if (object.quickLinkFallbackTabIndex != null)
            message.quickLinkFallbackTabIndex = object.quickLinkFallbackTabIndex | 0;
        if (object.isFamilySafe != null)
            message.isFamilySafe = Boolean(object.isFamilySafe);
        if (object.shareUrl != null)
            message.shareUrl = String(object.shareUrl);
        return message;
    };

    /**
     * Creates a plain object from a BrowseResponse message. Also converts values to other types if specified.
     * @function toObject
     * @memberof BrowseResponse
     * @static
     * @param {BrowseResponse} message BrowseResponse
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    BrowseResponse.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        var object = {};
        if (options.arrays || options.defaults) {
            object.category = [];
            object.breadcrumb = [];
            object.quickLink = [];
        }
        if (options.defaults) {
            object.contentsUrl = "";
            object.promoUrl = "";
            if (options.bytes === String)
                object.serverLogsCookie = "";
            else {
                object.serverLogsCookie = [];
                if (options.bytes !== Array)
                    object.serverLogsCookie = $util.newBuffer(object.serverLogsCookie);
            }
            object.title = "";
            object.backendId = 0;
            object.browseTab = null;
            object.landingTabIndex = 0;
            object.quickLinkTabIndex = 0;
            object.quickLinkFallbackTabIndex = 0;
            object.isFamilySafe = false;
            object.shareUrl = "";
        }
        if (message.contentsUrl != null && message.hasOwnProperty("contentsUrl"))
            object.contentsUrl = message.contentsUrl;
        if (message.promoUrl != null && message.hasOwnProperty("promoUrl"))
            object.promoUrl = message.promoUrl;
        if (message.category && message.category.length) {
            object.category = [];
            for (var j = 0; j < message.category.length; ++j)
                object.category[j] = $root.BrowseLink.toObject(message.category[j], options);
        }
        if (message.breadcrumb && message.breadcrumb.length) {
            object.breadcrumb = [];
            for (var j = 0; j < message.breadcrumb.length; ++j)
                object.breadcrumb[j] = $root.BrowseLink.toObject(message.breadcrumb[j], options);
        }
        if (message.quickLink && message.quickLink.length) {
            object.quickLink = [];
            for (var j = 0; j < message.quickLink.length; ++j)
                object.quickLink[j] = $root.QuickLink.toObject(message.quickLink[j], options);
        }
        if (message.serverLogsCookie != null && message.hasOwnProperty("serverLogsCookie"))
            object.serverLogsCookie = options.bytes === String ? $util.base64.encode(message.serverLogsCookie, 0, message.serverLogsCookie.length) : options.bytes === Array ? Array.prototype.slice.call(message.serverLogsCookie) : message.serverLogsCookie;
        if (message.title != null && message.hasOwnProperty("title"))
            object.title = message.title;
        if (message.backendId != null && message.hasOwnProperty("backendId"))
            object.backendId = message.backendId;
        if (message.browseTab != null && message.hasOwnProperty("browseTab"))
            object.browseTab = $root.BrowseTab.toObject(message.browseTab, options);
        if (message.landingTabIndex != null && message.hasOwnProperty("landingTabIndex"))
            object.landingTabIndex = message.landingTabIndex;
        if (message.quickLinkTabIndex != null && message.hasOwnProperty("quickLinkTabIndex"))
            object.quickLinkTabIndex = message.quickLinkTabIndex;
        if (message.quickLinkFallbackTabIndex != null && message.hasOwnProperty("quickLinkFallbackTabIndex"))
            object.quickLinkFallbackTabIndex = message.quickLinkFallbackTabIndex;
        if (message.isFamilySafe != null && message.hasOwnProperty("isFamilySafe"))
            object.isFamilySafe = message.isFamilySafe;
        if (message.shareUrl != null && message.hasOwnProperty("shareUrl"))
            object.shareUrl = message.shareUrl;
        return object;
    };

    /**
     * Converts this BrowseResponse to JSON.
     * @function toJSON
     * @memberof BrowseResponse
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    BrowseResponse.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return BrowseResponse;
})();

$root.DirectPurchase = (function() {

    /**
     * Properties of a DirectPurchase.
     * @exports IDirectPurchase
     * @interface IDirectPurchase
     * @property {string|null} [detailsUrl] DirectPurchase detailsUrl
     * @property {string|null} [purchaseItemId] DirectPurchase purchaseItemId
     * @property {string|null} [parentItemId] DirectPurchase parentItemId
     * @property {number|null} [offerType] DirectPurchase offerType
     */

    /**
     * Constructs a new DirectPurchase.
     * @exports DirectPurchase
     * @classdesc Represents a DirectPurchase.
     * @implements IDirectPurchase
     * @constructor
     * @param {IDirectPurchase=} [properties] Properties to set
     */
    function DirectPurchase(properties) {
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * DirectPurchase detailsUrl.
     * @member {string} detailsUrl
     * @memberof DirectPurchase
     * @instance
     */
    DirectPurchase.prototype.detailsUrl = "";

    /**
     * DirectPurchase purchaseItemId.
     * @member {string} purchaseItemId
     * @memberof DirectPurchase
     * @instance
     */
    DirectPurchase.prototype.purchaseItemId = "";

    /**
     * DirectPurchase parentItemId.
     * @member {string} parentItemId
     * @memberof DirectPurchase
     * @instance
     */
    DirectPurchase.prototype.parentItemId = "";

    /**
     * DirectPurchase offerType.
     * @member {number} offerType
     * @memberof DirectPurchase
     * @instance
     */
    DirectPurchase.prototype.offerType = 1;

    /**
     * Creates a new DirectPurchase instance using the specified properties.
     * @function create
     * @memberof DirectPurchase
     * @static
     * @param {IDirectPurchase=} [properties] Properties to set
     * @returns {DirectPurchase} DirectPurchase instance
     */
    DirectPurchase.create = function create(properties) {
        return new DirectPurchase(properties);
    };

    /**
     * Encodes the specified DirectPurchase message. Does not implicitly {@link DirectPurchase.verify|verify} messages.
     * @function encode
     * @memberof DirectPurchase
     * @static
     * @param {IDirectPurchase} message DirectPurchase message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    DirectPurchase.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.detailsUrl != null && Object.hasOwnProperty.call(message, "detailsUrl"))
            writer.uint32(/* id 1, wireType 2 =*/10).string(message.detailsUrl);
        if (message.purchaseItemId != null && Object.hasOwnProperty.call(message, "purchaseItemId"))
            writer.uint32(/* id 2, wireType 2 =*/18).string(message.purchaseItemId);
        if (message.parentItemId != null && Object.hasOwnProperty.call(message, "parentItemId"))
            writer.uint32(/* id 3, wireType 2 =*/26).string(message.parentItemId);
        if (message.offerType != null && Object.hasOwnProperty.call(message, "offerType"))
            writer.uint32(/* id 4, wireType 0 =*/32).int32(message.offerType);
        return writer;
    };

    /**
     * Encodes the specified DirectPurchase message, length delimited. Does not implicitly {@link DirectPurchase.verify|verify} messages.
     * @function encodeDelimited
     * @memberof DirectPurchase
     * @static
     * @param {IDirectPurchase} message DirectPurchase message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    DirectPurchase.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a DirectPurchase message from the specified reader or buffer.
     * @function decode
     * @memberof DirectPurchase
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {DirectPurchase} DirectPurchase
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    DirectPurchase.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.DirectPurchase();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.detailsUrl = reader.string();
                break;
            case 2:
                message.purchaseItemId = reader.string();
                break;
            case 3:
                message.parentItemId = reader.string();
                break;
            case 4:
                message.offerType = reader.int32();
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a DirectPurchase message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof DirectPurchase
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {DirectPurchase} DirectPurchase
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    DirectPurchase.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a DirectPurchase message.
     * @function verify
     * @memberof DirectPurchase
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    DirectPurchase.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.detailsUrl != null && message.hasOwnProperty("detailsUrl"))
            if (!$util.isString(message.detailsUrl))
                return "detailsUrl: string expected";
        if (message.purchaseItemId != null && message.hasOwnProperty("purchaseItemId"))
            if (!$util.isString(message.purchaseItemId))
                return "purchaseItemId: string expected";
        if (message.parentItemId != null && message.hasOwnProperty("parentItemId"))
            if (!$util.isString(message.parentItemId))
                return "parentItemId: string expected";
        if (message.offerType != null && message.hasOwnProperty("offerType"))
            if (!$util.isInteger(message.offerType))
                return "offerType: integer expected";
        return null;
    };

    /**
     * Creates a DirectPurchase message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof DirectPurchase
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {DirectPurchase} DirectPurchase
     */
    DirectPurchase.fromObject = function fromObject(object) {
        if (object instanceof $root.DirectPurchase)
            return object;
        var message = new $root.DirectPurchase();
        if (object.detailsUrl != null)
            message.detailsUrl = String(object.detailsUrl);
        if (object.purchaseItemId != null)
            message.purchaseItemId = String(object.purchaseItemId);
        if (object.parentItemId != null)
            message.parentItemId = String(object.parentItemId);
        if (object.offerType != null)
            message.offerType = object.offerType | 0;
        return message;
    };

    /**
     * Creates a plain object from a DirectPurchase message. Also converts values to other types if specified.
     * @function toObject
     * @memberof DirectPurchase
     * @static
     * @param {DirectPurchase} message DirectPurchase
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    DirectPurchase.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        var object = {};
        if (options.defaults) {
            object.detailsUrl = "";
            object.purchaseItemId = "";
            object.parentItemId = "";
            object.offerType = 1;
        }
        if (message.detailsUrl != null && message.hasOwnProperty("detailsUrl"))
            object.detailsUrl = message.detailsUrl;
        if (message.purchaseItemId != null && message.hasOwnProperty("purchaseItemId"))
            object.purchaseItemId = message.purchaseItemId;
        if (message.parentItemId != null && message.hasOwnProperty("parentItemId"))
            object.parentItemId = message.parentItemId;
        if (message.offerType != null && message.hasOwnProperty("offerType"))
            object.offerType = message.offerType;
        return object;
    };

    /**
     * Converts this DirectPurchase to JSON.
     * @function toJSON
     * @memberof DirectPurchase
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    DirectPurchase.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return DirectPurchase;
})();

$root.RedeemGiftCard = (function() {

    /**
     * Properties of a RedeemGiftCard.
     * @exports IRedeemGiftCard
     * @interface IRedeemGiftCard
     * @property {string|null} [prefillCode] RedeemGiftCard prefillCode
     * @property {string|null} [partnerPayload] RedeemGiftCard partnerPayload
     */

    /**
     * Constructs a new RedeemGiftCard.
     * @exports RedeemGiftCard
     * @classdesc Represents a RedeemGiftCard.
     * @implements IRedeemGiftCard
     * @constructor
     * @param {IRedeemGiftCard=} [properties] Properties to set
     */
    function RedeemGiftCard(properties) {
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * RedeemGiftCard prefillCode.
     * @member {string} prefillCode
     * @memberof RedeemGiftCard
     * @instance
     */
    RedeemGiftCard.prototype.prefillCode = "";

    /**
     * RedeemGiftCard partnerPayload.
     * @member {string} partnerPayload
     * @memberof RedeemGiftCard
     * @instance
     */
    RedeemGiftCard.prototype.partnerPayload = "";

    /**
     * Creates a new RedeemGiftCard instance using the specified properties.
     * @function create
     * @memberof RedeemGiftCard
     * @static
     * @param {IRedeemGiftCard=} [properties] Properties to set
     * @returns {RedeemGiftCard} RedeemGiftCard instance
     */
    RedeemGiftCard.create = function create(properties) {
        return new RedeemGiftCard(properties);
    };

    /**
     * Encodes the specified RedeemGiftCard message. Does not implicitly {@link RedeemGiftCard.verify|verify} messages.
     * @function encode
     * @memberof RedeemGiftCard
     * @static
     * @param {IRedeemGiftCard} message RedeemGiftCard message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    RedeemGiftCard.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.prefillCode != null && Object.hasOwnProperty.call(message, "prefillCode"))
            writer.uint32(/* id 1, wireType 2 =*/10).string(message.prefillCode);
        if (message.partnerPayload != null && Object.hasOwnProperty.call(message, "partnerPayload"))
            writer.uint32(/* id 2, wireType 2 =*/18).string(message.partnerPayload);
        return writer;
    };

    /**
     * Encodes the specified RedeemGiftCard message, length delimited. Does not implicitly {@link RedeemGiftCard.verify|verify} messages.
     * @function encodeDelimited
     * @memberof RedeemGiftCard
     * @static
     * @param {IRedeemGiftCard} message RedeemGiftCard message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    RedeemGiftCard.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a RedeemGiftCard message from the specified reader or buffer.
     * @function decode
     * @memberof RedeemGiftCard
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {RedeemGiftCard} RedeemGiftCard
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    RedeemGiftCard.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.RedeemGiftCard();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.prefillCode = reader.string();
                break;
            case 2:
                message.partnerPayload = reader.string();
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a RedeemGiftCard message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof RedeemGiftCard
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {RedeemGiftCard} RedeemGiftCard
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    RedeemGiftCard.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a RedeemGiftCard message.
     * @function verify
     * @memberof RedeemGiftCard
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    RedeemGiftCard.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.prefillCode != null && message.hasOwnProperty("prefillCode"))
            if (!$util.isString(message.prefillCode))
                return "prefillCode: string expected";
        if (message.partnerPayload != null && message.hasOwnProperty("partnerPayload"))
            if (!$util.isString(message.partnerPayload))
                return "partnerPayload: string expected";
        return null;
    };

    /**
     * Creates a RedeemGiftCard message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof RedeemGiftCard
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {RedeemGiftCard} RedeemGiftCard
     */
    RedeemGiftCard.fromObject = function fromObject(object) {
        if (object instanceof $root.RedeemGiftCard)
            return object;
        var message = new $root.RedeemGiftCard();
        if (object.prefillCode != null)
            message.prefillCode = String(object.prefillCode);
        if (object.partnerPayload != null)
            message.partnerPayload = String(object.partnerPayload);
        return message;
    };

    /**
     * Creates a plain object from a RedeemGiftCard message. Also converts values to other types if specified.
     * @function toObject
     * @memberof RedeemGiftCard
     * @static
     * @param {RedeemGiftCard} message RedeemGiftCard
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    RedeemGiftCard.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        var object = {};
        if (options.defaults) {
            object.prefillCode = "";
            object.partnerPayload = "";
        }
        if (message.prefillCode != null && message.hasOwnProperty("prefillCode"))
            object.prefillCode = message.prefillCode;
        if (message.partnerPayload != null && message.hasOwnProperty("partnerPayload"))
            object.partnerPayload = message.partnerPayload;
        return object;
    };

    /**
     * Converts this RedeemGiftCard to JSON.
     * @function toJSON
     * @memberof RedeemGiftCard
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    RedeemGiftCard.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return RedeemGiftCard;
})();

$root.ResolvedLink = (function() {

    /**
     * Properties of a ResolvedLink.
     * @exports IResolvedLink
     * @interface IResolvedLink
     * @property {string|null} [detailsUrl] ResolvedLink detailsUrl
     * @property {string|null} [browseUrl] ResolvedLink browseUrl
     * @property {string|null} [searchUrl] ResolvedLink searchUrl
     * @property {IDirectPurchase|null} [directPurchase] ResolvedLink directPurchase
     * @property {string|null} [homeUrl] ResolvedLink homeUrl
     * @property {IRedeemGiftCard|null} [redeemGiftCard] ResolvedLink redeemGiftCard
     * @property {Uint8Array|null} [serverLogsCookie] ResolvedLink serverLogsCookie
     * @property {IDocId|null} [DocId] ResolvedLink DocId
     * @property {string|null} [wishlistUrl] ResolvedLink wishlistUrl
     * @property {number|null} [backend] ResolvedLink backend
     * @property {string|null} [query] ResolvedLink query
     * @property {string|null} [myAccountUrl] ResolvedLink myAccountUrl
     * @property {IHelpCenter|null} [helpCenter] ResolvedLink helpCenter
     */

    /**
     * Constructs a new ResolvedLink.
     * @exports ResolvedLink
     * @classdesc Represents a ResolvedLink.
     * @implements IResolvedLink
     * @constructor
     * @param {IResolvedLink=} [properties] Properties to set
     */
    function ResolvedLink(properties) {
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * ResolvedLink detailsUrl.
     * @member {string} detailsUrl
     * @memberof ResolvedLink
     * @instance
     */
    ResolvedLink.prototype.detailsUrl = "";

    /**
     * ResolvedLink browseUrl.
     * @member {string} browseUrl
     * @memberof ResolvedLink
     * @instance
     */
    ResolvedLink.prototype.browseUrl = "";

    /**
     * ResolvedLink searchUrl.
     * @member {string} searchUrl
     * @memberof ResolvedLink
     * @instance
     */
    ResolvedLink.prototype.searchUrl = "";

    /**
     * ResolvedLink directPurchase.
     * @member {IDirectPurchase|null|undefined} directPurchase
     * @memberof ResolvedLink
     * @instance
     */
    ResolvedLink.prototype.directPurchase = null;

    /**
     * ResolvedLink homeUrl.
     * @member {string} homeUrl
     * @memberof ResolvedLink
     * @instance
     */
    ResolvedLink.prototype.homeUrl = "";

    /**
     * ResolvedLink redeemGiftCard.
     * @member {IRedeemGiftCard|null|undefined} redeemGiftCard
     * @memberof ResolvedLink
     * @instance
     */
    ResolvedLink.prototype.redeemGiftCard = null;

    /**
     * ResolvedLink serverLogsCookie.
     * @member {Uint8Array} serverLogsCookie
     * @memberof ResolvedLink
     * @instance
     */
    ResolvedLink.prototype.serverLogsCookie = $util.newBuffer([]);

    /**
     * ResolvedLink DocId.
     * @member {IDocId|null|undefined} DocId
     * @memberof ResolvedLink
     * @instance
     */
    ResolvedLink.prototype.DocId = null;

    /**
     * ResolvedLink wishlistUrl.
     * @member {string} wishlistUrl
     * @memberof ResolvedLink
     * @instance
     */
    ResolvedLink.prototype.wishlistUrl = "";

    /**
     * ResolvedLink backend.
     * @member {number} backend
     * @memberof ResolvedLink
     * @instance
     */
    ResolvedLink.prototype.backend = 0;

    /**
     * ResolvedLink query.
     * @member {string} query
     * @memberof ResolvedLink
     * @instance
     */
    ResolvedLink.prototype.query = "";

    /**
     * ResolvedLink myAccountUrl.
     * @member {string} myAccountUrl
     * @memberof ResolvedLink
     * @instance
     */
    ResolvedLink.prototype.myAccountUrl = "";

    /**
     * ResolvedLink helpCenter.
     * @member {IHelpCenter|null|undefined} helpCenter
     * @memberof ResolvedLink
     * @instance
     */
    ResolvedLink.prototype.helpCenter = null;

    /**
     * Creates a new ResolvedLink instance using the specified properties.
     * @function create
     * @memberof ResolvedLink
     * @static
     * @param {IResolvedLink=} [properties] Properties to set
     * @returns {ResolvedLink} ResolvedLink instance
     */
    ResolvedLink.create = function create(properties) {
        return new ResolvedLink(properties);
    };

    /**
     * Encodes the specified ResolvedLink message. Does not implicitly {@link ResolvedLink.verify|verify} messages.
     * @function encode
     * @memberof ResolvedLink
     * @static
     * @param {IResolvedLink} message ResolvedLink message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    ResolvedLink.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.detailsUrl != null && Object.hasOwnProperty.call(message, "detailsUrl"))
            writer.uint32(/* id 1, wireType 2 =*/10).string(message.detailsUrl);
        if (message.browseUrl != null && Object.hasOwnProperty.call(message, "browseUrl"))
            writer.uint32(/* id 2, wireType 2 =*/18).string(message.browseUrl);
        if (message.searchUrl != null && Object.hasOwnProperty.call(message, "searchUrl"))
            writer.uint32(/* id 3, wireType 2 =*/26).string(message.searchUrl);
        if (message.directPurchase != null && Object.hasOwnProperty.call(message, "directPurchase"))
            $root.DirectPurchase.encode(message.directPurchase, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
        if (message.homeUrl != null && Object.hasOwnProperty.call(message, "homeUrl"))
            writer.uint32(/* id 5, wireType 2 =*/42).string(message.homeUrl);
        if (message.redeemGiftCard != null && Object.hasOwnProperty.call(message, "redeemGiftCard"))
            $root.RedeemGiftCard.encode(message.redeemGiftCard, writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
        if (message.serverLogsCookie != null && Object.hasOwnProperty.call(message, "serverLogsCookie"))
            writer.uint32(/* id 7, wireType 2 =*/58).bytes(message.serverLogsCookie);
        if (message.DocId != null && Object.hasOwnProperty.call(message, "DocId"))
            $root.DocId.encode(message.DocId, writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();
        if (message.wishlistUrl != null && Object.hasOwnProperty.call(message, "wishlistUrl"))
            writer.uint32(/* id 9, wireType 2 =*/74).string(message.wishlistUrl);
        if (message.backend != null && Object.hasOwnProperty.call(message, "backend"))
            writer.uint32(/* id 10, wireType 0 =*/80).int32(message.backend);
        if (message.query != null && Object.hasOwnProperty.call(message, "query"))
            writer.uint32(/* id 11, wireType 2 =*/90).string(message.query);
        if (message.myAccountUrl != null && Object.hasOwnProperty.call(message, "myAccountUrl"))
            writer.uint32(/* id 12, wireType 2 =*/98).string(message.myAccountUrl);
        if (message.helpCenter != null && Object.hasOwnProperty.call(message, "helpCenter"))
            $root.HelpCenter.encode(message.helpCenter, writer.uint32(/* id 13, wireType 2 =*/106).fork()).ldelim();
        return writer;
    };

    /**
     * Encodes the specified ResolvedLink message, length delimited. Does not implicitly {@link ResolvedLink.verify|verify} messages.
     * @function encodeDelimited
     * @memberof ResolvedLink
     * @static
     * @param {IResolvedLink} message ResolvedLink message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    ResolvedLink.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a ResolvedLink message from the specified reader or buffer.
     * @function decode
     * @memberof ResolvedLink
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {ResolvedLink} ResolvedLink
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    ResolvedLink.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ResolvedLink();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.detailsUrl = reader.string();
                break;
            case 2:
                message.browseUrl = reader.string();
                break;
            case 3:
                message.searchUrl = reader.string();
                break;
            case 4:
                message.directPurchase = $root.DirectPurchase.decode(reader, reader.uint32());
                break;
            case 5:
                message.homeUrl = reader.string();
                break;
            case 6:
                message.redeemGiftCard = $root.RedeemGiftCard.decode(reader, reader.uint32());
                break;
            case 7:
                message.serverLogsCookie = reader.bytes();
                break;
            case 8:
                message.DocId = $root.DocId.decode(reader, reader.uint32());
                break;
            case 9:
                message.wishlistUrl = reader.string();
                break;
            case 10:
                message.backend = reader.int32();
                break;
            case 11:
                message.query = reader.string();
                break;
            case 12:
                message.myAccountUrl = reader.string();
                break;
            case 13:
                message.helpCenter = $root.HelpCenter.decode(reader, reader.uint32());
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a ResolvedLink message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof ResolvedLink
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {ResolvedLink} ResolvedLink
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    ResolvedLink.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a ResolvedLink message.
     * @function verify
     * @memberof ResolvedLink
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    ResolvedLink.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.detailsUrl != null && message.hasOwnProperty("detailsUrl"))
            if (!$util.isString(message.detailsUrl))
                return "detailsUrl: string expected";
        if (message.browseUrl != null && message.hasOwnProperty("browseUrl"))
            if (!$util.isString(message.browseUrl))
                return "browseUrl: string expected";
        if (message.searchUrl != null && message.hasOwnProperty("searchUrl"))
            if (!$util.isString(message.searchUrl))
                return "searchUrl: string expected";
        if (message.directPurchase != null && message.hasOwnProperty("directPurchase")) {
            var error = $root.DirectPurchase.verify(message.directPurchase);
            if (error)
                return "directPurchase." + error;
        }
        if (message.homeUrl != null && message.hasOwnProperty("homeUrl"))
            if (!$util.isString(message.homeUrl))
                return "homeUrl: string expected";
        if (message.redeemGiftCard != null && message.hasOwnProperty("redeemGiftCard")) {
            var error = $root.RedeemGiftCard.verify(message.redeemGiftCard);
            if (error)
                return "redeemGiftCard." + error;
        }
        if (message.serverLogsCookie != null && message.hasOwnProperty("serverLogsCookie"))
            if (!(message.serverLogsCookie && typeof message.serverLogsCookie.length === "number" || $util.isString(message.serverLogsCookie)))
                return "serverLogsCookie: buffer expected";
        if (message.DocId != null && message.hasOwnProperty("DocId")) {
            var error = $root.DocId.verify(message.DocId);
            if (error)
                return "DocId." + error;
        }
        if (message.wishlistUrl != null && message.hasOwnProperty("wishlistUrl"))
            if (!$util.isString(message.wishlistUrl))
                return "wishlistUrl: string expected";
        if (message.backend != null && message.hasOwnProperty("backend"))
            if (!$util.isInteger(message.backend))
                return "backend: integer expected";
        if (message.query != null && message.hasOwnProperty("query"))
            if (!$util.isString(message.query))
                return "query: string expected";
        if (message.myAccountUrl != null && message.hasOwnProperty("myAccountUrl"))
            if (!$util.isString(message.myAccountUrl))
                return "myAccountUrl: string expected";
        if (message.helpCenter != null && message.hasOwnProperty("helpCenter")) {
            var error = $root.HelpCenter.verify(message.helpCenter);
            if (error)
                return "helpCenter." + error;
        }
        return null;
    };

    /**
     * Creates a ResolvedLink message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof ResolvedLink
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {ResolvedLink} ResolvedLink
     */
    ResolvedLink.fromObject = function fromObject(object) {
        if (object instanceof $root.ResolvedLink)
            return object;
        var message = new $root.ResolvedLink();
        if (object.detailsUrl != null)
            message.detailsUrl = String(object.detailsUrl);
        if (object.browseUrl != null)
            message.browseUrl = String(object.browseUrl);
        if (object.searchUrl != null)
            message.searchUrl = String(object.searchUrl);
        if (object.directPurchase != null) {
            if (typeof object.directPurchase !== "object")
                throw TypeError(".ResolvedLink.directPurchase: object expected");
            message.directPurchase = $root.DirectPurchase.fromObject(object.directPurchase);
        }
        if (object.homeUrl != null)
            message.homeUrl = String(object.homeUrl);
        if (object.redeemGiftCard != null) {
            if (typeof object.redeemGiftCard !== "object")
                throw TypeError(".ResolvedLink.redeemGiftCard: object expected");
            message.redeemGiftCard = $root.RedeemGiftCard.fromObject(object.redeemGiftCard);
        }
        if (object.serverLogsCookie != null)
            if (typeof object.serverLogsCookie === "string")
                $util.base64.decode(object.serverLogsCookie, message.serverLogsCookie = $util.newBuffer($util.base64.length(object.serverLogsCookie)), 0);
            else if (object.serverLogsCookie.length)
                message.serverLogsCookie = object.serverLogsCookie;
        if (object.DocId != null) {
            if (typeof object.DocId !== "object")
                throw TypeError(".ResolvedLink.DocId: object expected");
            message.DocId = $root.DocId.fromObject(object.DocId);
        }
        if (object.wishlistUrl != null)
            message.wishlistUrl = String(object.wishlistUrl);
        if (object.backend != null)
            message.backend = object.backend | 0;
        if (object.query != null)
            message.query = String(object.query);
        if (object.myAccountUrl != null)
            message.myAccountUrl = String(object.myAccountUrl);
        if (object.helpCenter != null) {
            if (typeof object.helpCenter !== "object")
                throw TypeError(".ResolvedLink.helpCenter: object expected");
            message.helpCenter = $root.HelpCenter.fromObject(object.helpCenter);
        }
        return message;
    };

    /**
     * Creates a plain object from a ResolvedLink message. Also converts values to other types if specified.
     * @function toObject
     * @memberof ResolvedLink
     * @static
     * @param {ResolvedLink} message ResolvedLink
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    ResolvedLink.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        var object = {};
        if (options.defaults) {
            object.detailsUrl = "";
            object.browseUrl = "";
            object.searchUrl = "";
            object.directPurchase = null;
            object.homeUrl = "";
            object.redeemGiftCard = null;
            if (options.bytes === String)
                object.serverLogsCookie = "";
            else {
                object.serverLogsCookie = [];
                if (options.bytes !== Array)
                    object.serverLogsCookie = $util.newBuffer(object.serverLogsCookie);
            }
            object.DocId = null;
            object.wishlistUrl = "";
            object.backend = 0;
            object.query = "";
            object.myAccountUrl = "";
            object.helpCenter = null;
        }
        if (message.detailsUrl != null && message.hasOwnProperty("detailsUrl"))
            object.detailsUrl = message.detailsUrl;
        if (message.browseUrl != null && message.hasOwnProperty("browseUrl"))
            object.browseUrl = message.browseUrl;
        if (message.searchUrl != null && message.hasOwnProperty("searchUrl"))
            object.searchUrl = message.searchUrl;
        if (message.directPurchase != null && message.hasOwnProperty("directPurchase"))
            object.directPurchase = $root.DirectPurchase.toObject(message.directPurchase, options);
        if (message.homeUrl != null && message.hasOwnProperty("homeUrl"))
            object.homeUrl = message.homeUrl;
        if (message.redeemGiftCard != null && message.hasOwnProperty("redeemGiftCard"))
            object.redeemGiftCard = $root.RedeemGiftCard.toObject(message.redeemGiftCard, options);
        if (message.serverLogsCookie != null && message.hasOwnProperty("serverLogsCookie"))
            object.serverLogsCookie = options.bytes === String ? $util.base64.encode(message.serverLogsCookie, 0, message.serverLogsCookie.length) : options.bytes === Array ? Array.prototype.slice.call(message.serverLogsCookie) : message.serverLogsCookie;
        if (message.DocId != null && message.hasOwnProperty("DocId"))
            object.DocId = $root.DocId.toObject(message.DocId, options);
        if (message.wishlistUrl != null && message.hasOwnProperty("wishlistUrl"))
            object.wishlistUrl = message.wishlistUrl;
        if (message.backend != null && message.hasOwnProperty("backend"))
            object.backend = message.backend;
        if (message.query != null && message.hasOwnProperty("query"))
            object.query = message.query;
        if (message.myAccountUrl != null && message.hasOwnProperty("myAccountUrl"))
            object.myAccountUrl = message.myAccountUrl;
        if (message.helpCenter != null && message.hasOwnProperty("helpCenter"))
            object.helpCenter = $root.HelpCenter.toObject(message.helpCenter, options);
        return object;
    };

    /**
     * Converts this ResolvedLink to JSON.
     * @function toJSON
     * @memberof ResolvedLink
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    ResolvedLink.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return ResolvedLink;
})();

$root.HelpCenter = (function() {

    /**
     * Properties of a HelpCenter.
     * @exports IHelpCenter
     * @interface IHelpCenter
     * @property {string|null} [contextId] HelpCenter contextId
     */

    /**
     * Constructs a new HelpCenter.
     * @exports HelpCenter
     * @classdesc Represents a HelpCenter.
     * @implements IHelpCenter
     * @constructor
     * @param {IHelpCenter=} [properties] Properties to set
     */
    function HelpCenter(properties) {
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * HelpCenter contextId.
     * @member {string} contextId
     * @memberof HelpCenter
     * @instance
     */
    HelpCenter.prototype.contextId = "";

    /**
     * Creates a new HelpCenter instance using the specified properties.
     * @function create
     * @memberof HelpCenter
     * @static
     * @param {IHelpCenter=} [properties] Properties to set
     * @returns {HelpCenter} HelpCenter instance
     */
    HelpCenter.create = function create(properties) {
        return new HelpCenter(properties);
    };

    /**
     * Encodes the specified HelpCenter message. Does not implicitly {@link HelpCenter.verify|verify} messages.
     * @function encode
     * @memberof HelpCenter
     * @static
     * @param {IHelpCenter} message HelpCenter message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    HelpCenter.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.contextId != null && Object.hasOwnProperty.call(message, "contextId"))
            writer.uint32(/* id 1, wireType 2 =*/10).string(message.contextId);
        return writer;
    };

    /**
     * Encodes the specified HelpCenter message, length delimited. Does not implicitly {@link HelpCenter.verify|verify} messages.
     * @function encodeDelimited
     * @memberof HelpCenter
     * @static
     * @param {IHelpCenter} message HelpCenter message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    HelpCenter.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a HelpCenter message from the specified reader or buffer.
     * @function decode
     * @memberof HelpCenter
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {HelpCenter} HelpCenter
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    HelpCenter.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.HelpCenter();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.contextId = reader.string();
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a HelpCenter message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof HelpCenter
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {HelpCenter} HelpCenter
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    HelpCenter.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a HelpCenter message.
     * @function verify
     * @memberof HelpCenter
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    HelpCenter.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.contextId != null && message.hasOwnProperty("contextId"))
            if (!$util.isString(message.contextId))
                return "contextId: string expected";
        return null;
    };

    /**
     * Creates a HelpCenter message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof HelpCenter
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {HelpCenter} HelpCenter
     */
    HelpCenter.fromObject = function fromObject(object) {
        if (object instanceof $root.HelpCenter)
            return object;
        var message = new $root.HelpCenter();
        if (object.contextId != null)
            message.contextId = String(object.contextId);
        return message;
    };

    /**
     * Creates a plain object from a HelpCenter message. Also converts values to other types if specified.
     * @function toObject
     * @memberof HelpCenter
     * @static
     * @param {HelpCenter} message HelpCenter
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    HelpCenter.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        var object = {};
        if (options.defaults)
            object.contextId = "";
        if (message.contextId != null && message.hasOwnProperty("contextId"))
            object.contextId = message.contextId;
        return object;
    };

    /**
     * Converts this HelpCenter to JSON.
     * @function toJSON
     * @memberof HelpCenter
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    HelpCenter.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return HelpCenter;
})();

$root.QuickLink = (function() {

    /**
     * Properties of a QuickLink.
     * @exports IQuickLink
     * @interface IQuickLink
     * @property {string|null} [name] QuickLink name
     * @property {IImage|null} [image] QuickLink image
     * @property {IResolvedLink|null} [link] QuickLink link
     * @property {boolean|null} [displayRequired] QuickLink displayRequired
     * @property {Uint8Array|null} [serverLogsCookie] QuickLink serverLogsCookie
     * @property {number|null} [backendId] QuickLink backendId
     * @property {boolean|null} [prismStyle] QuickLink prismStyle
     */

    /**
     * Constructs a new QuickLink.
     * @exports QuickLink
     * @classdesc Represents a QuickLink.
     * @implements IQuickLink
     * @constructor
     * @param {IQuickLink=} [properties] Properties to set
     */
    function QuickLink(properties) {
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * QuickLink name.
     * @member {string} name
     * @memberof QuickLink
     * @instance
     */
    QuickLink.prototype.name = "";

    /**
     * QuickLink image.
     * @member {IImage|null|undefined} image
     * @memberof QuickLink
     * @instance
     */
    QuickLink.prototype.image = null;

    /**
     * QuickLink link.
     * @member {IResolvedLink|null|undefined} link
     * @memberof QuickLink
     * @instance
     */
    QuickLink.prototype.link = null;

    /**
     * QuickLink displayRequired.
     * @member {boolean} displayRequired
     * @memberof QuickLink
     * @instance
     */
    QuickLink.prototype.displayRequired = false;

    /**
     * QuickLink serverLogsCookie.
     * @member {Uint8Array} serverLogsCookie
     * @memberof QuickLink
     * @instance
     */
    QuickLink.prototype.serverLogsCookie = $util.newBuffer([]);

    /**
     * QuickLink backendId.
     * @member {number} backendId
     * @memberof QuickLink
     * @instance
     */
    QuickLink.prototype.backendId = 0;

    /**
     * QuickLink prismStyle.
     * @member {boolean} prismStyle
     * @memberof QuickLink
     * @instance
     */
    QuickLink.prototype.prismStyle = false;

    /**
     * Creates a new QuickLink instance using the specified properties.
     * @function create
     * @memberof QuickLink
     * @static
     * @param {IQuickLink=} [properties] Properties to set
     * @returns {QuickLink} QuickLink instance
     */
    QuickLink.create = function create(properties) {
        return new QuickLink(properties);
    };

    /**
     * Encodes the specified QuickLink message. Does not implicitly {@link QuickLink.verify|verify} messages.
     * @function encode
     * @memberof QuickLink
     * @static
     * @param {IQuickLink} message QuickLink message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    QuickLink.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.name != null && Object.hasOwnProperty.call(message, "name"))
            writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
        if (message.image != null && Object.hasOwnProperty.call(message, "image"))
            $root.Image.encode(message.image, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
        if (message.link != null && Object.hasOwnProperty.call(message, "link"))
            $root.ResolvedLink.encode(message.link, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
        if (message.displayRequired != null && Object.hasOwnProperty.call(message, "displayRequired"))
            writer.uint32(/* id 4, wireType 0 =*/32).bool(message.displayRequired);
        if (message.serverLogsCookie != null && Object.hasOwnProperty.call(message, "serverLogsCookie"))
            writer.uint32(/* id 5, wireType 2 =*/42).bytes(message.serverLogsCookie);
        if (message.backendId != null && Object.hasOwnProperty.call(message, "backendId"))
            writer.uint32(/* id 6, wireType 0 =*/48).int32(message.backendId);
        if (message.prismStyle != null && Object.hasOwnProperty.call(message, "prismStyle"))
            writer.uint32(/* id 7, wireType 0 =*/56).bool(message.prismStyle);
        return writer;
    };

    /**
     * Encodes the specified QuickLink message, length delimited. Does not implicitly {@link QuickLink.verify|verify} messages.
     * @function encodeDelimited
     * @memberof QuickLink
     * @static
     * @param {IQuickLink} message QuickLink message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    QuickLink.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a QuickLink message from the specified reader or buffer.
     * @function decode
     * @memberof QuickLink
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {QuickLink} QuickLink
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    QuickLink.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.QuickLink();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.name = reader.string();
                break;
            case 2:
                message.image = $root.Image.decode(reader, reader.uint32());
                break;
            case 3:
                message.link = $root.ResolvedLink.decode(reader, reader.uint32());
                break;
            case 4:
                message.displayRequired = reader.bool();
                break;
            case 5:
                message.serverLogsCookie = reader.bytes();
                break;
            case 6:
                message.backendId = reader.int32();
                break;
            case 7:
                message.prismStyle = reader.bool();
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a QuickLink message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof QuickLink
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {QuickLink} QuickLink
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    QuickLink.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a QuickLink message.
     * @function verify
     * @memberof QuickLink
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    QuickLink.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.name != null && message.hasOwnProperty("name"))
            if (!$util.isString(message.name))
                return "name: string expected";
        if (message.image != null && message.hasOwnProperty("image")) {
            var error = $root.Image.verify(message.image);
            if (error)
                return "image." + error;
        }
        if (message.link != null && message.hasOwnProperty("link")) {
            var error = $root.ResolvedLink.verify(message.link);
            if (error)
                return "link." + error;
        }
        if (message.displayRequired != null && message.hasOwnProperty("displayRequired"))
            if (typeof message.displayRequired !== "boolean")
                return "displayRequired: boolean expected";
        if (message.serverLogsCookie != null && message.hasOwnProperty("serverLogsCookie"))
            if (!(message.serverLogsCookie && typeof message.serverLogsCookie.length === "number" || $util.isString(message.serverLogsCookie)))
                return "serverLogsCookie: buffer expected";
        if (message.backendId != null && message.hasOwnProperty("backendId"))
            if (!$util.isInteger(message.backendId))
                return "backendId: integer expected";
        if (message.prismStyle != null && message.hasOwnProperty("prismStyle"))
            if (typeof message.prismStyle !== "boolean")
                return "prismStyle: boolean expected";
        return null;
    };

    /**
     * Creates a QuickLink message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof QuickLink
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {QuickLink} QuickLink
     */
    QuickLink.fromObject = function fromObject(object) {
        if (object instanceof $root.QuickLink)
            return object;
        var message = new $root.QuickLink();
        if (object.name != null)
            message.name = String(object.name);
        if (object.image != null) {
            if (typeof object.image !== "object")
                throw TypeError(".QuickLink.image: object expected");
            message.image = $root.Image.fromObject(object.image);
        }
        if (object.link != null) {
            if (typeof object.link !== "object")
                throw TypeError(".QuickLink.link: object expected");
            message.link = $root.ResolvedLink.fromObject(object.link);
        }
        if (object.displayRequired != null)
            message.displayRequired = Boolean(object.displayRequired);
        if (object.serverLogsCookie != null)
            if (typeof object.serverLogsCookie === "string")
                $util.base64.decode(object.serverLogsCookie, message.serverLogsCookie = $util.newBuffer($util.base64.length(object.serverLogsCookie)), 0);
            else if (object.serverLogsCookie.length)
                message.serverLogsCookie = object.serverLogsCookie;
        if (object.backendId != null)
            message.backendId = object.backendId | 0;
        if (object.prismStyle != null)
            message.prismStyle = Boolean(object.prismStyle);
        return message;
    };

    /**
     * Creates a plain object from a QuickLink message. Also converts values to other types if specified.
     * @function toObject
     * @memberof QuickLink
     * @static
     * @param {QuickLink} message QuickLink
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    QuickLink.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        var object = {};
        if (options.defaults) {
            object.name = "";
            object.image = null;
            object.link = null;
            object.displayRequired = false;
            if (options.bytes === String)
                object.serverLogsCookie = "";
            else {
                object.serverLogsCookie = [];
                if (options.bytes !== Array)
                    object.serverLogsCookie = $util.newBuffer(object.serverLogsCookie);
            }
            object.backendId = 0;
            object.prismStyle = false;
        }
        if (message.name != null && message.hasOwnProperty("name"))
            object.name = message.name;
        if (message.image != null && message.hasOwnProperty("image"))
            object.image = $root.Image.toObject(message.image, options);
        if (message.link != null && message.hasOwnProperty("link"))
            object.link = $root.ResolvedLink.toObject(message.link, options);
        if (message.displayRequired != null && message.hasOwnProperty("displayRequired"))
            object.displayRequired = message.displayRequired;
        if (message.serverLogsCookie != null && message.hasOwnProperty("serverLogsCookie"))
            object.serverLogsCookie = options.bytes === String ? $util.base64.encode(message.serverLogsCookie, 0, message.serverLogsCookie.length) : options.bytes === Array ? Array.prototype.slice.call(message.serverLogsCookie) : message.serverLogsCookie;
        if (message.backendId != null && message.hasOwnProperty("backendId"))
            object.backendId = message.backendId;
        if (message.prismStyle != null && message.hasOwnProperty("prismStyle"))
            object.prismStyle = message.prismStyle;
        return object;
    };

    /**
     * Converts this QuickLink to JSON.
     * @function toJSON
     * @memberof QuickLink
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    QuickLink.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return QuickLink;
})();

$root.BrowseTab = (function() {

    /**
     * Properties of a BrowseTab.
     * @exports IBrowseTab
     * @interface IBrowseTab
     * @property {string|null} [title] BrowseTab title
     * @property {Uint8Array|null} [serverLogsCookie] BrowseTab serverLogsCookie
     * @property {string|null} [listUrl] BrowseTab listUrl
     * @property {Array.<IBrowseLink>|null} [browseLink] BrowseTab browseLink
     * @property {Array.<IQuickLink>|null} [quickLink] BrowseTab quickLink
     * @property {string|null} [quickLinkTitle] BrowseTab quickLinkTitle
     * @property {string|null} [categoriesTitle] BrowseTab categoriesTitle
     * @property {number|null} [backendId] BrowseTab backendId
     * @property {string|null} [highlightsBannerUrl] BrowseTab highlightsBannerUrl
     */

    /**
     * Constructs a new BrowseTab.
     * @exports BrowseTab
     * @classdesc Represents a BrowseTab.
     * @implements IBrowseTab
     * @constructor
     * @param {IBrowseTab=} [properties] Properties to set
     */
    function BrowseTab(properties) {
        this.browseLink = [];
        this.quickLink = [];
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * BrowseTab title.
     * @member {string} title
     * @memberof BrowseTab
     * @instance
     */
    BrowseTab.prototype.title = "";

    /**
     * BrowseTab serverLogsCookie.
     * @member {Uint8Array} serverLogsCookie
     * @memberof BrowseTab
     * @instance
     */
    BrowseTab.prototype.serverLogsCookie = $util.newBuffer([]);

    /**
     * BrowseTab listUrl.
     * @member {string} listUrl
     * @memberof BrowseTab
     * @instance
     */
    BrowseTab.prototype.listUrl = "";

    /**
     * BrowseTab browseLink.
     * @member {Array.<IBrowseLink>} browseLink
     * @memberof BrowseTab
     * @instance
     */
    BrowseTab.prototype.browseLink = $util.emptyArray;

    /**
     * BrowseTab quickLink.
     * @member {Array.<IQuickLink>} quickLink
     * @memberof BrowseTab
     * @instance
     */
    BrowseTab.prototype.quickLink = $util.emptyArray;

    /**
     * BrowseTab quickLinkTitle.
     * @member {string} quickLinkTitle
     * @memberof BrowseTab
     * @instance
     */
    BrowseTab.prototype.quickLinkTitle = "";

    /**
     * BrowseTab categoriesTitle.
     * @member {string} categoriesTitle
     * @memberof BrowseTab
     * @instance
     */
    BrowseTab.prototype.categoriesTitle = "";

    /**
     * BrowseTab backendId.
     * @member {number} backendId
     * @memberof BrowseTab
     * @instance
     */
    BrowseTab.prototype.backendId = 0;

    /**
     * BrowseTab highlightsBannerUrl.
     * @member {string} highlightsBannerUrl
     * @memberof BrowseTab
     * @instance
     */
    BrowseTab.prototype.highlightsBannerUrl = "";

    /**
     * Creates a new BrowseTab instance using the specified properties.
     * @function create
     * @memberof BrowseTab
     * @static
     * @param {IBrowseTab=} [properties] Properties to set
     * @returns {BrowseTab} BrowseTab instance
     */
    BrowseTab.create = function create(properties) {
        return new BrowseTab(properties);
    };

    /**
     * Encodes the specified BrowseTab message. Does not implicitly {@link BrowseTab.verify|verify} messages.
     * @function encode
     * @memberof BrowseTab
     * @static
     * @param {IBrowseTab} message BrowseTab message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    BrowseTab.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.title != null && Object.hasOwnProperty.call(message, "title"))
            writer.uint32(/* id 1, wireType 2 =*/10).string(message.title);
        if (message.serverLogsCookie != null && Object.hasOwnProperty.call(message, "serverLogsCookie"))
            writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.serverLogsCookie);
        if (message.listUrl != null && Object.hasOwnProperty.call(message, "listUrl"))
            writer.uint32(/* id 3, wireType 2 =*/26).string(message.listUrl);
        if (message.browseLink != null && message.browseLink.length)
            for (var i = 0; i < message.browseLink.length; ++i)
                $root.BrowseLink.encode(message.browseLink[i], writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
        if (message.quickLink != null && message.quickLink.length)
            for (var i = 0; i < message.quickLink.length; ++i)
                $root.QuickLink.encode(message.quickLink[i], writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
        if (message.quickLinkTitle != null && Object.hasOwnProperty.call(message, "quickLinkTitle"))
            writer.uint32(/* id 6, wireType 2 =*/50).string(message.quickLinkTitle);
        if (message.categoriesTitle != null && Object.hasOwnProperty.call(message, "categoriesTitle"))
            writer.uint32(/* id 7, wireType 2 =*/58).string(message.categoriesTitle);
        if (message.backendId != null && Object.hasOwnProperty.call(message, "backendId"))
            writer.uint32(/* id 8, wireType 0 =*/64).int32(message.backendId);
        if (message.highlightsBannerUrl != null && Object.hasOwnProperty.call(message, "highlightsBannerUrl"))
            writer.uint32(/* id 9, wireType 2 =*/74).string(message.highlightsBannerUrl);
        return writer;
    };

    /**
     * Encodes the specified BrowseTab message, length delimited. Does not implicitly {@link BrowseTab.verify|verify} messages.
     * @function encodeDelimited
     * @memberof BrowseTab
     * @static
     * @param {IBrowseTab} message BrowseTab message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    BrowseTab.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a BrowseTab message from the specified reader or buffer.
     * @function decode
     * @memberof BrowseTab
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {BrowseTab} BrowseTab
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    BrowseTab.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.BrowseTab();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.title = reader.string();
                break;
            case 2:
                message.serverLogsCookie = reader.bytes();
                break;
            case 3:
                message.listUrl = reader.string();
                break;
            case 4:
                if (!(message.browseLink && message.browseLink.length))
                    message.browseLink = [];
                message.browseLink.push($root.BrowseLink.decode(reader, reader.uint32()));
                break;
            case 5:
                if (!(message.quickLink && message.quickLink.length))
                    message.quickLink = [];
                message.quickLink.push($root.QuickLink.decode(reader, reader.uint32()));
                break;
            case 6:
                message.quickLinkTitle = reader.string();
                break;
            case 7:
                message.categoriesTitle = reader.string();
                break;
            case 8:
                message.backendId = reader.int32();
                break;
            case 9:
                message.highlightsBannerUrl = reader.string();
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a BrowseTab message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof BrowseTab
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {BrowseTab} BrowseTab
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    BrowseTab.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a BrowseTab message.
     * @function verify
     * @memberof BrowseTab
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    BrowseTab.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.title != null && message.hasOwnProperty("title"))
            if (!$util.isString(message.title))
                return "title: string expected";
        if (message.serverLogsCookie != null && message.hasOwnProperty("serverLogsCookie"))
            if (!(message.serverLogsCookie && typeof message.serverLogsCookie.length === "number" || $util.isString(message.serverLogsCookie)))
                return "serverLogsCookie: buffer expected";
        if (message.listUrl != null && message.hasOwnProperty("listUrl"))
            if (!$util.isString(message.listUrl))
                return "listUrl: string expected";
        if (message.browseLink != null && message.hasOwnProperty("browseLink")) {
            if (!Array.isArray(message.browseLink))
                return "browseLink: array expected";
            for (var i = 0; i < message.browseLink.length; ++i) {
                var error = $root.BrowseLink.verify(message.browseLink[i]);
                if (error)
                    return "browseLink." + error;
            }
        }
        if (message.quickLink != null && message.hasOwnProperty("quickLink")) {
            if (!Array.isArray(message.quickLink))
                return "quickLink: array expected";
            for (var i = 0; i < message.quickLink.length; ++i) {
                var error = $root.QuickLink.verify(message.quickLink[i]);
                if (error)
                    return "quickLink." + error;
            }
        }
        if (message.quickLinkTitle != null && message.hasOwnProperty("quickLinkTitle"))
            if (!$util.isString(message.quickLinkTitle))
                return "quickLinkTitle: string expected";
        if (message.categoriesTitle != null && message.hasOwnProperty("categoriesTitle"))
            if (!$util.isString(message.categoriesTitle))
                return "categoriesTitle: string expected";
        if (message.backendId != null && message.hasOwnProperty("backendId"))
            if (!$util.isInteger(message.backendId))
                return "backendId: integer expected";
        if (message.highlightsBannerUrl != null && message.hasOwnProperty("highlightsBannerUrl"))
            if (!$util.isString(message.highlightsBannerUrl))
                return "highlightsBannerUrl: string expected";
        return null;
    };

    /**
     * Creates a BrowseTab message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof BrowseTab
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {BrowseTab} BrowseTab
     */
    BrowseTab.fromObject = function fromObject(object) {
        if (object instanceof $root.BrowseTab)
            return object;
        var message = new $root.BrowseTab();
        if (object.title != null)
            message.title = String(object.title);
        if (object.serverLogsCookie != null)
            if (typeof object.serverLogsCookie === "string")
                $util.base64.decode(object.serverLogsCookie, message.serverLogsCookie = $util.newBuffer($util.base64.length(object.serverLogsCookie)), 0);
            else if (object.serverLogsCookie.length)
                message.serverLogsCookie = object.serverLogsCookie;
        if (object.listUrl != null)
            message.listUrl = String(object.listUrl);
        if (object.browseLink) {
            if (!Array.isArray(object.browseLink))
                throw TypeError(".BrowseTab.browseLink: array expected");
            message.browseLink = [];
            for (var i = 0; i < object.browseLink.length; ++i) {
                if (typeof object.browseLink[i] !== "object")
                    throw TypeError(".BrowseTab.browseLink: object expected");
                message.browseLink[i] = $root.BrowseLink.fromObject(object.browseLink[i]);
            }
        }
        if (object.quickLink) {
            if (!Array.isArray(object.quickLink))
                throw TypeError(".BrowseTab.quickLink: array expected");
            message.quickLink = [];
            for (var i = 0; i < object.quickLink.length; ++i) {
                if (typeof object.quickLink[i] !== "object")
                    throw TypeError(".BrowseTab.quickLink: object expected");
                message.quickLink[i] = $root.QuickLink.fromObject(object.quickLink[i]);
            }
        }
        if (object.quickLinkTitle != null)
            message.quickLinkTitle = String(object.quickLinkTitle);
        if (object.categoriesTitle != null)
            message.categoriesTitle = String(object.categoriesTitle);
        if (object.backendId != null)
            message.backendId = object.backendId | 0;
        if (object.highlightsBannerUrl != null)
            message.highlightsBannerUrl = String(object.highlightsBannerUrl);
        return message;
    };

    /**
     * Creates a plain object from a BrowseTab message. Also converts values to other types if specified.
     * @function toObject
     * @memberof BrowseTab
     * @static
     * @param {BrowseTab} message BrowseTab
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    BrowseTab.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        var object = {};
        if (options.arrays || options.defaults) {
            object.browseLink = [];
            object.quickLink = [];
        }
        if (options.defaults) {
            object.title = "";
            if (options.bytes === String)
                object.serverLogsCookie = "";
            else {
                object.serverLogsCookie = [];
                if (options.bytes !== Array)
                    object.serverLogsCookie = $util.newBuffer(object.serverLogsCookie);
            }
            object.listUrl = "";
            object.quickLinkTitle = "";
            object.categoriesTitle = "";
            object.backendId = 0;
            object.highlightsBannerUrl = "";
        }
        if (message.title != null && message.hasOwnProperty("title"))
            object.title = message.title;
        if (message.serverLogsCookie != null && message.hasOwnProperty("serverLogsCookie"))
            object.serverLogsCookie = options.bytes === String ? $util.base64.encode(message.serverLogsCookie, 0, message.serverLogsCookie.length) : options.bytes === Array ? Array.prototype.slice.call(message.serverLogsCookie) : message.serverLogsCookie;
        if (message.listUrl != null && message.hasOwnProperty("listUrl"))
            object.listUrl = message.listUrl;
        if (message.browseLink && message.browseLink.length) {
            object.browseLink = [];
            for (var j = 0; j < message.browseLink.length; ++j)
                object.browseLink[j] = $root.BrowseLink.toObject(message.browseLink[j], options);
        }
        if (message.quickLink && message.quickLink.length) {
            object.quickLink = [];
            for (var j = 0; j < message.quickLink.length; ++j)
                object.quickLink[j] = $root.QuickLink.toObject(message.quickLink[j], options);
        }
        if (message.quickLinkTitle != null && message.hasOwnProperty("quickLinkTitle"))
            object.quickLinkTitle = message.quickLinkTitle;
        if (message.categoriesTitle != null && message.hasOwnProperty("categoriesTitle"))
            object.categoriesTitle = message.categoriesTitle;
        if (message.backendId != null && message.hasOwnProperty("backendId"))
            object.backendId = message.backendId;
        if (message.highlightsBannerUrl != null && message.hasOwnProperty("highlightsBannerUrl"))
            object.highlightsBannerUrl = message.highlightsBannerUrl;
        return object;
    };

    /**
     * Converts this BrowseTab to JSON.
     * @function toJSON
     * @memberof BrowseTab
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    BrowseTab.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return BrowseTab;
})();

$root.BuyResponse = (function() {

    /**
     * Properties of a BuyResponse.
     * @exports IBuyResponse
     * @interface IBuyResponse
     * @property {IPurchaseNotificationResponse|null} [purchaseResponse] BuyResponse purchaseResponse
     * @property {BuyResponse.ICheckoutInfo|null} [checkoutInfo] BuyResponse checkoutInfo
     * @property {string|null} [continueViaUrl] BuyResponse continueViaUrl
     * @property {string|null} [purchaseStatusUrl] BuyResponse purchaseStatusUrl
     * @property {string|null} [checkoutServiceId] BuyResponse checkoutServiceId
     * @property {boolean|null} [checkoutTokenRequired] BuyResponse checkoutTokenRequired
     * @property {string|null} [baseCheckoutUrl] BuyResponse baseCheckoutUrl
     * @property {Array.<string>|null} [tosCheckboxHtml] BuyResponse tosCheckboxHtml
     * @property {number|null} [iabPermissionError] BuyResponse iabPermissionError
     * @property {IPurchaseStatusResponse|null} [purchaseStatusResponse] BuyResponse purchaseStatusResponse
     * @property {string|null} [purchaseCookie] BuyResponse purchaseCookie
     * @property {IChallenge|null} [challenge] BuyResponse challenge
     * @property {string|null} [addInstrumentPromptHtml] BuyResponse addInstrumentPromptHtml
     * @property {string|null} [confirmButtonText] BuyResponse confirmButtonText
     * @property {string|null} [permissionErrorTitleText] BuyResponse permissionErrorTitleText
     * @property {string|null} [permissionErrorMessageText] BuyResponse permissionErrorMessageText
     * @property {Uint8Array|null} [serverLogsCookie] BuyResponse serverLogsCookie
     * @property {string|null} [encodedDeliveryToken] BuyResponse encodedDeliveryToken
     * @property {string|null} [unknownToken] BuyResponse unknownToken
     */

    /**
     * Constructs a new BuyResponse.
     * @exports BuyResponse
     * @classdesc Represents a BuyResponse.
     * @implements IBuyResponse
     * @constructor
     * @param {IBuyResponse=} [properties] Properties to set
     */
    function BuyResponse(properties) {
        this.tosCheckboxHtml = [];
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * BuyResponse purchaseResponse.
     * @member {IPurchaseNotificationResponse|null|undefined} purchaseResponse
     * @memberof BuyResponse
     * @instance
     */
    BuyResponse.prototype.purchaseResponse = null;

    /**
     * BuyResponse checkoutInfo.
     * @member {BuyResponse.ICheckoutInfo|null|undefined} checkoutInfo
     * @memberof BuyResponse
     * @instance
     */
    BuyResponse.prototype.checkoutInfo = null;

    /**
     * BuyResponse continueViaUrl.
     * @member {string} continueViaUrl
     * @memberof BuyResponse
     * @instance
     */
    BuyResponse.prototype.continueViaUrl = "";

    /**
     * BuyResponse purchaseStatusUrl.
     * @member {string} purchaseStatusUrl
     * @memberof BuyResponse
     * @instance
     */
    BuyResponse.prototype.purchaseStatusUrl = "";

    /**
     * BuyResponse checkoutServiceId.
     * @member {string} checkoutServiceId
     * @memberof BuyResponse
     * @instance
     */
    BuyResponse.prototype.checkoutServiceId = "";

    /**
     * BuyResponse checkoutTokenRequired.
     * @member {boolean} checkoutTokenRequired
     * @memberof BuyResponse
     * @instance
     */
    BuyResponse.prototype.checkoutTokenRequired = false;

    /**
     * BuyResponse baseCheckoutUrl.
     * @member {string} baseCheckoutUrl
     * @memberof BuyResponse
     * @instance
     */
    BuyResponse.prototype.baseCheckoutUrl = "";

    /**
     * BuyResponse tosCheckboxHtml.
     * @member {Array.<string>} tosCheckboxHtml
     * @memberof BuyResponse
     * @instance
     */
    BuyResponse.prototype.tosCheckboxHtml = $util.emptyArray;

    /**
     * BuyResponse iabPermissionError.
     * @member {number} iabPermissionError
     * @memberof BuyResponse
     * @instance
     */
    BuyResponse.prototype.iabPermissionError = 0;

    /**
     * BuyResponse purchaseStatusResponse.
     * @member {IPurchaseStatusResponse|null|undefined} purchaseStatusResponse
     * @memberof BuyResponse
     * @instance
     */
    BuyResponse.prototype.purchaseStatusResponse = null;

    /**
     * BuyResponse purchaseCookie.
     * @member {string} purchaseCookie
     * @memberof BuyResponse
     * @instance
     */
    BuyResponse.prototype.purchaseCookie = "";

    /**
     * BuyResponse challenge.
     * @member {IChallenge|null|undefined} challenge
     * @memberof BuyResponse
     * @instance
     */
    BuyResponse.prototype.challenge = null;

    /**
     * BuyResponse addInstrumentPromptHtml.
     * @member {string} addInstrumentPromptHtml
     * @memberof BuyResponse
     * @instance
     */
    BuyResponse.prototype.addInstrumentPromptHtml = "";

    /**
     * BuyResponse confirmButtonText.
     * @member {string} confirmButtonText
     * @memberof BuyResponse
     * @instance
     */
    BuyResponse.prototype.confirmButtonText = "";

    /**
     * BuyResponse permissionErrorTitleText.
     * @member {string} permissionErrorTitleText
     * @memberof BuyResponse
     * @instance
     */
    BuyResponse.prototype.permissionErrorTitleText = "";

    /**
     * BuyResponse permissionErrorMessageText.
     * @member {string} permissionErrorMessageText
     * @memberof BuyResponse
     * @instance
     */
    BuyResponse.prototype.permissionErrorMessageText = "";

    /**
     * BuyResponse serverLogsCookie.
     * @member {Uint8Array} serverLogsCookie
     * @memberof BuyResponse
     * @instance
     */
    BuyResponse.prototype.serverLogsCookie = $util.newBuffer([]);

    /**
     * BuyResponse encodedDeliveryToken.
     * @member {string} encodedDeliveryToken
     * @memberof BuyResponse
     * @instance
     */
    BuyResponse.prototype.encodedDeliveryToken = "";

    /**
     * BuyResponse unknownToken.
     * @member {string} unknownToken
     * @memberof BuyResponse
     * @instance
     */
    BuyResponse.prototype.unknownToken = "";

    /**
     * Creates a new BuyResponse instance using the specified properties.
     * @function create
     * @memberof BuyResponse
     * @static
     * @param {IBuyResponse=} [properties] Properties to set
     * @returns {BuyResponse} BuyResponse instance
     */
    BuyResponse.create = function create(properties) {
        return new BuyResponse(properties);
    };

    /**
     * Encodes the specified BuyResponse message. Does not implicitly {@link BuyResponse.verify|verify} messages.
     * @function encode
     * @memberof BuyResponse
     * @static
     * @param {IBuyResponse} message BuyResponse message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    BuyResponse.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.purchaseResponse != null && Object.hasOwnProperty.call(message, "purchaseResponse"))
            $root.PurchaseNotificationResponse.encode(message.purchaseResponse, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
        if (message.checkoutInfo != null && Object.hasOwnProperty.call(message, "checkoutInfo"))
            $root.BuyResponse.CheckoutInfo.encode(message.checkoutInfo, writer.uint32(/* id 2, wireType 3 =*/19)).uint32(/* id 2, wireType 4 =*/20);
        if (message.continueViaUrl != null && Object.hasOwnProperty.call(message, "continueViaUrl"))
            writer.uint32(/* id 8, wireType 2 =*/66).string(message.continueViaUrl);
        if (message.purchaseStatusUrl != null && Object.hasOwnProperty.call(message, "purchaseStatusUrl"))
            writer.uint32(/* id 9, wireType 2 =*/74).string(message.purchaseStatusUrl);
        if (message.checkoutServiceId != null && Object.hasOwnProperty.call(message, "checkoutServiceId"))
            writer.uint32(/* id 12, wireType 2 =*/98).string(message.checkoutServiceId);
        if (message.checkoutTokenRequired != null && Object.hasOwnProperty.call(message, "checkoutTokenRequired"))
            writer.uint32(/* id 13, wireType 0 =*/104).bool(message.checkoutTokenRequired);
        if (message.baseCheckoutUrl != null && Object.hasOwnProperty.call(message, "baseCheckoutUrl"))
            writer.uint32(/* id 14, wireType 2 =*/114).string(message.baseCheckoutUrl);
        if (message.tosCheckboxHtml != null && message.tosCheckboxHtml.length)
            for (var i = 0; i < message.tosCheckboxHtml.length; ++i)
                writer.uint32(/* id 37, wireType 2 =*/298).string(message.tosCheckboxHtml[i]);
        if (message.iabPermissionError != null && Object.hasOwnProperty.call(message, "iabPermissionError"))
            writer.uint32(/* id 38, wireType 0 =*/304).int32(message.iabPermissionError);
        if (message.purchaseStatusResponse != null && Object.hasOwnProperty.call(message, "purchaseStatusResponse"))
            $root.PurchaseStatusResponse.encode(message.purchaseStatusResponse, writer.uint32(/* id 39, wireType 2 =*/314).fork()).ldelim();
        if (message.purchaseCookie != null && Object.hasOwnProperty.call(message, "purchaseCookie"))
            writer.uint32(/* id 46, wireType 2 =*/370).string(message.purchaseCookie);
        if (message.challenge != null && Object.hasOwnProperty.call(message, "challenge"))
            $root.Challenge.encode(message.challenge, writer.uint32(/* id 49, wireType 2 =*/394).fork()).ldelim();
        if (message.addInstrumentPromptHtml != null && Object.hasOwnProperty.call(message, "addInstrumentPromptHtml"))
            writer.uint32(/* id 50, wireType 2 =*/402).string(message.addInstrumentPromptHtml);
        if (message.confirmButtonText != null && Object.hasOwnProperty.call(message, "confirmButtonText"))
            writer.uint32(/* id 51, wireType 2 =*/410).string(message.confirmButtonText);
        if (message.permissionErrorTitleText != null && Object.hasOwnProperty.call(message, "permissionErrorTitleText"))
            writer.uint32(/* id 52, wireType 2 =*/418).string(message.permissionErrorTitleText);
        if (message.permissionErrorMessageText != null && Object.hasOwnProperty.call(message, "permissionErrorMessageText"))
            writer.uint32(/* id 53, wireType 2 =*/426).string(message.permissionErrorMessageText);
        if (message.serverLogsCookie != null && Object.hasOwnProperty.call(message, "serverLogsCookie"))
            writer.uint32(/* id 54, wireType 2 =*/434).bytes(message.serverLogsCookie);
        if (message.encodedDeliveryToken != null && Object.hasOwnProperty.call(message, "encodedDeliveryToken"))
            writer.uint32(/* id 55, wireType 2 =*/442).string(message.encodedDeliveryToken);
        if (message.unknownToken != null && Object.hasOwnProperty.call(message, "unknownToken"))
            writer.uint32(/* id 56, wireType 2 =*/450).string(message.unknownToken);
        return writer;
    };

    /**
     * Encodes the specified BuyResponse message, length delimited. Does not implicitly {@link BuyResponse.verify|verify} messages.
     * @function encodeDelimited
     * @memberof BuyResponse
     * @static
     * @param {IBuyResponse} message BuyResponse message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    BuyResponse.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a BuyResponse message from the specified reader or buffer.
     * @function decode
     * @memberof BuyResponse
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {BuyResponse} BuyResponse
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    BuyResponse.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.BuyResponse();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.purchaseResponse = $root.PurchaseNotificationResponse.decode(reader, reader.uint32());
                break;
            case 2:
                message.checkoutInfo = $root.BuyResponse.CheckoutInfo.decode(reader);
                break;
            case 8:
                message.continueViaUrl = reader.string();
                break;
            case 9:
                message.purchaseStatusUrl = reader.string();
                break;
            case 12:
                message.checkoutServiceId = reader.string();
                break;
            case 13:
                message.checkoutTokenRequired = reader.bool();
                break;
            case 14:
                message.baseCheckoutUrl = reader.string();
                break;
            case 37:
                if (!(message.tosCheckboxHtml && message.tosCheckboxHtml.length))
                    message.tosCheckboxHtml = [];
                message.tosCheckboxHtml.push(reader.string());
                break;
            case 38:
                message.iabPermissionError = reader.int32();
                break;
            case 39:
                message.purchaseStatusResponse = $root.PurchaseStatusResponse.decode(reader, reader.uint32());
                break;
            case 46:
                message.purchaseCookie = reader.string();
                break;
            case 49:
                message.challenge = $root.Challenge.decode(reader, reader.uint32());
                break;
            case 50:
                message.addInstrumentPromptHtml = reader.string();
                break;
            case 51:
                message.confirmButtonText = reader.string();
                break;
            case 52:
                message.permissionErrorTitleText = reader.string();
                break;
            case 53:
                message.permissionErrorMessageText = reader.string();
                break;
            case 54:
                message.serverLogsCookie = reader.bytes();
                break;
            case 55:
                message.encodedDeliveryToken = reader.string();
                break;
            case 56:
                message.unknownToken = reader.string();
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a BuyResponse message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof BuyResponse
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {BuyResponse} BuyResponse
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    BuyResponse.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a BuyResponse message.
     * @function verify
     * @memberof BuyResponse
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    BuyResponse.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.purchaseResponse != null && message.hasOwnProperty("purchaseResponse")) {
            var error = $root.PurchaseNotificationResponse.verify(message.purchaseResponse);
            if (error)
                return "purchaseResponse." + error;
        }
        if (message.checkoutInfo != null && message.hasOwnProperty("checkoutInfo")) {
            var error = $root.BuyResponse.CheckoutInfo.verify(message.checkoutInfo);
            if (error)
                return "checkoutInfo." + error;
        }
        if (message.continueViaUrl != null && message.hasOwnProperty("continueViaUrl"))
            if (!$util.isString(message.continueViaUrl))
                return "continueViaUrl: string expected";
        if (message.purchaseStatusUrl != null && message.hasOwnProperty("purchaseStatusUrl"))
            if (!$util.isString(message.purchaseStatusUrl))
                return "purchaseStatusUrl: string expected";
        if (message.checkoutServiceId != null && message.hasOwnProperty("checkoutServiceId"))
            if (!$util.isString(message.checkoutServiceId))
                return "checkoutServiceId: string expected";
        if (message.checkoutTokenRequired != null && message.hasOwnProperty("checkoutTokenRequired"))
            if (typeof message.checkoutTokenRequired !== "boolean")
                return "checkoutTokenRequired: boolean expected";
        if (message.baseCheckoutUrl != null && message.hasOwnProperty("baseCheckoutUrl"))
            if (!$util.isString(message.baseCheckoutUrl))
                return "baseCheckoutUrl: string expected";
        if (message.tosCheckboxHtml != null && message.hasOwnProperty("tosCheckboxHtml")) {
            if (!Array.isArray(message.tosCheckboxHtml))
                return "tosCheckboxHtml: array expected";
            for (var i = 0; i < message.tosCheckboxHtml.length; ++i)
                if (!$util.isString(message.tosCheckboxHtml[i]))
                    return "tosCheckboxHtml: string[] expected";
        }
        if (message.iabPermissionError != null && message.hasOwnProperty("iabPermissionError"))
            if (!$util.isInteger(message.iabPermissionError))
                return "iabPermissionError: integer expected";
        if (message.purchaseStatusResponse != null && message.hasOwnProperty("purchaseStatusResponse")) {
            var error = $root.PurchaseStatusResponse.verify(message.purchaseStatusResponse);
            if (error)
                return "purchaseStatusResponse." + error;
        }
        if (message.purchaseCookie != null && message.hasOwnProperty("purchaseCookie"))
            if (!$util.isString(message.purchaseCookie))
                return "purchaseCookie: string expected";
        if (message.challenge != null && message.hasOwnProperty("challenge")) {
            var error = $root.Challenge.verify(message.challenge);
            if (error)
                return "challenge." + error;
        }
        if (message.addInstrumentPromptHtml != null && message.hasOwnProperty("addInstrumentPromptHtml"))
            if (!$util.isString(message.addInstrumentPromptHtml))
                return "addInstrumentPromptHtml: string expected";
        if (message.confirmButtonText != null && message.hasOwnProperty("confirmButtonText"))
            if (!$util.isString(message.confirmButtonText))
                return "confirmButtonText: string expected";
        if (message.permissionErrorTitleText != null && message.hasOwnProperty("permissionErrorTitleText"))
            if (!$util.isString(message.permissionErrorTitleText))
                return "permissionErrorTitleText: string expected";
        if (message.permissionErrorMessageText != null && message.hasOwnProperty("permissionErrorMessageText"))
            if (!$util.isString(message.permissionErrorMessageText))
                return "permissionErrorMessageText: string expected";
        if (message.serverLogsCookie != null && message.hasOwnProperty("serverLogsCookie"))
            if (!(message.serverLogsCookie && typeof message.serverLogsCookie.length === "number" || $util.isString(message.serverLogsCookie)))
                return "serverLogsCookie: buffer expected";
        if (message.encodedDeliveryToken != null && message.hasOwnProperty("encodedDeliveryToken"))
            if (!$util.isString(message.encodedDeliveryToken))
                return "encodedDeliveryToken: string expected";
        if (message.unknownToken != null && message.hasOwnProperty("unknownToken"))
            if (!$util.isString(message.unknownToken))
                return "unknownToken: string expected";
        return null;
    };

    /**
     * Creates a BuyResponse message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof BuyResponse
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {BuyResponse} BuyResponse
     */
    BuyResponse.fromObject = function fromObject(object) {
        if (object instanceof $root.BuyResponse)
            return object;
        var message = new $root.BuyResponse();
        if (object.purchaseResponse != null) {
            if (typeof object.purchaseResponse !== "object")
                throw TypeError(".BuyResponse.purchaseResponse: object expected");
            message.purchaseResponse = $root.PurchaseNotificationResponse.fromObject(object.purchaseResponse);
        }
        if (object.checkoutInfo != null) {
            if (typeof object.checkoutInfo !== "object")
                throw TypeError(".BuyResponse.checkoutInfo: object expected");
            message.checkoutInfo = $root.BuyResponse.CheckoutInfo.fromObject(object.checkoutInfo);
        }
        if (object.continueViaUrl != null)
            message.continueViaUrl = String(object.continueViaUrl);
        if (object.purchaseStatusUrl != null)
            message.purchaseStatusUrl = String(object.purchaseStatusUrl);
        if (object.checkoutServiceId != null)
            message.checkoutServiceId = String(object.checkoutServiceId);
        if (object.checkoutTokenRequired != null)
            message.checkoutTokenRequired = Boolean(object.checkoutTokenRequired);
        if (object.baseCheckoutUrl != null)
            message.baseCheckoutUrl = String(object.baseCheckoutUrl);
        if (object.tosCheckboxHtml) {
            if (!Array.isArray(object.tosCheckboxHtml))
                throw TypeError(".BuyResponse.tosCheckboxHtml: array expected");
            message.tosCheckboxHtml = [];
            for (var i = 0; i < object.tosCheckboxHtml.length; ++i)
                message.tosCheckboxHtml[i] = String(object.tosCheckboxHtml[i]);
        }
        if (object.iabPermissionError != null)
            message.iabPermissionError = object.iabPermissionError | 0;
        if (object.purchaseStatusResponse != null) {
            if (typeof object.purchaseStatusResponse !== "object")
                throw TypeError(".BuyResponse.purchaseStatusResponse: object expected");
            message.purchaseStatusResponse = $root.PurchaseStatusResponse.fromObject(object.purchaseStatusResponse);
        }
        if (object.purchaseCookie != null)
            message.purchaseCookie = String(object.purchaseCookie);
        if (object.challenge != null) {
            if (typeof object.challenge !== "object")
                throw TypeError(".BuyResponse.challenge: object expected");
            message.challenge = $root.Challenge.fromObject(object.challenge);
        }
        if (object.addInstrumentPromptHtml != null)
            message.addInstrumentPromptHtml = String(object.addInstrumentPromptHtml);
        if (object.confirmButtonText != null)
            message.confirmButtonText = String(object.confirmButtonText);
        if (object.permissionErrorTitleText != null)
            message.permissionErrorTitleText = String(object.permissionErrorTitleText);
        if (object.permissionErrorMessageText != null)
            message.permissionErrorMessageText = String(object.permissionErrorMessageText);
        if (object.serverLogsCookie != null)
            if (typeof object.serverLogsCookie === "string")
                $util.base64.decode(object.serverLogsCookie, message.serverLogsCookie = $util.newBuffer($util.base64.length(object.serverLogsCookie)), 0);
            else if (object.serverLogsCookie.length)
                message.serverLogsCookie = object.serverLogsCookie;
        if (object.encodedDeliveryToken != null)
            message.encodedDeliveryToken = String(object.encodedDeliveryToken);
        if (object.unknownToken != null)
            message.unknownToken = String(object.unknownToken);
        return message;
    };

    /**
     * Creates a plain object from a BuyResponse message. Also converts values to other types if specified.
     * @function toObject
     * @memberof BuyResponse
     * @static
     * @param {BuyResponse} message BuyResponse
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    BuyResponse.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        var object = {};
        if (options.arrays || options.defaults)
            object.tosCheckboxHtml = [];
        if (options.defaults) {
            object.purchaseResponse = null;
            object.checkoutInfo = null;
            object.continueViaUrl = "";
            object.purchaseStatusUrl = "";
            object.checkoutServiceId = "";
            object.checkoutTokenRequired = false;
            object.baseCheckoutUrl = "";
            object.iabPermissionError = 0;
            object.purchaseStatusResponse = null;
            object.purchaseCookie = "";
            object.challenge = null;
            object.addInstrumentPromptHtml = "";
            object.confirmButtonText = "";
            object.permissionErrorTitleText = "";
            object.permissionErrorMessageText = "";
            if (options.bytes === String)
                object.serverLogsCookie = "";
            else {
                object.serverLogsCookie = [];
                if (options.bytes !== Array)
                    object.serverLogsCookie = $util.newBuffer(object.serverLogsCookie);
            }
            object.encodedDeliveryToken = "";
            object.unknownToken = "";
        }
        if (message.purchaseResponse != null && message.hasOwnProperty("purchaseResponse"))
            object.purchaseResponse = $root.PurchaseNotificationResponse.toObject(message.purchaseResponse, options);
        if (message.checkoutInfo != null && message.hasOwnProperty("checkoutInfo"))
            object.checkoutInfo = $root.BuyResponse.CheckoutInfo.toObject(message.checkoutInfo, options);
        if (message.continueViaUrl != null && message.hasOwnProperty("continueViaUrl"))
            object.continueViaUrl = message.continueViaUrl;
        if (message.purchaseStatusUrl != null && message.hasOwnProperty("purchaseStatusUrl"))
            object.purchaseStatusUrl = message.purchaseStatusUrl;
        if (message.checkoutServiceId != null && message.hasOwnProperty("checkoutServiceId"))
            object.checkoutServiceId = message.checkoutServiceId;
        if (message.checkoutTokenRequired != null && message.hasOwnProperty("checkoutTokenRequired"))
            object.checkoutTokenRequired = message.checkoutTokenRequired;
        if (message.baseCheckoutUrl != null && message.hasOwnProperty("baseCheckoutUrl"))
            object.baseCheckoutUrl = message.baseCheckoutUrl;
        if (message.tosCheckboxHtml && message.tosCheckboxHtml.length) {
            object.tosCheckboxHtml = [];
            for (var j = 0; j < message.tosCheckboxHtml.length; ++j)
                object.tosCheckboxHtml[j] = message.tosCheckboxHtml[j];
        }
        if (message.iabPermissionError != null && message.hasOwnProperty("iabPermissionError"))
            object.iabPermissionError = message.iabPermissionError;
        if (message.purchaseStatusResponse != null && message.hasOwnProperty("purchaseStatusResponse"))
            object.purchaseStatusResponse = $root.PurchaseStatusResponse.toObject(message.purchaseStatusResponse, options);
        if (message.purchaseCookie != null && message.hasOwnProperty("purchaseCookie"))
            object.purchaseCookie = message.purchaseCookie;
        if (message.challenge != null && message.hasOwnProperty("challenge"))
            object.challenge = $root.Challenge.toObject(message.challenge, options);
        if (message.addInstrumentPromptHtml != null && message.hasOwnProperty("addInstrumentPromptHtml"))
            object.addInstrumentPromptHtml = message.addInstrumentPromptHtml;
        if (message.confirmButtonText != null && message.hasOwnProperty("confirmButtonText"))
            object.confirmButtonText = message.confirmButtonText;
        if (message.permissionErrorTitleText != null && message.hasOwnProperty("permissionErrorTitleText"))
            object.permissionErrorTitleText = message.permissionErrorTitleText;
        if (message.permissionErrorMessageText != null && message.hasOwnProperty("permissionErrorMessageText"))
            object.permissionErrorMessageText = message.permissionErrorMessageText;
        if (message.serverLogsCookie != null && message.hasOwnProperty("serverLogsCookie"))
            object.serverLogsCookie = options.bytes === String ? $util.base64.encode(message.serverLogsCookie, 0, message.serverLogsCookie.length) : options.bytes === Array ? Array.prototype.slice.call(message.serverLogsCookie) : message.serverLogsCookie;
        if (message.encodedDeliveryToken != null && message.hasOwnProperty("encodedDeliveryToken"))
            object.encodedDeliveryToken = message.encodedDeliveryToken;
        if (message.unknownToken != null && message.hasOwnProperty("unknownToken"))
            object.unknownToken = message.unknownToken;
        return object;
    };

    /**
     * Converts this BuyResponse to JSON.
     * @function toJSON
     * @memberof BuyResponse
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    BuyResponse.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    BuyResponse.CheckoutInfo = (function() {

        /**
         * Properties of a CheckoutInfo.
         * @memberof BuyResponse
         * @interface ICheckoutInfo
         * @property {ILineItem|null} [item] CheckoutInfo item
         * @property {Array.<ILineItem>|null} [subItem] CheckoutInfo subItem
         * @property {Array.<BuyResponse.CheckoutInfo.ICheckoutOption>|null} [checkoutOption] CheckoutInfo checkoutOption
         * @property {string|null} [deprecatedCheckoutUrl] CheckoutInfo deprecatedCheckoutUrl
         * @property {string|null} [addInstrumentUrl] CheckoutInfo addInstrumentUrl
         * @property {Array.<string>|null} [footerHtml] CheckoutInfo footerHtml
         * @property {Array.<number>|null} [eligibleInstrumentFamily] CheckoutInfo eligibleInstrumentFamily
         * @property {Array.<string>|null} [footnoteHtml] CheckoutInfo footnoteHtml
         * @property {Array.<IInstrument>|null} [eligibleInstrument] CheckoutInfo eligibleInstrument
         */

        /**
         * Constructs a new CheckoutInfo.
         * @memberof BuyResponse
         * @classdesc Represents a CheckoutInfo.
         * @implements ICheckoutInfo
         * @constructor
         * @param {BuyResponse.ICheckoutInfo=} [properties] Properties to set
         */
        function CheckoutInfo(properties) {
            this.subItem = [];
            this.checkoutOption = [];
            this.footerHtml = [];
            this.eligibleInstrumentFamily = [];
            this.footnoteHtml = [];
            this.eligibleInstrument = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * CheckoutInfo item.
         * @member {ILineItem|null|undefined} item
         * @memberof BuyResponse.CheckoutInfo
         * @instance
         */
        CheckoutInfo.prototype.item = null;

        /**
         * CheckoutInfo subItem.
         * @member {Array.<ILineItem>} subItem
         * @memberof BuyResponse.CheckoutInfo
         * @instance
         */
        CheckoutInfo.prototype.subItem = $util.emptyArray;

        /**
         * CheckoutInfo checkoutOption.
         * @member {Array.<BuyResponse.CheckoutInfo.ICheckoutOption>} checkoutOption
         * @memberof BuyResponse.CheckoutInfo
         * @instance
         */
        CheckoutInfo.prototype.checkoutOption = $util.emptyArray;

        /**
         * CheckoutInfo deprecatedCheckoutUrl.
         * @member {string} deprecatedCheckoutUrl
         * @memberof BuyResponse.CheckoutInfo
         * @instance
         */
        CheckoutInfo.prototype.deprecatedCheckoutUrl = "";

        /**
         * CheckoutInfo addInstrumentUrl.
         * @member {string} addInstrumentUrl
         * @memberof BuyResponse.CheckoutInfo
         * @instance
         */
        CheckoutInfo.prototype.addInstrumentUrl = "";

        /**
         * CheckoutInfo footerHtml.
         * @member {Array.<string>} footerHtml
         * @memberof BuyResponse.CheckoutInfo
         * @instance
         */
        CheckoutInfo.prototype.footerHtml = $util.emptyArray;

        /**
         * CheckoutInfo eligibleInstrumentFamily.
         * @member {Array.<number>} eligibleInstrumentFamily
         * @memberof BuyResponse.CheckoutInfo
         * @instance
         */
        CheckoutInfo.prototype.eligibleInstrumentFamily = $util.emptyArray;

        /**
         * CheckoutInfo footnoteHtml.
         * @member {Array.<string>} footnoteHtml
         * @memberof BuyResponse.CheckoutInfo
         * @instance
         */
        CheckoutInfo.prototype.footnoteHtml = $util.emptyArray;

        /**
         * CheckoutInfo eligibleInstrument.
         * @member {Array.<IInstrument>} eligibleInstrument
         * @memberof BuyResponse.CheckoutInfo
         * @instance
         */
        CheckoutInfo.prototype.eligibleInstrument = $util.emptyArray;

        /**
         * Creates a new CheckoutInfo instance using the specified properties.
         * @function create
         * @memberof BuyResponse.CheckoutInfo
         * @static
         * @param {BuyResponse.ICheckoutInfo=} [properties] Properties to set
         * @returns {BuyResponse.CheckoutInfo} CheckoutInfo instance
         */
        CheckoutInfo.create = function create(properties) {
            return new CheckoutInfo(properties);
        };

        /**
         * Encodes the specified CheckoutInfo message. Does not implicitly {@link BuyResponse.CheckoutInfo.verify|verify} messages.
         * @function encode
         * @memberof BuyResponse.CheckoutInfo
         * @static
         * @param {BuyResponse.ICheckoutInfo} message CheckoutInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CheckoutInfo.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.item != null && Object.hasOwnProperty.call(message, "item"))
                $root.LineItem.encode(message.item, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            if (message.subItem != null && message.subItem.length)
                for (var i = 0; i < message.subItem.length; ++i)
                    $root.LineItem.encode(message.subItem[i], writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            if (message.checkoutOption != null && message.checkoutOption.length)
                for (var i = 0; i < message.checkoutOption.length; ++i)
                    $root.BuyResponse.CheckoutInfo.CheckoutOption.encode(message.checkoutOption[i], writer.uint32(/* id 5, wireType 3 =*/43)).uint32(/* id 5, wireType 4 =*/44);
            if (message.deprecatedCheckoutUrl != null && Object.hasOwnProperty.call(message, "deprecatedCheckoutUrl"))
                writer.uint32(/* id 10, wireType 2 =*/82).string(message.deprecatedCheckoutUrl);
            if (message.addInstrumentUrl != null && Object.hasOwnProperty.call(message, "addInstrumentUrl"))
                writer.uint32(/* id 11, wireType 2 =*/90).string(message.addInstrumentUrl);
            if (message.footerHtml != null && message.footerHtml.length)
                for (var i = 0; i < message.footerHtml.length; ++i)
                    writer.uint32(/* id 20, wireType 2 =*/162).string(message.footerHtml[i]);
            if (message.eligibleInstrumentFamily != null && message.eligibleInstrumentFamily.length)
                for (var i = 0; i < message.eligibleInstrumentFamily.length; ++i)
                    writer.uint32(/* id 31, wireType 0 =*/248).int32(message.eligibleInstrumentFamily[i]);
            if (message.footnoteHtml != null && message.footnoteHtml.length)
                for (var i = 0; i < message.footnoteHtml.length; ++i)
                    writer.uint32(/* id 36, wireType 2 =*/290).string(message.footnoteHtml[i]);
            if (message.eligibleInstrument != null && message.eligibleInstrument.length)
                for (var i = 0; i < message.eligibleInstrument.length; ++i)
                    $root.Instrument.encode(message.eligibleInstrument[i], writer.uint32(/* id 44, wireType 2 =*/354).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified CheckoutInfo message, length delimited. Does not implicitly {@link BuyResponse.CheckoutInfo.verify|verify} messages.
         * @function encodeDelimited
         * @memberof BuyResponse.CheckoutInfo
         * @static
         * @param {BuyResponse.ICheckoutInfo} message CheckoutInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CheckoutInfo.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a CheckoutInfo message from the specified reader or buffer.
         * @function decode
         * @memberof BuyResponse.CheckoutInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {BuyResponse.CheckoutInfo} CheckoutInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CheckoutInfo.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.BuyResponse.CheckoutInfo();
            while (reader.pos < end) {
                var tag = reader.uint32();
                if ((tag & 7) === 4)
                    break;
                switch (tag >>> 3) {
                case 3:
                    message.item = $root.LineItem.decode(reader, reader.uint32());
                    break;
                case 4:
                    if (!(message.subItem && message.subItem.length))
                        message.subItem = [];
                    message.subItem.push($root.LineItem.decode(reader, reader.uint32()));
                    break;
                case 5:
                    if (!(message.checkoutOption && message.checkoutOption.length))
                        message.checkoutOption = [];
                    message.checkoutOption.push($root.BuyResponse.CheckoutInfo.CheckoutOption.decode(reader));
                    break;
                case 10:
                    message.deprecatedCheckoutUrl = reader.string();
                    break;
                case 11:
                    message.addInstrumentUrl = reader.string();
                    break;
                case 20:
                    if (!(message.footerHtml && message.footerHtml.length))
                        message.footerHtml = [];
                    message.footerHtml.push(reader.string());
                    break;
                case 31:
                    if (!(message.eligibleInstrumentFamily && message.eligibleInstrumentFamily.length))
                        message.eligibleInstrumentFamily = [];
                    if ((tag & 7) === 2) {
                        var end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.eligibleInstrumentFamily.push(reader.int32());
                    } else
                        message.eligibleInstrumentFamily.push(reader.int32());
                    break;
                case 36:
                    if (!(message.footnoteHtml && message.footnoteHtml.length))
                        message.footnoteHtml = [];
                    message.footnoteHtml.push(reader.string());
                    break;
                case 44:
                    if (!(message.eligibleInstrument && message.eligibleInstrument.length))
                        message.eligibleInstrument = [];
                    message.eligibleInstrument.push($root.Instrument.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a CheckoutInfo message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof BuyResponse.CheckoutInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {BuyResponse.CheckoutInfo} CheckoutInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CheckoutInfo.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a CheckoutInfo message.
         * @function verify
         * @memberof BuyResponse.CheckoutInfo
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CheckoutInfo.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.item != null && message.hasOwnProperty("item")) {
                var error = $root.LineItem.verify(message.item);
                if (error)
                    return "item." + error;
            }
            if (message.subItem != null && message.hasOwnProperty("subItem")) {
                if (!Array.isArray(message.subItem))
                    return "subItem: array expected";
                for (var i = 0; i < message.subItem.length; ++i) {
                    var error = $root.LineItem.verify(message.subItem[i]);
                    if (error)
                        return "subItem." + error;
                }
            }
            if (message.checkoutOption != null && message.hasOwnProperty("checkoutOption")) {
                if (!Array.isArray(message.checkoutOption))
                    return "checkoutOption: array expected";
                for (var i = 0; i < message.checkoutOption.length; ++i) {
                    var error = $root.BuyResponse.CheckoutInfo.CheckoutOption.verify(message.checkoutOption[i]);
                    if (error)
                        return "checkoutOption." + error;
                }
            }
            if (message.deprecatedCheckoutUrl != null && message.hasOwnProperty("deprecatedCheckoutUrl"))
                if (!$util.isString(message.deprecatedCheckoutUrl))
                    return "deprecatedCheckoutUrl: string expected";
            if (message.addInstrumentUrl != null && message.hasOwnProperty("addInstrumentUrl"))
                if (!$util.isString(message.addInstrumentUrl))
                    return "addInstrumentUrl: string expected";
            if (message.footerHtml != null && message.hasOwnProperty("footerHtml")) {
                if (!Array.isArray(message.footerHtml))
                    return "footerHtml: array expected";
                for (var i = 0; i < message.footerHtml.length; ++i)
                    if (!$util.isString(message.footerHtml[i]))
                        return "footerHtml: string[] expected";
            }
            if (message.eligibleInstrumentFamily != null && message.hasOwnProperty("eligibleInstrumentFamily")) {
                if (!Array.isArray(message.eligibleInstrumentFamily))
                    return "eligibleInstrumentFamily: array expected";
                for (var i = 0; i < message.eligibleInstrumentFamily.length; ++i)
                    if (!$util.isInteger(message.eligibleInstrumentFamily[i]))
                        return "eligibleInstrumentFamily: integer[] expected";
            }
            if (message.footnoteHtml != null && message.hasOwnProperty("footnoteHtml")) {
                if (!Array.isArray(message.footnoteHtml))
                    return "footnoteHtml: array expected";
                for (var i = 0; i < message.footnoteHtml.length; ++i)
                    if (!$util.isString(message.footnoteHtml[i]))
                        return "footnoteHtml: string[] expected";
            }
            if (message.eligibleInstrument != null && message.hasOwnProperty("eligibleInstrument")) {
                if (!Array.isArray(message.eligibleInstrument))
                    return "eligibleInstrument: array expected";
                for (var i = 0; i < message.eligibleInstrument.length; ++i) {
                    var error = $root.Instrument.verify(message.eligibleInstrument[i]);
                    if (error)
                        return "eligibleInstrument." + error;
                }
            }
            return null;
        };

        /**
         * Creates a CheckoutInfo message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof BuyResponse.CheckoutInfo
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {BuyResponse.CheckoutInfo} CheckoutInfo
         */
        CheckoutInfo.fromObject = function fromObject(object) {
            if (object instanceof $root.BuyResponse.CheckoutInfo)
                return object;
            var message = new $root.BuyResponse.CheckoutInfo();
            if (object.item != null) {
                if (typeof object.item !== "object")
                    throw TypeError(".BuyResponse.CheckoutInfo.item: object expected");
                message.item = $root.LineItem.fromObject(object.item);
            }
            if (object.subItem) {
                if (!Array.isArray(object.subItem))
                    throw TypeError(".BuyResponse.CheckoutInfo.subItem: array expected");
                message.subItem = [];
                for (var i = 0; i < object.subItem.length; ++i) {
                    if (typeof object.subItem[i] !== "object")
                        throw TypeError(".BuyResponse.CheckoutInfo.subItem: object expected");
                    message.subItem[i] = $root.LineItem.fromObject(object.subItem[i]);
                }
            }
            if (object.checkoutOption) {
                if (!Array.isArray(object.checkoutOption))
                    throw TypeError(".BuyResponse.CheckoutInfo.checkoutOption: array expected");
                message.checkoutOption = [];
                for (var i = 0; i < object.checkoutOption.length; ++i) {
                    if (typeof object.checkoutOption[i] !== "object")
                        throw TypeError(".BuyResponse.CheckoutInfo.checkoutOption: object expected");
                    message.checkoutOption[i] = $root.BuyResponse.CheckoutInfo.CheckoutOption.fromObject(object.checkoutOption[i]);
                }
            }
            if (object.deprecatedCheckoutUrl != null)
                message.deprecatedCheckoutUrl = String(object.deprecatedCheckoutUrl);
            if (object.addInstrumentUrl != null)
                message.addInstrumentUrl = String(object.addInstrumentUrl);
            if (object.footerHtml) {
                if (!Array.isArray(object.footerHtml))
                    throw TypeError(".BuyResponse.CheckoutInfo.footerHtml: array expected");
                message.footerHtml = [];
                for (var i = 0; i < object.footerHtml.length; ++i)
                    message.footerHtml[i] = String(object.footerHtml[i]);
            }
            if (object.eligibleInstrumentFamily) {
                if (!Array.isArray(object.eligibleInstrumentFamily))
                    throw TypeError(".BuyResponse.CheckoutInfo.eligibleInstrumentFamily: array expected");
                message.eligibleInstrumentFamily = [];
                for (var i = 0; i < object.eligibleInstrumentFamily.length; ++i)
                    message.eligibleInstrumentFamily[i] = object.eligibleInstrumentFamily[i] | 0;
            }
            if (object.footnoteHtml) {
                if (!Array.isArray(object.footnoteHtml))
                    throw TypeError(".BuyResponse.CheckoutInfo.footnoteHtml: array expected");
                message.footnoteHtml = [];
                for (var i = 0; i < object.footnoteHtml.length; ++i)
                    message.footnoteHtml[i] = String(object.footnoteHtml[i]);
            }
            if (object.eligibleInstrument) {
                if (!Array.isArray(object.eligibleInstrument))
                    throw TypeError(".BuyResponse.CheckoutInfo.eligibleInstrument: array expected");
                message.eligibleInstrument = [];
                for (var i = 0; i < object.eligibleInstrument.length; ++i) {
                    if (typeof object.eligibleInstrument[i] !== "object")
                        throw TypeError(".BuyResponse.CheckoutInfo.eligibleInstrument: object expected");
                    message.eligibleInstrument[i] = $root.Instrument.fromObject(object.eligibleInstrument[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a CheckoutInfo message. Also converts values to other types if specified.
         * @function toObject
         * @memberof BuyResponse.CheckoutInfo
         * @static
         * @param {BuyResponse.CheckoutInfo} message CheckoutInfo
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CheckoutInfo.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults) {
                object.subItem = [];
                object.checkoutOption = [];
                object.footerHtml = [];
                object.eligibleInstrumentFamily = [];
                object.footnoteHtml = [];
                object.eligibleInstrument = [];
            }
            if (options.defaults) {
                object.item = null;
                object.deprecatedCheckoutUrl = "";
                object.addInstrumentUrl = "";
            }
            if (message.item != null && message.hasOwnProperty("item"))
                object.item = $root.LineItem.toObject(message.item, options);
            if (message.subItem && message.subItem.length) {
                object.subItem = [];
                for (var j = 0; j < message.subItem.length; ++j)
                    object.subItem[j] = $root.LineItem.toObject(message.subItem[j], options);
            }
            if (message.checkoutOption && message.checkoutOption.length) {
                object.checkoutOption = [];
                for (var j = 0; j < message.checkoutOption.length; ++j)
                    object.checkoutOption[j] = $root.BuyResponse.CheckoutInfo.CheckoutOption.toObject(message.checkoutOption[j], options);
            }
            if (message.deprecatedCheckoutUrl != null && message.hasOwnProperty("deprecatedCheckoutUrl"))
                object.deprecatedCheckoutUrl = message.deprecatedCheckoutUrl;
            if (message.addInstrumentUrl != null && message.hasOwnProperty("addInstrumentUrl"))
                object.addInstrumentUrl = message.addInstrumentUrl;
            if (message.footerHtml && message.footerHtml.length) {
                object.footerHtml = [];
                for (var j = 0; j < message.footerHtml.length; ++j)
                    object.footerHtml[j] = message.footerHtml[j];
            }
            if (message.eligibleInstrumentFamily && message.eligibleInstrumentFamily.length) {
                object.eligibleInstrumentFamily = [];
                for (var j = 0; j < message.eligibleInstrumentFamily.length; ++j)
                    object.eligibleInstrumentFamily[j] = message.eligibleInstrumentFamily[j];
            }
            if (message.footnoteHtml && message.footnoteHtml.length) {
                object.footnoteHtml = [];
                for (var j = 0; j < message.footnoteHtml.length; ++j)
                    object.footnoteHtml[j] = message.footnoteHtml[j];
            }
            if (message.eligibleInstrument && message.eligibleInstrument.length) {
                object.eligibleInstrument = [];
                for (var j = 0; j < message.eligibleInstrument.length; ++j)
                    object.eligibleInstrument[j] = $root.Instrument.toObject(message.eligibleInstrument[j], options);
            }
            return object;
        };

        /**
         * Converts this CheckoutInfo to JSON.
         * @function toJSON
         * @memberof BuyResponse.CheckoutInfo
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CheckoutInfo.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        CheckoutInfo.CheckoutOption = (function() {

            /**
             * Properties of a CheckoutOption.
             * @memberof BuyResponse.CheckoutInfo
             * @interface ICheckoutOption
             * @property {string|null} [formOfPayment] CheckoutOption formOfPayment
             * @property {string|null} [encodedAdjustedCart] CheckoutOption encodedAdjustedCart
             * @property {string|null} [instrumentId] CheckoutOption instrumentId
             * @property {Array.<ILineItem>|null} [item] CheckoutOption item
             * @property {Array.<ILineItem>|null} [subItem] CheckoutOption subItem
             * @property {ILineItem|null} [total] CheckoutOption total
             * @property {Array.<string>|null} [footerHtml] CheckoutOption footerHtml
             * @property {number|null} [instrumentFamily] CheckoutOption instrumentFamily
             * @property {Array.<number>|null} [deprecatedInstrumentInapplicableReason] CheckoutOption deprecatedInstrumentInapplicableReason
             * @property {boolean|null} [selectedInstrument] CheckoutOption selectedInstrument
             * @property {ILineItem|null} [summary] CheckoutOption summary
             * @property {Array.<string>|null} [footnoteHtml] CheckoutOption footnoteHtml
             * @property {IInstrument|null} [instrument] CheckoutOption instrument
             * @property {string|null} [purchaseCookie] CheckoutOption purchaseCookie
             * @property {Array.<string>|null} [disabledReason] CheckoutOption disabledReason
             */

            /**
             * Constructs a new CheckoutOption.
             * @memberof BuyResponse.CheckoutInfo
             * @classdesc Represents a CheckoutOption.
             * @implements ICheckoutOption
             * @constructor
             * @param {BuyResponse.CheckoutInfo.ICheckoutOption=} [properties] Properties to set
             */
            function CheckoutOption(properties) {
                this.item = [];
                this.subItem = [];
                this.footerHtml = [];
                this.deprecatedInstrumentInapplicableReason = [];
                this.footnoteHtml = [];
                this.disabledReason = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * CheckoutOption formOfPayment.
             * @member {string} formOfPayment
             * @memberof BuyResponse.CheckoutInfo.CheckoutOption
             * @instance
             */
            CheckoutOption.prototype.formOfPayment = "";

            /**
             * CheckoutOption encodedAdjustedCart.
             * @member {string} encodedAdjustedCart
             * @memberof BuyResponse.CheckoutInfo.CheckoutOption
             * @instance
             */
            CheckoutOption.prototype.encodedAdjustedCart = "";

            /**
             * CheckoutOption instrumentId.
             * @member {string} instrumentId
             * @memberof BuyResponse.CheckoutInfo.CheckoutOption
             * @instance
             */
            CheckoutOption.prototype.instrumentId = "";

            /**
             * CheckoutOption item.
             * @member {Array.<ILineItem>} item
             * @memberof BuyResponse.CheckoutInfo.CheckoutOption
             * @instance
             */
            CheckoutOption.prototype.item = $util.emptyArray;

            /**
             * CheckoutOption subItem.
             * @member {Array.<ILineItem>} subItem
             * @memberof BuyResponse.CheckoutInfo.CheckoutOption
             * @instance
             */
            CheckoutOption.prototype.subItem = $util.emptyArray;

            /**
             * CheckoutOption total.
             * @member {ILineItem|null|undefined} total
             * @memberof BuyResponse.CheckoutInfo.CheckoutOption
             * @instance
             */
            CheckoutOption.prototype.total = null;

            /**
             * CheckoutOption footerHtml.
             * @member {Array.<string>} footerHtml
             * @memberof BuyResponse.CheckoutInfo.CheckoutOption
             * @instance
             */
            CheckoutOption.prototype.footerHtml = $util.emptyArray;

            /**
             * CheckoutOption instrumentFamily.
             * @member {number} instrumentFamily
             * @memberof BuyResponse.CheckoutInfo.CheckoutOption
             * @instance
             */
            CheckoutOption.prototype.instrumentFamily = 0;

            /**
             * CheckoutOption deprecatedInstrumentInapplicableReason.
             * @member {Array.<number>} deprecatedInstrumentInapplicableReason
             * @memberof BuyResponse.CheckoutInfo.CheckoutOption
             * @instance
             */
            CheckoutOption.prototype.deprecatedInstrumentInapplicableReason = $util.emptyArray;

            /**
             * CheckoutOption selectedInstrument.
             * @member {boolean} selectedInstrument
             * @memberof BuyResponse.CheckoutInfo.CheckoutOption
             * @instance
             */
            CheckoutOption.prototype.selectedInstrument = false;

            /**
             * CheckoutOption summary.
             * @member {ILineItem|null|undefined} summary
             * @memberof BuyResponse.CheckoutInfo.CheckoutOption
             * @instance
             */
            CheckoutOption.prototype.summary = null;

            /**
             * CheckoutOption footnoteHtml.
             * @member {Array.<string>} footnoteHtml
             * @memberof BuyResponse.CheckoutInfo.CheckoutOption
             * @instance
             */
            CheckoutOption.prototype.footnoteHtml = $util.emptyArray;

            /**
             * CheckoutOption instrument.
             * @member {IInstrument|null|undefined} instrument
             * @memberof BuyResponse.CheckoutInfo.CheckoutOption
             * @instance
             */
            CheckoutOption.prototype.instrument = null;

            /**
             * CheckoutOption purchaseCookie.
             * @member {string} purchaseCookie
             * @memberof BuyResponse.CheckoutInfo.CheckoutOption
             * @instance
             */
            CheckoutOption.prototype.purchaseCookie = "";

            /**
             * CheckoutOption disabledReason.
             * @member {Array.<string>} disabledReason
             * @memberof BuyResponse.CheckoutInfo.CheckoutOption
             * @instance
             */
            CheckoutOption.prototype.disabledReason = $util.emptyArray;

            /**
             * Creates a new CheckoutOption instance using the specified properties.
             * @function create
             * @memberof BuyResponse.CheckoutInfo.CheckoutOption
             * @static
             * @param {BuyResponse.CheckoutInfo.ICheckoutOption=} [properties] Properties to set
             * @returns {BuyResponse.CheckoutInfo.CheckoutOption} CheckoutOption instance
             */
            CheckoutOption.create = function create(properties) {
                return new CheckoutOption(properties);
            };

            /**
             * Encodes the specified CheckoutOption message. Does not implicitly {@link BuyResponse.CheckoutInfo.CheckoutOption.verify|verify} messages.
             * @function encode
             * @memberof BuyResponse.CheckoutInfo.CheckoutOption
             * @static
             * @param {BuyResponse.CheckoutInfo.ICheckoutOption} message CheckoutOption message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            CheckoutOption.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.formOfPayment != null && Object.hasOwnProperty.call(message, "formOfPayment"))
                    writer.uint32(/* id 6, wireType 2 =*/50).string(message.formOfPayment);
                if (message.encodedAdjustedCart != null && Object.hasOwnProperty.call(message, "encodedAdjustedCart"))
                    writer.uint32(/* id 7, wireType 2 =*/58).string(message.encodedAdjustedCart);
                if (message.instrumentId != null && Object.hasOwnProperty.call(message, "instrumentId"))
                    writer.uint32(/* id 15, wireType 2 =*/122).string(message.instrumentId);
                if (message.item != null && message.item.length)
                    for (var i = 0; i < message.item.length; ++i)
                        $root.LineItem.encode(message.item[i], writer.uint32(/* id 16, wireType 2 =*/130).fork()).ldelim();
                if (message.subItem != null && message.subItem.length)
                    for (var i = 0; i < message.subItem.length; ++i)
                        $root.LineItem.encode(message.subItem[i], writer.uint32(/* id 17, wireType 2 =*/138).fork()).ldelim();
                if (message.total != null && Object.hasOwnProperty.call(message, "total"))
                    $root.LineItem.encode(message.total, writer.uint32(/* id 18, wireType 2 =*/146).fork()).ldelim();
                if (message.footerHtml != null && message.footerHtml.length)
                    for (var i = 0; i < message.footerHtml.length; ++i)
                        writer.uint32(/* id 19, wireType 2 =*/154).string(message.footerHtml[i]);
                if (message.instrumentFamily != null && Object.hasOwnProperty.call(message, "instrumentFamily"))
                    writer.uint32(/* id 29, wireType 0 =*/232).int32(message.instrumentFamily);
                if (message.deprecatedInstrumentInapplicableReason != null && message.deprecatedInstrumentInapplicableReason.length)
                    for (var i = 0; i < message.deprecatedInstrumentInapplicableReason.length; ++i)
                        writer.uint32(/* id 30, wireType 0 =*/240).int32(message.deprecatedInstrumentInapplicableReason[i]);
                if (message.selectedInstrument != null && Object.hasOwnProperty.call(message, "selectedInstrument"))
                    writer.uint32(/* id 32, wireType 0 =*/256).bool(message.selectedInstrument);
                if (message.summary != null && Object.hasOwnProperty.call(message, "summary"))
                    $root.LineItem.encode(message.summary, writer.uint32(/* id 33, wireType 2 =*/266).fork()).ldelim();
                if (message.footnoteHtml != null && message.footnoteHtml.length)
                    for (var i = 0; i < message.footnoteHtml.length; ++i)
                        writer.uint32(/* id 35, wireType 2 =*/282).string(message.footnoteHtml[i]);
                if (message.instrument != null && Object.hasOwnProperty.call(message, "instrument"))
                    $root.Instrument.encode(message.instrument, writer.uint32(/* id 43, wireType 2 =*/346).fork()).ldelim();
                if (message.purchaseCookie != null && Object.hasOwnProperty.call(message, "purchaseCookie"))
                    writer.uint32(/* id 45, wireType 2 =*/362).string(message.purchaseCookie);
                if (message.disabledReason != null && message.disabledReason.length)
                    for (var i = 0; i < message.disabledReason.length; ++i)
                        writer.uint32(/* id 48, wireType 2 =*/386).string(message.disabledReason[i]);
                return writer;
            };

            /**
             * Encodes the specified CheckoutOption message, length delimited. Does not implicitly {@link BuyResponse.CheckoutInfo.CheckoutOption.verify|verify} messages.
             * @function encodeDelimited
             * @memberof BuyResponse.CheckoutInfo.CheckoutOption
             * @static
             * @param {BuyResponse.CheckoutInfo.ICheckoutOption} message CheckoutOption message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            CheckoutOption.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a CheckoutOption message from the specified reader or buffer.
             * @function decode
             * @memberof BuyResponse.CheckoutInfo.CheckoutOption
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {BuyResponse.CheckoutInfo.CheckoutOption} CheckoutOption
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            CheckoutOption.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.BuyResponse.CheckoutInfo.CheckoutOption();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    if ((tag & 7) === 4)
                        break;
                    switch (tag >>> 3) {
                    case 6:
                        message.formOfPayment = reader.string();
                        break;
                    case 7:
                        message.encodedAdjustedCart = reader.string();
                        break;
                    case 15:
                        message.instrumentId = reader.string();
                        break;
                    case 16:
                        if (!(message.item && message.item.length))
                            message.item = [];
                        message.item.push($root.LineItem.decode(reader, reader.uint32()));
                        break;
                    case 17:
                        if (!(message.subItem && message.subItem.length))
                            message.subItem = [];
                        message.subItem.push($root.LineItem.decode(reader, reader.uint32()));
                        break;
                    case 18:
                        message.total = $root.LineItem.decode(reader, reader.uint32());
                        break;
                    case 19:
                        if (!(message.footerHtml && message.footerHtml.length))
                            message.footerHtml = [];
                        message.footerHtml.push(reader.string());
                        break;
                    case 29:
                        message.instrumentFamily = reader.int32();
                        break;
                    case 30:
                        if (!(message.deprecatedInstrumentInapplicableReason && message.deprecatedInstrumentInapplicableReason.length))
                            message.deprecatedInstrumentInapplicableReason = [];
                        if ((tag & 7) === 2) {
                            var end2 = reader.uint32() + reader.pos;
                            while (reader.pos < end2)
                                message.deprecatedInstrumentInapplicableReason.push(reader.int32());
                        } else
                            message.deprecatedInstrumentInapplicableReason.push(reader.int32());
                        break;
                    case 32:
                        message.selectedInstrument = reader.bool();
                        break;
                    case 33:
                        message.summary = $root.LineItem.decode(reader, reader.uint32());
                        break;
                    case 35:
                        if (!(message.footnoteHtml && message.footnoteHtml.length))
                            message.footnoteHtml = [];
                        message.footnoteHtml.push(reader.string());
                        break;
                    case 43:
                        message.instrument = $root.Instrument.decode(reader, reader.uint32());
                        break;
                    case 45:
                        message.purchaseCookie = reader.string();
                        break;
                    case 48:
                        if (!(message.disabledReason && message.disabledReason.length))
                            message.disabledReason = [];
                        message.disabledReason.push(reader.string());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a CheckoutOption message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof BuyResponse.CheckoutInfo.CheckoutOption
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {BuyResponse.CheckoutInfo.CheckoutOption} CheckoutOption
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            CheckoutOption.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a CheckoutOption message.
             * @function verify
             * @memberof BuyResponse.CheckoutInfo.CheckoutOption
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            CheckoutOption.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.formOfPayment != null && message.hasOwnProperty("formOfPayment"))
                    if (!$util.isString(message.formOfPayment))
                        return "formOfPayment: string expected";
                if (message.encodedAdjustedCart != null && message.hasOwnProperty("encodedAdjustedCart"))
                    if (!$util.isString(message.encodedAdjustedCart))
                        return "encodedAdjustedCart: string expected";
                if (message.instrumentId != null && message.hasOwnProperty("instrumentId"))
                    if (!$util.isString(message.instrumentId))
                        return "instrumentId: string expected";
                if (message.item != null && message.hasOwnProperty("item")) {
                    if (!Array.isArray(message.item))
                        return "item: array expected";
                    for (var i = 0; i < message.item.length; ++i) {
                        var error = $root.LineItem.verify(message.item[i]);
                        if (error)
                            return "item." + error;
                    }
                }
                if (message.subItem != null && message.hasOwnProperty("subItem")) {
                    if (!Array.isArray(message.subItem))
                        return "subItem: array expected";
                    for (var i = 0; i < message.subItem.length; ++i) {
                        var error = $root.LineItem.verify(message.subItem[i]);
                        if (error)
                            return "subItem." + error;
                    }
                }
                if (message.total != null && message.hasOwnProperty("total")) {
                    var error = $root.LineItem.verify(message.total);
                    if (error)
                        return "total." + error;
                }
                if (message.footerHtml != null && message.hasOwnProperty("footerHtml")) {
                    if (!Array.isArray(message.footerHtml))
                        return "footerHtml: array expected";
                    for (var i = 0; i < message.footerHtml.length; ++i)
                        if (!$util.isString(message.footerHtml[i]))
                            return "footerHtml: string[] expected";
                }
                if (message.instrumentFamily != null && message.hasOwnProperty("instrumentFamily"))
                    if (!$util.isInteger(message.instrumentFamily))
                        return "instrumentFamily: integer expected";
                if (message.deprecatedInstrumentInapplicableReason != null && message.hasOwnProperty("deprecatedInstrumentInapplicableReason")) {
                    if (!Array.isArray(message.deprecatedInstrumentInapplicableReason))
                        return "deprecatedInstrumentInapplicableReason: array expected";
                    for (var i = 0; i < message.deprecatedInstrumentInapplicableReason.length; ++i)
                        if (!$util.isInteger(message.deprecatedInstrumentInapplicableReason[i]))
                            return "deprecatedInstrumentInapplicableReason: integer[] expected";
                }
                if (message.selectedInstrument != null && message.hasOwnProperty("selectedInstrument"))
                    if (typeof message.selectedInstrument !== "boolean")
                        return "selectedInstrument: boolean expected";
                if (message.summary != null && message.hasOwnProperty("summary")) {
                    var error = $root.LineItem.verify(message.summary);
                    if (error)
                        return "summary." + error;
                }
                if (message.footnoteHtml != null && message.hasOwnProperty("footnoteHtml")) {
                    if (!Array.isArray(message.footnoteHtml))
                        return "footnoteHtml: array expected";
                    for (var i = 0; i < message.footnoteHtml.length; ++i)
                        if (!$util.isString(message.footnoteHtml[i]))
                            return "footnoteHtml: string[] expected";
                }
                if (message.instrument != null && message.hasOwnProperty("instrument")) {
                    var error = $root.Instrument.verify(message.instrument);
                    if (error)
                        return "instrument." + error;
                }
                if (message.purchaseCookie != null && message.hasOwnProperty("purchaseCookie"))
                    if (!$util.isString(message.purchaseCookie))
                        return "purchaseCookie: string expected";
                if (message.disabledReason != null && message.hasOwnProperty("disabledReason")) {
                    if (!Array.isArray(message.disabledReason))
                        return "disabledReason: array expected";
                    for (var i = 0; i < message.disabledReason.length; ++i)
                        if (!$util.isString(message.disabledReason[i]))
                            return "disabledReason: string[] expected";
                }
                return null;
            };

            /**
             * Creates a CheckoutOption message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof BuyResponse.CheckoutInfo.CheckoutOption
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {BuyResponse.CheckoutInfo.CheckoutOption} CheckoutOption
             */
            CheckoutOption.fromObject = function fromObject(object) {
                if (object instanceof $root.BuyResponse.CheckoutInfo.CheckoutOption)
                    return object;
                var message = new $root.BuyResponse.CheckoutInfo.CheckoutOption();
                if (object.formOfPayment != null)
                    message.formOfPayment = String(object.formOfPayment);
                if (object.encodedAdjustedCart != null)
                    message.encodedAdjustedCart = String(object.encodedAdjustedCart);
                if (object.instrumentId != null)
                    message.instrumentId = String(object.instrumentId);
                if (object.item) {
                    if (!Array.isArray(object.item))
                        throw TypeError(".BuyResponse.CheckoutInfo.CheckoutOption.item: array expected");
                    message.item = [];
                    for (var i = 0; i < object.item.length; ++i) {
                        if (typeof object.item[i] !== "object")
                            throw TypeError(".BuyResponse.CheckoutInfo.CheckoutOption.item: object expected");
                        message.item[i] = $root.LineItem.fromObject(object.item[i]);
                    }
                }
                if (object.subItem) {
                    if (!Array.isArray(object.subItem))
                        throw TypeError(".BuyResponse.CheckoutInfo.CheckoutOption.subItem: array expected");
                    message.subItem = [];
                    for (var i = 0; i < object.subItem.length; ++i) {
                        if (typeof object.subItem[i] !== "object")
                            throw TypeError(".BuyResponse.CheckoutInfo.CheckoutOption.subItem: object expected");
                        message.subItem[i] = $root.LineItem.fromObject(object.subItem[i]);
                    }
                }
                if (object.total != null) {
                    if (typeof object.total !== "object")
                        throw TypeError(".BuyResponse.CheckoutInfo.CheckoutOption.total: object expected");
                    message.total = $root.LineItem.fromObject(object.total);
                }
                if (object.footerHtml) {
                    if (!Array.isArray(object.footerHtml))
                        throw TypeError(".BuyResponse.CheckoutInfo.CheckoutOption.footerHtml: array expected");
                    message.footerHtml = [];
                    for (var i = 0; i < object.footerHtml.length; ++i)
                        message.footerHtml[i] = String(object.footerHtml[i]);
                }
                if (object.instrumentFamily != null)
                    message.instrumentFamily = object.instrumentFamily | 0;
                if (object.deprecatedInstrumentInapplicableReason) {
                    if (!Array.isArray(object.deprecatedInstrumentInapplicableReason))
                        throw TypeError(".BuyResponse.CheckoutInfo.CheckoutOption.deprecatedInstrumentInapplicableReason: array expected");
                    message.deprecatedInstrumentInapplicableReason = [];
                    for (var i = 0; i < object.deprecatedInstrumentInapplicableReason.length; ++i)
                        message.deprecatedInstrumentInapplicableReason[i] = object.deprecatedInstrumentInapplicableReason[i] | 0;
                }
                if (object.selectedInstrument != null)
                    message.selectedInstrument = Boolean(object.selectedInstrument);
                if (object.summary != null) {
                    if (typeof object.summary !== "object")
                        throw TypeError(".BuyResponse.CheckoutInfo.CheckoutOption.summary: object expected");
                    message.summary = $root.LineItem.fromObject(object.summary);
                }
                if (object.footnoteHtml) {
                    if (!Array.isArray(object.footnoteHtml))
                        throw TypeError(".BuyResponse.CheckoutInfo.CheckoutOption.footnoteHtml: array expected");
                    message.footnoteHtml = [];
                    for (var i = 0; i < object.footnoteHtml.length; ++i)
                        message.footnoteHtml[i] = String(object.footnoteHtml[i]);
                }
                if (object.instrument != null) {
                    if (typeof object.instrument !== "object")
                        throw TypeError(".BuyResponse.CheckoutInfo.CheckoutOption.instrument: object expected");
                    message.instrument = $root.Instrument.fromObject(object.instrument);
                }
                if (object.purchaseCookie != null)
                    message.purchaseCookie = String(object.purchaseCookie);
                if (object.disabledReason) {
                    if (!Array.isArray(object.disabledReason))
                        throw TypeError(".BuyResponse.CheckoutInfo.CheckoutOption.disabledReason: array expected");
                    message.disabledReason = [];
                    for (var i = 0; i < object.disabledReason.length; ++i)
                        message.disabledReason[i] = String(object.disabledReason[i]);
                }
                return message;
            };

            /**
             * Creates a plain object from a CheckoutOption message. Also converts values to other types if specified.
             * @function toObject
             * @memberof BuyResponse.CheckoutInfo.CheckoutOption
             * @static
             * @param {BuyResponse.CheckoutInfo.CheckoutOption} message CheckoutOption
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            CheckoutOption.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults) {
                    object.item = [];
                    object.subItem = [];
                    object.footerHtml = [];
                    object.deprecatedInstrumentInapplicableReason = [];
                    object.footnoteHtml = [];
                    object.disabledReason = [];
                }
                if (options.defaults) {
                    object.formOfPayment = "";
                    object.encodedAdjustedCart = "";
                    object.instrumentId = "";
                    object.total = null;
                    object.instrumentFamily = 0;
                    object.selectedInstrument = false;
                    object.summary = null;
                    object.instrument = null;
                    object.purchaseCookie = "";
                }
                if (message.formOfPayment != null && message.hasOwnProperty("formOfPayment"))
                    object.formOfPayment = message.formOfPayment;
                if (message.encodedAdjustedCart != null && message.hasOwnProperty("encodedAdjustedCart"))
                    object.encodedAdjustedCart = message.encodedAdjustedCart;
                if (message.instrumentId != null && message.hasOwnProperty("instrumentId"))
                    object.instrumentId = message.instrumentId;
                if (message.item && message.item.length) {
                    object.item = [];
                    for (var j = 0; j < message.item.length; ++j)
                        object.item[j] = $root.LineItem.toObject(message.item[j], options);
                }
                if (message.subItem && message.subItem.length) {
                    object.subItem = [];
                    for (var j = 0; j < message.subItem.length; ++j)
                        object.subItem[j] = $root.LineItem.toObject(message.subItem[j], options);
                }
                if (message.total != null && message.hasOwnProperty("total"))
                    object.total = $root.LineItem.toObject(message.total, options);
                if (message.footerHtml && message.footerHtml.length) {
                    object.footerHtml = [];
                    for (var j = 0; j < message.footerHtml.length; ++j)
                        object.footerHtml[j] = message.footerHtml[j];
                }
                if (message.instrumentFamily != null && message.hasOwnProperty("instrumentFamily"))
                    object.instrumentFamily = message.instrumentFamily;
                if (message.deprecatedInstrumentInapplicableReason && message.deprecatedInstrumentInapplicableReason.length) {
                    object.deprecatedInstrumentInapplicableReason = [];
                    for (var j = 0; j < message.deprecatedInstrumentInapplicableReason.length; ++j)
                        object.deprecatedInstrumentInapplicableReason[j] = message.deprecatedInstrumentInapplicableReason[j];
                }
                if (message.selectedInstrument != null && message.hasOwnProperty("selectedInstrument"))
                    object.selectedInstrument = message.selectedInstrument;
                if (message.summary != null && message.hasOwnProperty("summary"))
                    object.summary = $root.LineItem.toObject(message.summary, options);
                if (message.footnoteHtml && message.footnoteHtml.length) {
                    object.footnoteHtml = [];
                    for (var j = 0; j < message.footnoteHtml.length; ++j)
                        object.footnoteHtml[j] = message.footnoteHtml[j];
                }
                if (message.instrument != null && message.hasOwnProperty("instrument"))
                    object.instrument = $root.Instrument.toObject(message.instrument, options);
                if (message.purchaseCookie != null && message.hasOwnProperty("purchaseCookie"))
                    object.purchaseCookie = message.purchaseCookie;
                if (message.disabledReason && message.disabledReason.length) {
                    object.disabledReason = [];
                    for (var j = 0; j < message.disabledReason.length; ++j)
                        object.disabledReason[j] = message.disabledReason[j];
                }
                return object;
            };

            /**
             * Converts this CheckoutOption to JSON.
             * @function toJSON
             * @memberof BuyResponse.CheckoutInfo.CheckoutOption
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            CheckoutOption.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return CheckoutOption;
        })();

        return CheckoutInfo;
    })();

    return BuyResponse;
})();

$root.LineItem = (function() {

    /**
     * Properties of a LineItem.
     * @exports ILineItem
     * @interface ILineItem
     * @property {string|null} [name] LineItem name
     * @property {string|null} [description] LineItem description
     * @property {IOffer|null} [offer] LineItem offer
     * @property {IMoney|null} [amount] LineItem amount
     */

    /**
     * Constructs a new LineItem.
     * @exports LineItem
     * @classdesc Represents a LineItem.
     * @implements ILineItem
     * @constructor
     * @param {ILineItem=} [properties] Properties to set
     */
    function LineItem(properties) {
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * LineItem name.
     * @member {string} name
     * @memberof LineItem
     * @instance
     */
    LineItem.prototype.name = "";

    /**
     * LineItem description.
     * @member {string} description
     * @memberof LineItem
     * @instance
     */
    LineItem.prototype.description = "";

    /**
     * LineItem offer.
     * @member {IOffer|null|undefined} offer
     * @memberof LineItem
     * @instance
     */
    LineItem.prototype.offer = null;

    /**
     * LineItem amount.
     * @member {IMoney|null|undefined} amount
     * @memberof LineItem
     * @instance
     */
    LineItem.prototype.amount = null;

    /**
     * Creates a new LineItem instance using the specified properties.
     * @function create
     * @memberof LineItem
     * @static
     * @param {ILineItem=} [properties] Properties to set
     * @returns {LineItem} LineItem instance
     */
    LineItem.create = function create(properties) {
        return new LineItem(properties);
    };

    /**
     * Encodes the specified LineItem message. Does not implicitly {@link LineItem.verify|verify} messages.
     * @function encode
     * @memberof LineItem
     * @static
     * @param {ILineItem} message LineItem message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    LineItem.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.name != null && Object.hasOwnProperty.call(message, "name"))
            writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
        if (message.description != null && Object.hasOwnProperty.call(message, "description"))
            writer.uint32(/* id 2, wireType 2 =*/18).string(message.description);
        if (message.offer != null && Object.hasOwnProperty.call(message, "offer"))
            $root.Offer.encode(message.offer, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
        if (message.amount != null && Object.hasOwnProperty.call(message, "amount"))
            $root.Money.encode(message.amount, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
        return writer;
    };

    /**
     * Encodes the specified LineItem message, length delimited. Does not implicitly {@link LineItem.verify|verify} messages.
     * @function encodeDelimited
     * @memberof LineItem
     * @static
     * @param {ILineItem} message LineItem message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    LineItem.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a LineItem message from the specified reader or buffer.
     * @function decode
     * @memberof LineItem
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {LineItem} LineItem
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    LineItem.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.LineItem();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.name = reader.string();
                break;
            case 2:
                message.description = reader.string();
                break;
            case 3:
                message.offer = $root.Offer.decode(reader, reader.uint32());
                break;
            case 4:
                message.amount = $root.Money.decode(reader, reader.uint32());
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a LineItem message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof LineItem
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {LineItem} LineItem
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    LineItem.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a LineItem message.
     * @function verify
     * @memberof LineItem
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    LineItem.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.name != null && message.hasOwnProperty("name"))
            if (!$util.isString(message.name))
                return "name: string expected";
        if (message.description != null && message.hasOwnProperty("description"))
            if (!$util.isString(message.description))
                return "description: string expected";
        if (message.offer != null && message.hasOwnProperty("offer")) {
            var error = $root.Offer.verify(message.offer);
            if (error)
                return "offer." + error;
        }
        if (message.amount != null && message.hasOwnProperty("amount")) {
            var error = $root.Money.verify(message.amount);
            if (error)
                return "amount." + error;
        }
        return null;
    };

    /**
     * Creates a LineItem message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof LineItem
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {LineItem} LineItem
     */
    LineItem.fromObject = function fromObject(object) {
        if (object instanceof $root.LineItem)
            return object;
        var message = new $root.LineItem();
        if (object.name != null)
            message.name = String(object.name);
        if (object.description != null)
            message.description = String(object.description);
        if (object.offer != null) {
            if (typeof object.offer !== "object")
                throw TypeError(".LineItem.offer: object expected");
            message.offer = $root.Offer.fromObject(object.offer);
        }
        if (object.amount != null) {
            if (typeof object.amount !== "object")
                throw TypeError(".LineItem.amount: object expected");
            message.amount = $root.Money.fromObject(object.amount);
        }
        return message;
    };

    /**
     * Creates a plain object from a LineItem message. Also converts values to other types if specified.
     * @function toObject
     * @memberof LineItem
     * @static
     * @param {LineItem} message LineItem
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    LineItem.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        var object = {};
        if (options.defaults) {
            object.name = "";
            object.description = "";
            object.offer = null;
            object.amount = null;
        }
        if (message.name != null && message.hasOwnProperty("name"))
            object.name = message.name;
        if (message.description != null && message.hasOwnProperty("description"))
            object.description = message.description;
        if (message.offer != null && message.hasOwnProperty("offer"))
            object.offer = $root.Offer.toObject(message.offer, options);
        if (message.amount != null && message.hasOwnProperty("amount"))
            object.amount = $root.Money.toObject(message.amount, options);
        return object;
    };

    /**
     * Converts this LineItem to JSON.
     * @function toJSON
     * @memberof LineItem
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    LineItem.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return LineItem;
})();

$root.Money = (function() {

    /**
     * Properties of a Money.
     * @exports IMoney
     * @interface IMoney
     * @property {number|Long|null} [micros] Money micros
     * @property {string|null} [currencyCode] Money currencyCode
     * @property {string|null} [formattedAmount] Money formattedAmount
     */

    /**
     * Constructs a new Money.
     * @exports Money
     * @classdesc Represents a Money.
     * @implements IMoney
     * @constructor
     * @param {IMoney=} [properties] Properties to set
     */
    function Money(properties) {
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * Money micros.
     * @member {number|Long} micros
     * @memberof Money
     * @instance
     */
    Money.prototype.micros = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

    /**
     * Money currencyCode.
     * @member {string} currencyCode
     * @memberof Money
     * @instance
     */
    Money.prototype.currencyCode = "";

    /**
     * Money formattedAmount.
     * @member {string} formattedAmount
     * @memberof Money
     * @instance
     */
    Money.prototype.formattedAmount = "";

    /**
     * Creates a new Money instance using the specified properties.
     * @function create
     * @memberof Money
     * @static
     * @param {IMoney=} [properties] Properties to set
     * @returns {Money} Money instance
     */
    Money.create = function create(properties) {
        return new Money(properties);
    };

    /**
     * Encodes the specified Money message. Does not implicitly {@link Money.verify|verify} messages.
     * @function encode
     * @memberof Money
     * @static
     * @param {IMoney} message Money message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    Money.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.micros != null && Object.hasOwnProperty.call(message, "micros"))
            writer.uint32(/* id 1, wireType 0 =*/8).int64(message.micros);
        if (message.currencyCode != null && Object.hasOwnProperty.call(message, "currencyCode"))
            writer.uint32(/* id 2, wireType 2 =*/18).string(message.currencyCode);
        if (message.formattedAmount != null && Object.hasOwnProperty.call(message, "formattedAmount"))
            writer.uint32(/* id 3, wireType 2 =*/26).string(message.formattedAmount);
        return writer;
    };

    /**
     * Encodes the specified Money message, length delimited. Does not implicitly {@link Money.verify|verify} messages.
     * @function encodeDelimited
     * @memberof Money
     * @static
     * @param {IMoney} message Money message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    Money.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a Money message from the specified reader or buffer.
     * @function decode
     * @memberof Money
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {Money} Money
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    Money.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Money();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.micros = reader.int64();
                break;
            case 2:
                message.currencyCode = reader.string();
                break;
            case 3:
                message.formattedAmount = reader.string();
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a Money message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof Money
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {Money} Money
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    Money.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a Money message.
     * @function verify
     * @memberof Money
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    Money.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.micros != null && message.hasOwnProperty("micros"))
            if (!$util.isInteger(message.micros) && !(message.micros && $util.isInteger(message.micros.low) && $util.isInteger(message.micros.high)))
                return "micros: integer|Long expected";
        if (message.currencyCode != null && message.hasOwnProperty("currencyCode"))
            if (!$util.isString(message.currencyCode))
                return "currencyCode: string expected";
        if (message.formattedAmount != null && message.hasOwnProperty("formattedAmount"))
            if (!$util.isString(message.formattedAmount))
                return "formattedAmount: string expected";
        return null;
    };

    /**
     * Creates a Money message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof Money
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {Money} Money
     */
    Money.fromObject = function fromObject(object) {
        if (object instanceof $root.Money)
            return object;
        var message = new $root.Money();
        if (object.micros != null)
            if ($util.Long)
                (message.micros = $util.Long.fromValue(object.micros)).unsigned = false;
            else if (typeof object.micros === "string")
                message.micros = parseInt(object.micros, 10);
            else if (typeof object.micros === "number")
                message.micros = object.micros;
            else if (typeof object.micros === "object")
                message.micros = new $util.LongBits(object.micros.low >>> 0, object.micros.high >>> 0).toNumber();
        if (object.currencyCode != null)
            message.currencyCode = String(object.currencyCode);
        if (object.formattedAmount != null)
            message.formattedAmount = String(object.formattedAmount);
        return message;
    };

    /**
     * Creates a plain object from a Money message. Also converts values to other types if specified.
     * @function toObject
     * @memberof Money
     * @static
     * @param {Money} message Money
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    Money.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        var object = {};
        if (options.defaults) {
            if ($util.Long) {
                var long = new $util.Long(0, 0, false);
                object.micros = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
            } else
                object.micros = options.longs === String ? "0" : 0;
            object.currencyCode = "";
            object.formattedAmount = "";
        }
        if (message.micros != null && message.hasOwnProperty("micros"))
            if (typeof message.micros === "number")
                object.micros = options.longs === String ? String(message.micros) : message.micros;
            else
                object.micros = options.longs === String ? $util.Long.prototype.toString.call(message.micros) : options.longs === Number ? new $util.LongBits(message.micros.low >>> 0, message.micros.high >>> 0).toNumber() : message.micros;
        if (message.currencyCode != null && message.hasOwnProperty("currencyCode"))
            object.currencyCode = message.currencyCode;
        if (message.formattedAmount != null && message.hasOwnProperty("formattedAmount"))
            object.formattedAmount = message.formattedAmount;
        return object;
    };

    /**
     * Converts this Money to JSON.
     * @function toJSON
     * @memberof Money
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    Money.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return Money;
})();

$root.PurchaseNotificationResponse = (function() {

    /**
     * Properties of a PurchaseNotificationResponse.
     * @exports IPurchaseNotificationResponse
     * @interface IPurchaseNotificationResponse
     * @property {number|null} [status] PurchaseNotificationResponse status
     * @property {IDebugInfo|null} [debugInfo] PurchaseNotificationResponse debugInfo
     * @property {string|null} [localizedErrorMessage] PurchaseNotificationResponse localizedErrorMessage
     * @property {string|null} [purchaseId] PurchaseNotificationResponse purchaseId
     */

    /**
     * Constructs a new PurchaseNotificationResponse.
     * @exports PurchaseNotificationResponse
     * @classdesc Represents a PurchaseNotificationResponse.
     * @implements IPurchaseNotificationResponse
     * @constructor
     * @param {IPurchaseNotificationResponse=} [properties] Properties to set
     */
    function PurchaseNotificationResponse(properties) {
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * PurchaseNotificationResponse status.
     * @member {number} status
     * @memberof PurchaseNotificationResponse
     * @instance
     */
    PurchaseNotificationResponse.prototype.status = 0;

    /**
     * PurchaseNotificationResponse debugInfo.
     * @member {IDebugInfo|null|undefined} debugInfo
     * @memberof PurchaseNotificationResponse
     * @instance
     */
    PurchaseNotificationResponse.prototype.debugInfo = null;

    /**
     * PurchaseNotificationResponse localizedErrorMessage.
     * @member {string} localizedErrorMessage
     * @memberof PurchaseNotificationResponse
     * @instance
     */
    PurchaseNotificationResponse.prototype.localizedErrorMessage = "";

    /**
     * PurchaseNotificationResponse purchaseId.
     * @member {string} purchaseId
     * @memberof PurchaseNotificationResponse
     * @instance
     */
    PurchaseNotificationResponse.prototype.purchaseId = "";

    /**
     * Creates a new PurchaseNotificationResponse instance using the specified properties.
     * @function create
     * @memberof PurchaseNotificationResponse
     * @static
     * @param {IPurchaseNotificationResponse=} [properties] Properties to set
     * @returns {PurchaseNotificationResponse} PurchaseNotificationResponse instance
     */
    PurchaseNotificationResponse.create = function create(properties) {
        return new PurchaseNotificationResponse(properties);
    };

    /**
     * Encodes the specified PurchaseNotificationResponse message. Does not implicitly {@link PurchaseNotificationResponse.verify|verify} messages.
     * @function encode
     * @memberof PurchaseNotificationResponse
     * @static
     * @param {IPurchaseNotificationResponse} message PurchaseNotificationResponse message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    PurchaseNotificationResponse.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.status != null && Object.hasOwnProperty.call(message, "status"))
            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.status);
        if (message.debugInfo != null && Object.hasOwnProperty.call(message, "debugInfo"))
            $root.DebugInfo.encode(message.debugInfo, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
        if (message.localizedErrorMessage != null && Object.hasOwnProperty.call(message, "localizedErrorMessage"))
            writer.uint32(/* id 3, wireType 2 =*/26).string(message.localizedErrorMessage);
        if (message.purchaseId != null && Object.hasOwnProperty.call(message, "purchaseId"))
            writer.uint32(/* id 4, wireType 2 =*/34).string(message.purchaseId);
        return writer;
    };

    /**
     * Encodes the specified PurchaseNotificationResponse message, length delimited. Does not implicitly {@link PurchaseNotificationResponse.verify|verify} messages.
     * @function encodeDelimited
     * @memberof PurchaseNotificationResponse
     * @static
     * @param {IPurchaseNotificationResponse} message PurchaseNotificationResponse message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    PurchaseNotificationResponse.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a PurchaseNotificationResponse message from the specified reader or buffer.
     * @function decode
     * @memberof PurchaseNotificationResponse
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {PurchaseNotificationResponse} PurchaseNotificationResponse
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    PurchaseNotificationResponse.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.PurchaseNotificationResponse();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.status = reader.int32();
                break;
            case 2:
                message.debugInfo = $root.DebugInfo.decode(reader, reader.uint32());
                break;
            case 3:
                message.localizedErrorMessage = reader.string();
                break;
            case 4:
                message.purchaseId = reader.string();
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a PurchaseNotificationResponse message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof PurchaseNotificationResponse
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {PurchaseNotificationResponse} PurchaseNotificationResponse
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    PurchaseNotificationResponse.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a PurchaseNotificationResponse message.
     * @function verify
     * @memberof PurchaseNotificationResponse
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    PurchaseNotificationResponse.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.status != null && message.hasOwnProperty("status"))
            if (!$util.isInteger(message.status))
                return "status: integer expected";
        if (message.debugInfo != null && message.hasOwnProperty("debugInfo")) {
            var error = $root.DebugInfo.verify(message.debugInfo);
            if (error)
                return "debugInfo." + error;
        }
        if (message.localizedErrorMessage != null && message.hasOwnProperty("localizedErrorMessage"))
            if (!$util.isString(message.localizedErrorMessage))
                return "localizedErrorMessage: string expected";
        if (message.purchaseId != null && message.hasOwnProperty("purchaseId"))
            if (!$util.isString(message.purchaseId))
                return "purchaseId: string expected";
        return null;
    };

    /**
     * Creates a PurchaseNotificationResponse message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof PurchaseNotificationResponse
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {PurchaseNotificationResponse} PurchaseNotificationResponse
     */
    PurchaseNotificationResponse.fromObject = function fromObject(object) {
        if (object instanceof $root.PurchaseNotificationResponse)
            return object;
        var message = new $root.PurchaseNotificationResponse();
        if (object.status != null)
            message.status = object.status | 0;
        if (object.debugInfo != null) {
            if (typeof object.debugInfo !== "object")
                throw TypeError(".PurchaseNotificationResponse.debugInfo: object expected");
            message.debugInfo = $root.DebugInfo.fromObject(object.debugInfo);
        }
        if (object.localizedErrorMessage != null)
            message.localizedErrorMessage = String(object.localizedErrorMessage);
        if (object.purchaseId != null)
            message.purchaseId = String(object.purchaseId);
        return message;
    };

    /**
     * Creates a plain object from a PurchaseNotificationResponse message. Also converts values to other types if specified.
     * @function toObject
     * @memberof PurchaseNotificationResponse
     * @static
     * @param {PurchaseNotificationResponse} message PurchaseNotificationResponse
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    PurchaseNotificationResponse.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        var object = {};
        if (options.defaults) {
            object.status = 0;
            object.debugInfo = null;
            object.localizedErrorMessage = "";
            object.purchaseId = "";
        }
        if (message.status != null && message.hasOwnProperty("status"))
            object.status = message.status;
        if (message.debugInfo != null && message.hasOwnProperty("debugInfo"))
            object.debugInfo = $root.DebugInfo.toObject(message.debugInfo, options);
        if (message.localizedErrorMessage != null && message.hasOwnProperty("localizedErrorMessage"))
            object.localizedErrorMessage = message.localizedErrorMessage;
        if (message.purchaseId != null && message.hasOwnProperty("purchaseId"))
            object.purchaseId = message.purchaseId;
        return object;
    };

    /**
     * Converts this PurchaseNotificationResponse to JSON.
     * @function toJSON
     * @memberof PurchaseNotificationResponse
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    PurchaseNotificationResponse.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return PurchaseNotificationResponse;
})();

$root.PurchaseStatusResponse = (function() {

    /**
     * Properties of a PurchaseStatusResponse.
     * @exports IPurchaseStatusResponse
     * @interface IPurchaseStatusResponse
     * @property {number|null} [status] PurchaseStatusResponse status
     * @property {string|null} [statusMsg] PurchaseStatusResponse statusMsg
     * @property {string|null} [statusTitle] PurchaseStatusResponse statusTitle
     * @property {string|null} [briefMessage] PurchaseStatusResponse briefMessage
     * @property {string|null} [infoUrl] PurchaseStatusResponse infoUrl
     * @property {ILibraryUpdate|null} [libraryUpdate] PurchaseStatusResponse libraryUpdate
     * @property {IInstrument|null} [rejectedInstrument] PurchaseStatusResponse rejectedInstrument
     * @property {IAndroidAppDeliveryData|null} [appDeliveryData] PurchaseStatusResponse appDeliveryData
     */

    /**
     * Constructs a new PurchaseStatusResponse.
     * @exports PurchaseStatusResponse
     * @classdesc Represents a PurchaseStatusResponse.
     * @implements IPurchaseStatusResponse
     * @constructor
     * @param {IPurchaseStatusResponse=} [properties] Properties to set
     */
    function PurchaseStatusResponse(properties) {
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * PurchaseStatusResponse status.
     * @member {number} status
     * @memberof PurchaseStatusResponse
     * @instance
     */
    PurchaseStatusResponse.prototype.status = 0;

    /**
     * PurchaseStatusResponse statusMsg.
     * @member {string} statusMsg
     * @memberof PurchaseStatusResponse
     * @instance
     */
    PurchaseStatusResponse.prototype.statusMsg = "";

    /**
     * PurchaseStatusResponse statusTitle.
     * @member {string} statusTitle
     * @memberof PurchaseStatusResponse
     * @instance
     */
    PurchaseStatusResponse.prototype.statusTitle = "";

    /**
     * PurchaseStatusResponse briefMessage.
     * @member {string} briefMessage
     * @memberof PurchaseStatusResponse
     * @instance
     */
    PurchaseStatusResponse.prototype.briefMessage = "";

    /**
     * PurchaseStatusResponse infoUrl.
     * @member {string} infoUrl
     * @memberof PurchaseStatusResponse
     * @instance
     */
    PurchaseStatusResponse.prototype.infoUrl = "";

    /**
     * PurchaseStatusResponse libraryUpdate.
     * @member {ILibraryUpdate|null|undefined} libraryUpdate
     * @memberof PurchaseStatusResponse
     * @instance
     */
    PurchaseStatusResponse.prototype.libraryUpdate = null;

    /**
     * PurchaseStatusResponse rejectedInstrument.
     * @member {IInstrument|null|undefined} rejectedInstrument
     * @memberof PurchaseStatusResponse
     * @instance
     */
    PurchaseStatusResponse.prototype.rejectedInstrument = null;

    /**
     * PurchaseStatusResponse appDeliveryData.
     * @member {IAndroidAppDeliveryData|null|undefined} appDeliveryData
     * @memberof PurchaseStatusResponse
     * @instance
     */
    PurchaseStatusResponse.prototype.appDeliveryData = null;

    /**
     * Creates a new PurchaseStatusResponse instance using the specified properties.
     * @function create
     * @memberof PurchaseStatusResponse
     * @static
     * @param {IPurchaseStatusResponse=} [properties] Properties to set
     * @returns {PurchaseStatusResponse} PurchaseStatusResponse instance
     */
    PurchaseStatusResponse.create = function create(properties) {
        return new PurchaseStatusResponse(properties);
    };

    /**
     * Encodes the specified PurchaseStatusResponse message. Does not implicitly {@link PurchaseStatusResponse.verify|verify} messages.
     * @function encode
     * @memberof PurchaseStatusResponse
     * @static
     * @param {IPurchaseStatusResponse} message PurchaseStatusResponse message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    PurchaseStatusResponse.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.status != null && Object.hasOwnProperty.call(message, "status"))
            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.status);
        if (message.statusMsg != null && Object.hasOwnProperty.call(message, "statusMsg"))
            writer.uint32(/* id 2, wireType 2 =*/18).string(message.statusMsg);
        if (message.statusTitle != null && Object.hasOwnProperty.call(message, "statusTitle"))
            writer.uint32(/* id 3, wireType 2 =*/26).string(message.statusTitle);
        if (message.briefMessage != null && Object.hasOwnProperty.call(message, "briefMessage"))
            writer.uint32(/* id 4, wireType 2 =*/34).string(message.briefMessage);
        if (message.infoUrl != null && Object.hasOwnProperty.call(message, "infoUrl"))
            writer.uint32(/* id 5, wireType 2 =*/42).string(message.infoUrl);
        if (message.libraryUpdate != null && Object.hasOwnProperty.call(message, "libraryUpdate"))
            $root.LibraryUpdate.encode(message.libraryUpdate, writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
        if (message.rejectedInstrument != null && Object.hasOwnProperty.call(message, "rejectedInstrument"))
            $root.Instrument.encode(message.rejectedInstrument, writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
        if (message.appDeliveryData != null && Object.hasOwnProperty.call(message, "appDeliveryData"))
            $root.AndroidAppDeliveryData.encode(message.appDeliveryData, writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();
        return writer;
    };

    /**
     * Encodes the specified PurchaseStatusResponse message, length delimited. Does not implicitly {@link PurchaseStatusResponse.verify|verify} messages.
     * @function encodeDelimited
     * @memberof PurchaseStatusResponse
     * @static
     * @param {IPurchaseStatusResponse} message PurchaseStatusResponse message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    PurchaseStatusResponse.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a PurchaseStatusResponse message from the specified reader or buffer.
     * @function decode
     * @memberof PurchaseStatusResponse
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {PurchaseStatusResponse} PurchaseStatusResponse
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    PurchaseStatusResponse.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.PurchaseStatusResponse();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.status = reader.int32();
                break;
            case 2:
                message.statusMsg = reader.string();
                break;
            case 3:
                message.statusTitle = reader.string();
                break;
            case 4:
                message.briefMessage = reader.string();
                break;
            case 5:
                message.infoUrl = reader.string();
                break;
            case 6:
                message.libraryUpdate = $root.LibraryUpdate.decode(reader, reader.uint32());
                break;
            case 7:
                message.rejectedInstrument = $root.Instrument.decode(reader, reader.uint32());
                break;
            case 8:
                message.appDeliveryData = $root.AndroidAppDeliveryData.decode(reader, reader.uint32());
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a PurchaseStatusResponse message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof PurchaseStatusResponse
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {PurchaseStatusResponse} PurchaseStatusResponse
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    PurchaseStatusResponse.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a PurchaseStatusResponse message.
     * @function verify
     * @memberof PurchaseStatusResponse
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    PurchaseStatusResponse.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.status != null && message.hasOwnProperty("status"))
            if (!$util.isInteger(message.status))
                return "status: integer expected";
        if (message.statusMsg != null && message.hasOwnProperty("statusMsg"))
            if (!$util.isString(message.statusMsg))
                return "statusMsg: string expected";
        if (message.statusTitle != null && message.hasOwnProperty("statusTitle"))
            if (!$util.isString(message.statusTitle))
                return "statusTitle: string expected";
        if (message.briefMessage != null && message.hasOwnProperty("briefMessage"))
            if (!$util.isString(message.briefMessage))
                return "briefMessage: string expected";
        if (message.infoUrl != null && message.hasOwnProperty("infoUrl"))
            if (!$util.isString(message.infoUrl))
                return "infoUrl: string expected";
        if (message.libraryUpdate != null && message.hasOwnProperty("libraryUpdate")) {
            var error = $root.LibraryUpdate.verify(message.libraryUpdate);
            if (error)
                return "libraryUpdate." + error;
        }
        if (message.rejectedInstrument != null && message.hasOwnProperty("rejectedInstrument")) {
            var error = $root.Instrument.verify(message.rejectedInstrument);
            if (error)
                return "rejectedInstrument." + error;
        }
        if (message.appDeliveryData != null && message.hasOwnProperty("appDeliveryData")) {
            var error = $root.AndroidAppDeliveryData.verify(message.appDeliveryData);
            if (error)
                return "appDeliveryData." + error;
        }
        return null;
    };

    /**
     * Creates a PurchaseStatusResponse message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof PurchaseStatusResponse
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {PurchaseStatusResponse} PurchaseStatusResponse
     */
    PurchaseStatusResponse.fromObject = function fromObject(object) {
        if (object instanceof $root.PurchaseStatusResponse)
            return object;
        var message = new $root.PurchaseStatusResponse();
        if (object.status != null)
            message.status = object.status | 0;
        if (object.statusMsg != null)
            message.statusMsg = String(object.statusMsg);
        if (object.statusTitle != null)
            message.statusTitle = String(object.statusTitle);
        if (object.briefMessage != null)
            message.briefMessage = String(object.briefMessage);
        if (object.infoUrl != null)
            message.infoUrl = String(object.infoUrl);
        if (object.libraryUpdate != null) {
            if (typeof object.libraryUpdate !== "object")
                throw TypeError(".PurchaseStatusResponse.libraryUpdate: object expected");
            message.libraryUpdate = $root.LibraryUpdate.fromObject(object.libraryUpdate);
        }
        if (object.rejectedInstrument != null) {
            if (typeof object.rejectedInstrument !== "object")
                throw TypeError(".PurchaseStatusResponse.rejectedInstrument: object expected");
            message.rejectedInstrument = $root.Instrument.fromObject(object.rejectedInstrument);
        }
        if (object.appDeliveryData != null) {
            if (typeof object.appDeliveryData !== "object")
                throw TypeError(".PurchaseStatusResponse.appDeliveryData: object expected");
            message.appDeliveryData = $root.AndroidAppDeliveryData.fromObject(object.appDeliveryData);
        }
        return message;
    };

    /**
     * Creates a plain object from a PurchaseStatusResponse message. Also converts values to other types if specified.
     * @function toObject
     * @memberof PurchaseStatusResponse
     * @static
     * @param {PurchaseStatusResponse} message PurchaseStatusResponse
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    PurchaseStatusResponse.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        var object = {};
        if (options.defaults) {
            object.status = 0;
            object.statusMsg = "";
            object.statusTitle = "";
            object.briefMessage = "";
            object.infoUrl = "";
            object.libraryUpdate = null;
            object.rejectedInstrument = null;
            object.appDeliveryData = null;
        }
        if (message.status != null && message.hasOwnProperty("status"))
            object.status = message.status;
        if (message.statusMsg != null && message.hasOwnProperty("statusMsg"))
            object.statusMsg = message.statusMsg;
        if (message.statusTitle != null && message.hasOwnProperty("statusTitle"))
            object.statusTitle = message.statusTitle;
        if (message.briefMessage != null && message.hasOwnProperty("briefMessage"))
            object.briefMessage = message.briefMessage;
        if (message.infoUrl != null && message.hasOwnProperty("infoUrl"))
            object.infoUrl = message.infoUrl;
        if (message.libraryUpdate != null && message.hasOwnProperty("libraryUpdate"))
            object.libraryUpdate = $root.LibraryUpdate.toObject(message.libraryUpdate, options);
        if (message.rejectedInstrument != null && message.hasOwnProperty("rejectedInstrument"))
            object.rejectedInstrument = $root.Instrument.toObject(message.rejectedInstrument, options);
        if (message.appDeliveryData != null && message.hasOwnProperty("appDeliveryData"))
            object.appDeliveryData = $root.AndroidAppDeliveryData.toObject(message.appDeliveryData, options);
        return object;
    };

    /**
     * Converts this PurchaseStatusResponse to JSON.
     * @function toJSON
     * @memberof PurchaseStatusResponse
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    PurchaseStatusResponse.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return PurchaseStatusResponse;
})();

$root.PurchaseHistoryDetails = (function() {

    /**
     * Properties of a PurchaseHistoryDetails.
     * @exports IPurchaseHistoryDetails
     * @interface IPurchaseHistoryDetails
     * @property {number|Long|null} [purchaseTimestampMillis] PurchaseHistoryDetails purchaseTimestampMillis
     * @property {string|null} [purchaseDetailsHtml] PurchaseHistoryDetails purchaseDetailsHtml
     * @property {IOffer|null} [offer] PurchaseHistoryDetails offer
     * @property {string|null} [purchaseStatus] PurchaseHistoryDetails purchaseStatus
     * @property {string|null} [titleBylineHtml] PurchaseHistoryDetails titleBylineHtml
     * @property {Uint8Array|null} [clientRefundContext] PurchaseHistoryDetails clientRefundContext
     * @property {IImage|null} [purchaseDetailsImage] PurchaseHistoryDetails purchaseDetailsImage
     */

    /**
     * Constructs a new PurchaseHistoryDetails.
     * @exports PurchaseHistoryDetails
     * @classdesc Represents a PurchaseHistoryDetails.
     * @implements IPurchaseHistoryDetails
     * @constructor
     * @param {IPurchaseHistoryDetails=} [properties] Properties to set
     */
    function PurchaseHistoryDetails(properties) {
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * PurchaseHistoryDetails purchaseTimestampMillis.
     * @member {number|Long} purchaseTimestampMillis
     * @memberof PurchaseHistoryDetails
     * @instance
     */
    PurchaseHistoryDetails.prototype.purchaseTimestampMillis = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

    /**
     * PurchaseHistoryDetails purchaseDetailsHtml.
     * @member {string} purchaseDetailsHtml
     * @memberof PurchaseHistoryDetails
     * @instance
     */
    PurchaseHistoryDetails.prototype.purchaseDetailsHtml = "";

    /**
     * PurchaseHistoryDetails offer.
     * @member {IOffer|null|undefined} offer
     * @memberof PurchaseHistoryDetails
     * @instance
     */
    PurchaseHistoryDetails.prototype.offer = null;

    /**
     * PurchaseHistoryDetails purchaseStatus.
     * @member {string} purchaseStatus
     * @memberof PurchaseHistoryDetails
     * @instance
     */
    PurchaseHistoryDetails.prototype.purchaseStatus = "";

    /**
     * PurchaseHistoryDetails titleBylineHtml.
     * @member {string} titleBylineHtml
     * @memberof PurchaseHistoryDetails
     * @instance
     */
    PurchaseHistoryDetails.prototype.titleBylineHtml = "";

    /**
     * PurchaseHistoryDetails clientRefundContext.
     * @member {Uint8Array} clientRefundContext
     * @memberof PurchaseHistoryDetails
     * @instance
     */
    PurchaseHistoryDetails.prototype.clientRefundContext = $util.newBuffer([]);

    /**
     * PurchaseHistoryDetails purchaseDetailsImage.
     * @member {IImage|null|undefined} purchaseDetailsImage
     * @memberof PurchaseHistoryDetails
     * @instance
     */
    PurchaseHistoryDetails.prototype.purchaseDetailsImage = null;

    /**
     * Creates a new PurchaseHistoryDetails instance using the specified properties.
     * @function create
     * @memberof PurchaseHistoryDetails
     * @static
     * @param {IPurchaseHistoryDetails=} [properties] Properties to set
     * @returns {PurchaseHistoryDetails} PurchaseHistoryDetails instance
     */
    PurchaseHistoryDetails.create = function create(properties) {
        return new PurchaseHistoryDetails(properties);
    };

    /**
     * Encodes the specified PurchaseHistoryDetails message. Does not implicitly {@link PurchaseHistoryDetails.verify|verify} messages.
     * @function encode
     * @memberof PurchaseHistoryDetails
     * @static
     * @param {IPurchaseHistoryDetails} message PurchaseHistoryDetails message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    PurchaseHistoryDetails.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.purchaseTimestampMillis != null && Object.hasOwnProperty.call(message, "purchaseTimestampMillis"))
            writer.uint32(/* id 2, wireType 0 =*/16).int64(message.purchaseTimestampMillis);
        if (message.purchaseDetailsHtml != null && Object.hasOwnProperty.call(message, "purchaseDetailsHtml"))
            writer.uint32(/* id 3, wireType 2 =*/26).string(message.purchaseDetailsHtml);
        if (message.offer != null && Object.hasOwnProperty.call(message, "offer"))
            $root.Offer.encode(message.offer, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
        if (message.purchaseStatus != null && Object.hasOwnProperty.call(message, "purchaseStatus"))
            writer.uint32(/* id 6, wireType 2 =*/50).string(message.purchaseStatus);
        if (message.titleBylineHtml != null && Object.hasOwnProperty.call(message, "titleBylineHtml"))
            writer.uint32(/* id 7, wireType 2 =*/58).string(message.titleBylineHtml);
        if (message.clientRefundContext != null && Object.hasOwnProperty.call(message, "clientRefundContext"))
            writer.uint32(/* id 8, wireType 2 =*/66).bytes(message.clientRefundContext);
        if (message.purchaseDetailsImage != null && Object.hasOwnProperty.call(message, "purchaseDetailsImage"))
            $root.Image.encode(message.purchaseDetailsImage, writer.uint32(/* id 9, wireType 2 =*/74).fork()).ldelim();
        return writer;
    };

    /**
     * Encodes the specified PurchaseHistoryDetails message, length delimited. Does not implicitly {@link PurchaseHistoryDetails.verify|verify} messages.
     * @function encodeDelimited
     * @memberof PurchaseHistoryDetails
     * @static
     * @param {IPurchaseHistoryDetails} message PurchaseHistoryDetails message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    PurchaseHistoryDetails.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a PurchaseHistoryDetails message from the specified reader or buffer.
     * @function decode
     * @memberof PurchaseHistoryDetails
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {PurchaseHistoryDetails} PurchaseHistoryDetails
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    PurchaseHistoryDetails.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.PurchaseHistoryDetails();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            case 2:
                message.purchaseTimestampMillis = reader.int64();
                break;
            case 3:
                message.purchaseDetailsHtml = reader.string();
                break;
            case 5:
                message.offer = $root.Offer.decode(reader, reader.uint32());
                break;
            case 6:
                message.purchaseStatus = reader.string();
                break;
            case 7:
                message.titleBylineHtml = reader.string();
                break;
            case 8:
                message.clientRefundContext = reader.bytes();
                break;
            case 9:
                message.purchaseDetailsImage = $root.Image.decode(reader, reader.uint32());
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a PurchaseHistoryDetails message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof PurchaseHistoryDetails
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {PurchaseHistoryDetails} PurchaseHistoryDetails
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    PurchaseHistoryDetails.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a PurchaseHistoryDetails message.
     * @function verify
     * @memberof PurchaseHistoryDetails
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    PurchaseHistoryDetails.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.purchaseTimestampMillis != null && message.hasOwnProperty("purchaseTimestampMillis"))
            if (!$util.isInteger(message.purchaseTimestampMillis) && !(message.purchaseTimestampMillis && $util.isInteger(message.purchaseTimestampMillis.low) && $util.isInteger(message.purchaseTimestampMillis.high)))
                return "purchaseTimestampMillis: integer|Long expected";
        if (message.purchaseDetailsHtml != null && message.hasOwnProperty("purchaseDetailsHtml"))
            if (!$util.isString(message.purchaseDetailsHtml))
                return "purchaseDetailsHtml: string expected";
        if (message.offer != null && message.hasOwnProperty("offer")) {
            var error = $root.Offer.verify(message.offer);
            if (error)
                return "offer." + error;
        }
        if (message.purchaseStatus != null && message.hasOwnProperty("purchaseStatus"))
            if (!$util.isString(message.purchaseStatus))
                return "purchaseStatus: string expected";
        if (message.titleBylineHtml != null && message.hasOwnProperty("titleBylineHtml"))
            if (!$util.isString(message.titleBylineHtml))
                return "titleBylineHtml: string expected";
        if (message.clientRefundContext != null && message.hasOwnProperty("clientRefundContext"))
            if (!(message.clientRefundContext && typeof message.clientRefundContext.length === "number" || $util.isString(message.clientRefundContext)))
                return "clientRefundContext: buffer expected";
        if (message.purchaseDetailsImage != null && message.hasOwnProperty("purchaseDetailsImage")) {
            var error = $root.Image.verify(message.purchaseDetailsImage);
            if (error)
                return "purchaseDetailsImage." + error;
        }
        return null;
    };

    /**
     * Creates a PurchaseHistoryDetails message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof PurchaseHistoryDetails
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {PurchaseHistoryDetails} PurchaseHistoryDetails
     */
    PurchaseHistoryDetails.fromObject = function fromObject(object) {
        if (object instanceof $root.PurchaseHistoryDetails)
            return object;
        var message = new $root.PurchaseHistoryDetails();
        if (object.purchaseTimestampMillis != null)
            if ($util.Long)
                (message.purchaseTimestampMillis = $util.Long.fromValue(object.purchaseTimestampMillis)).unsigned = false;
            else if (typeof object.purchaseTimestampMillis === "string")
                message.purchaseTimestampMillis = parseInt(object.purchaseTimestampMillis, 10);
            else if (typeof object.purchaseTimestampMillis === "number")
                message.purchaseTimestampMillis = object.purchaseTimestampMillis;
            else if (typeof object.purchaseTimestampMillis === "object")
                message.purchaseTimestampMillis = new $util.LongBits(object.purchaseTimestampMillis.low >>> 0, object.purchaseTimestampMillis.high >>> 0).toNumber();
        if (object.purchaseDetailsHtml != null)
            message.purchaseDetailsHtml = String(object.purchaseDetailsHtml);
        if (object.offer != null) {
            if (typeof object.offer !== "object")
                throw TypeError(".PurchaseHistoryDetails.offer: object expected");
            message.offer = $root.Offer.fromObject(object.offer);
        }
        if (object.purchaseStatus != null)
            message.purchaseStatus = String(object.purchaseStatus);
        if (object.titleBylineHtml != null)
            message.titleBylineHtml = String(object.titleBylineHtml);
        if (object.clientRefundContext != null)
            if (typeof object.clientRefundContext === "string")
                $util.base64.decode(object.clientRefundContext, message.clientRefundContext = $util.newBuffer($util.base64.length(object.clientRefundContext)), 0);
            else if (object.clientRefundContext.length)
                message.clientRefundContext = object.clientRefundContext;
        if (object.purchaseDetailsImage != null) {
            if (typeof object.purchaseDetailsImage !== "object")
                throw TypeError(".PurchaseHistoryDetails.purchaseDetailsImage: object expected");
            message.purchaseDetailsImage = $root.Image.fromObject(object.purchaseDetailsImage);
        }
        return message;
    };

    /**
     * Creates a plain object from a PurchaseHistoryDetails message. Also converts values to other types if specified.
     * @function toObject
     * @memberof PurchaseHistoryDetails
     * @static
     * @param {PurchaseHistoryDetails} message PurchaseHistoryDetails
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    PurchaseHistoryDetails.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        var object = {};
        if (options.defaults) {
            if ($util.Long) {
                var long = new $util.Long(0, 0, false);
                object.purchaseTimestampMillis = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
            } else
                object.purchaseTimestampMillis = options.longs === String ? "0" : 0;
            object.purchaseDetailsHtml = "";
            object.offer = null;
            object.purchaseStatus = "";
            object.titleBylineHtml = "";
            if (options.bytes === String)
                object.clientRefundContext = "";
            else {
                object.clientRefundContext = [];
                if (options.bytes !== Array)
                    object.clientRefundContext = $util.newBuffer(object.clientRefundContext);
            }
            object.purchaseDetailsImage = null;
        }
        if (message.purchaseTimestampMillis != null && message.hasOwnProperty("purchaseTimestampMillis"))
            if (typeof message.purchaseTimestampMillis === "number")
                object.purchaseTimestampMillis = options.longs === String ? String(message.purchaseTimestampMillis) : message.purchaseTimestampMillis;
            else
                object.purchaseTimestampMillis = options.longs === String ? $util.Long.prototype.toString.call(message.purchaseTimestampMillis) : options.longs === Number ? new $util.LongBits(message.purchaseTimestampMillis.low >>> 0, message.purchaseTimestampMillis.high >>> 0).toNumber() : message.purchaseTimestampMillis;
        if (message.purchaseDetailsHtml != null && message.hasOwnProperty("purchaseDetailsHtml"))
            object.purchaseDetailsHtml = message.purchaseDetailsHtml;
        if (message.offer != null && message.hasOwnProperty("offer"))
            object.offer = $root.Offer.toObject(message.offer, options);
        if (message.purchaseStatus != null && message.hasOwnProperty("purchaseStatus"))
            object.purchaseStatus = message.purchaseStatus;
        if (message.titleBylineHtml != null && message.hasOwnProperty("titleBylineHtml"))
            object.titleBylineHtml = message.titleBylineHtml;
        if (message.clientRefundContext != null && message.hasOwnProperty("clientRefundContext"))
            object.clientRefundContext = options.bytes === String ? $util.base64.encode(message.clientRefundContext, 0, message.clientRefundContext.length) : options.bytes === Array ? Array.prototype.slice.call(message.clientRefundContext) : message.clientRefundContext;
        if (message.purchaseDetailsImage != null && message.hasOwnProperty("purchaseDetailsImage"))
            object.purchaseDetailsImage = $root.Image.toObject(message.purchaseDetailsImage, options);
        return object;
    };

    /**
     * Converts this PurchaseHistoryDetails to JSON.
     * @function toJSON
     * @memberof PurchaseHistoryDetails
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    PurchaseHistoryDetails.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return PurchaseHistoryDetails;
})();

$root.BillingProfileResponse = (function() {

    /**
     * Properties of a BillingProfileResponse.
     * @exports IBillingProfileResponse
     * @interface IBillingProfileResponse
     * @property {number|null} [result] BillingProfileResponse result
     * @property {IBillingProfile|null} [billingProfile] BillingProfileResponse billingProfile
     * @property {string|null} [userMessageHtml] BillingProfileResponse userMessageHtml
     */

    /**
     * Constructs a new BillingProfileResponse.
     * @exports BillingProfileResponse
     * @classdesc Represents a BillingProfileResponse.
     * @implements IBillingProfileResponse
     * @constructor
     * @param {IBillingProfileResponse=} [properties] Properties to set
     */
    function BillingProfileResponse(properties) {
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * BillingProfileResponse result.
     * @member {number} result
     * @memberof BillingProfileResponse
     * @instance
     */
    BillingProfileResponse.prototype.result = 0;

    /**
     * BillingProfileResponse billingProfile.
     * @member {IBillingProfile|null|undefined} billingProfile
     * @memberof BillingProfileResponse
     * @instance
     */
    BillingProfileResponse.prototype.billingProfile = null;

    /**
     * BillingProfileResponse userMessageHtml.
     * @member {string} userMessageHtml
     * @memberof BillingProfileResponse
     * @instance
     */
    BillingProfileResponse.prototype.userMessageHtml = "";

    /**
     * Creates a new BillingProfileResponse instance using the specified properties.
     * @function create
     * @memberof BillingProfileResponse
     * @static
     * @param {IBillingProfileResponse=} [properties] Properties to set
     * @returns {BillingProfileResponse} BillingProfileResponse instance
     */
    BillingProfileResponse.create = function create(properties) {
        return new BillingProfileResponse(properties);
    };

    /**
     * Encodes the specified BillingProfileResponse message. Does not implicitly {@link BillingProfileResponse.verify|verify} messages.
     * @function encode
     * @memberof BillingProfileResponse
     * @static
     * @param {IBillingProfileResponse} message BillingProfileResponse message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    BillingProfileResponse.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.result != null && Object.hasOwnProperty.call(message, "result"))
            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.result);
        if (message.billingProfile != null && Object.hasOwnProperty.call(message, "billingProfile"))
            $root.BillingProfile.encode(message.billingProfile, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
        if (message.userMessageHtml != null && Object.hasOwnProperty.call(message, "userMessageHtml"))
            writer.uint32(/* id 3, wireType 2 =*/26).string(message.userMessageHtml);
        return writer;
    };

    /**
     * Encodes the specified BillingProfileResponse message, length delimited. Does not implicitly {@link BillingProfileResponse.verify|verify} messages.
     * @function encodeDelimited
     * @memberof BillingProfileResponse
     * @static
     * @param {IBillingProfileResponse} message BillingProfileResponse message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    BillingProfileResponse.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a BillingProfileResponse message from the specified reader or buffer.
     * @function decode
     * @memberof BillingProfileResponse
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {BillingProfileResponse} BillingProfileResponse
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    BillingProfileResponse.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.BillingProfileResponse();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.result = reader.int32();
                break;
            case 2:
                message.billingProfile = $root.BillingProfile.decode(reader, reader.uint32());
                break;
            case 3:
                message.userMessageHtml = reader.string();
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a BillingProfileResponse message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof BillingProfileResponse
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {BillingProfileResponse} BillingProfileResponse
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    BillingProfileResponse.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a BillingProfileResponse message.
     * @function verify
     * @memberof BillingProfileResponse
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    BillingProfileResponse.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.result != null && message.hasOwnProperty("result"))
            if (!$util.isInteger(message.result))
                return "result: integer expected";
        if (message.billingProfile != null && message.hasOwnProperty("billingProfile")) {
            var error = $root.BillingProfile.verify(message.billingProfile);
            if (error)
                return "billingProfile." + error;
        }
        if (message.userMessageHtml != null && message.hasOwnProperty("userMessageHtml"))
            if (!$util.isString(message.userMessageHtml))
                return "userMessageHtml: string expected";
        return null;
    };

    /**
     * Creates a BillingProfileResponse message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof BillingProfileResponse
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {BillingProfileResponse} BillingProfileResponse
     */
    BillingProfileResponse.fromObject = function fromObject(object) {
        if (object instanceof $root.BillingProfileResponse)
            return object;
        var message = new $root.BillingProfileResponse();
        if (object.result != null)
            message.result = object.result | 0;
        if (object.billingProfile != null) {
            if (typeof object.billingProfile !== "object")
                throw TypeError(".BillingProfileResponse.billingProfile: object expected");
            message.billingProfile = $root.BillingProfile.fromObject(object.billingProfile);
        }
        if (object.userMessageHtml != null)
            message.userMessageHtml = String(object.userMessageHtml);
        return message;
    };

    /**
     * Creates a plain object from a BillingProfileResponse message. Also converts values to other types if specified.
     * @function toObject
     * @memberof BillingProfileResponse
     * @static
     * @param {BillingProfileResponse} message BillingProfileResponse
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    BillingProfileResponse.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        var object = {};
        if (options.defaults) {
            object.result = 0;
            object.billingProfile = null;
            object.userMessageHtml = "";
        }
        if (message.result != null && message.hasOwnProperty("result"))
            object.result = message.result;
        if (message.billingProfile != null && message.hasOwnProperty("billingProfile"))
            object.billingProfile = $root.BillingProfile.toObject(message.billingProfile, options);
        if (message.userMessageHtml != null && message.hasOwnProperty("userMessageHtml"))
            object.userMessageHtml = message.userMessageHtml;
        return object;
    };

    /**
     * Converts this BillingProfileResponse to JSON.
     * @function toJSON
     * @memberof BillingProfileResponse
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    BillingProfileResponse.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return BillingProfileResponse;
})();

$root.CheckInstrumentResponse = (function() {

    /**
     * Properties of a CheckInstrumentResponse.
     * @exports ICheckInstrumentResponse
     * @interface ICheckInstrumentResponse
     * @property {boolean|null} [userHasValidInstrument] CheckInstrumentResponse userHasValidInstrument
     * @property {boolean|null} [checkoutTokenRequired] CheckInstrumentResponse checkoutTokenRequired
     * @property {Array.<IInstrument>|null} [instrument] CheckInstrumentResponse instrument
     * @property {Array.<IInstrument>|null} [eligibleInstrument] CheckInstrumentResponse eligibleInstrument
     */

    /**
     * Constructs a new CheckInstrumentResponse.
     * @exports CheckInstrumentResponse
     * @classdesc Represents a CheckInstrumentResponse.
     * @implements ICheckInstrumentResponse
     * @constructor
     * @param {ICheckInstrumentResponse=} [properties] Properties to set
     */
    function CheckInstrumentResponse(properties) {
        this.instrument = [];
        this.eligibleInstrument = [];
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * CheckInstrumentResponse userHasValidInstrument.
     * @member {boolean} userHasValidInstrument
     * @memberof CheckInstrumentResponse
     * @instance
     */
    CheckInstrumentResponse.prototype.userHasValidInstrument = false;

    /**
     * CheckInstrumentResponse checkoutTokenRequired.
     * @member {boolean} checkoutTokenRequired
     * @memberof CheckInstrumentResponse
     * @instance
     */
    CheckInstrumentResponse.prototype.checkoutTokenRequired = false;

    /**
     * CheckInstrumentResponse instrument.
     * @member {Array.<IInstrument>} instrument
     * @memberof CheckInstrumentResponse
     * @instance
     */
    CheckInstrumentResponse.prototype.instrument = $util.emptyArray;

    /**
     * CheckInstrumentResponse eligibleInstrument.
     * @member {Array.<IInstrument>} eligibleInstrument
     * @memberof CheckInstrumentResponse
     * @instance
     */
    CheckInstrumentResponse.prototype.eligibleInstrument = $util.emptyArray;

    /**
     * Creates a new CheckInstrumentResponse instance using the specified properties.
     * @function create
     * @memberof CheckInstrumentResponse
     * @static
     * @param {ICheckInstrumentResponse=} [properties] Properties to set
     * @returns {CheckInstrumentResponse} CheckInstrumentResponse instance
     */
    CheckInstrumentResponse.create = function create(properties) {
        return new CheckInstrumentResponse(properties);
    };

    /**
     * Encodes the specified CheckInstrumentResponse message. Does not implicitly {@link CheckInstrumentResponse.verify|verify} messages.
     * @function encode
     * @memberof CheckInstrumentResponse
     * @static
     * @param {ICheckInstrumentResponse} message CheckInstrumentResponse message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    CheckInstrumentResponse.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.userHasValidInstrument != null && Object.hasOwnProperty.call(message, "userHasValidInstrument"))
            writer.uint32(/* id 1, wireType 0 =*/8).bool(message.userHasValidInstrument);
        if (message.checkoutTokenRequired != null && Object.hasOwnProperty.call(message, "checkoutTokenRequired"))
            writer.uint32(/* id 2, wireType 0 =*/16).bool(message.checkoutTokenRequired);
        if (message.instrument != null && message.instrument.length)
            for (var i = 0; i < message.instrument.length; ++i)
                $root.Instrument.encode(message.instrument[i], writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
        if (message.eligibleInstrument != null && message.eligibleInstrument.length)
            for (var i = 0; i < message.eligibleInstrument.length; ++i)
                $root.Instrument.encode(message.eligibleInstrument[i], writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
        return writer;
    };

    /**
     * Encodes the specified CheckInstrumentResponse message, length delimited. Does not implicitly {@link CheckInstrumentResponse.verify|verify} messages.
     * @function encodeDelimited
     * @memberof CheckInstrumentResponse
     * @static
     * @param {ICheckInstrumentResponse} message CheckInstrumentResponse message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    CheckInstrumentResponse.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a CheckInstrumentResponse message from the specified reader or buffer.
     * @function decode
     * @memberof CheckInstrumentResponse
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CheckInstrumentResponse} CheckInstrumentResponse
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CheckInstrumentResponse.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CheckInstrumentResponse();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.userHasValidInstrument = reader.bool();
                break;
            case 2:
                message.checkoutTokenRequired = reader.bool();
                break;
            case 4:
                if (!(message.instrument && message.instrument.length))
                    message.instrument = [];
                message.instrument.push($root.Instrument.decode(reader, reader.uint32()));
                break;
            case 5:
                if (!(message.eligibleInstrument && message.eligibleInstrument.length))
                    message.eligibleInstrument = [];
                message.eligibleInstrument.push($root.Instrument.decode(reader, reader.uint32()));
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a CheckInstrumentResponse message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof CheckInstrumentResponse
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {CheckInstrumentResponse} CheckInstrumentResponse
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CheckInstrumentResponse.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a CheckInstrumentResponse message.
     * @function verify
     * @memberof CheckInstrumentResponse
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    CheckInstrumentResponse.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.userHasValidInstrument != null && message.hasOwnProperty("userHasValidInstrument"))
            if (typeof message.userHasValidInstrument !== "boolean")
                return "userHasValidInstrument: boolean expected";
        if (message.checkoutTokenRequired != null && message.hasOwnProperty("checkoutTokenRequired"))
            if (typeof message.checkoutTokenRequired !== "boolean")
                return "checkoutTokenRequired: boolean expected";
        if (message.instrument != null && message.hasOwnProperty("instrument")) {
            if (!Array.isArray(message.instrument))
                return "instrument: array expected";
            for (var i = 0; i < message.instrument.length; ++i) {
                var error = $root.Instrument.verify(message.instrument[i]);
                if (error)
                    return "instrument." + error;
            }
        }
        if (message.eligibleInstrument != null && message.hasOwnProperty("eligibleInstrument")) {
            if (!Array.isArray(message.eligibleInstrument))
                return "eligibleInstrument: array expected";
            for (var i = 0; i < message.eligibleInstrument.length; ++i) {
                var error = $root.Instrument.verify(message.eligibleInstrument[i]);
                if (error)
                    return "eligibleInstrument." + error;
            }
        }
        return null;
    };

    /**
     * Creates a CheckInstrumentResponse message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof CheckInstrumentResponse
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {CheckInstrumentResponse} CheckInstrumentResponse
     */
    CheckInstrumentResponse.fromObject = function fromObject(object) {
        if (object instanceof $root.CheckInstrumentResponse)
            return object;
        var message = new $root.CheckInstrumentResponse();
        if (object.userHasValidInstrument != null)
            message.userHasValidInstrument = Boolean(object.userHasValidInstrument);
        if (object.checkoutTokenRequired != null)
            message.checkoutTokenRequired = Boolean(object.checkoutTokenRequired);
        if (object.instrument) {
            if (!Array.isArray(object.instrument))
                throw TypeError(".CheckInstrumentResponse.instrument: array expected");
            message.instrument = [];
            for (var i = 0; i < object.instrument.length; ++i) {
                if (typeof object.instrument[i] !== "object")
                    throw TypeError(".CheckInstrumentResponse.instrument: object expected");
                message.instrument[i] = $root.Instrument.fromObject(object.instrument[i]);
            }
        }
        if (object.eligibleInstrument) {
            if (!Array.isArray(object.eligibleInstrument))
                throw TypeError(".CheckInstrumentResponse.eligibleInstrument: array expected");
            message.eligibleInstrument = [];
            for (var i = 0; i < object.eligibleInstrument.length; ++i) {
                if (typeof object.eligibleInstrument[i] !== "object")
                    throw TypeError(".CheckInstrumentResponse.eligibleInstrument: object expected");
                message.eligibleInstrument[i] = $root.Instrument.fromObject(object.eligibleInstrument[i]);
            }
        }
        return message;
    };

    /**
     * Creates a plain object from a CheckInstrumentResponse message. Also converts values to other types if specified.
     * @function toObject
     * @memberof CheckInstrumentResponse
     * @static
     * @param {CheckInstrumentResponse} message CheckInstrumentResponse
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    CheckInstrumentResponse.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        var object = {};
        if (options.arrays || options.defaults) {
            object.instrument = [];
            object.eligibleInstrument = [];
        }
        if (options.defaults) {
            object.userHasValidInstrument = false;
            object.checkoutTokenRequired = false;
        }
        if (message.userHasValidInstrument != null && message.hasOwnProperty("userHasValidInstrument"))
            object.userHasValidInstrument = message.userHasValidInstrument;
        if (message.checkoutTokenRequired != null && message.hasOwnProperty("checkoutTokenRequired"))
            object.checkoutTokenRequired = message.checkoutTokenRequired;
        if (message.instrument && message.instrument.length) {
            object.instrument = [];
            for (var j = 0; j < message.instrument.length; ++j)
                object.instrument[j] = $root.Instrument.toObject(message.instrument[j], options);
        }
        if (message.eligibleInstrument && message.eligibleInstrument.length) {
            object.eligibleInstrument = [];
            for (var j = 0; j < message.eligibleInstrument.length; ++j)
                object.eligibleInstrument[j] = $root.Instrument.toObject(message.eligibleInstrument[j], options);
        }
        return object;
    };

    /**
     * Converts this CheckInstrumentResponse to JSON.
     * @function toJSON
     * @memberof CheckInstrumentResponse
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    CheckInstrumentResponse.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return CheckInstrumentResponse;
})();

$root.InstrumentSetupInfoResponse = (function() {

    /**
     * Properties of an InstrumentSetupInfoResponse.
     * @exports IInstrumentSetupInfoResponse
     * @interface IInstrumentSetupInfoResponse
     * @property {Array.<IInstrumentSetupInfo>|null} [setupInfo] InstrumentSetupInfoResponse setupInfo
     * @property {boolean|null} [checkoutTokenRequired] InstrumentSetupInfoResponse checkoutTokenRequired
     */

    /**
     * Constructs a new InstrumentSetupInfoResponse.
     * @exports InstrumentSetupInfoResponse
     * @classdesc Represents an InstrumentSetupInfoResponse.
     * @implements IInstrumentSetupInfoResponse
     * @constructor
     * @param {IInstrumentSetupInfoResponse=} [properties] Properties to set
     */
    function InstrumentSetupInfoResponse(properties) {
        this.setupInfo = [];
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * InstrumentSetupInfoResponse setupInfo.
     * @member {Array.<IInstrumentSetupInfo>} setupInfo
     * @memberof InstrumentSetupInfoResponse
     * @instance
     */
    InstrumentSetupInfoResponse.prototype.setupInfo = $util.emptyArray;

    /**
     * InstrumentSetupInfoResponse checkoutTokenRequired.
     * @member {boolean} checkoutTokenRequired
     * @memberof InstrumentSetupInfoResponse
     * @instance
     */
    InstrumentSetupInfoResponse.prototype.checkoutTokenRequired = false;

    /**
     * Creates a new InstrumentSetupInfoResponse instance using the specified properties.
     * @function create
     * @memberof InstrumentSetupInfoResponse
     * @static
     * @param {IInstrumentSetupInfoResponse=} [properties] Properties to set
     * @returns {InstrumentSetupInfoResponse} InstrumentSetupInfoResponse instance
     */
    InstrumentSetupInfoResponse.create = function create(properties) {
        return new InstrumentSetupInfoResponse(properties);
    };

    /**
     * Encodes the specified InstrumentSetupInfoResponse message. Does not implicitly {@link InstrumentSetupInfoResponse.verify|verify} messages.
     * @function encode
     * @memberof InstrumentSetupInfoResponse
     * @static
     * @param {IInstrumentSetupInfoResponse} message InstrumentSetupInfoResponse message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    InstrumentSetupInfoResponse.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.setupInfo != null && message.setupInfo.length)
            for (var i = 0; i < message.setupInfo.length; ++i)
                $root.InstrumentSetupInfo.encode(message.setupInfo[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
        if (message.checkoutTokenRequired != null && Object.hasOwnProperty.call(message, "checkoutTokenRequired"))
            writer.uint32(/* id 2, wireType 0 =*/16).bool(message.checkoutTokenRequired);
        return writer;
    };

    /**
     * Encodes the specified InstrumentSetupInfoResponse message, length delimited. Does not implicitly {@link InstrumentSetupInfoResponse.verify|verify} messages.
     * @function encodeDelimited
     * @memberof InstrumentSetupInfoResponse
     * @static
     * @param {IInstrumentSetupInfoResponse} message InstrumentSetupInfoResponse message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    InstrumentSetupInfoResponse.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes an InstrumentSetupInfoResponse message from the specified reader or buffer.
     * @function decode
     * @memberof InstrumentSetupInfoResponse
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {InstrumentSetupInfoResponse} InstrumentSetupInfoResponse
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    InstrumentSetupInfoResponse.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.InstrumentSetupInfoResponse();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                if (!(message.setupInfo && message.setupInfo.length))
                    message.setupInfo = [];
                message.setupInfo.push($root.InstrumentSetupInfo.decode(reader, reader.uint32()));
                break;
            case 2:
                message.checkoutTokenRequired = reader.bool();
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes an InstrumentSetupInfoResponse message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof InstrumentSetupInfoResponse
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {InstrumentSetupInfoResponse} InstrumentSetupInfoResponse
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    InstrumentSetupInfoResponse.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies an InstrumentSetupInfoResponse message.
     * @function verify
     * @memberof InstrumentSetupInfoResponse
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    InstrumentSetupInfoResponse.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.setupInfo != null && message.hasOwnProperty("setupInfo")) {
            if (!Array.isArray(message.setupInfo))
                return "setupInfo: array expected";
            for (var i = 0; i < message.setupInfo.length; ++i) {
                var error = $root.InstrumentSetupInfo.verify(message.setupInfo[i]);
                if (error)
                    return "setupInfo." + error;
            }
        }
        if (message.checkoutTokenRequired != null && message.hasOwnProperty("checkoutTokenRequired"))
            if (typeof message.checkoutTokenRequired !== "boolean")
                return "checkoutTokenRequired: boolean expected";
        return null;
    };

    /**
     * Creates an InstrumentSetupInfoResponse message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof InstrumentSetupInfoResponse
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {InstrumentSetupInfoResponse} InstrumentSetupInfoResponse
     */
    InstrumentSetupInfoResponse.fromObject = function fromObject(object) {
        if (object instanceof $root.InstrumentSetupInfoResponse)
            return object;
        var message = new $root.InstrumentSetupInfoResponse();
        if (object.setupInfo) {
            if (!Array.isArray(object.setupInfo))
                throw TypeError(".InstrumentSetupInfoResponse.setupInfo: array expected");
            message.setupInfo = [];
            for (var i = 0; i < object.setupInfo.length; ++i) {
                if (typeof object.setupInfo[i] !== "object")
                    throw TypeError(".InstrumentSetupInfoResponse.setupInfo: object expected");
                message.setupInfo[i] = $root.InstrumentSetupInfo.fromObject(object.setupInfo[i]);
            }
        }
        if (object.checkoutTokenRequired != null)
            message.checkoutTokenRequired = Boolean(object.checkoutTokenRequired);
        return message;
    };

    /**
     * Creates a plain object from an InstrumentSetupInfoResponse message. Also converts values to other types if specified.
     * @function toObject
     * @memberof InstrumentSetupInfoResponse
     * @static
     * @param {InstrumentSetupInfoResponse} message InstrumentSetupInfoResponse
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    InstrumentSetupInfoResponse.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        var object = {};
        if (options.arrays || options.defaults)
            object.setupInfo = [];
        if (options.defaults)
            object.checkoutTokenRequired = false;
        if (message.setupInfo && message.setupInfo.length) {
            object.setupInfo = [];
            for (var j = 0; j < message.setupInfo.length; ++j)
                object.setupInfo[j] = $root.InstrumentSetupInfo.toObject(message.setupInfo[j], options);
        }
        if (message.checkoutTokenRequired != null && message.hasOwnProperty("checkoutTokenRequired"))
            object.checkoutTokenRequired = message.checkoutTokenRequired;
        return object;
    };

    /**
     * Converts this InstrumentSetupInfoResponse to JSON.
     * @function toJSON
     * @memberof InstrumentSetupInfoResponse
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    InstrumentSetupInfoResponse.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return InstrumentSetupInfoResponse;
})();

$root.RedeemGiftCardRequest = (function() {

    /**
     * Properties of a RedeemGiftCardRequest.
     * @exports IRedeemGiftCardRequest
     * @interface IRedeemGiftCardRequest
     * @property {string|null} [giftCardPin] RedeemGiftCardRequest giftCardPin
     * @property {IAddress|null} [address] RedeemGiftCardRequest address
     * @property {Array.<string>|null} [acceptedLegalDocumentId] RedeemGiftCardRequest acceptedLegalDocumentId
     * @property {string|null} [checkoutToken] RedeemGiftCardRequest checkoutToken
     */

    /**
     * Constructs a new RedeemGiftCardRequest.
     * @exports RedeemGiftCardRequest
     * @classdesc Represents a RedeemGiftCardRequest.
     * @implements IRedeemGiftCardRequest
     * @constructor
     * @param {IRedeemGiftCardRequest=} [properties] Properties to set
     */
    function RedeemGiftCardRequest(properties) {
        this.acceptedLegalDocumentId = [];
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * RedeemGiftCardRequest giftCardPin.
     * @member {string} giftCardPin
     * @memberof RedeemGiftCardRequest
     * @instance
     */
    RedeemGiftCardRequest.prototype.giftCardPin = "";

    /**
     * RedeemGiftCardRequest address.
     * @member {IAddress|null|undefined} address
     * @memberof RedeemGiftCardRequest
     * @instance
     */
    RedeemGiftCardRequest.prototype.address = null;

    /**
     * RedeemGiftCardRequest acceptedLegalDocumentId.
     * @member {Array.<string>} acceptedLegalDocumentId
     * @memberof RedeemGiftCardRequest
     * @instance
     */
    RedeemGiftCardRequest.prototype.acceptedLegalDocumentId = $util.emptyArray;

    /**
     * RedeemGiftCardRequest checkoutToken.
     * @member {string} checkoutToken
     * @memberof RedeemGiftCardRequest
     * @instance
     */
    RedeemGiftCardRequest.prototype.checkoutToken = "";

    /**
     * Creates a new RedeemGiftCardRequest instance using the specified properties.
     * @function create
     * @memberof RedeemGiftCardRequest
     * @static
     * @param {IRedeemGiftCardRequest=} [properties] Properties to set
     * @returns {RedeemGiftCardRequest} RedeemGiftCardRequest instance
     */
    RedeemGiftCardRequest.create = function create(properties) {
        return new RedeemGiftCardRequest(properties);
    };

    /**
     * Encodes the specified RedeemGiftCardRequest message. Does not implicitly {@link RedeemGiftCardRequest.verify|verify} messages.
     * @function encode
     * @memberof RedeemGiftCardRequest
     * @static
     * @param {IRedeemGiftCardRequest} message RedeemGiftCardRequest message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    RedeemGiftCardRequest.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.giftCardPin != null && Object.hasOwnProperty.call(message, "giftCardPin"))
            writer.uint32(/* id 1, wireType 2 =*/10).string(message.giftCardPin);
        if (message.address != null && Object.hasOwnProperty.call(message, "address"))
            $root.Address.encode(message.address, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
        if (message.acceptedLegalDocumentId != null && message.acceptedLegalDocumentId.length)
            for (var i = 0; i < message.acceptedLegalDocumentId.length; ++i)
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.acceptedLegalDocumentId[i]);
        if (message.checkoutToken != null && Object.hasOwnProperty.call(message, "checkoutToken"))
            writer.uint32(/* id 4, wireType 2 =*/34).string(message.checkoutToken);
        return writer;
    };

    /**
     * Encodes the specified RedeemGiftCardRequest message, length delimited. Does not implicitly {@link RedeemGiftCardRequest.verify|verify} messages.
     * @function encodeDelimited
     * @memberof RedeemGiftCardRequest
     * @static
     * @param {IRedeemGiftCardRequest} message RedeemGiftCardRequest message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    RedeemGiftCardRequest.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a RedeemGiftCardRequest message from the specified reader or buffer.
     * @function decode
     * @memberof RedeemGiftCardRequest
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {RedeemGiftCardRequest} RedeemGiftCardRequest
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    RedeemGiftCardRequest.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.RedeemGiftCardRequest();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.giftCardPin = reader.string();
                break;
            case 2:
                message.address = $root.Address.decode(reader, reader.uint32());
                break;
            case 3:
                if (!(message.acceptedLegalDocumentId && message.acceptedLegalDocumentId.length))
                    message.acceptedLegalDocumentId = [];
                message.acceptedLegalDocumentId.push(reader.string());
                break;
            case 4:
                message.checkoutToken = reader.string();
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a RedeemGiftCardRequest message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof RedeemGiftCardRequest
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {RedeemGiftCardRequest} RedeemGiftCardRequest
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    RedeemGiftCardRequest.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a RedeemGiftCardRequest message.
     * @function verify
     * @memberof RedeemGiftCardRequest
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    RedeemGiftCardRequest.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.giftCardPin != null && message.hasOwnProperty("giftCardPin"))
            if (!$util.isString(message.giftCardPin))
                return "giftCardPin: string expected";
        if (message.address != null && message.hasOwnProperty("address")) {
            var error = $root.Address.verify(message.address);
            if (error)
                return "address." + error;
        }
        if (message.acceptedLegalDocumentId != null && message.hasOwnProperty("acceptedLegalDocumentId")) {
            if (!Array.isArray(message.acceptedLegalDocumentId))
                return "acceptedLegalDocumentId: array expected";
            for (var i = 0; i < message.acceptedLegalDocumentId.length; ++i)
                if (!$util.isString(message.acceptedLegalDocumentId[i]))
                    return "acceptedLegalDocumentId: string[] expected";
        }
        if (message.checkoutToken != null && message.hasOwnProperty("checkoutToken"))
            if (!$util.isString(message.checkoutToken))
                return "checkoutToken: string expected";
        return null;
    };

    /**
     * Creates a RedeemGiftCardRequest message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof RedeemGiftCardRequest
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {RedeemGiftCardRequest} RedeemGiftCardRequest
     */
    RedeemGiftCardRequest.fromObject = function fromObject(object) {
        if (object instanceof $root.RedeemGiftCardRequest)
            return object;
        var message = new $root.RedeemGiftCardRequest();
        if (object.giftCardPin != null)
            message.giftCardPin = String(object.giftCardPin);
        if (object.address != null) {
            if (typeof object.address !== "object")
                throw TypeError(".RedeemGiftCardRequest.address: object expected");
            message.address = $root.Address.fromObject(object.address);
        }
        if (object.acceptedLegalDocumentId) {
            if (!Array.isArray(object.acceptedLegalDocumentId))
                throw TypeError(".RedeemGiftCardRequest.acceptedLegalDocumentId: array expected");
            message.acceptedLegalDocumentId = [];
            for (var i = 0; i < object.acceptedLegalDocumentId.length; ++i)
                message.acceptedLegalDocumentId[i] = String(object.acceptedLegalDocumentId[i]);
        }
        if (object.checkoutToken != null)
            message.checkoutToken = String(object.checkoutToken);
        return message;
    };

    /**
     * Creates a plain object from a RedeemGiftCardRequest message. Also converts values to other types if specified.
     * @function toObject
     * @memberof RedeemGiftCardRequest
     * @static
     * @param {RedeemGiftCardRequest} message RedeemGiftCardRequest
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    RedeemGiftCardRequest.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        var object = {};
        if (options.arrays || options.defaults)
            object.acceptedLegalDocumentId = [];
        if (options.defaults) {
            object.giftCardPin = "";
            object.address = null;
            object.checkoutToken = "";
        }
        if (message.giftCardPin != null && message.hasOwnProperty("giftCardPin"))
            object.giftCardPin = message.giftCardPin;
        if (message.address != null && message.hasOwnProperty("address"))
            object.address = $root.Address.toObject(message.address, options);
        if (message.acceptedLegalDocumentId && message.acceptedLegalDocumentId.length) {
            object.acceptedLegalDocumentId = [];
            for (var j = 0; j < message.acceptedLegalDocumentId.length; ++j)
                object.acceptedLegalDocumentId[j] = message.acceptedLegalDocumentId[j];
        }
        if (message.checkoutToken != null && message.hasOwnProperty("checkoutToken"))
            object.checkoutToken = message.checkoutToken;
        return object;
    };

    /**
     * Converts this RedeemGiftCardRequest to JSON.
     * @function toJSON
     * @memberof RedeemGiftCardRequest
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    RedeemGiftCardRequest.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return RedeemGiftCardRequest;
})();

$root.RedeemGiftCardResponse = (function() {

    /**
     * Properties of a RedeemGiftCardResponse.
     * @exports IRedeemGiftCardResponse
     * @interface IRedeemGiftCardResponse
     * @property {number|null} [result] RedeemGiftCardResponse result
     * @property {string|null} [userMessageHtml] RedeemGiftCardResponse userMessageHtml
     * @property {string|null} [balanceHtml] RedeemGiftCardResponse balanceHtml
     * @property {IAddressChallenge|null} [addressChallenge] RedeemGiftCardResponse addressChallenge
     * @property {boolean|null} [checkoutTokenRequired] RedeemGiftCardResponse checkoutTokenRequired
     */

    /**
     * Constructs a new RedeemGiftCardResponse.
     * @exports RedeemGiftCardResponse
     * @classdesc Represents a RedeemGiftCardResponse.
     * @implements IRedeemGiftCardResponse
     * @constructor
     * @param {IRedeemGiftCardResponse=} [properties] Properties to set
     */
    function RedeemGiftCardResponse(properties) {
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * RedeemGiftCardResponse result.
     * @member {number} result
     * @memberof RedeemGiftCardResponse
     * @instance
     */
    RedeemGiftCardResponse.prototype.result = 0;

    /**
     * RedeemGiftCardResponse userMessageHtml.
     * @member {string} userMessageHtml
     * @memberof RedeemGiftCardResponse
     * @instance
     */
    RedeemGiftCardResponse.prototype.userMessageHtml = "";

    /**
     * RedeemGiftCardResponse balanceHtml.
     * @member {string} balanceHtml
     * @memberof RedeemGiftCardResponse
     * @instance
     */
    RedeemGiftCardResponse.prototype.balanceHtml = "";

    /**
     * RedeemGiftCardResponse addressChallenge.
     * @member {IAddressChallenge|null|undefined} addressChallenge
     * @memberof RedeemGiftCardResponse
     * @instance
     */
    RedeemGiftCardResponse.prototype.addressChallenge = null;

    /**
     * RedeemGiftCardResponse checkoutTokenRequired.
     * @member {boolean} checkoutTokenRequired
     * @memberof RedeemGiftCardResponse
     * @instance
     */
    RedeemGiftCardResponse.prototype.checkoutTokenRequired = false;

    /**
     * Creates a new RedeemGiftCardResponse instance using the specified properties.
     * @function create
     * @memberof RedeemGiftCardResponse
     * @static
     * @param {IRedeemGiftCardResponse=} [properties] Properties to set
     * @returns {RedeemGiftCardResponse} RedeemGiftCardResponse instance
     */
    RedeemGiftCardResponse.create = function create(properties) {
        return new RedeemGiftCardResponse(properties);
    };

    /**
     * Encodes the specified RedeemGiftCardResponse message. Does not implicitly {@link RedeemGiftCardResponse.verify|verify} messages.
     * @function encode
     * @memberof RedeemGiftCardResponse
     * @static
     * @param {IRedeemGiftCardResponse} message RedeemGiftCardResponse message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    RedeemGiftCardResponse.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.result != null && Object.hasOwnProperty.call(message, "result"))
            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.result);
        if (message.userMessageHtml != null && Object.hasOwnProperty.call(message, "userMessageHtml"))
            writer.uint32(/* id 2, wireType 2 =*/18).string(message.userMessageHtml);
        if (message.balanceHtml != null && Object.hasOwnProperty.call(message, "balanceHtml"))
            writer.uint32(/* id 3, wireType 2 =*/26).string(message.balanceHtml);
        if (message.addressChallenge != null && Object.hasOwnProperty.call(message, "addressChallenge"))
            $root.AddressChallenge.encode(message.addressChallenge, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
        if (message.checkoutTokenRequired != null && Object.hasOwnProperty.call(message, "checkoutTokenRequired"))
            writer.uint32(/* id 5, wireType 0 =*/40).bool(message.checkoutTokenRequired);
        return writer;
    };

    /**
     * Encodes the specified RedeemGiftCardResponse message, length delimited. Does not implicitly {@link RedeemGiftCardResponse.verify|verify} messages.
     * @function encodeDelimited
     * @memberof RedeemGiftCardResponse
     * @static
     * @param {IRedeemGiftCardResponse} message RedeemGiftCardResponse message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    RedeemGiftCardResponse.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a RedeemGiftCardResponse message from the specified reader or buffer.
     * @function decode
     * @memberof RedeemGiftCardResponse
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {RedeemGiftCardResponse} RedeemGiftCardResponse
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    RedeemGiftCardResponse.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.RedeemGiftCardResponse();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.result = reader.int32();
                break;
            case 2:
                message.userMessageHtml = reader.string();
                break;
            case 3:
                message.balanceHtml = reader.string();
                break;
            case 4:
                message.addressChallenge = $root.AddressChallenge.decode(reader, reader.uint32());
                break;
            case 5:
                message.checkoutTokenRequired = reader.bool();
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a RedeemGiftCardResponse message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof RedeemGiftCardResponse
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {RedeemGiftCardResponse} RedeemGiftCardResponse
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    RedeemGiftCardResponse.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a RedeemGiftCardResponse message.
     * @function verify
     * @memberof RedeemGiftCardResponse
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    RedeemGiftCardResponse.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.result != null && message.hasOwnProperty("result"))
            if (!$util.isInteger(message.result))
                return "result: integer expected";
        if (message.userMessageHtml != null && message.hasOwnProperty("userMessageHtml"))
            if (!$util.isString(message.userMessageHtml))
                return "userMessageHtml: string expected";
        if (message.balanceHtml != null && message.hasOwnProperty("balanceHtml"))
            if (!$util.isString(message.balanceHtml))
                return "balanceHtml: string expected";
        if (message.addressChallenge != null && message.hasOwnProperty("addressChallenge")) {
            var error = $root.AddressChallenge.verify(message.addressChallenge);
            if (error)
                return "addressChallenge." + error;
        }
        if (message.checkoutTokenRequired != null && message.hasOwnProperty("checkoutTokenRequired"))
            if (typeof message.checkoutTokenRequired !== "boolean")
                return "checkoutTokenRequired: boolean expected";
        return null;
    };

    /**
     * Creates a RedeemGiftCardResponse message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof RedeemGiftCardResponse
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {RedeemGiftCardResponse} RedeemGiftCardResponse
     */
    RedeemGiftCardResponse.fromObject = function fromObject(object) {
        if (object instanceof $root.RedeemGiftCardResponse)
            return object;
        var message = new $root.RedeemGiftCardResponse();
        if (object.result != null)
            message.result = object.result | 0;
        if (object.userMessageHtml != null)
            message.userMessageHtml = String(object.userMessageHtml);
        if (object.balanceHtml != null)
            message.balanceHtml = String(object.balanceHtml);
        if (object.addressChallenge != null) {
            if (typeof object.addressChallenge !== "object")
                throw TypeError(".RedeemGiftCardResponse.addressChallenge: object expected");
            message.addressChallenge = $root.AddressChallenge.fromObject(object.addressChallenge);
        }
        if (object.checkoutTokenRequired != null)
            message.checkoutTokenRequired = Boolean(object.checkoutTokenRequired);
        return message;
    };

    /**
     * Creates a plain object from a RedeemGiftCardResponse message. Also converts values to other types if specified.
     * @function toObject
     * @memberof RedeemGiftCardResponse
     * @static
     * @param {RedeemGiftCardResponse} message RedeemGiftCardResponse
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    RedeemGiftCardResponse.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        var object = {};
        if (options.defaults) {
            object.result = 0;
            object.userMessageHtml = "";
            object.balanceHtml = "";
            object.addressChallenge = null;
            object.checkoutTokenRequired = false;
        }
        if (message.result != null && message.hasOwnProperty("result"))
            object.result = message.result;
        if (message.userMessageHtml != null && message.hasOwnProperty("userMessageHtml"))
            object.userMessageHtml = message.userMessageHtml;
        if (message.balanceHtml != null && message.hasOwnProperty("balanceHtml"))
            object.balanceHtml = message.balanceHtml;
        if (message.addressChallenge != null && message.hasOwnProperty("addressChallenge"))
            object.addressChallenge = $root.AddressChallenge.toObject(message.addressChallenge, options);
        if (message.checkoutTokenRequired != null && message.hasOwnProperty("checkoutTokenRequired"))
            object.checkoutTokenRequired = message.checkoutTokenRequired;
        return object;
    };

    /**
     * Converts this RedeemGiftCardResponse to JSON.
     * @function toJSON
     * @memberof RedeemGiftCardResponse
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    RedeemGiftCardResponse.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return RedeemGiftCardResponse;
})();

$root.UpdateInstrumentRequest = (function() {

    /**
     * Properties of an UpdateInstrumentRequest.
     * @exports IUpdateInstrumentRequest
     * @interface IUpdateInstrumentRequest
     * @property {IInstrument|null} [instrument] UpdateInstrumentRequest instrument
     * @property {string|null} [checkoutToken] UpdateInstrumentRequest checkoutToken
     */

    /**
     * Constructs a new UpdateInstrumentRequest.
     * @exports UpdateInstrumentRequest
     * @classdesc Represents an UpdateInstrumentRequest.
     * @implements IUpdateInstrumentRequest
     * @constructor
     * @param {IUpdateInstrumentRequest=} [properties] Properties to set
     */
    function UpdateInstrumentRequest(properties) {
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * UpdateInstrumentRequest instrument.
     * @member {IInstrument|null|undefined} instrument
     * @memberof UpdateInstrumentRequest
     * @instance
     */
    UpdateInstrumentRequest.prototype.instrument = null;

    /**
     * UpdateInstrumentRequest checkoutToken.
     * @member {string} checkoutToken
     * @memberof UpdateInstrumentRequest
     * @instance
     */
    UpdateInstrumentRequest.prototype.checkoutToken = "";

    /**
     * Creates a new UpdateInstrumentRequest instance using the specified properties.
     * @function create
     * @memberof UpdateInstrumentRequest
     * @static
     * @param {IUpdateInstrumentRequest=} [properties] Properties to set
     * @returns {UpdateInstrumentRequest} UpdateInstrumentRequest instance
     */
    UpdateInstrumentRequest.create = function create(properties) {
        return new UpdateInstrumentRequest(properties);
    };

    /**
     * Encodes the specified UpdateInstrumentRequest message. Does not implicitly {@link UpdateInstrumentRequest.verify|verify} messages.
     * @function encode
     * @memberof UpdateInstrumentRequest
     * @static
     * @param {IUpdateInstrumentRequest} message UpdateInstrumentRequest message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    UpdateInstrumentRequest.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.instrument != null && Object.hasOwnProperty.call(message, "instrument"))
            $root.Instrument.encode(message.instrument, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
        if (message.checkoutToken != null && Object.hasOwnProperty.call(message, "checkoutToken"))
            writer.uint32(/* id 2, wireType 2 =*/18).string(message.checkoutToken);
        return writer;
    };

    /**
     * Encodes the specified UpdateInstrumentRequest message, length delimited. Does not implicitly {@link UpdateInstrumentRequest.verify|verify} messages.
     * @function encodeDelimited
     * @memberof UpdateInstrumentRequest
     * @static
     * @param {IUpdateInstrumentRequest} message UpdateInstrumentRequest message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    UpdateInstrumentRequest.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes an UpdateInstrumentRequest message from the specified reader or buffer.
     * @function decode
     * @memberof UpdateInstrumentRequest
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {UpdateInstrumentRequest} UpdateInstrumentRequest
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    UpdateInstrumentRequest.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.UpdateInstrumentRequest();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.instrument = $root.Instrument.decode(reader, reader.uint32());
                break;
            case 2:
                message.checkoutToken = reader.string();
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes an UpdateInstrumentRequest message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof UpdateInstrumentRequest
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {UpdateInstrumentRequest} UpdateInstrumentRequest
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    UpdateInstrumentRequest.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies an UpdateInstrumentRequest message.
     * @function verify
     * @memberof UpdateInstrumentRequest
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    UpdateInstrumentRequest.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.instrument != null && message.hasOwnProperty("instrument")) {
            var error = $root.Instrument.verify(message.instrument);
            if (error)
                return "instrument." + error;
        }
        if (message.checkoutToken != null && message.hasOwnProperty("checkoutToken"))
            if (!$util.isString(message.checkoutToken))
                return "checkoutToken: string expected";
        return null;
    };

    /**
     * Creates an UpdateInstrumentRequest message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof UpdateInstrumentRequest
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {UpdateInstrumentRequest} UpdateInstrumentRequest
     */
    UpdateInstrumentRequest.fromObject = function fromObject(object) {
        if (object instanceof $root.UpdateInstrumentRequest)
            return object;
        var message = new $root.UpdateInstrumentRequest();
        if (object.instrument != null) {
            if (typeof object.instrument !== "object")
                throw TypeError(".UpdateInstrumentRequest.instrument: object expected");
            message.instrument = $root.Instrument.fromObject(object.instrument);
        }
        if (object.checkoutToken != null)
            message.checkoutToken = String(object.checkoutToken);
        return message;
    };

    /**
     * Creates a plain object from an UpdateInstrumentRequest message. Also converts values to other types if specified.
     * @function toObject
     * @memberof UpdateInstrumentRequest
     * @static
     * @param {UpdateInstrumentRequest} message UpdateInstrumentRequest
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    UpdateInstrumentRequest.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        var object = {};
        if (options.defaults) {
            object.instrument = null;
            object.checkoutToken = "";
        }
        if (message.instrument != null && message.hasOwnProperty("instrument"))
            object.instrument = $root.Instrument.toObject(message.instrument, options);
        if (message.checkoutToken != null && message.hasOwnProperty("checkoutToken"))
            object.checkoutToken = message.checkoutToken;
        return object;
    };

    /**
     * Converts this UpdateInstrumentRequest to JSON.
     * @function toJSON
     * @memberof UpdateInstrumentRequest
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    UpdateInstrumentRequest.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return UpdateInstrumentRequest;
})();

$root.UpdateInstrumentResponse = (function() {

    /**
     * Properties of an UpdateInstrumentResponse.
     * @exports IUpdateInstrumentResponse
     * @interface IUpdateInstrumentResponse
     * @property {number|null} [result] UpdateInstrumentResponse result
     * @property {string|null} [instrumentId] UpdateInstrumentResponse instrumentId
     * @property {string|null} [userMessageHtml] UpdateInstrumentResponse userMessageHtml
     * @property {Array.<IInputValidationError>|null} [errorInputField] UpdateInstrumentResponse errorInputField
     * @property {boolean|null} [checkoutTokenRequired] UpdateInstrumentResponse checkoutTokenRequired
     * @property {IRedeemedPromoOffer|null} [redeemedOffer] UpdateInstrumentResponse redeemedOffer
     */

    /**
     * Constructs a new UpdateInstrumentResponse.
     * @exports UpdateInstrumentResponse
     * @classdesc Represents an UpdateInstrumentResponse.
     * @implements IUpdateInstrumentResponse
     * @constructor
     * @param {IUpdateInstrumentResponse=} [properties] Properties to set
     */
    function UpdateInstrumentResponse(properties) {
        this.errorInputField = [];
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * UpdateInstrumentResponse result.
     * @member {number} result
     * @memberof UpdateInstrumentResponse
     * @instance
     */
    UpdateInstrumentResponse.prototype.result = 0;

    /**
     * UpdateInstrumentResponse instrumentId.
     * @member {string} instrumentId
     * @memberof UpdateInstrumentResponse
     * @instance
     */
    UpdateInstrumentResponse.prototype.instrumentId = "";

    /**
     * UpdateInstrumentResponse userMessageHtml.
     * @member {string} userMessageHtml
     * @memberof UpdateInstrumentResponse
     * @instance
     */
    UpdateInstrumentResponse.prototype.userMessageHtml = "";

    /**
     * UpdateInstrumentResponse errorInputField.
     * @member {Array.<IInputValidationError>} errorInputField
     * @memberof UpdateInstrumentResponse
     * @instance
     */
    UpdateInstrumentResponse.prototype.errorInputField = $util.emptyArray;

    /**
     * UpdateInstrumentResponse checkoutTokenRequired.
     * @member {boolean} checkoutTokenRequired
     * @memberof UpdateInstrumentResponse
     * @instance
     */
    UpdateInstrumentResponse.prototype.checkoutTokenRequired = false;

    /**
     * UpdateInstrumentResponse redeemedOffer.
     * @member {IRedeemedPromoOffer|null|undefined} redeemedOffer
     * @memberof UpdateInstrumentResponse
     * @instance
     */
    UpdateInstrumentResponse.prototype.redeemedOffer = null;

    /**
     * Creates a new UpdateInstrumentResponse instance using the specified properties.
     * @function create
     * @memberof UpdateInstrumentResponse
     * @static
     * @param {IUpdateInstrumentResponse=} [properties] Properties to set
     * @returns {UpdateInstrumentResponse} UpdateInstrumentResponse instance
     */
    UpdateInstrumentResponse.create = function create(properties) {
        return new UpdateInstrumentResponse(properties);
    };

    /**
     * Encodes the specified UpdateInstrumentResponse message. Does not implicitly {@link UpdateInstrumentResponse.verify|verify} messages.
     * @function encode
     * @memberof UpdateInstrumentResponse
     * @static
     * @param {IUpdateInstrumentResponse} message UpdateInstrumentResponse message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    UpdateInstrumentResponse.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.result != null && Object.hasOwnProperty.call(message, "result"))
            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.result);
        if (message.instrumentId != null && Object.hasOwnProperty.call(message, "instrumentId"))
            writer.uint32(/* id 2, wireType 2 =*/18).string(message.instrumentId);
        if (message.userMessageHtml != null && Object.hasOwnProperty.call(message, "userMessageHtml"))
            writer.uint32(/* id 3, wireType 2 =*/26).string(message.userMessageHtml);
        if (message.errorInputField != null && message.errorInputField.length)
            for (var i = 0; i < message.errorInputField.length; ++i)
                $root.InputValidationError.encode(message.errorInputField[i], writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
        if (message.checkoutTokenRequired != null && Object.hasOwnProperty.call(message, "checkoutTokenRequired"))
            writer.uint32(/* id 5, wireType 0 =*/40).bool(message.checkoutTokenRequired);
        if (message.redeemedOffer != null && Object.hasOwnProperty.call(message, "redeemedOffer"))
            $root.RedeemedPromoOffer.encode(message.redeemedOffer, writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
        return writer;
    };

    /**
     * Encodes the specified UpdateInstrumentResponse message, length delimited. Does not implicitly {@link UpdateInstrumentResponse.verify|verify} messages.
     * @function encodeDelimited
     * @memberof UpdateInstrumentResponse
     * @static
     * @param {IUpdateInstrumentResponse} message UpdateInstrumentResponse message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    UpdateInstrumentResponse.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes an UpdateInstrumentResponse message from the specified reader or buffer.
     * @function decode
     * @memberof UpdateInstrumentResponse
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {UpdateInstrumentResponse} UpdateInstrumentResponse
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    UpdateInstrumentResponse.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.UpdateInstrumentResponse();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.result = reader.int32();
                break;
            case 2:
                message.instrumentId = reader.string();
                break;
            case 3:
                message.userMessageHtml = reader.string();
                break;
            case 4:
                if (!(message.errorInputField && message.errorInputField.length))
                    message.errorInputField = [];
                message.errorInputField.push($root.InputValidationError.decode(reader, reader.uint32()));
                break;
            case 5:
                message.checkoutTokenRequired = reader.bool();
                break;
            case 6:
                message.redeemedOffer = $root.RedeemedPromoOffer.decode(reader, reader.uint32());
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes an UpdateInstrumentResponse message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof UpdateInstrumentResponse
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {UpdateInstrumentResponse} UpdateInstrumentResponse
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    UpdateInstrumentResponse.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies an UpdateInstrumentResponse message.
     * @function verify
     * @memberof UpdateInstrumentResponse
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    UpdateInstrumentResponse.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.result != null && message.hasOwnProperty("result"))
            if (!$util.isInteger(message.result))
                return "result: integer expected";
        if (message.instrumentId != null && message.hasOwnProperty("instrumentId"))
            if (!$util.isString(message.instrumentId))
                return "instrumentId: string expected";
        if (message.userMessageHtml != null && message.hasOwnProperty("userMessageHtml"))
            if (!$util.isString(message.userMessageHtml))
                return "userMessageHtml: string expected";
        if (message.errorInputField != null && message.hasOwnProperty("errorInputField")) {
            if (!Array.isArray(message.errorInputField))
                return "errorInputField: array expected";
            for (var i = 0; i < message.errorInputField.length; ++i) {
                var error = $root.InputValidationError.verify(message.errorInputField[i]);
                if (error)
                    return "errorInputField." + error;
            }
        }
        if (message.checkoutTokenRequired != null && message.hasOwnProperty("checkoutTokenRequired"))
            if (typeof message.checkoutTokenRequired !== "boolean")
                return "checkoutTokenRequired: boolean expected";
        if (message.redeemedOffer != null && message.hasOwnProperty("redeemedOffer")) {
            var error = $root.RedeemedPromoOffer.verify(message.redeemedOffer);
            if (error)
                return "redeemedOffer." + error;
        }
        return null;
    };

    /**
     * Creates an UpdateInstrumentResponse message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof UpdateInstrumentResponse
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {UpdateInstrumentResponse} UpdateInstrumentResponse
     */
    UpdateInstrumentResponse.fromObject = function fromObject(object) {
        if (object instanceof $root.UpdateInstrumentResponse)
            return object;
        var message = new $root.UpdateInstrumentResponse();
        if (object.result != null)
            message.result = object.result | 0;
        if (object.instrumentId != null)
            message.instrumentId = String(object.instrumentId);
        if (object.userMessageHtml != null)
            message.userMessageHtml = String(object.userMessageHtml);
        if (object.errorInputField) {
            if (!Array.isArray(object.errorInputField))
                throw TypeError(".UpdateInstrumentResponse.errorInputField: array expected");
            message.errorInputField = [];
            for (var i = 0; i < object.errorInputField.length; ++i) {
                if (typeof object.errorInputField[i] !== "object")
                    throw TypeError(".UpdateInstrumentResponse.errorInputField: object expected");
                message.errorInputField[i] = $root.InputValidationError.fromObject(object.errorInputField[i]);
            }
        }
        if (object.checkoutTokenRequired != null)
            message.checkoutTokenRequired = Boolean(object.checkoutTokenRequired);
        if (object.redeemedOffer != null) {
            if (typeof object.redeemedOffer !== "object")
                throw TypeError(".UpdateInstrumentResponse.redeemedOffer: object expected");
            message.redeemedOffer = $root.RedeemedPromoOffer.fromObject(object.redeemedOffer);
        }
        return message;
    };

    /**
     * Creates a plain object from an UpdateInstrumentResponse message. Also converts values to other types if specified.
     * @function toObject
     * @memberof UpdateInstrumentResponse
     * @static
     * @param {UpdateInstrumentResponse} message UpdateInstrumentResponse
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    UpdateInstrumentResponse.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        var object = {};
        if (options.arrays || options.defaults)
            object.errorInputField = [];
        if (options.defaults) {
            object.result = 0;
            object.instrumentId = "";
            object.userMessageHtml = "";
            object.checkoutTokenRequired = false;
            object.redeemedOffer = null;
        }
        if (message.result != null && message.hasOwnProperty("result"))
            object.result = message.result;
        if (message.instrumentId != null && message.hasOwnProperty("instrumentId"))
            object.instrumentId = message.instrumentId;
        if (message.userMessageHtml != null && message.hasOwnProperty("userMessageHtml"))
            object.userMessageHtml = message.userMessageHtml;
        if (message.errorInputField && message.errorInputField.length) {
            object.errorInputField = [];
            for (var j = 0; j < message.errorInputField.length; ++j)
                object.errorInputField[j] = $root.InputValidationError.toObject(message.errorInputField[j], options);
        }
        if (message.checkoutTokenRequired != null && message.hasOwnProperty("checkoutTokenRequired"))
            object.checkoutTokenRequired = message.checkoutTokenRequired;
        if (message.redeemedOffer != null && message.hasOwnProperty("redeemedOffer"))
            object.redeemedOffer = $root.RedeemedPromoOffer.toObject(message.redeemedOffer, options);
        return object;
    };

    /**
     * Converts this UpdateInstrumentResponse to JSON.
     * @function toJSON
     * @memberof UpdateInstrumentResponse
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    UpdateInstrumentResponse.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return UpdateInstrumentResponse;
})();

$root.InitiateAssociationResponse = (function() {

    /**
     * Properties of an InitiateAssociationResponse.
     * @exports IInitiateAssociationResponse
     * @interface IInitiateAssociationResponse
     * @property {string|null} [userToken] InitiateAssociationResponse userToken
     */

    /**
     * Constructs a new InitiateAssociationResponse.
     * @exports InitiateAssociationResponse
     * @classdesc Represents an InitiateAssociationResponse.
     * @implements IInitiateAssociationResponse
     * @constructor
     * @param {IInitiateAssociationResponse=} [properties] Properties to set
     */
    function InitiateAssociationResponse(properties) {
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * InitiateAssociationResponse userToken.
     * @member {string} userToken
     * @memberof InitiateAssociationResponse
     * @instance
     */
    InitiateAssociationResponse.prototype.userToken = "";

    /**
     * Creates a new InitiateAssociationResponse instance using the specified properties.
     * @function create
     * @memberof InitiateAssociationResponse
     * @static
     * @param {IInitiateAssociationResponse=} [properties] Properties to set
     * @returns {InitiateAssociationResponse} InitiateAssociationResponse instance
     */
    InitiateAssociationResponse.create = function create(properties) {
        return new InitiateAssociationResponse(properties);
    };

    /**
     * Encodes the specified InitiateAssociationResponse message. Does not implicitly {@link InitiateAssociationResponse.verify|verify} messages.
     * @function encode
     * @memberof InitiateAssociationResponse
     * @static
     * @param {IInitiateAssociationResponse} message InitiateAssociationResponse message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    InitiateAssociationResponse.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.userToken != null && Object.hasOwnProperty.call(message, "userToken"))
            writer.uint32(/* id 1, wireType 2 =*/10).string(message.userToken);
        return writer;
    };

    /**
     * Encodes the specified InitiateAssociationResponse message, length delimited. Does not implicitly {@link InitiateAssociationResponse.verify|verify} messages.
     * @function encodeDelimited
     * @memberof InitiateAssociationResponse
     * @static
     * @param {IInitiateAssociationResponse} message InitiateAssociationResponse message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    InitiateAssociationResponse.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes an InitiateAssociationResponse message from the specified reader or buffer.
     * @function decode
     * @memberof InitiateAssociationResponse
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {InitiateAssociationResponse} InitiateAssociationResponse
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    InitiateAssociationResponse.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.InitiateAssociationResponse();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.userToken = reader.string();
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes an InitiateAssociationResponse message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof InitiateAssociationResponse
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {InitiateAssociationResponse} InitiateAssociationResponse
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    InitiateAssociationResponse.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies an InitiateAssociationResponse message.
     * @function verify
     * @memberof InitiateAssociationResponse
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    InitiateAssociationResponse.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.userToken != null && message.hasOwnProperty("userToken"))
            if (!$util.isString(message.userToken))
                return "userToken: string expected";
        return null;
    };

    /**
     * Creates an InitiateAssociationResponse message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof InitiateAssociationResponse
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {InitiateAssociationResponse} InitiateAssociationResponse
     */
    InitiateAssociationResponse.fromObject = function fromObject(object) {
        if (object instanceof $root.InitiateAssociationResponse)
            return object;
        var message = new $root.InitiateAssociationResponse();
        if (object.userToken != null)
            message.userToken = String(object.userToken);
        return message;
    };

    /**
     * Creates a plain object from an InitiateAssociationResponse message. Also converts values to other types if specified.
     * @function toObject
     * @memberof InitiateAssociationResponse
     * @static
     * @param {InitiateAssociationResponse} message InitiateAssociationResponse
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    InitiateAssociationResponse.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        var object = {};
        if (options.defaults)
            object.userToken = "";
        if (message.userToken != null && message.hasOwnProperty("userToken"))
            object.userToken = message.userToken;
        return object;
    };

    /**
     * Converts this InitiateAssociationResponse to JSON.
     * @function toJSON
     * @memberof InitiateAssociationResponse
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    InitiateAssociationResponse.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return InitiateAssociationResponse;
})();

$root.VerifyAssociationResponse = (function() {

    /**
     * Properties of a VerifyAssociationResponse.
     * @exports IVerifyAssociationResponse
     * @interface IVerifyAssociationResponse
     * @property {number|null} [status] VerifyAssociationResponse status
     * @property {IAddress|null} [billingAddress] VerifyAssociationResponse billingAddress
     * @property {ICarrierTos|null} [carrierTos] VerifyAssociationResponse carrierTos
     * @property {string|null} [carrierErrorMessage] VerifyAssociationResponse carrierErrorMessage
     */

    /**
     * Constructs a new VerifyAssociationResponse.
     * @exports VerifyAssociationResponse
     * @classdesc Represents a VerifyAssociationResponse.
     * @implements IVerifyAssociationResponse
     * @constructor
     * @param {IVerifyAssociationResponse=} [properties] Properties to set
     */
    function VerifyAssociationResponse(properties) {
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * VerifyAssociationResponse status.
     * @member {number} status
     * @memberof VerifyAssociationResponse
     * @instance
     */
    VerifyAssociationResponse.prototype.status = 0;

    /**
     * VerifyAssociationResponse billingAddress.
     * @member {IAddress|null|undefined} billingAddress
     * @memberof VerifyAssociationResponse
     * @instance
     */
    VerifyAssociationResponse.prototype.billingAddress = null;

    /**
     * VerifyAssociationResponse carrierTos.
     * @member {ICarrierTos|null|undefined} carrierTos
     * @memberof VerifyAssociationResponse
     * @instance
     */
    VerifyAssociationResponse.prototype.carrierTos = null;

    /**
     * VerifyAssociationResponse carrierErrorMessage.
     * @member {string} carrierErrorMessage
     * @memberof VerifyAssociationResponse
     * @instance
     */
    VerifyAssociationResponse.prototype.carrierErrorMessage = "";

    /**
     * Creates a new VerifyAssociationResponse instance using the specified properties.
     * @function create
     * @memberof VerifyAssociationResponse
     * @static
     * @param {IVerifyAssociationResponse=} [properties] Properties to set
     * @returns {VerifyAssociationResponse} VerifyAssociationResponse instance
     */
    VerifyAssociationResponse.create = function create(properties) {
        return new VerifyAssociationResponse(properties);
    };

    /**
     * Encodes the specified VerifyAssociationResponse message. Does not implicitly {@link VerifyAssociationResponse.verify|verify} messages.
     * @function encode
     * @memberof VerifyAssociationResponse
     * @static
     * @param {IVerifyAssociationResponse} message VerifyAssociationResponse message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    VerifyAssociationResponse.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.status != null && Object.hasOwnProperty.call(message, "status"))
            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.status);
        if (message.billingAddress != null && Object.hasOwnProperty.call(message, "billingAddress"))
            $root.Address.encode(message.billingAddress, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
        if (message.carrierTos != null && Object.hasOwnProperty.call(message, "carrierTos"))
            $root.CarrierTos.encode(message.carrierTos, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
        if (message.carrierErrorMessage != null && Object.hasOwnProperty.call(message, "carrierErrorMessage"))
            writer.uint32(/* id 4, wireType 2 =*/34).string(message.carrierErrorMessage);
        return writer;
    };

    /**
     * Encodes the specified VerifyAssociationResponse message, length delimited. Does not implicitly {@link VerifyAssociationResponse.verify|verify} messages.
     * @function encodeDelimited
     * @memberof VerifyAssociationResponse
     * @static
     * @param {IVerifyAssociationResponse} message VerifyAssociationResponse message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    VerifyAssociationResponse.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a VerifyAssociationResponse message from the specified reader or buffer.
     * @function decode
     * @memberof VerifyAssociationResponse
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {VerifyAssociationResponse} VerifyAssociationResponse
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    VerifyAssociationResponse.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.VerifyAssociationResponse();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.status = reader.int32();
                break;
            case 2:
                message.billingAddress = $root.Address.decode(reader, reader.uint32());
                break;
            case 3:
                message.carrierTos = $root.CarrierTos.decode(reader, reader.uint32());
                break;
            case 4:
                message.carrierErrorMessage = reader.string();
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a VerifyAssociationResponse message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof VerifyAssociationResponse
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {VerifyAssociationResponse} VerifyAssociationResponse
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    VerifyAssociationResponse.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a VerifyAssociationResponse message.
     * @function verify
     * @memberof VerifyAssociationResponse
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    VerifyAssociationResponse.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.status != null && message.hasOwnProperty("status"))
            if (!$util.isInteger(message.status))
                return "status: integer expected";
        if (message.billingAddress != null && message.hasOwnProperty("billingAddress")) {
            var error = $root.Address.verify(message.billingAddress);
            if (error)
                return "billingAddress." + error;
        }
        if (message.carrierTos != null && message.hasOwnProperty("carrierTos")) {
            var error = $root.CarrierTos.verify(message.carrierTos);
            if (error)
                return "carrierTos." + error;
        }
        if (message.carrierErrorMessage != null && message.hasOwnProperty("carrierErrorMessage"))
            if (!$util.isString(message.carrierErrorMessage))
                return "carrierErrorMessage: string expected";
        return null;
    };

    /**
     * Creates a VerifyAssociationResponse message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof VerifyAssociationResponse
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {VerifyAssociationResponse} VerifyAssociationResponse
     */
    VerifyAssociationResponse.fromObject = function fromObject(object) {
        if (object instanceof $root.VerifyAssociationResponse)
            return object;
        var message = new $root.VerifyAssociationResponse();
        if (object.status != null)
            message.status = object.status | 0;
        if (object.billingAddress != null) {
            if (typeof object.billingAddress !== "object")
                throw TypeError(".VerifyAssociationResponse.billingAddress: object expected");
            message.billingAddress = $root.Address.fromObject(object.billingAddress);
        }
        if (object.carrierTos != null) {
            if (typeof object.carrierTos !== "object")
                throw TypeError(".VerifyAssociationResponse.carrierTos: object expected");
            message.carrierTos = $root.CarrierTos.fromObject(object.carrierTos);
        }
        if (object.carrierErrorMessage != null)
            message.carrierErrorMessage = String(object.carrierErrorMessage);
        return message;
    };

    /**
     * Creates a plain object from a VerifyAssociationResponse message. Also converts values to other types if specified.
     * @function toObject
     * @memberof VerifyAssociationResponse
     * @static
     * @param {VerifyAssociationResponse} message VerifyAssociationResponse
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    VerifyAssociationResponse.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        var object = {};
        if (options.defaults) {
            object.status = 0;
            object.billingAddress = null;
            object.carrierTos = null;
            object.carrierErrorMessage = "";
        }
        if (message.status != null && message.hasOwnProperty("status"))
            object.status = message.status;
        if (message.billingAddress != null && message.hasOwnProperty("billingAddress"))
            object.billingAddress = $root.Address.toObject(message.billingAddress, options);
        if (message.carrierTos != null && message.hasOwnProperty("carrierTos"))
            object.carrierTos = $root.CarrierTos.toObject(message.carrierTos, options);
        if (message.carrierErrorMessage != null && message.hasOwnProperty("carrierErrorMessage"))
            object.carrierErrorMessage = message.carrierErrorMessage;
        return object;
    };

    /**
     * Converts this VerifyAssociationResponse to JSON.
     * @function toJSON
     * @memberof VerifyAssociationResponse
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    VerifyAssociationResponse.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return VerifyAssociationResponse;
})();

$root.AddressChallenge = (function() {

    /**
     * Properties of an AddressChallenge.
     * @exports IAddressChallenge
     * @interface IAddressChallenge
     * @property {string|null} [responseAddressParam] AddressChallenge responseAddressParam
     * @property {string|null} [responseCheckboxesParam] AddressChallenge responseCheckboxesParam
     * @property {string|null} [title] AddressChallenge title
     * @property {string|null} [descriptionHtml] AddressChallenge descriptionHtml
     * @property {Array.<IFormCheckbox>|null} [checkbox] AddressChallenge checkbox
     * @property {IAddress|null} [address] AddressChallenge address
     * @property {Array.<IInputValidationError>|null} [errorInputField] AddressChallenge errorInputField
     * @property {string|null} [errorHtml] AddressChallenge errorHtml
     * @property {Array.<number>|null} [requiredField] AddressChallenge requiredField
     * @property {Array.<ICountry>|null} [supportedCountry] AddressChallenge supportedCountry
     */

    /**
     * Constructs a new AddressChallenge.
     * @exports AddressChallenge
     * @classdesc Represents an AddressChallenge.
     * @implements IAddressChallenge
     * @constructor
     * @param {IAddressChallenge=} [properties] Properties to set
     */
    function AddressChallenge(properties) {
        this.checkbox = [];
        this.errorInputField = [];
        this.requiredField = [];
        this.supportedCountry = [];
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * AddressChallenge responseAddressParam.
     * @member {string} responseAddressParam
     * @memberof AddressChallenge
     * @instance
     */
    AddressChallenge.prototype.responseAddressParam = "";

    /**
     * AddressChallenge responseCheckboxesParam.
     * @member {string} responseCheckboxesParam
     * @memberof AddressChallenge
     * @instance
     */
    AddressChallenge.prototype.responseCheckboxesParam = "";

    /**
     * AddressChallenge title.
     * @member {string} title
     * @memberof AddressChallenge
     * @instance
     */
    AddressChallenge.prototype.title = "";

    /**
     * AddressChallenge descriptionHtml.
     * @member {string} descriptionHtml
     * @memberof AddressChallenge
     * @instance
     */
    AddressChallenge.prototype.descriptionHtml = "";

    /**
     * AddressChallenge checkbox.
     * @member {Array.<IFormCheckbox>} checkbox
     * @memberof AddressChallenge
     * @instance
     */
    AddressChallenge.prototype.checkbox = $util.emptyArray;

    /**
     * AddressChallenge address.
     * @member {IAddress|null|undefined} address
     * @memberof AddressChallenge
     * @instance
     */
    AddressChallenge.prototype.address = null;

    /**
     * AddressChallenge errorInputField.
     * @member {Array.<IInputValidationError>} errorInputField
     * @memberof AddressChallenge
     * @instance
     */
    AddressChallenge.prototype.errorInputField = $util.emptyArray;

    /**
     * AddressChallenge errorHtml.
     * @member {string} errorHtml
     * @memberof AddressChallenge
     * @instance
     */
    AddressChallenge.prototype.errorHtml = "";

    /**
     * AddressChallenge requiredField.
     * @member {Array.<number>} requiredField
     * @memberof AddressChallenge
     * @instance
     */
    AddressChallenge.prototype.requiredField = $util.emptyArray;

    /**
     * AddressChallenge supportedCountry.
     * @member {Array.<ICountry>} supportedCountry
     * @memberof AddressChallenge
     * @instance
     */
    AddressChallenge.prototype.supportedCountry = $util.emptyArray;

    /**
     * Creates a new AddressChallenge instance using the specified properties.
     * @function create
     * @memberof AddressChallenge
     * @static
     * @param {IAddressChallenge=} [properties] Properties to set
     * @returns {AddressChallenge} AddressChallenge instance
     */
    AddressChallenge.create = function create(properties) {
        return new AddressChallenge(properties);
    };

    /**
     * Encodes the specified AddressChallenge message. Does not implicitly {@link AddressChallenge.verify|verify} messages.
     * @function encode
     * @memberof AddressChallenge
     * @static
     * @param {IAddressChallenge} message AddressChallenge message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    AddressChallenge.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.responseAddressParam != null && Object.hasOwnProperty.call(message, "responseAddressParam"))
            writer.uint32(/* id 1, wireType 2 =*/10).string(message.responseAddressParam);
        if (message.responseCheckboxesParam != null && Object.hasOwnProperty.call(message, "responseCheckboxesParam"))
            writer.uint32(/* id 2, wireType 2 =*/18).string(message.responseCheckboxesParam);
        if (message.title != null && Object.hasOwnProperty.call(message, "title"))
            writer.uint32(/* id 3, wireType 2 =*/26).string(message.title);
        if (message.descriptionHtml != null && Object.hasOwnProperty.call(message, "descriptionHtml"))
            writer.uint32(/* id 4, wireType 2 =*/34).string(message.descriptionHtml);
        if (message.checkbox != null && message.checkbox.length)
            for (var i = 0; i < message.checkbox.length; ++i)
                $root.FormCheckbox.encode(message.checkbox[i], writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
        if (message.address != null && Object.hasOwnProperty.call(message, "address"))
            $root.Address.encode(message.address, writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
        if (message.errorInputField != null && message.errorInputField.length)
            for (var i = 0; i < message.errorInputField.length; ++i)
                $root.InputValidationError.encode(message.errorInputField[i], writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
        if (message.errorHtml != null && Object.hasOwnProperty.call(message, "errorHtml"))
            writer.uint32(/* id 8, wireType 2 =*/66).string(message.errorHtml);
        if (message.requiredField != null && message.requiredField.length)
            for (var i = 0; i < message.requiredField.length; ++i)
                writer.uint32(/* id 9, wireType 0 =*/72).int32(message.requiredField[i]);
        if (message.supportedCountry != null && message.supportedCountry.length)
            for (var i = 0; i < message.supportedCountry.length; ++i)
                $root.Country.encode(message.supportedCountry[i], writer.uint32(/* id 10, wireType 2 =*/82).fork()).ldelim();
        return writer;
    };

    /**
     * Encodes the specified AddressChallenge message, length delimited. Does not implicitly {@link AddressChallenge.verify|verify} messages.
     * @function encodeDelimited
     * @memberof AddressChallenge
     * @static
     * @param {IAddressChallenge} message AddressChallenge message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    AddressChallenge.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes an AddressChallenge message from the specified reader or buffer.
     * @function decode
     * @memberof AddressChallenge
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {AddressChallenge} AddressChallenge
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    AddressChallenge.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.AddressChallenge();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.responseAddressParam = reader.string();
                break;
            case 2:
                message.responseCheckboxesParam = reader.string();
                break;
            case 3:
                message.title = reader.string();
                break;
            case 4:
                message.descriptionHtml = reader.string();
                break;
            case 5:
                if (!(message.checkbox && message.checkbox.length))
                    message.checkbox = [];
                message.checkbox.push($root.FormCheckbox.decode(reader, reader.uint32()));
                break;
            case 6:
                message.address = $root.Address.decode(reader, reader.uint32());
                break;
            case 7:
                if (!(message.errorInputField && message.errorInputField.length))
                    message.errorInputField = [];
                message.errorInputField.push($root.InputValidationError.decode(reader, reader.uint32()));
                break;
            case 8:
                message.errorHtml = reader.string();
                break;
            case 9:
                if (!(message.requiredField && message.requiredField.length))
                    message.requiredField = [];
                if ((tag & 7) === 2) {
                    var end2 = reader.uint32() + reader.pos;
                    while (reader.pos < end2)
                        message.requiredField.push(reader.int32());
                } else
                    message.requiredField.push(reader.int32());
                break;
            case 10:
                if (!(message.supportedCountry && message.supportedCountry.length))
                    message.supportedCountry = [];
                message.supportedCountry.push($root.Country.decode(reader, reader.uint32()));
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes an AddressChallenge message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof AddressChallenge
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {AddressChallenge} AddressChallenge
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    AddressChallenge.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies an AddressChallenge message.
     * @function verify
     * @memberof AddressChallenge
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    AddressChallenge.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.responseAddressParam != null && message.hasOwnProperty("responseAddressParam"))
            if (!$util.isString(message.responseAddressParam))
                return "responseAddressParam: string expected";
        if (message.responseCheckboxesParam != null && message.hasOwnProperty("responseCheckboxesParam"))
            if (!$util.isString(message.responseCheckboxesParam))
                return "responseCheckboxesParam: string expected";
        if (message.title != null && message.hasOwnProperty("title"))
            if (!$util.isString(message.title))
                return "title: string expected";
        if (message.descriptionHtml != null && message.hasOwnProperty("descriptionHtml"))
            if (!$util.isString(message.descriptionHtml))
                return "descriptionHtml: string expected";
        if (message.checkbox != null && message.hasOwnProperty("checkbox")) {
            if (!Array.isArray(message.checkbox))
                return "checkbox: array expected";
            for (var i = 0; i < message.checkbox.length; ++i) {
                var error = $root.FormCheckbox.verify(message.checkbox[i]);
                if (error)
                    return "checkbox." + error;
            }
        }
        if (message.address != null && message.hasOwnProperty("address")) {
            var error = $root.Address.verify(message.address);
            if (error)
                return "address." + error;
        }
        if (message.errorInputField != null && message.hasOwnProperty("errorInputField")) {
            if (!Array.isArray(message.errorInputField))
                return "errorInputField: array expected";
            for (var i = 0; i < message.errorInputField.length; ++i) {
                var error = $root.InputValidationError.verify(message.errorInputField[i]);
                if (error)
                    return "errorInputField." + error;
            }
        }
        if (message.errorHtml != null && message.hasOwnProperty("errorHtml"))
            if (!$util.isString(message.errorHtml))
                return "errorHtml: string expected";
        if (message.requiredField != null && message.hasOwnProperty("requiredField")) {
            if (!Array.isArray(message.requiredField))
                return "requiredField: array expected";
            for (var i = 0; i < message.requiredField.length; ++i)
                if (!$util.isInteger(message.requiredField[i]))
                    return "requiredField: integer[] expected";
        }
        if (message.supportedCountry != null && message.hasOwnProperty("supportedCountry")) {
            if (!Array.isArray(message.supportedCountry))
                return "supportedCountry: array expected";
            for (var i = 0; i < message.supportedCountry.length; ++i) {
                var error = $root.Country.verify(message.supportedCountry[i]);
                if (error)
                    return "supportedCountry." + error;
            }
        }
        return null;
    };

    /**
     * Creates an AddressChallenge message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof AddressChallenge
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {AddressChallenge} AddressChallenge
     */
    AddressChallenge.fromObject = function fromObject(object) {
        if (object instanceof $root.AddressChallenge)
            return object;
        var message = new $root.AddressChallenge();
        if (object.responseAddressParam != null)
            message.responseAddressParam = String(object.responseAddressParam);
        if (object.responseCheckboxesParam != null)
            message.responseCheckboxesParam = String(object.responseCheckboxesParam);
        if (object.title != null)
            message.title = String(object.title);
        if (object.descriptionHtml != null)
            message.descriptionHtml = String(object.descriptionHtml);
        if (object.checkbox) {
            if (!Array.isArray(object.checkbox))
                throw TypeError(".AddressChallenge.checkbox: array expected");
            message.checkbox = [];
            for (var i = 0; i < object.checkbox.length; ++i) {
                if (typeof object.checkbox[i] !== "object")
                    throw TypeError(".AddressChallenge.checkbox: object expected");
                message.checkbox[i] = $root.FormCheckbox.fromObject(object.checkbox[i]);
            }
        }
        if (object.address != null) {
            if (typeof object.address !== "object")
                throw TypeError(".AddressChallenge.address: object expected");
            message.address = $root.Address.fromObject(object.address);
        }
        if (object.errorInputField) {
            if (!Array.isArray(object.errorInputField))
                throw TypeError(".AddressChallenge.errorInputField: array expected");
            message.errorInputField = [];
            for (var i = 0; i < object.errorInputField.length; ++i) {
                if (typeof object.errorInputField[i] !== "object")
                    throw TypeError(".AddressChallenge.errorInputField: object expected");
                message.errorInputField[i] = $root.InputValidationError.fromObject(object.errorInputField[i]);
            }
        }
        if (object.errorHtml != null)
            message.errorHtml = String(object.errorHtml);
        if (object.requiredField) {
            if (!Array.isArray(object.requiredField))
                throw TypeError(".AddressChallenge.requiredField: array expected");
            message.requiredField = [];
            for (var i = 0; i < object.requiredField.length; ++i)
                message.requiredField[i] = object.requiredField[i] | 0;
        }
        if (object.supportedCountry) {
            if (!Array.isArray(object.supportedCountry))
                throw TypeError(".AddressChallenge.supportedCountry: array expected");
            message.supportedCountry = [];
            for (var i = 0; i < object.supportedCountry.length; ++i) {
                if (typeof object.supportedCountry[i] !== "object")
                    throw TypeError(".AddressChallenge.supportedCountry: object expected");
                message.supportedCountry[i] = $root.Country.fromObject(object.supportedCountry[i]);
            }
        }
        return message;
    };

    /**
     * Creates a plain object from an AddressChallenge message. Also converts values to other types if specified.
     * @function toObject
     * @memberof AddressChallenge
     * @static
     * @param {AddressChallenge} message AddressChallenge
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    AddressChallenge.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        var object = {};
        if (options.arrays || options.defaults) {
            object.checkbox = [];
            object.errorInputField = [];
            object.requiredField = [];
            object.supportedCountry = [];
        }
        if (options.defaults) {
            object.responseAddressParam = "";
            object.responseCheckboxesParam = "";
            object.title = "";
            object.descriptionHtml = "";
            object.address = null;
            object.errorHtml = "";
        }
        if (message.responseAddressParam != null && message.hasOwnProperty("responseAddressParam"))
            object.responseAddressParam = message.responseAddressParam;
        if (message.responseCheckboxesParam != null && message.hasOwnProperty("responseCheckboxesParam"))
            object.responseCheckboxesParam = message.responseCheckboxesParam;
        if (message.title != null && message.hasOwnProperty("title"))
            object.title = message.title;
        if (message.descriptionHtml != null && message.hasOwnProperty("descriptionHtml"))
            object.descriptionHtml = message.descriptionHtml;
        if (message.checkbox && message.checkbox.length) {
            object.checkbox = [];
            for (var j = 0; j < message.checkbox.length; ++j)
                object.checkbox[j] = $root.FormCheckbox.toObject(message.checkbox[j], options);
        }
        if (message.address != null && message.hasOwnProperty("address"))
            object.address = $root.Address.toObject(message.address, options);
        if (message.errorInputField && message.errorInputField.length) {
            object.errorInputField = [];
            for (var j = 0; j < message.errorInputField.length; ++j)
                object.errorInputField[j] = $root.InputValidationError.toObject(message.errorInputField[j], options);
        }
        if (message.errorHtml != null && message.hasOwnProperty("errorHtml"))
            object.errorHtml = message.errorHtml;
        if (message.requiredField && message.requiredField.length) {
            object.requiredField = [];
            for (var j = 0; j < message.requiredField.length; ++j)
                object.requiredField[j] = message.requiredField[j];
        }
        if (message.supportedCountry && message.supportedCountry.length) {
            object.supportedCountry = [];
            for (var j = 0; j < message.supportedCountry.length; ++j)
                object.supportedCountry[j] = $root.Country.toObject(message.supportedCountry[j], options);
        }
        return object;
    };

    /**
     * Converts this AddressChallenge to JSON.
     * @function toJSON
     * @memberof AddressChallenge
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    AddressChallenge.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return AddressChallenge;
})();

$root.AuthenticationChallenge = (function() {

    /**
     * Properties of an AuthenticationChallenge.
     * @exports IAuthenticationChallenge
     * @interface IAuthenticationChallenge
     * @property {number|null} [authenticationType] AuthenticationChallenge authenticationType
     * @property {string|null} [responseAuthenticationTypeParam] AuthenticationChallenge responseAuthenticationTypeParam
     * @property {string|null} [responseRetryCountParam] AuthenticationChallenge responseRetryCountParam
     * @property {string|null} [pinHeaderText] AuthenticationChallenge pinHeaderText
     * @property {string|null} [pinDescriptionTextHtml] AuthenticationChallenge pinDescriptionTextHtml
     * @property {string|null} [gaiaHeaderText] AuthenticationChallenge gaiaHeaderText
     * @property {string|null} [gaiaDescriptionTextHtml] AuthenticationChallenge gaiaDescriptionTextHtml
     * @property {string|null} [gaiaFooterTextHtml] AuthenticationChallenge gaiaFooterTextHtml
     * @property {IFormCheckbox|null} [gaiaOptOutCheckbox] AuthenticationChallenge gaiaOptOutCheckbox
     * @property {string|null} [gaiaOptOutDescriptionTextHtml] AuthenticationChallenge gaiaOptOutDescriptionTextHtml
     */

    /**
     * Constructs a new AuthenticationChallenge.
     * @exports AuthenticationChallenge
     * @classdesc Represents an AuthenticationChallenge.
     * @implements IAuthenticationChallenge
     * @constructor
     * @param {IAuthenticationChallenge=} [properties] Properties to set
     */
    function AuthenticationChallenge(properties) {
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * AuthenticationChallenge authenticationType.
     * @member {number} authenticationType
     * @memberof AuthenticationChallenge
     * @instance
     */
    AuthenticationChallenge.prototype.authenticationType = 0;

    /**
     * AuthenticationChallenge responseAuthenticationTypeParam.
     * @member {string} responseAuthenticationTypeParam
     * @memberof AuthenticationChallenge
     * @instance
     */
    AuthenticationChallenge.prototype.responseAuthenticationTypeParam = "";

    /**
     * AuthenticationChallenge responseRetryCountParam.
     * @member {string} responseRetryCountParam
     * @memberof AuthenticationChallenge
     * @instance
     */
    AuthenticationChallenge.prototype.responseRetryCountParam = "";

    /**
     * AuthenticationChallenge pinHeaderText.
     * @member {string} pinHeaderText
     * @memberof AuthenticationChallenge
     * @instance
     */
    AuthenticationChallenge.prototype.pinHeaderText = "";

    /**
     * AuthenticationChallenge pinDescriptionTextHtml.
     * @member {string} pinDescriptionTextHtml
     * @memberof AuthenticationChallenge
     * @instance
     */
    AuthenticationChallenge.prototype.pinDescriptionTextHtml = "";

    /**
     * AuthenticationChallenge gaiaHeaderText.
     * @member {string} gaiaHeaderText
     * @memberof AuthenticationChallenge
     * @instance
     */
    AuthenticationChallenge.prototype.gaiaHeaderText = "";

    /**
     * AuthenticationChallenge gaiaDescriptionTextHtml.
     * @member {string} gaiaDescriptionTextHtml
     * @memberof AuthenticationChallenge
     * @instance
     */
    AuthenticationChallenge.prototype.gaiaDescriptionTextHtml = "";

    /**
     * AuthenticationChallenge gaiaFooterTextHtml.
     * @member {string} gaiaFooterTextHtml
     * @memberof AuthenticationChallenge
     * @instance
     */
    AuthenticationChallenge.prototype.gaiaFooterTextHtml = "";

    /**
     * AuthenticationChallenge gaiaOptOutCheckbox.
     * @member {IFormCheckbox|null|undefined} gaiaOptOutCheckbox
     * @memberof AuthenticationChallenge
     * @instance
     */
    AuthenticationChallenge.prototype.gaiaOptOutCheckbox = null;

    /**
     * AuthenticationChallenge gaiaOptOutDescriptionTextHtml.
     * @member {string} gaiaOptOutDescriptionTextHtml
     * @memberof AuthenticationChallenge
     * @instance
     */
    AuthenticationChallenge.prototype.gaiaOptOutDescriptionTextHtml = "";

    /**
     * Creates a new AuthenticationChallenge instance using the specified properties.
     * @function create
     * @memberof AuthenticationChallenge
     * @static
     * @param {IAuthenticationChallenge=} [properties] Properties to set
     * @returns {AuthenticationChallenge} AuthenticationChallenge instance
     */
    AuthenticationChallenge.create = function create(properties) {
        return new AuthenticationChallenge(properties);
    };

    /**
     * Encodes the specified AuthenticationChallenge message. Does not implicitly {@link AuthenticationChallenge.verify|verify} messages.
     * @function encode
     * @memberof AuthenticationChallenge
     * @static
     * @param {IAuthenticationChallenge} message AuthenticationChallenge message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    AuthenticationChallenge.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.authenticationType != null && Object.hasOwnProperty.call(message, "authenticationType"))
            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.authenticationType);
        if (message.responseAuthenticationTypeParam != null && Object.hasOwnProperty.call(message, "responseAuthenticationTypeParam"))
            writer.uint32(/* id 2, wireType 2 =*/18).string(message.responseAuthenticationTypeParam);
        if (message.responseRetryCountParam != null && Object.hasOwnProperty.call(message, "responseRetryCountParam"))
            writer.uint32(/* id 3, wireType 2 =*/26).string(message.responseRetryCountParam);
        if (message.pinHeaderText != null && Object.hasOwnProperty.call(message, "pinHeaderText"))
            writer.uint32(/* id 4, wireType 2 =*/34).string(message.pinHeaderText);
        if (message.pinDescriptionTextHtml != null && Object.hasOwnProperty.call(message, "pinDescriptionTextHtml"))
            writer.uint32(/* id 5, wireType 2 =*/42).string(message.pinDescriptionTextHtml);
        if (message.gaiaHeaderText != null && Object.hasOwnProperty.call(message, "gaiaHeaderText"))
            writer.uint32(/* id 6, wireType 2 =*/50).string(message.gaiaHeaderText);
        if (message.gaiaDescriptionTextHtml != null && Object.hasOwnProperty.call(message, "gaiaDescriptionTextHtml"))
            writer.uint32(/* id 7, wireType 2 =*/58).string(message.gaiaDescriptionTextHtml);
        if (message.gaiaFooterTextHtml != null && Object.hasOwnProperty.call(message, "gaiaFooterTextHtml"))
            writer.uint32(/* id 8, wireType 2 =*/66).string(message.gaiaFooterTextHtml);
        if (message.gaiaOptOutCheckbox != null && Object.hasOwnProperty.call(message, "gaiaOptOutCheckbox"))
            $root.FormCheckbox.encode(message.gaiaOptOutCheckbox, writer.uint32(/* id 9, wireType 2 =*/74).fork()).ldelim();
        if (message.gaiaOptOutDescriptionTextHtml != null && Object.hasOwnProperty.call(message, "gaiaOptOutDescriptionTextHtml"))
            writer.uint32(/* id 10, wireType 2 =*/82).string(message.gaiaOptOutDescriptionTextHtml);
        return writer;
    };

    /**
     * Encodes the specified AuthenticationChallenge message, length delimited. Does not implicitly {@link AuthenticationChallenge.verify|verify} messages.
     * @function encodeDelimited
     * @memberof AuthenticationChallenge
     * @static
     * @param {IAuthenticationChallenge} message AuthenticationChallenge message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    AuthenticationChallenge.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes an AuthenticationChallenge message from the specified reader or buffer.
     * @function decode
     * @memberof AuthenticationChallenge
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {AuthenticationChallenge} AuthenticationChallenge
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    AuthenticationChallenge.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.AuthenticationChallenge();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.authenticationType = reader.int32();
                break;
            case 2:
                message.responseAuthenticationTypeParam = reader.string();
                break;
            case 3:
                message.responseRetryCountParam = reader.string();
                break;
            case 4:
                message.pinHeaderText = reader.string();
                break;
            case 5:
                message.pinDescriptionTextHtml = reader.string();
                break;
            case 6:
                message.gaiaHeaderText = reader.string();
                break;
            case 7:
                message.gaiaDescriptionTextHtml = reader.string();
                break;
            case 8:
                message.gaiaFooterTextHtml = reader.string();
                break;
            case 9:
                message.gaiaOptOutCheckbox = $root.FormCheckbox.decode(reader, reader.uint32());
                break;
            case 10:
                message.gaiaOptOutDescriptionTextHtml = reader.string();
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes an AuthenticationChallenge message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof AuthenticationChallenge
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {AuthenticationChallenge} AuthenticationChallenge
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    AuthenticationChallenge.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies an AuthenticationChallenge message.
     * @function verify
     * @memberof AuthenticationChallenge
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    AuthenticationChallenge.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.authenticationType != null && message.hasOwnProperty("authenticationType"))
            if (!$util.isInteger(message.authenticationType))
                return "authenticationType: integer expected";
        if (message.responseAuthenticationTypeParam != null && message.hasOwnProperty("responseAuthenticationTypeParam"))
            if (!$util.isString(message.responseAuthenticationTypeParam))
                return "responseAuthenticationTypeParam: string expected";
        if (message.responseRetryCountParam != null && message.hasOwnProperty("responseRetryCountParam"))
            if (!$util.isString(message.responseRetryCountParam))
                return "responseRetryCountParam: string expected";
        if (message.pinHeaderText != null && message.hasOwnProperty("pinHeaderText"))
            if (!$util.isString(message.pinHeaderText))
                return "pinHeaderText: string expected";
        if (message.pinDescriptionTextHtml != null && message.hasOwnProperty("pinDescriptionTextHtml"))
            if (!$util.isString(message.pinDescriptionTextHtml))
                return "pinDescriptionTextHtml: string expected";
        if (message.gaiaHeaderText != null && message.hasOwnProperty("gaiaHeaderText"))
            if (!$util.isString(message.gaiaHeaderText))
                return "gaiaHeaderText: string expected";
        if (message.gaiaDescriptionTextHtml != null && message.hasOwnProperty("gaiaDescriptionTextHtml"))
            if (!$util.isString(message.gaiaDescriptionTextHtml))
                return "gaiaDescriptionTextHtml: string expected";
        if (message.gaiaFooterTextHtml != null && message.hasOwnProperty("gaiaFooterTextHtml"))
            if (!$util.isString(message.gaiaFooterTextHtml))
                return "gaiaFooterTextHtml: string expected";
        if (message.gaiaOptOutCheckbox != null && message.hasOwnProperty("gaiaOptOutCheckbox")) {
            var error = $root.FormCheckbox.verify(message.gaiaOptOutCheckbox);
            if (error)
                return "gaiaOptOutCheckbox." + error;
        }
        if (message.gaiaOptOutDescriptionTextHtml != null && message.hasOwnProperty("gaiaOptOutDescriptionTextHtml"))
            if (!$util.isString(message.gaiaOptOutDescriptionTextHtml))
                return "gaiaOptOutDescriptionTextHtml: string expected";
        return null;
    };

    /**
     * Creates an AuthenticationChallenge message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof AuthenticationChallenge
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {AuthenticationChallenge} AuthenticationChallenge
     */
    AuthenticationChallenge.fromObject = function fromObject(object) {
        if (object instanceof $root.AuthenticationChallenge)
            return object;
        var message = new $root.AuthenticationChallenge();
        if (object.authenticationType != null)
            message.authenticationType = object.authenticationType | 0;
        if (object.responseAuthenticationTypeParam != null)
            message.responseAuthenticationTypeParam = String(object.responseAuthenticationTypeParam);
        if (object.responseRetryCountParam != null)
            message.responseRetryCountParam = String(object.responseRetryCountParam);
        if (object.pinHeaderText != null)
            message.pinHeaderText = String(object.pinHeaderText);
        if (object.pinDescriptionTextHtml != null)
            message.pinDescriptionTextHtml = String(object.pinDescriptionTextHtml);
        if (object.gaiaHeaderText != null)
            message.gaiaHeaderText = String(object.gaiaHeaderText);
        if (object.gaiaDescriptionTextHtml != null)
            message.gaiaDescriptionTextHtml = String(object.gaiaDescriptionTextHtml);
        if (object.gaiaFooterTextHtml != null)
            message.gaiaFooterTextHtml = String(object.gaiaFooterTextHtml);
        if (object.gaiaOptOutCheckbox != null) {
            if (typeof object.gaiaOptOutCheckbox !== "object")
                throw TypeError(".AuthenticationChallenge.gaiaOptOutCheckbox: object expected");
            message.gaiaOptOutCheckbox = $root.FormCheckbox.fromObject(object.gaiaOptOutCheckbox);
        }
        if (object.gaiaOptOutDescriptionTextHtml != null)
            message.gaiaOptOutDescriptionTextHtml = String(object.gaiaOptOutDescriptionTextHtml);
        return message;
    };

    /**
     * Creates a plain object from an AuthenticationChallenge message. Also converts values to other types if specified.
     * @function toObject
     * @memberof AuthenticationChallenge
     * @static
     * @param {AuthenticationChallenge} message AuthenticationChallenge
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    AuthenticationChallenge.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        var object = {};
        if (options.defaults) {
            object.authenticationType = 0;
            object.responseAuthenticationTypeParam = "";
            object.responseRetryCountParam = "";
            object.pinHeaderText = "";
            object.pinDescriptionTextHtml = "";
            object.gaiaHeaderText = "";
            object.gaiaDescriptionTextHtml = "";
            object.gaiaFooterTextHtml = "";
            object.gaiaOptOutCheckbox = null;
            object.gaiaOptOutDescriptionTextHtml = "";
        }
        if (message.authenticationType != null && message.hasOwnProperty("authenticationType"))
            object.authenticationType = message.authenticationType;
        if (message.responseAuthenticationTypeParam != null && message.hasOwnProperty("responseAuthenticationTypeParam"))
            object.responseAuthenticationTypeParam = message.responseAuthenticationTypeParam;
        if (message.responseRetryCountParam != null && message.hasOwnProperty("responseRetryCountParam"))
            object.responseRetryCountParam = message.responseRetryCountParam;
        if (message.pinHeaderText != null && message.hasOwnProperty("pinHeaderText"))
            object.pinHeaderText = message.pinHeaderText;
        if (message.pinDescriptionTextHtml != null && message.hasOwnProperty("pinDescriptionTextHtml"))
            object.pinDescriptionTextHtml = message.pinDescriptionTextHtml;
        if (message.gaiaHeaderText != null && message.hasOwnProperty("gaiaHeaderText"))
            object.gaiaHeaderText = message.gaiaHeaderText;
        if (message.gaiaDescriptionTextHtml != null && message.hasOwnProperty("gaiaDescriptionTextHtml"))
            object.gaiaDescriptionTextHtml = message.gaiaDescriptionTextHtml;
        if (message.gaiaFooterTextHtml != null && message.hasOwnProperty("gaiaFooterTextHtml"))
            object.gaiaFooterTextHtml = message.gaiaFooterTextHtml;
        if (message.gaiaOptOutCheckbox != null && message.hasOwnProperty("gaiaOptOutCheckbox"))
            object.gaiaOptOutCheckbox = $root.FormCheckbox.toObject(message.gaiaOptOutCheckbox, options);
        if (message.gaiaOptOutDescriptionTextHtml != null && message.hasOwnProperty("gaiaOptOutDescriptionTextHtml"))
            object.gaiaOptOutDescriptionTextHtml = message.gaiaOptOutDescriptionTextHtml;
        return object;
    };

    /**
     * Converts this AuthenticationChallenge to JSON.
     * @function toJSON
     * @memberof AuthenticationChallenge
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    AuthenticationChallenge.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return AuthenticationChallenge;
})();

$root.Challenge = (function() {

    /**
     * Properties of a Challenge.
     * @exports IChallenge
     * @interface IChallenge
     * @property {IAddressChallenge|null} [addressChallenge] Challenge addressChallenge
     * @property {IAuthenticationChallenge|null} [authenticationChallenge] Challenge authenticationChallenge
     * @property {IWebViewChallenge|null} [webViewChallenge] Challenge webViewChallenge
     */

    /**
     * Constructs a new Challenge.
     * @exports Challenge
     * @classdesc Represents a Challenge.
     * @implements IChallenge
     * @constructor
     * @param {IChallenge=} [properties] Properties to set
     */
    function Challenge(properties) {
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * Challenge addressChallenge.
     * @member {IAddressChallenge|null|undefined} addressChallenge
     * @memberof Challenge
     * @instance
     */
    Challenge.prototype.addressChallenge = null;

    /**
     * Challenge authenticationChallenge.
     * @member {IAuthenticationChallenge|null|undefined} authenticationChallenge
     * @memberof Challenge
     * @instance
     */
    Challenge.prototype.authenticationChallenge = null;

    /**
     * Challenge webViewChallenge.
     * @member {IWebViewChallenge|null|undefined} webViewChallenge
     * @memberof Challenge
     * @instance
     */
    Challenge.prototype.webViewChallenge = null;

    /**
     * Creates a new Challenge instance using the specified properties.
     * @function create
     * @memberof Challenge
     * @static
     * @param {IChallenge=} [properties] Properties to set
     * @returns {Challenge} Challenge instance
     */
    Challenge.create = function create(properties) {
        return new Challenge(properties);
    };

    /**
     * Encodes the specified Challenge message. Does not implicitly {@link Challenge.verify|verify} messages.
     * @function encode
     * @memberof Challenge
     * @static
     * @param {IChallenge} message Challenge message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    Challenge.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.addressChallenge != null && Object.hasOwnProperty.call(message, "addressChallenge"))
            $root.AddressChallenge.encode(message.addressChallenge, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
        if (message.authenticationChallenge != null && Object.hasOwnProperty.call(message, "authenticationChallenge"))
            $root.AuthenticationChallenge.encode(message.authenticationChallenge, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
        if (message.webViewChallenge != null && Object.hasOwnProperty.call(message, "webViewChallenge"))
            $root.WebViewChallenge.encode(message.webViewChallenge, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
        return writer;
    };

    /**
     * Encodes the specified Challenge message, length delimited. Does not implicitly {@link Challenge.verify|verify} messages.
     * @function encodeDelimited
     * @memberof Challenge
     * @static
     * @param {IChallenge} message Challenge message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    Challenge.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a Challenge message from the specified reader or buffer.
     * @function decode
     * @memberof Challenge
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {Challenge} Challenge
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    Challenge.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Challenge();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.addressChallenge = $root.AddressChallenge.decode(reader, reader.uint32());
                break;
            case 2:
                message.authenticationChallenge = $root.AuthenticationChallenge.decode(reader, reader.uint32());
                break;
            case 3:
                message.webViewChallenge = $root.WebViewChallenge.decode(reader, reader.uint32());
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a Challenge message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof Challenge
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {Challenge} Challenge
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    Challenge.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a Challenge message.
     * @function verify
     * @memberof Challenge
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    Challenge.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.addressChallenge != null && message.hasOwnProperty("addressChallenge")) {
            var error = $root.AddressChallenge.verify(message.addressChallenge);
            if (error)
                return "addressChallenge." + error;
        }
        if (message.authenticationChallenge != null && message.hasOwnProperty("authenticationChallenge")) {
            var error = $root.AuthenticationChallenge.verify(message.authenticationChallenge);
            if (error)
                return "authenticationChallenge." + error;
        }
        if (message.webViewChallenge != null && message.hasOwnProperty("webViewChallenge")) {
            var error = $root.WebViewChallenge.verify(message.webViewChallenge);
            if (error)
                return "webViewChallenge." + error;
        }
        return null;
    };

    /**
     * Creates a Challenge message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof Challenge
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {Challenge} Challenge
     */
    Challenge.fromObject = function fromObject(object) {
        if (object instanceof $root.Challenge)
            return object;
        var message = new $root.Challenge();
        if (object.addressChallenge != null) {
            if (typeof object.addressChallenge !== "object")
                throw TypeError(".Challenge.addressChallenge: object expected");
            message.addressChallenge = $root.AddressChallenge.fromObject(object.addressChallenge);
        }
        if (object.authenticationChallenge != null) {
            if (typeof object.authenticationChallenge !== "object")
                throw TypeError(".Challenge.authenticationChallenge: object expected");
            message.authenticationChallenge = $root.AuthenticationChallenge.fromObject(object.authenticationChallenge);
        }
        if (object.webViewChallenge != null) {
            if (typeof object.webViewChallenge !== "object")
                throw TypeError(".Challenge.webViewChallenge: object expected");
            message.webViewChallenge = $root.WebViewChallenge.fromObject(object.webViewChallenge);
        }
        return message;
    };

    /**
     * Creates a plain object from a Challenge message. Also converts values to other types if specified.
     * @function toObject
     * @memberof Challenge
     * @static
     * @param {Challenge} message Challenge
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    Challenge.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        var object = {};
        if (options.defaults) {
            object.addressChallenge = null;
            object.authenticationChallenge = null;
            object.webViewChallenge = null;
        }
        if (message.addressChallenge != null && message.hasOwnProperty("addressChallenge"))
            object.addressChallenge = $root.AddressChallenge.toObject(message.addressChallenge, options);
        if (message.authenticationChallenge != null && message.hasOwnProperty("authenticationChallenge"))
            object.authenticationChallenge = $root.AuthenticationChallenge.toObject(message.authenticationChallenge, options);
        if (message.webViewChallenge != null && message.hasOwnProperty("webViewChallenge"))
            object.webViewChallenge = $root.WebViewChallenge.toObject(message.webViewChallenge, options);
        return object;
    };

    /**
     * Converts this Challenge to JSON.
     * @function toJSON
     * @memberof Challenge
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    Challenge.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return Challenge;
})();

$root.Country = (function() {

    /**
     * Properties of a Country.
     * @exports ICountry
     * @interface ICountry
     * @property {string|null} [regionCode] Country regionCode
     * @property {string|null} [displayName] Country displayName
     */

    /**
     * Constructs a new Country.
     * @exports Country
     * @classdesc Represents a Country.
     * @implements ICountry
     * @constructor
     * @param {ICountry=} [properties] Properties to set
     */
    function Country(properties) {
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * Country regionCode.
     * @member {string} regionCode
     * @memberof Country
     * @instance
     */
    Country.prototype.regionCode = "";

    /**
     * Country displayName.
     * @member {string} displayName
     * @memberof Country
     * @instance
     */
    Country.prototype.displayName = "";

    /**
     * Creates a new Country instance using the specified properties.
     * @function create
     * @memberof Country
     * @static
     * @param {ICountry=} [properties] Properties to set
     * @returns {Country} Country instance
     */
    Country.create = function create(properties) {
        return new Country(properties);
    };

    /**
     * Encodes the specified Country message. Does not implicitly {@link Country.verify|verify} messages.
     * @function encode
     * @memberof Country
     * @static
     * @param {ICountry} message Country message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    Country.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.regionCode != null && Object.hasOwnProperty.call(message, "regionCode"))
            writer.uint32(/* id 1, wireType 2 =*/10).string(message.regionCode);
        if (message.displayName != null && Object.hasOwnProperty.call(message, "displayName"))
            writer.uint32(/* id 2, wireType 2 =*/18).string(message.displayName);
        return writer;
    };

    /**
     * Encodes the specified Country message, length delimited. Does not implicitly {@link Country.verify|verify} messages.
     * @function encodeDelimited
     * @memberof Country
     * @static
     * @param {ICountry} message Country message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    Country.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a Country message from the specified reader or buffer.
     * @function decode
     * @memberof Country
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {Country} Country
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    Country.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Country();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.regionCode = reader.string();
                break;
            case 2:
                message.displayName = reader.string();
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a Country message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof Country
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {Country} Country
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    Country.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a Country message.
     * @function verify
     * @memberof Country
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    Country.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.regionCode != null && message.hasOwnProperty("regionCode"))
            if (!$util.isString(message.regionCode))
                return "regionCode: string expected";
        if (message.displayName != null && message.hasOwnProperty("displayName"))
            if (!$util.isString(message.displayName))
                return "displayName: string expected";
        return null;
    };

    /**
     * Creates a Country message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof Country
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {Country} Country
     */
    Country.fromObject = function fromObject(object) {
        if (object instanceof $root.Country)
            return object;
        var message = new $root.Country();
        if (object.regionCode != null)
            message.regionCode = String(object.regionCode);
        if (object.displayName != null)
            message.displayName = String(object.displayName);
        return message;
    };

    /**
     * Creates a plain object from a Country message. Also converts values to other types if specified.
     * @function toObject
     * @memberof Country
     * @static
     * @param {Country} message Country
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    Country.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        var object = {};
        if (options.defaults) {
            object.regionCode = "";
            object.displayName = "";
        }
        if (message.regionCode != null && message.hasOwnProperty("regionCode"))
            object.regionCode = message.regionCode;
        if (message.displayName != null && message.hasOwnProperty("displayName"))
            object.displayName = message.displayName;
        return object;
    };

    /**
     * Converts this Country to JSON.
     * @function toJSON
     * @memberof Country
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    Country.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return Country;
})();

$root.FormCheckbox = (function() {

    /**
     * Properties of a FormCheckbox.
     * @exports IFormCheckbox
     * @interface IFormCheckbox
     * @property {string|null} [description] FormCheckbox description
     * @property {boolean|null} [checked] FormCheckbox checked
     * @property {boolean|null} [required] FormCheckbox required
     * @property {string|null} [id] FormCheckbox id
     */

    /**
     * Constructs a new FormCheckbox.
     * @exports FormCheckbox
     * @classdesc Represents a FormCheckbox.
     * @implements IFormCheckbox
     * @constructor
     * @param {IFormCheckbox=} [properties] Properties to set
     */
    function FormCheckbox(properties) {
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * FormCheckbox description.
     * @member {string} description
     * @memberof FormCheckbox
     * @instance
     */
    FormCheckbox.prototype.description = "";

    /**
     * FormCheckbox checked.
     * @member {boolean} checked
     * @memberof FormCheckbox
     * @instance
     */
    FormCheckbox.prototype.checked = false;

    /**
     * FormCheckbox required.
     * @member {boolean} required
     * @memberof FormCheckbox
     * @instance
     */
    FormCheckbox.prototype.required = false;

    /**
     * FormCheckbox id.
     * @member {string} id
     * @memberof FormCheckbox
     * @instance
     */
    FormCheckbox.prototype.id = "";

    /**
     * Creates a new FormCheckbox instance using the specified properties.
     * @function create
     * @memberof FormCheckbox
     * @static
     * @param {IFormCheckbox=} [properties] Properties to set
     * @returns {FormCheckbox} FormCheckbox instance
     */
    FormCheckbox.create = function create(properties) {
        return new FormCheckbox(properties);
    };

    /**
     * Encodes the specified FormCheckbox message. Does not implicitly {@link FormCheckbox.verify|verify} messages.
     * @function encode
     * @memberof FormCheckbox
     * @static
     * @param {IFormCheckbox} message FormCheckbox message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    FormCheckbox.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.description != null && Object.hasOwnProperty.call(message, "description"))
            writer.uint32(/* id 1, wireType 2 =*/10).string(message.description);
        if (message.checked != null && Object.hasOwnProperty.call(message, "checked"))
            writer.uint32(/* id 2, wireType 0 =*/16).bool(message.checked);
        if (message.required != null && Object.hasOwnProperty.call(message, "required"))
            writer.uint32(/* id 3, wireType 0 =*/24).bool(message.required);
        if (message.id != null && Object.hasOwnProperty.call(message, "id"))
            writer.uint32(/* id 4, wireType 2 =*/34).string(message.id);
        return writer;
    };

    /**
     * Encodes the specified FormCheckbox message, length delimited. Does not implicitly {@link FormCheckbox.verify|verify} messages.
     * @function encodeDelimited
     * @memberof FormCheckbox
     * @static
     * @param {IFormCheckbox} message FormCheckbox message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    FormCheckbox.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a FormCheckbox message from the specified reader or buffer.
     * @function decode
     * @memberof FormCheckbox
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {FormCheckbox} FormCheckbox
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    FormCheckbox.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.FormCheckbox();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.description = reader.string();
                break;
            case 2:
                message.checked = reader.bool();
                break;
            case 3:
                message.required = reader.bool();
                break;
            case 4:
                message.id = reader.string();
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a FormCheckbox message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof FormCheckbox
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {FormCheckbox} FormCheckbox
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    FormCheckbox.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a FormCheckbox message.
     * @function verify
     * @memberof FormCheckbox
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    FormCheckbox.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.description != null && message.hasOwnProperty("description"))
            if (!$util.isString(message.description))
                return "description: string expected";
        if (message.checked != null && message.hasOwnProperty("checked"))
            if (typeof message.checked !== "boolean")
                return "checked: boolean expected";
        if (message.required != null && message.hasOwnProperty("required"))
            if (typeof message.required !== "boolean")
                return "required: boolean expected";
        if (message.id != null && message.hasOwnProperty("id"))
            if (!$util.isString(message.id))
                return "id: string expected";
        return null;
    };

    /**
     * Creates a FormCheckbox message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof FormCheckbox
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {FormCheckbox} FormCheckbox
     */
    FormCheckbox.fromObject = function fromObject(object) {
        if (object instanceof $root.FormCheckbox)
            return object;
        var message = new $root.FormCheckbox();
        if (object.description != null)
            message.description = String(object.description);
        if (object.checked != null)
            message.checked = Boolean(object.checked);
        if (object.required != null)
            message.required = Boolean(object.required);
        if (object.id != null)
            message.id = String(object.id);
        return message;
    };

    /**
     * Creates a plain object from a FormCheckbox message. Also converts values to other types if specified.
     * @function toObject
     * @memberof FormCheckbox
     * @static
     * @param {FormCheckbox} message FormCheckbox
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    FormCheckbox.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        var object = {};
        if (options.defaults) {
            object.description = "";
            object.checked = false;
            object.required = false;
            object.id = "";
        }
        if (message.description != null && message.hasOwnProperty("description"))
            object.description = message.description;
        if (message.checked != null && message.hasOwnProperty("checked"))
            object.checked = message.checked;
        if (message.required != null && message.hasOwnProperty("required"))
            object.required = message.required;
        if (message.id != null && message.hasOwnProperty("id"))
            object.id = message.id;
        return object;
    };

    /**
     * Converts this FormCheckbox to JSON.
     * @function toJSON
     * @memberof FormCheckbox
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    FormCheckbox.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return FormCheckbox;
})();

$root.InputValidationError = (function() {

    /**
     * Properties of an InputValidationError.
     * @exports IInputValidationError
     * @interface IInputValidationError
     * @property {number|null} [inputField] InputValidationError inputField
     * @property {string|null} [errorMessage] InputValidationError errorMessage
     */

    /**
     * Constructs a new InputValidationError.
     * @exports InputValidationError
     * @classdesc Represents an InputValidationError.
     * @implements IInputValidationError
     * @constructor
     * @param {IInputValidationError=} [properties] Properties to set
     */
    function InputValidationError(properties) {
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * InputValidationError inputField.
     * @member {number} inputField
     * @memberof InputValidationError
     * @instance
     */
    InputValidationError.prototype.inputField = 0;

    /**
     * InputValidationError errorMessage.
     * @member {string} errorMessage
     * @memberof InputValidationError
     * @instance
     */
    InputValidationError.prototype.errorMessage = "";

    /**
     * Creates a new InputValidationError instance using the specified properties.
     * @function create
     * @memberof InputValidationError
     * @static
     * @param {IInputValidationError=} [properties] Properties to set
     * @returns {InputValidationError} InputValidationError instance
     */
    InputValidationError.create = function create(properties) {
        return new InputValidationError(properties);
    };

    /**
     * Encodes the specified InputValidationError message. Does not implicitly {@link InputValidationError.verify|verify} messages.
     * @function encode
     * @memberof InputValidationError
     * @static
     * @param {IInputValidationError} message InputValidationError message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    InputValidationError.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.inputField != null && Object.hasOwnProperty.call(message, "inputField"))
            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.inputField);
        if (message.errorMessage != null && Object.hasOwnProperty.call(message, "errorMessage"))
            writer.uint32(/* id 2, wireType 2 =*/18).string(message.errorMessage);
        return writer;
    };

    /**
     * Encodes the specified InputValidationError message, length delimited. Does not implicitly {@link InputValidationError.verify|verify} messages.
     * @function encodeDelimited
     * @memberof InputValidationError
     * @static
     * @param {IInputValidationError} message InputValidationError message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    InputValidationError.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes an InputValidationError message from the specified reader or buffer.
     * @function decode
     * @memberof InputValidationError
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {InputValidationError} InputValidationError
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    InputValidationError.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.InputValidationError();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.inputField = reader.int32();
                break;
            case 2:
                message.errorMessage = reader.string();
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes an InputValidationError message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof InputValidationError
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {InputValidationError} InputValidationError
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    InputValidationError.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies an InputValidationError message.
     * @function verify
     * @memberof InputValidationError
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    InputValidationError.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.inputField != null && message.hasOwnProperty("inputField"))
            if (!$util.isInteger(message.inputField))
                return "inputField: integer expected";
        if (message.errorMessage != null && message.hasOwnProperty("errorMessage"))
            if (!$util.isString(message.errorMessage))
                return "errorMessage: string expected";
        return null;
    };

    /**
     * Creates an InputValidationError message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof InputValidationError
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {InputValidationError} InputValidationError
     */
    InputValidationError.fromObject = function fromObject(object) {
        if (object instanceof $root.InputValidationError)
            return object;
        var message = new $root.InputValidationError();
        if (object.inputField != null)
            message.inputField = object.inputField | 0;
        if (object.errorMessage != null)
            message.errorMessage = String(object.errorMessage);
        return message;
    };

    /**
     * Creates a plain object from an InputValidationError message. Also converts values to other types if specified.
     * @function toObject
     * @memberof InputValidationError
     * @static
     * @param {InputValidationError} message InputValidationError
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    InputValidationError.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        var object = {};
        if (options.defaults) {
            object.inputField = 0;
            object.errorMessage = "";
        }
        if (message.inputField != null && message.hasOwnProperty("inputField"))
            object.inputField = message.inputField;
        if (message.errorMessage != null && message.hasOwnProperty("errorMessage"))
            object.errorMessage = message.errorMessage;
        return object;
    };

    /**
     * Converts this InputValidationError to JSON.
     * @function toJSON
     * @memberof InputValidationError
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    InputValidationError.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return InputValidationError;
})();

$root.WebViewChallenge = (function() {

    /**
     * Properties of a WebViewChallenge.
     * @exports IWebViewChallenge
     * @interface IWebViewChallenge
     * @property {string|null} [startUrl] WebViewChallenge startUrl
     * @property {string|null} [targetUrlRegexp] WebViewChallenge targetUrlRegexp
     * @property {string|null} [cancelButtonDisplayLabel] WebViewChallenge cancelButtonDisplayLabel
     * @property {string|null} [responseTargetUrlParam] WebViewChallenge responseTargetUrlParam
     * @property {string|null} [cancelUrlRegexp] WebViewChallenge cancelUrlRegexp
     * @property {string|null} [title] WebViewChallenge title
     */

    /**
     * Constructs a new WebViewChallenge.
     * @exports WebViewChallenge
     * @classdesc Represents a WebViewChallenge.
     * @implements IWebViewChallenge
     * @constructor
     * @param {IWebViewChallenge=} [properties] Properties to set
     */
    function WebViewChallenge(properties) {
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * WebViewChallenge startUrl.
     * @member {string} startUrl
     * @memberof WebViewChallenge
     * @instance
     */
    WebViewChallenge.prototype.startUrl = "";

    /**
     * WebViewChallenge targetUrlRegexp.
     * @member {string} targetUrlRegexp
     * @memberof WebViewChallenge
     * @instance
     */
    WebViewChallenge.prototype.targetUrlRegexp = "";

    /**
     * WebViewChallenge cancelButtonDisplayLabel.
     * @member {string} cancelButtonDisplayLabel
     * @memberof WebViewChallenge
     * @instance
     */
    WebViewChallenge.prototype.cancelButtonDisplayLabel = "";

    /**
     * WebViewChallenge responseTargetUrlParam.
     * @member {string} responseTargetUrlParam
     * @memberof WebViewChallenge
     * @instance
     */
    WebViewChallenge.prototype.responseTargetUrlParam = "";

    /**
     * WebViewChallenge cancelUrlRegexp.
     * @member {string} cancelUrlRegexp
     * @memberof WebViewChallenge
     * @instance
     */
    WebViewChallenge.prototype.cancelUrlRegexp = "";

    /**
     * WebViewChallenge title.
     * @member {string} title
     * @memberof WebViewChallenge
     * @instance
     */
    WebViewChallenge.prototype.title = "";

    /**
     * Creates a new WebViewChallenge instance using the specified properties.
     * @function create
     * @memberof WebViewChallenge
     * @static
     * @param {IWebViewChallenge=} [properties] Properties to set
     * @returns {WebViewChallenge} WebViewChallenge instance
     */
    WebViewChallenge.create = function create(properties) {
        return new WebViewChallenge(properties);
    };

    /**
     * Encodes the specified WebViewChallenge message. Does not implicitly {@link WebViewChallenge.verify|verify} messages.
     * @function encode
     * @memberof WebViewChallenge
     * @static
     * @param {IWebViewChallenge} message WebViewChallenge message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    WebViewChallenge.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.startUrl != null && Object.hasOwnProperty.call(message, "startUrl"))
            writer.uint32(/* id 1, wireType 2 =*/10).string(message.startUrl);
        if (message.targetUrlRegexp != null && Object.hasOwnProperty.call(message, "targetUrlRegexp"))
            writer.uint32(/* id 2, wireType 2 =*/18).string(message.targetUrlRegexp);
        if (message.cancelButtonDisplayLabel != null && Object.hasOwnProperty.call(message, "cancelButtonDisplayLabel"))
            writer.uint32(/* id 3, wireType 2 =*/26).string(message.cancelButtonDisplayLabel);
        if (message.responseTargetUrlParam != null && Object.hasOwnProperty.call(message, "responseTargetUrlParam"))
            writer.uint32(/* id 4, wireType 2 =*/34).string(message.responseTargetUrlParam);
        if (message.cancelUrlRegexp != null && Object.hasOwnProperty.call(message, "cancelUrlRegexp"))
            writer.uint32(/* id 5, wireType 2 =*/42).string(message.cancelUrlRegexp);
        if (message.title != null && Object.hasOwnProperty.call(message, "title"))
            writer.uint32(/* id 6, wireType 2 =*/50).string(message.title);
        return writer;
    };

    /**
     * Encodes the specified WebViewChallenge message, length delimited. Does not implicitly {@link WebViewChallenge.verify|verify} messages.
     * @function encodeDelimited
     * @memberof WebViewChallenge
     * @static
     * @param {IWebViewChallenge} message WebViewChallenge message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    WebViewChallenge.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a WebViewChallenge message from the specified reader or buffer.
     * @function decode
     * @memberof WebViewChallenge
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {WebViewChallenge} WebViewChallenge
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    WebViewChallenge.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.WebViewChallenge();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.startUrl = reader.string();
                break;
            case 2:
                message.targetUrlRegexp = reader.string();
                break;
            case 3:
                message.cancelButtonDisplayLabel = reader.string();
                break;
            case 4:
                message.responseTargetUrlParam = reader.string();
                break;
            case 5:
                message.cancelUrlRegexp = reader.string();
                break;
            case 6:
                message.title = reader.string();
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a WebViewChallenge message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof WebViewChallenge
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {WebViewChallenge} WebViewChallenge
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    WebViewChallenge.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a WebViewChallenge message.
     * @function verify
     * @memberof WebViewChallenge
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    WebViewChallenge.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.startUrl != null && message.hasOwnProperty("startUrl"))
            if (!$util.isString(message.startUrl))
                return "startUrl: string expected";
        if (message.targetUrlRegexp != null && message.hasOwnProperty("targetUrlRegexp"))
            if (!$util.isString(message.targetUrlRegexp))
                return "targetUrlRegexp: string expected";
        if (message.cancelButtonDisplayLabel != null && message.hasOwnProperty("cancelButtonDisplayLabel"))
            if (!$util.isString(message.cancelButtonDisplayLabel))
                return "cancelButtonDisplayLabel: string expected";
        if (message.responseTargetUrlParam != null && message.hasOwnProperty("responseTargetUrlParam"))
            if (!$util.isString(message.responseTargetUrlParam))
                return "responseTargetUrlParam: string expected";
        if (message.cancelUrlRegexp != null && message.hasOwnProperty("cancelUrlRegexp"))
            if (!$util.isString(message.cancelUrlRegexp))
                return "cancelUrlRegexp: string expected";
        if (message.title != null && message.hasOwnProperty("title"))
            if (!$util.isString(message.title))
                return "title: string expected";
        return null;
    };

    /**
     * Creates a WebViewChallenge message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof WebViewChallenge
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {WebViewChallenge} WebViewChallenge
     */
    WebViewChallenge.fromObject = function fromObject(object) {
        if (object instanceof $root.WebViewChallenge)
            return object;
        var message = new $root.WebViewChallenge();
        if (object.startUrl != null)
            message.startUrl = String(object.startUrl);
        if (object.targetUrlRegexp != null)
            message.targetUrlRegexp = String(object.targetUrlRegexp);
        if (object.cancelButtonDisplayLabel != null)
            message.cancelButtonDisplayLabel = String(object.cancelButtonDisplayLabel);
        if (object.responseTargetUrlParam != null)
            message.responseTargetUrlParam = String(object.responseTargetUrlParam);
        if (object.cancelUrlRegexp != null)
            message.cancelUrlRegexp = String(object.cancelUrlRegexp);
        if (object.title != null)
            message.title = String(object.title);
        return message;
    };

    /**
     * Creates a plain object from a WebViewChallenge message. Also converts values to other types if specified.
     * @function toObject
     * @memberof WebViewChallenge
     * @static
     * @param {WebViewChallenge} message WebViewChallenge
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    WebViewChallenge.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        var object = {};
        if (options.defaults) {
            object.startUrl = "";
            object.targetUrlRegexp = "";
            object.cancelButtonDisplayLabel = "";
            object.responseTargetUrlParam = "";
            object.cancelUrlRegexp = "";
            object.title = "";
        }
        if (message.startUrl != null && message.hasOwnProperty("startUrl"))
            object.startUrl = message.startUrl;
        if (message.targetUrlRegexp != null && message.hasOwnProperty("targetUrlRegexp"))
            object.targetUrlRegexp = message.targetUrlRegexp;
        if (message.cancelButtonDisplayLabel != null && message.hasOwnProperty("cancelButtonDisplayLabel"))
            object.cancelButtonDisplayLabel = message.cancelButtonDisplayLabel;
        if (message.responseTargetUrlParam != null && message.hasOwnProperty("responseTargetUrlParam"))
            object.responseTargetUrlParam = message.responseTargetUrlParam;
        if (message.cancelUrlRegexp != null && message.hasOwnProperty("cancelUrlRegexp"))
            object.cancelUrlRegexp = message.cancelUrlRegexp;
        if (message.title != null && message.hasOwnProperty("title"))
            object.title = message.title;
        return object;
    };

    /**
     * Converts this WebViewChallenge to JSON.
     * @function toJSON
     * @memberof WebViewChallenge
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    WebViewChallenge.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return WebViewChallenge;
})();

$root.AddCreditCardPromoOffer = (function() {

    /**
     * Properties of an AddCreditCardPromoOffer.
     * @exports IAddCreditCardPromoOffer
     * @interface IAddCreditCardPromoOffer
     * @property {string|null} [headerText] AddCreditCardPromoOffer headerText
     * @property {string|null} [descriptionHtml] AddCreditCardPromoOffer descriptionHtml
     * @property {IImage|null} [image] AddCreditCardPromoOffer image
     * @property {string|null} [introductoryTextHtml] AddCreditCardPromoOffer introductoryTextHtml
     * @property {string|null} [offerTitle] AddCreditCardPromoOffer offerTitle
     * @property {string|null} [noActionDescription] AddCreditCardPromoOffer noActionDescription
     * @property {string|null} [termsAndConditionsHtml] AddCreditCardPromoOffer termsAndConditionsHtml
     */

    /**
     * Constructs a new AddCreditCardPromoOffer.
     * @exports AddCreditCardPromoOffer
     * @classdesc Represents an AddCreditCardPromoOffer.
     * @implements IAddCreditCardPromoOffer
     * @constructor
     * @param {IAddCreditCardPromoOffer=} [properties] Properties to set
     */
    function AddCreditCardPromoOffer(properties) {
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * AddCreditCardPromoOffer headerText.
     * @member {string} headerText
     * @memberof AddCreditCardPromoOffer
     * @instance
     */
    AddCreditCardPromoOffer.prototype.headerText = "";

    /**
     * AddCreditCardPromoOffer descriptionHtml.
     * @member {string} descriptionHtml
     * @memberof AddCreditCardPromoOffer
     * @instance
     */
    AddCreditCardPromoOffer.prototype.descriptionHtml = "";

    /**
     * AddCreditCardPromoOffer image.
     * @member {IImage|null|undefined} image
     * @memberof AddCreditCardPromoOffer
     * @instance
     */
    AddCreditCardPromoOffer.prototype.image = null;

    /**
     * AddCreditCardPromoOffer introductoryTextHtml.
     * @member {string} introductoryTextHtml
     * @memberof AddCreditCardPromoOffer
     * @instance
     */
    AddCreditCardPromoOffer.prototype.introductoryTextHtml = "";

    /**
     * AddCreditCardPromoOffer offerTitle.
     * @member {string} offerTitle
     * @memberof AddCreditCardPromoOffer
     * @instance
     */
    AddCreditCardPromoOffer.prototype.offerTitle = "";

    /**
     * AddCreditCardPromoOffer noActionDescription.
     * @member {string} noActionDescription
     * @memberof AddCreditCardPromoOffer
     * @instance
     */
    AddCreditCardPromoOffer.prototype.noActionDescription = "";

    /**
     * AddCreditCardPromoOffer termsAndConditionsHtml.
     * @member {string} termsAndConditionsHtml
     * @memberof AddCreditCardPromoOffer
     * @instance
     */
    AddCreditCardPromoOffer.prototype.termsAndConditionsHtml = "";

    /**
     * Creates a new AddCreditCardPromoOffer instance using the specified properties.
     * @function create
     * @memberof AddCreditCardPromoOffer
     * @static
     * @param {IAddCreditCardPromoOffer=} [properties] Properties to set
     * @returns {AddCreditCardPromoOffer} AddCreditCardPromoOffer instance
     */
    AddCreditCardPromoOffer.create = function create(properties) {
        return new AddCreditCardPromoOffer(properties);
    };

    /**
     * Encodes the specified AddCreditCardPromoOffer message. Does not implicitly {@link AddCreditCardPromoOffer.verify|verify} messages.
     * @function encode
     * @memberof AddCreditCardPromoOffer
     * @static
     * @param {IAddCreditCardPromoOffer} message AddCreditCardPromoOffer message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    AddCreditCardPromoOffer.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.headerText != null && Object.hasOwnProperty.call(message, "headerText"))
            writer.uint32(/* id 1, wireType 2 =*/10).string(message.headerText);
        if (message.descriptionHtml != null && Object.hasOwnProperty.call(message, "descriptionHtml"))
            writer.uint32(/* id 2, wireType 2 =*/18).string(message.descriptionHtml);
        if (message.image != null && Object.hasOwnProperty.call(message, "image"))
            $root.Image.encode(message.image, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
        if (message.introductoryTextHtml != null && Object.hasOwnProperty.call(message, "introductoryTextHtml"))
            writer.uint32(/* id 4, wireType 2 =*/34).string(message.introductoryTextHtml);
        if (message.offerTitle != null && Object.hasOwnProperty.call(message, "offerTitle"))
            writer.uint32(/* id 5, wireType 2 =*/42).string(message.offerTitle);
        if (message.noActionDescription != null && Object.hasOwnProperty.call(message, "noActionDescription"))
            writer.uint32(/* id 6, wireType 2 =*/50).string(message.noActionDescription);
        if (message.termsAndConditionsHtml != null && Object.hasOwnProperty.call(message, "termsAndConditionsHtml"))
            writer.uint32(/* id 7, wireType 2 =*/58).string(message.termsAndConditionsHtml);
        return writer;
    };

    /**
     * Encodes the specified AddCreditCardPromoOffer message, length delimited. Does not implicitly {@link AddCreditCardPromoOffer.verify|verify} messages.
     * @function encodeDelimited
     * @memberof AddCreditCardPromoOffer
     * @static
     * @param {IAddCreditCardPromoOffer} message AddCreditCardPromoOffer message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    AddCreditCardPromoOffer.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes an AddCreditCardPromoOffer message from the specified reader or buffer.
     * @function decode
     * @memberof AddCreditCardPromoOffer
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {AddCreditCardPromoOffer} AddCreditCardPromoOffer
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    AddCreditCardPromoOffer.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.AddCreditCardPromoOffer();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.headerText = reader.string();
                break;
            case 2:
                message.descriptionHtml = reader.string();
                break;
            case 3:
                message.image = $root.Image.decode(reader, reader.uint32());
                break;
            case 4:
                message.introductoryTextHtml = reader.string();
                break;
            case 5:
                message.offerTitle = reader.string();
                break;
            case 6:
                message.noActionDescription = reader.string();
                break;
            case 7:
                message.termsAndConditionsHtml = reader.string();
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes an AddCreditCardPromoOffer message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof AddCreditCardPromoOffer
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {AddCreditCardPromoOffer} AddCreditCardPromoOffer
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    AddCreditCardPromoOffer.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies an AddCreditCardPromoOffer message.
     * @function verify
     * @memberof AddCreditCardPromoOffer
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    AddCreditCardPromoOffer.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.headerText != null && message.hasOwnProperty("headerText"))
            if (!$util.isString(message.headerText))
                return "headerText: string expected";
        if (message.descriptionHtml != null && message.hasOwnProperty("descriptionHtml"))
            if (!$util.isString(message.descriptionHtml))
                return "descriptionHtml: string expected";
        if (message.image != null && message.hasOwnProperty("image")) {
            var error = $root.Image.verify(message.image);
            if (error)
                return "image." + error;
        }
        if (message.introductoryTextHtml != null && message.hasOwnProperty("introductoryTextHtml"))
            if (!$util.isString(message.introductoryTextHtml))
                return "introductoryTextHtml: string expected";
        if (message.offerTitle != null && message.hasOwnProperty("offerTitle"))
            if (!$util.isString(message.offerTitle))
                return "offerTitle: string expected";
        if (message.noActionDescription != null && message.hasOwnProperty("noActionDescription"))
            if (!$util.isString(message.noActionDescription))
                return "noActionDescription: string expected";
        if (message.termsAndConditionsHtml != null && message.hasOwnProperty("termsAndConditionsHtml"))
            if (!$util.isString(message.termsAndConditionsHtml))
                return "termsAndConditionsHtml: string expected";
        return null;
    };

    /**
     * Creates an AddCreditCardPromoOffer message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof AddCreditCardPromoOffer
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {AddCreditCardPromoOffer} AddCreditCardPromoOffer
     */
    AddCreditCardPromoOffer.fromObject = function fromObject(object) {
        if (object instanceof $root.AddCreditCardPromoOffer)
            return object;
        var message = new $root.AddCreditCardPromoOffer();
        if (object.headerText != null)
            message.headerText = String(object.headerText);
        if (object.descriptionHtml != null)
            message.descriptionHtml = String(object.descriptionHtml);
        if (object.image != null) {
            if (typeof object.image !== "object")
                throw TypeError(".AddCreditCardPromoOffer.image: object expected");
            message.image = $root.Image.fromObject(object.image);
        }
        if (object.introductoryTextHtml != null)
            message.introductoryTextHtml = String(object.introductoryTextHtml);
        if (object.offerTitle != null)
            message.offerTitle = String(object.offerTitle);
        if (object.noActionDescription != null)
            message.noActionDescription = String(object.noActionDescription);
        if (object.termsAndConditionsHtml != null)
            message.termsAndConditionsHtml = String(object.termsAndConditionsHtml);
        return message;
    };

    /**
     * Creates a plain object from an AddCreditCardPromoOffer message. Also converts values to other types if specified.
     * @function toObject
     * @memberof AddCreditCardPromoOffer
     * @static
     * @param {AddCreditCardPromoOffer} message AddCreditCardPromoOffer
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    AddCreditCardPromoOffer.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        var object = {};
        if (options.defaults) {
            object.headerText = "";
            object.descriptionHtml = "";
            object.image = null;
            object.introductoryTextHtml = "";
            object.offerTitle = "";
            object.noActionDescription = "";
            object.termsAndConditionsHtml = "";
        }
        if (message.headerText != null && message.hasOwnProperty("headerText"))
            object.headerText = message.headerText;
        if (message.descriptionHtml != null && message.hasOwnProperty("descriptionHtml"))
            object.descriptionHtml = message.descriptionHtml;
        if (message.image != null && message.hasOwnProperty("image"))
            object.image = $root.Image.toObject(message.image, options);
        if (message.introductoryTextHtml != null && message.hasOwnProperty("introductoryTextHtml"))
            object.introductoryTextHtml = message.introductoryTextHtml;
        if (message.offerTitle != null && message.hasOwnProperty("offerTitle"))
            object.offerTitle = message.offerTitle;
        if (message.noActionDescription != null && message.hasOwnProperty("noActionDescription"))
            object.noActionDescription = message.noActionDescription;
        if (message.termsAndConditionsHtml != null && message.hasOwnProperty("termsAndConditionsHtml"))
            object.termsAndConditionsHtml = message.termsAndConditionsHtml;
        return object;
    };

    /**
     * Converts this AddCreditCardPromoOffer to JSON.
     * @function toJSON
     * @memberof AddCreditCardPromoOffer
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    AddCreditCardPromoOffer.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return AddCreditCardPromoOffer;
})();

$root.AvailablePromoOffer = (function() {

    /**
     * Properties of an AvailablePromoOffer.
     * @exports IAvailablePromoOffer
     * @interface IAvailablePromoOffer
     * @property {IAddCreditCardPromoOffer|null} [addCreditCardOffer] AvailablePromoOffer addCreditCardOffer
     */

    /**
     * Constructs a new AvailablePromoOffer.
     * @exports AvailablePromoOffer
     * @classdesc Represents an AvailablePromoOffer.
     * @implements IAvailablePromoOffer
     * @constructor
     * @param {IAvailablePromoOffer=} [properties] Properties to set
     */
    function AvailablePromoOffer(properties) {
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * AvailablePromoOffer addCreditCardOffer.
     * @member {IAddCreditCardPromoOffer|null|undefined} addCreditCardOffer
     * @memberof AvailablePromoOffer
     * @instance
     */
    AvailablePromoOffer.prototype.addCreditCardOffer = null;

    /**
     * Creates a new AvailablePromoOffer instance using the specified properties.
     * @function create
     * @memberof AvailablePromoOffer
     * @static
     * @param {IAvailablePromoOffer=} [properties] Properties to set
     * @returns {AvailablePromoOffer} AvailablePromoOffer instance
     */
    AvailablePromoOffer.create = function create(properties) {
        return new AvailablePromoOffer(properties);
    };

    /**
     * Encodes the specified AvailablePromoOffer message. Does not implicitly {@link AvailablePromoOffer.verify|verify} messages.
     * @function encode
     * @memberof AvailablePromoOffer
     * @static
     * @param {IAvailablePromoOffer} message AvailablePromoOffer message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    AvailablePromoOffer.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.addCreditCardOffer != null && Object.hasOwnProperty.call(message, "addCreditCardOffer"))
            $root.AddCreditCardPromoOffer.encode(message.addCreditCardOffer, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
        return writer;
    };

    /**
     * Encodes the specified AvailablePromoOffer message, length delimited. Does not implicitly {@link AvailablePromoOffer.verify|verify} messages.
     * @function encodeDelimited
     * @memberof AvailablePromoOffer
     * @static
     * @param {IAvailablePromoOffer} message AvailablePromoOffer message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    AvailablePromoOffer.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes an AvailablePromoOffer message from the specified reader or buffer.
     * @function decode
     * @memberof AvailablePromoOffer
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {AvailablePromoOffer} AvailablePromoOffer
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    AvailablePromoOffer.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.AvailablePromoOffer();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.addCreditCardOffer = $root.AddCreditCardPromoOffer.decode(reader, reader.uint32());
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes an AvailablePromoOffer message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof AvailablePromoOffer
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {AvailablePromoOffer} AvailablePromoOffer
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    AvailablePromoOffer.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies an AvailablePromoOffer message.
     * @function verify
     * @memberof AvailablePromoOffer
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    AvailablePromoOffer.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.addCreditCardOffer != null && message.hasOwnProperty("addCreditCardOffer")) {
            var error = $root.AddCreditCardPromoOffer.verify(message.addCreditCardOffer);
            if (error)
                return "addCreditCardOffer." + error;
        }
        return null;
    };

    /**
     * Creates an AvailablePromoOffer message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof AvailablePromoOffer
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {AvailablePromoOffer} AvailablePromoOffer
     */
    AvailablePromoOffer.fromObject = function fromObject(object) {
        if (object instanceof $root.AvailablePromoOffer)
            return object;
        var message = new $root.AvailablePromoOffer();
        if (object.addCreditCardOffer != null) {
            if (typeof object.addCreditCardOffer !== "object")
                throw TypeError(".AvailablePromoOffer.addCreditCardOffer: object expected");
            message.addCreditCardOffer = $root.AddCreditCardPromoOffer.fromObject(object.addCreditCardOffer);
        }
        return message;
    };

    /**
     * Creates a plain object from an AvailablePromoOffer message. Also converts values to other types if specified.
     * @function toObject
     * @memberof AvailablePromoOffer
     * @static
     * @param {AvailablePromoOffer} message AvailablePromoOffer
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    AvailablePromoOffer.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        var object = {};
        if (options.defaults)
            object.addCreditCardOffer = null;
        if (message.addCreditCardOffer != null && message.hasOwnProperty("addCreditCardOffer"))
            object.addCreditCardOffer = $root.AddCreditCardPromoOffer.toObject(message.addCreditCardOffer, options);
        return object;
    };

    /**
     * Converts this AvailablePromoOffer to JSON.
     * @function toJSON
     * @memberof AvailablePromoOffer
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    AvailablePromoOffer.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return AvailablePromoOffer;
})();

$root.CheckPromoOfferResponse = (function() {

    /**
     * Properties of a CheckPromoOfferResponse.
     * @exports ICheckPromoOfferResponse
     * @interface ICheckPromoOfferResponse
     * @property {Array.<IAvailablePromoOffer>|null} [availableOffer] CheckPromoOfferResponse availableOffer
     * @property {IRedeemedPromoOffer|null} [redeemedOffer] CheckPromoOfferResponse redeemedOffer
     * @property {boolean|null} [checkoutTokenRequired] CheckPromoOfferResponse checkoutTokenRequired
     */

    /**
     * Constructs a new CheckPromoOfferResponse.
     * @exports CheckPromoOfferResponse
     * @classdesc Represents a CheckPromoOfferResponse.
     * @implements ICheckPromoOfferResponse
     * @constructor
     * @param {ICheckPromoOfferResponse=} [properties] Properties to set
     */
    function CheckPromoOfferResponse(properties) {
        this.availableOffer = [];
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * CheckPromoOfferResponse availableOffer.
     * @member {Array.<IAvailablePromoOffer>} availableOffer
     * @memberof CheckPromoOfferResponse
     * @instance
     */
    CheckPromoOfferResponse.prototype.availableOffer = $util.emptyArray;

    /**
     * CheckPromoOfferResponse redeemedOffer.
     * @member {IRedeemedPromoOffer|null|undefined} redeemedOffer
     * @memberof CheckPromoOfferResponse
     * @instance
     */
    CheckPromoOfferResponse.prototype.redeemedOffer = null;

    /**
     * CheckPromoOfferResponse checkoutTokenRequired.
     * @member {boolean} checkoutTokenRequired
     * @memberof CheckPromoOfferResponse
     * @instance
     */
    CheckPromoOfferResponse.prototype.checkoutTokenRequired = false;

    /**
     * Creates a new CheckPromoOfferResponse instance using the specified properties.
     * @function create
     * @memberof CheckPromoOfferResponse
     * @static
     * @param {ICheckPromoOfferResponse=} [properties] Properties to set
     * @returns {CheckPromoOfferResponse} CheckPromoOfferResponse instance
     */
    CheckPromoOfferResponse.create = function create(properties) {
        return new CheckPromoOfferResponse(properties);
    };

    /**
     * Encodes the specified CheckPromoOfferResponse message. Does not implicitly {@link CheckPromoOfferResponse.verify|verify} messages.
     * @function encode
     * @memberof CheckPromoOfferResponse
     * @static
     * @param {ICheckPromoOfferResponse} message CheckPromoOfferResponse message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    CheckPromoOfferResponse.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.availableOffer != null && message.availableOffer.length)
            for (var i = 0; i < message.availableOffer.length; ++i)
                $root.AvailablePromoOffer.encode(message.availableOffer[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
        if (message.redeemedOffer != null && Object.hasOwnProperty.call(message, "redeemedOffer"))
            $root.RedeemedPromoOffer.encode(message.redeemedOffer, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
        if (message.checkoutTokenRequired != null && Object.hasOwnProperty.call(message, "checkoutTokenRequired"))
            writer.uint32(/* id 3, wireType 0 =*/24).bool(message.checkoutTokenRequired);
        return writer;
    };

    /**
     * Encodes the specified CheckPromoOfferResponse message, length delimited. Does not implicitly {@link CheckPromoOfferResponse.verify|verify} messages.
     * @function encodeDelimited
     * @memberof CheckPromoOfferResponse
     * @static
     * @param {ICheckPromoOfferResponse} message CheckPromoOfferResponse message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    CheckPromoOfferResponse.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a CheckPromoOfferResponse message from the specified reader or buffer.
     * @function decode
     * @memberof CheckPromoOfferResponse
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CheckPromoOfferResponse} CheckPromoOfferResponse
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CheckPromoOfferResponse.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CheckPromoOfferResponse();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                if (!(message.availableOffer && message.availableOffer.length))
                    message.availableOffer = [];
                message.availableOffer.push($root.AvailablePromoOffer.decode(reader, reader.uint32()));
                break;
            case 2:
                message.redeemedOffer = $root.RedeemedPromoOffer.decode(reader, reader.uint32());
                break;
            case 3:
                message.checkoutTokenRequired = reader.bool();
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a CheckPromoOfferResponse message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof CheckPromoOfferResponse
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {CheckPromoOfferResponse} CheckPromoOfferResponse
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CheckPromoOfferResponse.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a CheckPromoOfferResponse message.
     * @function verify
     * @memberof CheckPromoOfferResponse
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    CheckPromoOfferResponse.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.availableOffer != null && message.hasOwnProperty("availableOffer")) {
            if (!Array.isArray(message.availableOffer))
                return "availableOffer: array expected";
            for (var i = 0; i < message.availableOffer.length; ++i) {
                var error = $root.AvailablePromoOffer.verify(message.availableOffer[i]);
                if (error)
                    return "availableOffer." + error;
            }
        }
        if (message.redeemedOffer != null && message.hasOwnProperty("redeemedOffer")) {
            var error = $root.RedeemedPromoOffer.verify(message.redeemedOffer);
            if (error)
                return "redeemedOffer." + error;
        }
        if (message.checkoutTokenRequired != null && message.hasOwnProperty("checkoutTokenRequired"))
            if (typeof message.checkoutTokenRequired !== "boolean")
                return "checkoutTokenRequired: boolean expected";
        return null;
    };

    /**
     * Creates a CheckPromoOfferResponse message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof CheckPromoOfferResponse
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {CheckPromoOfferResponse} CheckPromoOfferResponse
     */
    CheckPromoOfferResponse.fromObject = function fromObject(object) {
        if (object instanceof $root.CheckPromoOfferResponse)
            return object;
        var message = new $root.CheckPromoOfferResponse();
        if (object.availableOffer) {
            if (!Array.isArray(object.availableOffer))
                throw TypeError(".CheckPromoOfferResponse.availableOffer: array expected");
            message.availableOffer = [];
            for (var i = 0; i < object.availableOffer.length; ++i) {
                if (typeof object.availableOffer[i] !== "object")
                    throw TypeError(".CheckPromoOfferResponse.availableOffer: object expected");
                message.availableOffer[i] = $root.AvailablePromoOffer.fromObject(object.availableOffer[i]);
            }
        }
        if (object.redeemedOffer != null) {
            if (typeof object.redeemedOffer !== "object")
                throw TypeError(".CheckPromoOfferResponse.redeemedOffer: object expected");
            message.redeemedOffer = $root.RedeemedPromoOffer.fromObject(object.redeemedOffer);
        }
        if (object.checkoutTokenRequired != null)
            message.checkoutTokenRequired = Boolean(object.checkoutTokenRequired);
        return message;
    };

    /**
     * Creates a plain object from a CheckPromoOfferResponse message. Also converts values to other types if specified.
     * @function toObject
     * @memberof CheckPromoOfferResponse
     * @static
     * @param {CheckPromoOfferResponse} message CheckPromoOfferResponse
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    CheckPromoOfferResponse.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        var object = {};
        if (options.arrays || options.defaults)
            object.availableOffer = [];
        if (options.defaults) {
            object.redeemedOffer = null;
            object.checkoutTokenRequired = false;
        }
        if (message.availableOffer && message.availableOffer.length) {
            object.availableOffer = [];
            for (var j = 0; j < message.availableOffer.length; ++j)
                object.availableOffer[j] = $root.AvailablePromoOffer.toObject(message.availableOffer[j], options);
        }
        if (message.redeemedOffer != null && message.hasOwnProperty("redeemedOffer"))
            object.redeemedOffer = $root.RedeemedPromoOffer.toObject(message.redeemedOffer, options);
        if (message.checkoutTokenRequired != null && message.hasOwnProperty("checkoutTokenRequired"))
            object.checkoutTokenRequired = message.checkoutTokenRequired;
        return object;
    };

    /**
     * Converts this CheckPromoOfferResponse to JSON.
     * @function toJSON
     * @memberof CheckPromoOfferResponse
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    CheckPromoOfferResponse.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return CheckPromoOfferResponse;
})();

$root.RedeemedPromoOffer = (function() {

    /**
     * Properties of a RedeemedPromoOffer.
     * @exports IRedeemedPromoOffer
     * @interface IRedeemedPromoOffer
     * @property {string|null} [headerText] RedeemedPromoOffer headerText
     * @property {string|null} [descriptionHtml] RedeemedPromoOffer descriptionHtml
     * @property {IImage|null} [image] RedeemedPromoOffer image
     */

    /**
     * Constructs a new RedeemedPromoOffer.
     * @exports RedeemedPromoOffer
     * @classdesc Represents a RedeemedPromoOffer.
     * @implements IRedeemedPromoOffer
     * @constructor
     * @param {IRedeemedPromoOffer=} [properties] Properties to set
     */
    function RedeemedPromoOffer(properties) {
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * RedeemedPromoOffer headerText.
     * @member {string} headerText
     * @memberof RedeemedPromoOffer
     * @instance
     */
    RedeemedPromoOffer.prototype.headerText = "";

    /**
     * RedeemedPromoOffer descriptionHtml.
     * @member {string} descriptionHtml
     * @memberof RedeemedPromoOffer
     * @instance
     */
    RedeemedPromoOffer.prototype.descriptionHtml = "";

    /**
     * RedeemedPromoOffer image.
     * @member {IImage|null|undefined} image
     * @memberof RedeemedPromoOffer
     * @instance
     */
    RedeemedPromoOffer.prototype.image = null;

    /**
     * Creates a new RedeemedPromoOffer instance using the specified properties.
     * @function create
     * @memberof RedeemedPromoOffer
     * @static
     * @param {IRedeemedPromoOffer=} [properties] Properties to set
     * @returns {RedeemedPromoOffer} RedeemedPromoOffer instance
     */
    RedeemedPromoOffer.create = function create(properties) {
        return new RedeemedPromoOffer(properties);
    };

    /**
     * Encodes the specified RedeemedPromoOffer message. Does not implicitly {@link RedeemedPromoOffer.verify|verify} messages.
     * @function encode
     * @memberof RedeemedPromoOffer
     * @static
     * @param {IRedeemedPromoOffer} message RedeemedPromoOffer message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    RedeemedPromoOffer.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.headerText != null && Object.hasOwnProperty.call(message, "headerText"))
            writer.uint32(/* id 1, wireType 2 =*/10).string(message.headerText);
        if (message.descriptionHtml != null && Object.hasOwnProperty.call(message, "descriptionHtml"))
            writer.uint32(/* id 2, wireType 2 =*/18).string(message.descriptionHtml);
        if (message.image != null && Object.hasOwnProperty.call(message, "image"))
            $root.Image.encode(message.image, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
        return writer;
    };

    /**
     * Encodes the specified RedeemedPromoOffer message, length delimited. Does not implicitly {@link RedeemedPromoOffer.verify|verify} messages.
     * @function encodeDelimited
     * @memberof RedeemedPromoOffer
     * @static
     * @param {IRedeemedPromoOffer} message RedeemedPromoOffer message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    RedeemedPromoOffer.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a RedeemedPromoOffer message from the specified reader or buffer.
     * @function decode
     * @memberof RedeemedPromoOffer
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {RedeemedPromoOffer} RedeemedPromoOffer
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    RedeemedPromoOffer.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.RedeemedPromoOffer();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.headerText = reader.string();
                break;
            case 2:
                message.descriptionHtml = reader.string();
                break;
            case 3:
                message.image = $root.Image.decode(reader, reader.uint32());
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a RedeemedPromoOffer message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof RedeemedPromoOffer
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {RedeemedPromoOffer} RedeemedPromoOffer
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    RedeemedPromoOffer.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a RedeemedPromoOffer message.
     * @function verify
     * @memberof RedeemedPromoOffer
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    RedeemedPromoOffer.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.headerText != null && message.hasOwnProperty("headerText"))
            if (!$util.isString(message.headerText))
                return "headerText: string expected";
        if (message.descriptionHtml != null && message.hasOwnProperty("descriptionHtml"))
            if (!$util.isString(message.descriptionHtml))
                return "descriptionHtml: string expected";
        if (message.image != null && message.hasOwnProperty("image")) {
            var error = $root.Image.verify(message.image);
            if (error)
                return "image." + error;
        }
        return null;
    };

    /**
     * Creates a RedeemedPromoOffer message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof RedeemedPromoOffer
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {RedeemedPromoOffer} RedeemedPromoOffer
     */
    RedeemedPromoOffer.fromObject = function fromObject(object) {
        if (object instanceof $root.RedeemedPromoOffer)
            return object;
        var message = new $root.RedeemedPromoOffer();
        if (object.headerText != null)
            message.headerText = String(object.headerText);
        if (object.descriptionHtml != null)
            message.descriptionHtml = String(object.descriptionHtml);
        if (object.image != null) {
            if (typeof object.image !== "object")
                throw TypeError(".RedeemedPromoOffer.image: object expected");
            message.image = $root.Image.fromObject(object.image);
        }
        return message;
    };

    /**
     * Creates a plain object from a RedeemedPromoOffer message. Also converts values to other types if specified.
     * @function toObject
     * @memberof RedeemedPromoOffer
     * @static
     * @param {RedeemedPromoOffer} message RedeemedPromoOffer
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    RedeemedPromoOffer.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        var object = {};
        if (options.defaults) {
            object.headerText = "";
            object.descriptionHtml = "";
            object.image = null;
        }
        if (message.headerText != null && message.hasOwnProperty("headerText"))
            object.headerText = message.headerText;
        if (message.descriptionHtml != null && message.hasOwnProperty("descriptionHtml"))
            object.descriptionHtml = message.descriptionHtml;
        if (message.image != null && message.hasOwnProperty("image"))
            object.image = $root.Image.toObject(message.image, options);
        return object;
    };

    /**
     * Converts this RedeemedPromoOffer to JSON.
     * @function toJSON
     * @memberof RedeemedPromoOffer
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    RedeemedPromoOffer.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return RedeemedPromoOffer;
})();

$root.DocId = (function() {

    /**
     * Properties of a DocId.
     * @exports IDocId
     * @interface IDocId
     * @property {string|null} [backendDocId] DocId backendDocId
     * @property {number|null} [type] DocId type
     * @property {number|null} [backend] DocId backend
     */

    /**
     * Constructs a new DocId.
     * @exports DocId
     * @classdesc Represents a DocId.
     * @implements IDocId
     * @constructor
     * @param {IDocId=} [properties] Properties to set
     */
    function DocId(properties) {
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * DocId backendDocId.
     * @member {string} backendDocId
     * @memberof DocId
     * @instance
     */
    DocId.prototype.backendDocId = "";

    /**
     * DocId type.
     * @member {number} type
     * @memberof DocId
     * @instance
     */
    DocId.prototype.type = 1;

    /**
     * DocId backend.
     * @member {number} backend
     * @memberof DocId
     * @instance
     */
    DocId.prototype.backend = 0;

    /**
     * Creates a new DocId instance using the specified properties.
     * @function create
     * @memberof DocId
     * @static
     * @param {IDocId=} [properties] Properties to set
     * @returns {DocId} DocId instance
     */
    DocId.create = function create(properties) {
        return new DocId(properties);
    };

    /**
     * Encodes the specified DocId message. Does not implicitly {@link DocId.verify|verify} messages.
     * @function encode
     * @memberof DocId
     * @static
     * @param {IDocId} message DocId message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    DocId.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.backendDocId != null && Object.hasOwnProperty.call(message, "backendDocId"))
            writer.uint32(/* id 1, wireType 2 =*/10).string(message.backendDocId);
        if (message.type != null && Object.hasOwnProperty.call(message, "type"))
            writer.uint32(/* id 2, wireType 0 =*/16).int32(message.type);
        if (message.backend != null && Object.hasOwnProperty.call(message, "backend"))
            writer.uint32(/* id 3, wireType 0 =*/24).int32(message.backend);
        return writer;
    };

    /**
     * Encodes the specified DocId message, length delimited. Does not implicitly {@link DocId.verify|verify} messages.
     * @function encodeDelimited
     * @memberof DocId
     * @static
     * @param {IDocId} message DocId message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    DocId.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a DocId message from the specified reader or buffer.
     * @function decode
     * @memberof DocId
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {DocId} DocId
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    DocId.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.DocId();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.backendDocId = reader.string();
                break;
            case 2:
                message.type = reader.int32();
                break;
            case 3:
                message.backend = reader.int32();
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a DocId message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof DocId
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {DocId} DocId
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    DocId.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a DocId message.
     * @function verify
     * @memberof DocId
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    DocId.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.backendDocId != null && message.hasOwnProperty("backendDocId"))
            if (!$util.isString(message.backendDocId))
                return "backendDocId: string expected";
        if (message.type != null && message.hasOwnProperty("type"))
            if (!$util.isInteger(message.type))
                return "type: integer expected";
        if (message.backend != null && message.hasOwnProperty("backend"))
            if (!$util.isInteger(message.backend))
                return "backend: integer expected";
        return null;
    };

    /**
     * Creates a DocId message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof DocId
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {DocId} DocId
     */
    DocId.fromObject = function fromObject(object) {
        if (object instanceof $root.DocId)
            return object;
        var message = new $root.DocId();
        if (object.backendDocId != null)
            message.backendDocId = String(object.backendDocId);
        if (object.type != null)
            message.type = object.type | 0;
        if (object.backend != null)
            message.backend = object.backend | 0;
        return message;
    };

    /**
     * Creates a plain object from a DocId message. Also converts values to other types if specified.
     * @function toObject
     * @memberof DocId
     * @static
     * @param {DocId} message DocId
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    DocId.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        var object = {};
        if (options.defaults) {
            object.backendDocId = "";
            object.type = 1;
            object.backend = 0;
        }
        if (message.backendDocId != null && message.hasOwnProperty("backendDocId"))
            object.backendDocId = message.backendDocId;
        if (message.type != null && message.hasOwnProperty("type"))
            object.type = message.type;
        if (message.backend != null && message.hasOwnProperty("backend"))
            object.backend = message.backend;
        return object;
    };

    /**
     * Converts this DocId to JSON.
     * @function toJSON
     * @memberof DocId
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    DocId.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return DocId;
})();

$root.Install = (function() {

    /**
     * Properties of an Install.
     * @exports IInstall
     * @interface IInstall
     * @property {number|Long|null} [androidId] Install androidId
     * @property {number|null} [version] Install version
     * @property {boolean|null} [bundled] Install bundled
     * @property {boolean|null} [pending] Install pending
     * @property {number|Long|null} [lastUpdated] Install lastUpdated
     */

    /**
     * Constructs a new Install.
     * @exports Install
     * @classdesc Represents an Install.
     * @implements IInstall
     * @constructor
     * @param {IInstall=} [properties] Properties to set
     */
    function Install(properties) {
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * Install androidId.
     * @member {number|Long} androidId
     * @memberof Install
     * @instance
     */
    Install.prototype.androidId = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

    /**
     * Install version.
     * @member {number} version
     * @memberof Install
     * @instance
     */
    Install.prototype.version = 0;

    /**
     * Install bundled.
     * @member {boolean} bundled
     * @memberof Install
     * @instance
     */
    Install.prototype.bundled = false;

    /**
     * Install pending.
     * @member {boolean} pending
     * @memberof Install
     * @instance
     */
    Install.prototype.pending = false;

    /**
     * Install lastUpdated.
     * @member {number|Long} lastUpdated
     * @memberof Install
     * @instance
     */
    Install.prototype.lastUpdated = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

    /**
     * Creates a new Install instance using the specified properties.
     * @function create
     * @memberof Install
     * @static
     * @param {IInstall=} [properties] Properties to set
     * @returns {Install} Install instance
     */
    Install.create = function create(properties) {
        return new Install(properties);
    };

    /**
     * Encodes the specified Install message. Does not implicitly {@link Install.verify|verify} messages.
     * @function encode
     * @memberof Install
     * @static
     * @param {IInstall} message Install message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    Install.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.androidId != null && Object.hasOwnProperty.call(message, "androidId"))
            writer.uint32(/* id 1, wireType 1 =*/9).fixed64(message.androidId);
        if (message.version != null && Object.hasOwnProperty.call(message, "version"))
            writer.uint32(/* id 2, wireType 0 =*/16).int32(message.version);
        if (message.bundled != null && Object.hasOwnProperty.call(message, "bundled"))
            writer.uint32(/* id 3, wireType 0 =*/24).bool(message.bundled);
        if (message.pending != null && Object.hasOwnProperty.call(message, "pending"))
            writer.uint32(/* id 4, wireType 0 =*/32).bool(message.pending);
        if (message.lastUpdated != null && Object.hasOwnProperty.call(message, "lastUpdated"))
            writer.uint32(/* id 5, wireType 0 =*/40).int64(message.lastUpdated);
        return writer;
    };

    /**
     * Encodes the specified Install message, length delimited. Does not implicitly {@link Install.verify|verify} messages.
     * @function encodeDelimited
     * @memberof Install
     * @static
     * @param {IInstall} message Install message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    Install.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes an Install message from the specified reader or buffer.
     * @function decode
     * @memberof Install
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {Install} Install
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    Install.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Install();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.androidId = reader.fixed64();
                break;
            case 2:
                message.version = reader.int32();
                break;
            case 3:
                message.bundled = reader.bool();
                break;
            case 4:
                message.pending = reader.bool();
                break;
            case 5:
                message.lastUpdated = reader.int64();
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes an Install message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof Install
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {Install} Install
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    Install.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies an Install message.
     * @function verify
     * @memberof Install
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    Install.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.androidId != null && message.hasOwnProperty("androidId"))
            if (!$util.isInteger(message.androidId) && !(message.androidId && $util.isInteger(message.androidId.low) && $util.isInteger(message.androidId.high)))
                return "androidId: integer|Long expected";
        if (message.version != null && message.hasOwnProperty("version"))
            if (!$util.isInteger(message.version))
                return "version: integer expected";
        if (message.bundled != null && message.hasOwnProperty("bundled"))
            if (typeof message.bundled !== "boolean")
                return "bundled: boolean expected";
        if (message.pending != null && message.hasOwnProperty("pending"))
            if (typeof message.pending !== "boolean")
                return "pending: boolean expected";
        if (message.lastUpdated != null && message.hasOwnProperty("lastUpdated"))
            if (!$util.isInteger(message.lastUpdated) && !(message.lastUpdated && $util.isInteger(message.lastUpdated.low) && $util.isInteger(message.lastUpdated.high)))
                return "lastUpdated: integer|Long expected";
        return null;
    };

    /**
     * Creates an Install message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof Install
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {Install} Install
     */
    Install.fromObject = function fromObject(object) {
        if (object instanceof $root.Install)
            return object;
        var message = new $root.Install();
        if (object.androidId != null)
            if ($util.Long)
                (message.androidId = $util.Long.fromValue(object.androidId)).unsigned = false;
            else if (typeof object.androidId === "string")
                message.androidId = parseInt(object.androidId, 10);
            else if (typeof object.androidId === "number")
                message.androidId = object.androidId;
            else if (typeof object.androidId === "object")
                message.androidId = new $util.LongBits(object.androidId.low >>> 0, object.androidId.high >>> 0).toNumber();
        if (object.version != null)
            message.version = object.version | 0;
        if (object.bundled != null)
            message.bundled = Boolean(object.bundled);
        if (object.pending != null)
            message.pending = Boolean(object.pending);
        if (object.lastUpdated != null)
            if ($util.Long)
                (message.lastUpdated = $util.Long.fromValue(object.lastUpdated)).unsigned = false;
            else if (typeof object.lastUpdated === "string")
                message.lastUpdated = parseInt(object.lastUpdated, 10);
            else if (typeof object.lastUpdated === "number")
                message.lastUpdated = object.lastUpdated;
            else if (typeof object.lastUpdated === "object")
                message.lastUpdated = new $util.LongBits(object.lastUpdated.low >>> 0, object.lastUpdated.high >>> 0).toNumber();
        return message;
    };

    /**
     * Creates a plain object from an Install message. Also converts values to other types if specified.
     * @function toObject
     * @memberof Install
     * @static
     * @param {Install} message Install
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    Install.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        var object = {};
        if (options.defaults) {
            if ($util.Long) {
                var long = new $util.Long(0, 0, false);
                object.androidId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
            } else
                object.androidId = options.longs === String ? "0" : 0;
            object.version = 0;
            object.bundled = false;
            object.pending = false;
            if ($util.Long) {
                var long = new $util.Long(0, 0, false);
                object.lastUpdated = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
            } else
                object.lastUpdated = options.longs === String ? "0" : 0;
        }
        if (message.androidId != null && message.hasOwnProperty("androidId"))
            if (typeof message.androidId === "number")
                object.androidId = options.longs === String ? String(message.androidId) : message.androidId;
            else
                object.androidId = options.longs === String ? $util.Long.prototype.toString.call(message.androidId) : options.longs === Number ? new $util.LongBits(message.androidId.low >>> 0, message.androidId.high >>> 0).toNumber() : message.androidId;
        if (message.version != null && message.hasOwnProperty("version"))
            object.version = message.version;
        if (message.bundled != null && message.hasOwnProperty("bundled"))
            object.bundled = message.bundled;
        if (message.pending != null && message.hasOwnProperty("pending"))
            object.pending = message.pending;
        if (message.lastUpdated != null && message.hasOwnProperty("lastUpdated"))
            if (typeof message.lastUpdated === "number")
                object.lastUpdated = options.longs === String ? String(message.lastUpdated) : message.lastUpdated;
            else
                object.lastUpdated = options.longs === String ? $util.Long.prototype.toString.call(message.lastUpdated) : options.longs === Number ? new $util.LongBits(message.lastUpdated.low >>> 0, message.lastUpdated.high >>> 0).toNumber() : message.lastUpdated;
        return object;
    };

    /**
     * Converts this Install to JSON.
     * @function toJSON
     * @memberof Install
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    Install.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return Install;
})();

$root.GroupLicenseKey = (function() {

    /**
     * Properties of a GroupLicenseKey.
     * @exports IGroupLicenseKey
     * @interface IGroupLicenseKey
     * @property {number|Long|null} [dasherCustomerId] GroupLicenseKey dasherCustomerId
     * @property {IDocId|null} [docId] GroupLicenseKey docId
     * @property {number|null} [licensedOfferType] GroupLicenseKey licensedOfferType
     * @property {number|null} [type] GroupLicenseKey type
     * @property {number|null} [rentalPeriodDays] GroupLicenseKey rentalPeriodDays
     */

    /**
     * Constructs a new GroupLicenseKey.
     * @exports GroupLicenseKey
     * @classdesc Represents a GroupLicenseKey.
     * @implements IGroupLicenseKey
     * @constructor
     * @param {IGroupLicenseKey=} [properties] Properties to set
     */
    function GroupLicenseKey(properties) {
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * GroupLicenseKey dasherCustomerId.
     * @member {number|Long} dasherCustomerId
     * @memberof GroupLicenseKey
     * @instance
     */
    GroupLicenseKey.prototype.dasherCustomerId = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

    /**
     * GroupLicenseKey docId.
     * @member {IDocId|null|undefined} docId
     * @memberof GroupLicenseKey
     * @instance
     */
    GroupLicenseKey.prototype.docId = null;

    /**
     * GroupLicenseKey licensedOfferType.
     * @member {number} licensedOfferType
     * @memberof GroupLicenseKey
     * @instance
     */
    GroupLicenseKey.prototype.licensedOfferType = 1;

    /**
     * GroupLicenseKey type.
     * @member {number} type
     * @memberof GroupLicenseKey
     * @instance
     */
    GroupLicenseKey.prototype.type = 0;

    /**
     * GroupLicenseKey rentalPeriodDays.
     * @member {number} rentalPeriodDays
     * @memberof GroupLicenseKey
     * @instance
     */
    GroupLicenseKey.prototype.rentalPeriodDays = 0;

    /**
     * Creates a new GroupLicenseKey instance using the specified properties.
     * @function create
     * @memberof GroupLicenseKey
     * @static
     * @param {IGroupLicenseKey=} [properties] Properties to set
     * @returns {GroupLicenseKey} GroupLicenseKey instance
     */
    GroupLicenseKey.create = function create(properties) {
        return new GroupLicenseKey(properties);
    };

    /**
     * Encodes the specified GroupLicenseKey message. Does not implicitly {@link GroupLicenseKey.verify|verify} messages.
     * @function encode
     * @memberof GroupLicenseKey
     * @static
     * @param {IGroupLicenseKey} message GroupLicenseKey message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    GroupLicenseKey.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.dasherCustomerId != null && Object.hasOwnProperty.call(message, "dasherCustomerId"))
            writer.uint32(/* id 1, wireType 1 =*/9).fixed64(message.dasherCustomerId);
        if (message.docId != null && Object.hasOwnProperty.call(message, "docId"))
            $root.DocId.encode(message.docId, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
        if (message.licensedOfferType != null && Object.hasOwnProperty.call(message, "licensedOfferType"))
            writer.uint32(/* id 3, wireType 0 =*/24).int32(message.licensedOfferType);
        if (message.type != null && Object.hasOwnProperty.call(message, "type"))
            writer.uint32(/* id 4, wireType 0 =*/32).int32(message.type);
        if (message.rentalPeriodDays != null && Object.hasOwnProperty.call(message, "rentalPeriodDays"))
            writer.uint32(/* id 5, wireType 0 =*/40).int32(message.rentalPeriodDays);
        return writer;
    };

    /**
     * Encodes the specified GroupLicenseKey message, length delimited. Does not implicitly {@link GroupLicenseKey.verify|verify} messages.
     * @function encodeDelimited
     * @memberof GroupLicenseKey
     * @static
     * @param {IGroupLicenseKey} message GroupLicenseKey message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    GroupLicenseKey.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a GroupLicenseKey message from the specified reader or buffer.
     * @function decode
     * @memberof GroupLicenseKey
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {GroupLicenseKey} GroupLicenseKey
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    GroupLicenseKey.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.GroupLicenseKey();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.dasherCustomerId = reader.fixed64();
                break;
            case 2:
                message.docId = $root.DocId.decode(reader, reader.uint32());
                break;
            case 3:
                message.licensedOfferType = reader.int32();
                break;
            case 4:
                message.type = reader.int32();
                break;
            case 5:
                message.rentalPeriodDays = reader.int32();
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a GroupLicenseKey message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof GroupLicenseKey
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {GroupLicenseKey} GroupLicenseKey
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    GroupLicenseKey.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a GroupLicenseKey message.
     * @function verify
     * @memberof GroupLicenseKey
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    GroupLicenseKey.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.dasherCustomerId != null && message.hasOwnProperty("dasherCustomerId"))
            if (!$util.isInteger(message.dasherCustomerId) && !(message.dasherCustomerId && $util.isInteger(message.dasherCustomerId.low) && $util.isInteger(message.dasherCustomerId.high)))
                return "dasherCustomerId: integer|Long expected";
        if (message.docId != null && message.hasOwnProperty("docId")) {
            var error = $root.DocId.verify(message.docId);
            if (error)
                return "docId." + error;
        }
        if (message.licensedOfferType != null && message.hasOwnProperty("licensedOfferType"))
            if (!$util.isInteger(message.licensedOfferType))
                return "licensedOfferType: integer expected";
        if (message.type != null && message.hasOwnProperty("type"))
            if (!$util.isInteger(message.type))
                return "type: integer expected";
        if (message.rentalPeriodDays != null && message.hasOwnProperty("rentalPeriodDays"))
            if (!$util.isInteger(message.rentalPeriodDays))
                return "rentalPeriodDays: integer expected";
        return null;
    };

    /**
     * Creates a GroupLicenseKey message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof GroupLicenseKey
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {GroupLicenseKey} GroupLicenseKey
     */
    GroupLicenseKey.fromObject = function fromObject(object) {
        if (object instanceof $root.GroupLicenseKey)
            return object;
        var message = new $root.GroupLicenseKey();
        if (object.dasherCustomerId != null)
            if ($util.Long)
                (message.dasherCustomerId = $util.Long.fromValue(object.dasherCustomerId)).unsigned = false;
            else if (typeof object.dasherCustomerId === "string")
                message.dasherCustomerId = parseInt(object.dasherCustomerId, 10);
            else if (typeof object.dasherCustomerId === "number")
                message.dasherCustomerId = object.dasherCustomerId;
            else if (typeof object.dasherCustomerId === "object")
                message.dasherCustomerId = new $util.LongBits(object.dasherCustomerId.low >>> 0, object.dasherCustomerId.high >>> 0).toNumber();
        if (object.docId != null) {
            if (typeof object.docId !== "object")
                throw TypeError(".GroupLicenseKey.docId: object expected");
            message.docId = $root.DocId.fromObject(object.docId);
        }
        if (object.licensedOfferType != null)
            message.licensedOfferType = object.licensedOfferType | 0;
        if (object.type != null)
            message.type = object.type | 0;
        if (object.rentalPeriodDays != null)
            message.rentalPeriodDays = object.rentalPeriodDays | 0;
        return message;
    };

    /**
     * Creates a plain object from a GroupLicenseKey message. Also converts values to other types if specified.
     * @function toObject
     * @memberof GroupLicenseKey
     * @static
     * @param {GroupLicenseKey} message GroupLicenseKey
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    GroupLicenseKey.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        var object = {};
        if (options.defaults) {
            if ($util.Long) {
                var long = new $util.Long(0, 0, false);
                object.dasherCustomerId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
            } else
                object.dasherCustomerId = options.longs === String ? "0" : 0;
            object.docId = null;
            object.licensedOfferType = 1;
            object.type = 0;
            object.rentalPeriodDays = 0;
        }
        if (message.dasherCustomerId != null && message.hasOwnProperty("dasherCustomerId"))
            if (typeof message.dasherCustomerId === "number")
                object.dasherCustomerId = options.longs === String ? String(message.dasherCustomerId) : message.dasherCustomerId;
            else
                object.dasherCustomerId = options.longs === String ? $util.Long.prototype.toString.call(message.dasherCustomerId) : options.longs === Number ? new $util.LongBits(message.dasherCustomerId.low >>> 0, message.dasherCustomerId.high >>> 0).toNumber() : message.dasherCustomerId;
        if (message.docId != null && message.hasOwnProperty("docId"))
            object.docId = $root.DocId.toObject(message.docId, options);
        if (message.licensedOfferType != null && message.hasOwnProperty("licensedOfferType"))
            object.licensedOfferType = message.licensedOfferType;
        if (message.type != null && message.hasOwnProperty("type"))
            object.type = message.type;
        if (message.rentalPeriodDays != null && message.hasOwnProperty("rentalPeriodDays"))
            object.rentalPeriodDays = message.rentalPeriodDays;
        return object;
    };

    /**
     * Converts this GroupLicenseKey to JSON.
     * @function toJSON
     * @memberof GroupLicenseKey
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    GroupLicenseKey.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return GroupLicenseKey;
})();

$root.LicenseTerms = (function() {

    /**
     * Properties of a LicenseTerms.
     * @exports ILicenseTerms
     * @interface ILicenseTerms
     * @property {IGroupLicenseKey|null} [groupLicenseKey] LicenseTerms groupLicenseKey
     */

    /**
     * Constructs a new LicenseTerms.
     * @exports LicenseTerms
     * @classdesc Represents a LicenseTerms.
     * @implements ILicenseTerms
     * @constructor
     * @param {ILicenseTerms=} [properties] Properties to set
     */
    function LicenseTerms(properties) {
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * LicenseTerms groupLicenseKey.
     * @member {IGroupLicenseKey|null|undefined} groupLicenseKey
     * @memberof LicenseTerms
     * @instance
     */
    LicenseTerms.prototype.groupLicenseKey = null;

    /**
     * Creates a new LicenseTerms instance using the specified properties.
     * @function create
     * @memberof LicenseTerms
     * @static
     * @param {ILicenseTerms=} [properties] Properties to set
     * @returns {LicenseTerms} LicenseTerms instance
     */
    LicenseTerms.create = function create(properties) {
        return new LicenseTerms(properties);
    };

    /**
     * Encodes the specified LicenseTerms message. Does not implicitly {@link LicenseTerms.verify|verify} messages.
     * @function encode
     * @memberof LicenseTerms
     * @static
     * @param {ILicenseTerms} message LicenseTerms message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    LicenseTerms.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.groupLicenseKey != null && Object.hasOwnProperty.call(message, "groupLicenseKey"))
            $root.GroupLicenseKey.encode(message.groupLicenseKey, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
        return writer;
    };

    /**
     * Encodes the specified LicenseTerms message, length delimited. Does not implicitly {@link LicenseTerms.verify|verify} messages.
     * @function encodeDelimited
     * @memberof LicenseTerms
     * @static
     * @param {ILicenseTerms} message LicenseTerms message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    LicenseTerms.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a LicenseTerms message from the specified reader or buffer.
     * @function decode
     * @memberof LicenseTerms
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {LicenseTerms} LicenseTerms
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    LicenseTerms.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.LicenseTerms();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.groupLicenseKey = $root.GroupLicenseKey.decode(reader, reader.uint32());
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a LicenseTerms message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof LicenseTerms
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {LicenseTerms} LicenseTerms
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    LicenseTerms.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a LicenseTerms message.
     * @function verify
     * @memberof LicenseTerms
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    LicenseTerms.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.groupLicenseKey != null && message.hasOwnProperty("groupLicenseKey")) {
            var error = $root.GroupLicenseKey.verify(message.groupLicenseKey);
            if (error)
                return "groupLicenseKey." + error;
        }
        return null;
    };

    /**
     * Creates a LicenseTerms message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof LicenseTerms
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {LicenseTerms} LicenseTerms
     */
    LicenseTerms.fromObject = function fromObject(object) {
        if (object instanceof $root.LicenseTerms)
            return object;
        var message = new $root.LicenseTerms();
        if (object.groupLicenseKey != null) {
            if (typeof object.groupLicenseKey !== "object")
                throw TypeError(".LicenseTerms.groupLicenseKey: object expected");
            message.groupLicenseKey = $root.GroupLicenseKey.fromObject(object.groupLicenseKey);
        }
        return message;
    };

    /**
     * Creates a plain object from a LicenseTerms message. Also converts values to other types if specified.
     * @function toObject
     * @memberof LicenseTerms
     * @static
     * @param {LicenseTerms} message LicenseTerms
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    LicenseTerms.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        var object = {};
        if (options.defaults)
            object.groupLicenseKey = null;
        if (message.groupLicenseKey != null && message.hasOwnProperty("groupLicenseKey"))
            object.groupLicenseKey = $root.GroupLicenseKey.toObject(message.groupLicenseKey, options);
        return object;
    };

    /**
     * Converts this LicenseTerms to JSON.
     * @function toJSON
     * @memberof LicenseTerms
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    LicenseTerms.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return LicenseTerms;
})();

$root.Offer = (function() {

    /**
     * Properties of an Offer.
     * @exports IOffer
     * @interface IOffer
     * @property {number|Long|null} [micros] Offer micros
     * @property {string|null} [currencyCode] Offer currencyCode
     * @property {string|null} [formattedAmount] Offer formattedAmount
     * @property {Array.<IOffer>|null} [convertedPrice] Offer convertedPrice
     * @property {boolean|null} [checkoutFlowRequired] Offer checkoutFlowRequired
     * @property {number|Long|null} [fullPriceMicros] Offer fullPriceMicros
     * @property {string|null} [formattedFullAmount] Offer formattedFullAmount
     * @property {number|null} [offerType] Offer offerType
     * @property {IRentalTerms|null} [rentalTerms] Offer rentalTerms
     * @property {number|Long|null} [onSaleDate] Offer onSaleDate
     * @property {Array.<string>|null} [promotionLabel] Offer promotionLabel
     * @property {ISubscriptionTerms|null} [subscriptionTerms] Offer subscriptionTerms
     * @property {string|null} [formattedName] Offer formattedName
     * @property {string|null} [formattedDescription] Offer formattedDescription
     * @property {boolean|null} [preorder] Offer preorder
     * @property {number|null} [onSaleDateDisplayTimeZoneOffsetMillis] Offer onSaleDateDisplayTimeZoneOffsetMillis
     * @property {number|null} [licensedOfferType] Offer licensedOfferType
     * @property {ISubscriptionContentTerms|null} [subscriptionContentTerms] Offer subscriptionContentTerms
     * @property {string|null} [offerId] Offer offerId
     * @property {number|Long|null} [preorderFulfillmentDisplayDate] Offer preorderFulfillmentDisplayDate
     * @property {ILicenseTerms|null} [licenseTerms] Offer licenseTerms
     * @property {boolean|null} [sale] Offer sale
     * @property {IVoucherTerms|null} [voucherTerms] Offer voucherTerms
     * @property {Array.<IOfferPayment>|null} [offerPayment] Offer offerPayment
     * @property {boolean|null} [repeatLastPayment] Offer repeatLastPayment
     * @property {string|null} [buyButtonLabel] Offer buyButtonLabel
     * @property {boolean|null} [instantPurchaseEnabled] Offer instantPurchaseEnabled
     * @property {number|Long|null} [saleEndTimestamp] Offer saleEndTimestamp
     * @property {string|null} [saleMessage] Offer saleMessage
     */

    /**
     * Constructs a new Offer.
     * @exports Offer
     * @classdesc Represents an Offer.
     * @implements IOffer
     * @constructor
     * @param {IOffer=} [properties] Properties to set
     */
    function Offer(properties) {
        this.convertedPrice = [];
        this.promotionLabel = [];
        this.offerPayment = [];
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * Offer micros.
     * @member {number|Long} micros
     * @memberof Offer
     * @instance
     */
    Offer.prototype.micros = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

    /**
     * Offer currencyCode.
     * @member {string} currencyCode
     * @memberof Offer
     * @instance
     */
    Offer.prototype.currencyCode = "";

    /**
     * Offer formattedAmount.
     * @member {string} formattedAmount
     * @memberof Offer
     * @instance
     */
    Offer.prototype.formattedAmount = "";

    /**
     * Offer convertedPrice.
     * @member {Array.<IOffer>} convertedPrice
     * @memberof Offer
     * @instance
     */
    Offer.prototype.convertedPrice = $util.emptyArray;

    /**
     * Offer checkoutFlowRequired.
     * @member {boolean} checkoutFlowRequired
     * @memberof Offer
     * @instance
     */
    Offer.prototype.checkoutFlowRequired = false;

    /**
     * Offer fullPriceMicros.
     * @member {number|Long} fullPriceMicros
     * @memberof Offer
     * @instance
     */
    Offer.prototype.fullPriceMicros = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

    /**
     * Offer formattedFullAmount.
     * @member {string} formattedFullAmount
     * @memberof Offer
     * @instance
     */
    Offer.prototype.formattedFullAmount = "";

    /**
     * Offer offerType.
     * @member {number} offerType
     * @memberof Offer
     * @instance
     */
    Offer.prototype.offerType = 1;

    /**
     * Offer rentalTerms.
     * @member {IRentalTerms|null|undefined} rentalTerms
     * @memberof Offer
     * @instance
     */
    Offer.prototype.rentalTerms = null;

    /**
     * Offer onSaleDate.
     * @member {number|Long} onSaleDate
     * @memberof Offer
     * @instance
     */
    Offer.prototype.onSaleDate = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

    /**
     * Offer promotionLabel.
     * @member {Array.<string>} promotionLabel
     * @memberof Offer
     * @instance
     */
    Offer.prototype.promotionLabel = $util.emptyArray;

    /**
     * Offer subscriptionTerms.
     * @member {ISubscriptionTerms|null|undefined} subscriptionTerms
     * @memberof Offer
     * @instance
     */
    Offer.prototype.subscriptionTerms = null;

    /**
     * Offer formattedName.
     * @member {string} formattedName
     * @memberof Offer
     * @instance
     */
    Offer.prototype.formattedName = "";

    /**
     * Offer formattedDescription.
     * @member {string} formattedDescription
     * @memberof Offer
     * @instance
     */
    Offer.prototype.formattedDescription = "";

    /**
     * Offer preorder.
     * @member {boolean} preorder
     * @memberof Offer
     * @instance
     */
    Offer.prototype.preorder = false;

    /**
     * Offer onSaleDateDisplayTimeZoneOffsetMillis.
     * @member {number} onSaleDateDisplayTimeZoneOffsetMillis
     * @memberof Offer
     * @instance
     */
    Offer.prototype.onSaleDateDisplayTimeZoneOffsetMillis = 0;

    /**
     * Offer licensedOfferType.
     * @member {number} licensedOfferType
     * @memberof Offer
     * @instance
     */
    Offer.prototype.licensedOfferType = 0;

    /**
     * Offer subscriptionContentTerms.
     * @member {ISubscriptionContentTerms|null|undefined} subscriptionContentTerms
     * @memberof Offer
     * @instance
     */
    Offer.prototype.subscriptionContentTerms = null;

    /**
     * Offer offerId.
     * @member {string} offerId
     * @memberof Offer
     * @instance
     */
    Offer.prototype.offerId = "";

    /**
     * Offer preorderFulfillmentDisplayDate.
     * @member {number|Long} preorderFulfillmentDisplayDate
     * @memberof Offer
     * @instance
     */
    Offer.prototype.preorderFulfillmentDisplayDate = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

    /**
     * Offer licenseTerms.
     * @member {ILicenseTerms|null|undefined} licenseTerms
     * @memberof Offer
     * @instance
     */
    Offer.prototype.licenseTerms = null;

    /**
     * Offer sale.
     * @member {boolean} sale
     * @memberof Offer
     * @instance
     */
    Offer.prototype.sale = false;

    /**
     * Offer voucherTerms.
     * @member {IVoucherTerms|null|undefined} voucherTerms
     * @memberof Offer
     * @instance
     */
    Offer.prototype.voucherTerms = null;

    /**
     * Offer offerPayment.
     * @member {Array.<IOfferPayment>} offerPayment
     * @memberof Offer
     * @instance
     */
    Offer.prototype.offerPayment = $util.emptyArray;

    /**
     * Offer repeatLastPayment.
     * @member {boolean} repeatLastPayment
     * @memberof Offer
     * @instance
     */
    Offer.prototype.repeatLastPayment = false;

    /**
     * Offer buyButtonLabel.
     * @member {string} buyButtonLabel
     * @memberof Offer
     * @instance
     */
    Offer.prototype.buyButtonLabel = "";

    /**
     * Offer instantPurchaseEnabled.
     * @member {boolean} instantPurchaseEnabled
     * @memberof Offer
     * @instance
     */
    Offer.prototype.instantPurchaseEnabled = false;

    /**
     * Offer saleEndTimestamp.
     * @member {number|Long} saleEndTimestamp
     * @memberof Offer
     * @instance
     */
    Offer.prototype.saleEndTimestamp = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

    /**
     * Offer saleMessage.
     * @member {string} saleMessage
     * @memberof Offer
     * @instance
     */
    Offer.prototype.saleMessage = "";

    /**
     * Creates a new Offer instance using the specified properties.
     * @function create
     * @memberof Offer
     * @static
     * @param {IOffer=} [properties] Properties to set
     * @returns {Offer} Offer instance
     */
    Offer.create = function create(properties) {
        return new Offer(properties);
    };

    /**
     * Encodes the specified Offer message. Does not implicitly {@link Offer.verify|verify} messages.
     * @function encode
     * @memberof Offer
     * @static
     * @param {IOffer} message Offer message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    Offer.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.micros != null && Object.hasOwnProperty.call(message, "micros"))
            writer.uint32(/* id 1, wireType 0 =*/8).int64(message.micros);
        if (message.currencyCode != null && Object.hasOwnProperty.call(message, "currencyCode"))
            writer.uint32(/* id 2, wireType 2 =*/18).string(message.currencyCode);
        if (message.formattedAmount != null && Object.hasOwnProperty.call(message, "formattedAmount"))
            writer.uint32(/* id 3, wireType 2 =*/26).string(message.formattedAmount);
        if (message.convertedPrice != null && message.convertedPrice.length)
            for (var i = 0; i < message.convertedPrice.length; ++i)
                $root.Offer.encode(message.convertedPrice[i], writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
        if (message.checkoutFlowRequired != null && Object.hasOwnProperty.call(message, "checkoutFlowRequired"))
            writer.uint32(/* id 5, wireType 0 =*/40).bool(message.checkoutFlowRequired);
        if (message.fullPriceMicros != null && Object.hasOwnProperty.call(message, "fullPriceMicros"))
            writer.uint32(/* id 6, wireType 0 =*/48).int64(message.fullPriceMicros);
        if (message.formattedFullAmount != null && Object.hasOwnProperty.call(message, "formattedFullAmount"))
            writer.uint32(/* id 7, wireType 2 =*/58).string(message.formattedFullAmount);
        if (message.offerType != null && Object.hasOwnProperty.call(message, "offerType"))
            writer.uint32(/* id 8, wireType 0 =*/64).int32(message.offerType);
        if (message.rentalTerms != null && Object.hasOwnProperty.call(message, "rentalTerms"))
            $root.RentalTerms.encode(message.rentalTerms, writer.uint32(/* id 9, wireType 2 =*/74).fork()).ldelim();
        if (message.onSaleDate != null && Object.hasOwnProperty.call(message, "onSaleDate"))
            writer.uint32(/* id 10, wireType 0 =*/80).int64(message.onSaleDate);
        if (message.promotionLabel != null && message.promotionLabel.length)
            for (var i = 0; i < message.promotionLabel.length; ++i)
                writer.uint32(/* id 11, wireType 2 =*/90).string(message.promotionLabel[i]);
        if (message.subscriptionTerms != null && Object.hasOwnProperty.call(message, "subscriptionTerms"))
            $root.SubscriptionTerms.encode(message.subscriptionTerms, writer.uint32(/* id 12, wireType 2 =*/98).fork()).ldelim();
        if (message.formattedName != null && Object.hasOwnProperty.call(message, "formattedName"))
            writer.uint32(/* id 13, wireType 2 =*/106).string(message.formattedName);
        if (message.formattedDescription != null && Object.hasOwnProperty.call(message, "formattedDescription"))
            writer.uint32(/* id 14, wireType 2 =*/114).string(message.formattedDescription);
        if (message.preorder != null && Object.hasOwnProperty.call(message, "preorder"))
            writer.uint32(/* id 15, wireType 0 =*/120).bool(message.preorder);
        if (message.onSaleDateDisplayTimeZoneOffsetMillis != null && Object.hasOwnProperty.call(message, "onSaleDateDisplayTimeZoneOffsetMillis"))
            writer.uint32(/* id 16, wireType 0 =*/128).int32(message.onSaleDateDisplayTimeZoneOffsetMillis);
        if (message.licensedOfferType != null && Object.hasOwnProperty.call(message, "licensedOfferType"))
            writer.uint32(/* id 17, wireType 0 =*/136).int32(message.licensedOfferType);
        if (message.subscriptionContentTerms != null && Object.hasOwnProperty.call(message, "subscriptionContentTerms"))
            $root.SubscriptionContentTerms.encode(message.subscriptionContentTerms, writer.uint32(/* id 18, wireType 2 =*/146).fork()).ldelim();
        if (message.offerId != null && Object.hasOwnProperty.call(message, "offerId"))
            writer.uint32(/* id 19, wireType 2 =*/154).string(message.offerId);
        if (message.preorderFulfillmentDisplayDate != null && Object.hasOwnProperty.call(message, "preorderFulfillmentDisplayDate"))
            writer.uint32(/* id 20, wireType 0 =*/160).int64(message.preorderFulfillmentDisplayDate);
        if (message.licenseTerms != null && Object.hasOwnProperty.call(message, "licenseTerms"))
            $root.LicenseTerms.encode(message.licenseTerms, writer.uint32(/* id 21, wireType 2 =*/170).fork()).ldelim();
        if (message.sale != null && Object.hasOwnProperty.call(message, "sale"))
            writer.uint32(/* id 22, wireType 0 =*/176).bool(message.sale);
        if (message.voucherTerms != null && Object.hasOwnProperty.call(message, "voucherTerms"))
            $root.VoucherTerms.encode(message.voucherTerms, writer.uint32(/* id 23, wireType 2 =*/186).fork()).ldelim();
        if (message.offerPayment != null && message.offerPayment.length)
            for (var i = 0; i < message.offerPayment.length; ++i)
                $root.OfferPayment.encode(message.offerPayment[i], writer.uint32(/* id 24, wireType 2 =*/194).fork()).ldelim();
        if (message.repeatLastPayment != null && Object.hasOwnProperty.call(message, "repeatLastPayment"))
            writer.uint32(/* id 25, wireType 0 =*/200).bool(message.repeatLastPayment);
        if (message.buyButtonLabel != null && Object.hasOwnProperty.call(message, "buyButtonLabel"))
            writer.uint32(/* id 26, wireType 2 =*/210).string(message.buyButtonLabel);
        if (message.instantPurchaseEnabled != null && Object.hasOwnProperty.call(message, "instantPurchaseEnabled"))
            writer.uint32(/* id 27, wireType 0 =*/216).bool(message.instantPurchaseEnabled);
        if (message.saleEndTimestamp != null && Object.hasOwnProperty.call(message, "saleEndTimestamp"))
            writer.uint32(/* id 30, wireType 0 =*/240).int64(message.saleEndTimestamp);
        if (message.saleMessage != null && Object.hasOwnProperty.call(message, "saleMessage"))
            writer.uint32(/* id 31, wireType 2 =*/250).string(message.saleMessage);
        return writer;
    };

    /**
     * Encodes the specified Offer message, length delimited. Does not implicitly {@link Offer.verify|verify} messages.
     * @function encodeDelimited
     * @memberof Offer
     * @static
     * @param {IOffer} message Offer message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    Offer.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes an Offer message from the specified reader or buffer.
     * @function decode
     * @memberof Offer
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {Offer} Offer
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    Offer.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Offer();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.micros = reader.int64();
                break;
            case 2:
                message.currencyCode = reader.string();
                break;
            case 3:
                message.formattedAmount = reader.string();
                break;
            case 4:
                if (!(message.convertedPrice && message.convertedPrice.length))
                    message.convertedPrice = [];
                message.convertedPrice.push($root.Offer.decode(reader, reader.uint32()));
                break;
            case 5:
                message.checkoutFlowRequired = reader.bool();
                break;
            case 6:
                message.fullPriceMicros = reader.int64();
                break;
            case 7:
                message.formattedFullAmount = reader.string();
                break;
            case 8:
                message.offerType = reader.int32();
                break;
            case 9:
                message.rentalTerms = $root.RentalTerms.decode(reader, reader.uint32());
                break;
            case 10:
                message.onSaleDate = reader.int64();
                break;
            case 11:
                if (!(message.promotionLabel && message.promotionLabel.length))
                    message.promotionLabel = [];
                message.promotionLabel.push(reader.string());
                break;
            case 12:
                message.subscriptionTerms = $root.SubscriptionTerms.decode(reader, reader.uint32());
                break;
            case 13:
                message.formattedName = reader.string();
                break;
            case 14:
                message.formattedDescription = reader.string();
                break;
            case 15:
                message.preorder = reader.bool();
                break;
            case 16:
                message.onSaleDateDisplayTimeZoneOffsetMillis = reader.int32();
                break;
            case 17:
                message.licensedOfferType = reader.int32();
                break;
            case 18:
                message.subscriptionContentTerms = $root.SubscriptionContentTerms.decode(reader, reader.uint32());
                break;
            case 19:
                message.offerId = reader.string();
                break;
            case 20:
                message.preorderFulfillmentDisplayDate = reader.int64();
                break;
            case 21:
                message.licenseTerms = $root.LicenseTerms.decode(reader, reader.uint32());
                break;
            case 22:
                message.sale = reader.bool();
                break;
            case 23:
                message.voucherTerms = $root.VoucherTerms.decode(reader, reader.uint32());
                break;
            case 24:
                if (!(message.offerPayment && message.offerPayment.length))
                    message.offerPayment = [];
                message.offerPayment.push($root.OfferPayment.decode(reader, reader.uint32()));
                break;
            case 25:
                message.repeatLastPayment = reader.bool();
                break;
            case 26:
                message.buyButtonLabel = reader.string();
                break;
            case 27:
                message.instantPurchaseEnabled = reader.bool();
                break;
            case 30:
                message.saleEndTimestamp = reader.int64();
                break;
            case 31:
                message.saleMessage = reader.string();
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes an Offer message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof Offer
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {Offer} Offer
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    Offer.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies an Offer message.
     * @function verify
     * @memberof Offer
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    Offer.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.micros != null && message.hasOwnProperty("micros"))
            if (!$util.isInteger(message.micros) && !(message.micros && $util.isInteger(message.micros.low) && $util.isInteger(message.micros.high)))
                return "micros: integer|Long expected";
        if (message.currencyCode != null && message.hasOwnProperty("currencyCode"))
            if (!$util.isString(message.currencyCode))
                return "currencyCode: string expected";
        if (message.formattedAmount != null && message.hasOwnProperty("formattedAmount"))
            if (!$util.isString(message.formattedAmount))
                return "formattedAmount: string expected";
        if (message.convertedPrice != null && message.hasOwnProperty("convertedPrice")) {
            if (!Array.isArray(message.convertedPrice))
                return "convertedPrice: array expected";
            for (var i = 0; i < message.convertedPrice.length; ++i) {
                var error = $root.Offer.verify(message.convertedPrice[i]);
                if (error)
                    return "convertedPrice." + error;
            }
        }
        if (message.checkoutFlowRequired != null && message.hasOwnProperty("checkoutFlowRequired"))
            if (typeof message.checkoutFlowRequired !== "boolean")
                return "checkoutFlowRequired: boolean expected";
        if (message.fullPriceMicros != null && message.hasOwnProperty("fullPriceMicros"))
            if (!$util.isInteger(message.fullPriceMicros) && !(message.fullPriceMicros && $util.isInteger(message.fullPriceMicros.low) && $util.isInteger(message.fullPriceMicros.high)))
                return "fullPriceMicros: integer|Long expected";
        if (message.formattedFullAmount != null && message.hasOwnProperty("formattedFullAmount"))
            if (!$util.isString(message.formattedFullAmount))
                return "formattedFullAmount: string expected";
        if (message.offerType != null && message.hasOwnProperty("offerType"))
            if (!$util.isInteger(message.offerType))
                return "offerType: integer expected";
        if (message.rentalTerms != null && message.hasOwnProperty("rentalTerms")) {
            var error = $root.RentalTerms.verify(message.rentalTerms);
            if (error)
                return "rentalTerms." + error;
        }
        if (message.onSaleDate != null && message.hasOwnProperty("onSaleDate"))
            if (!$util.isInteger(message.onSaleDate) && !(message.onSaleDate && $util.isInteger(message.onSaleDate.low) && $util.isInteger(message.onSaleDate.high)))
                return "onSaleDate: integer|Long expected";
        if (message.promotionLabel != null && message.hasOwnProperty("promotionLabel")) {
            if (!Array.isArray(message.promotionLabel))
                return "promotionLabel: array expected";
            for (var i = 0; i < message.promotionLabel.length; ++i)
                if (!$util.isString(message.promotionLabel[i]))
                    return "promotionLabel: string[] expected";
        }
        if (message.subscriptionTerms != null && message.hasOwnProperty("subscriptionTerms")) {
            var error = $root.SubscriptionTerms.verify(message.subscriptionTerms);
            if (error)
                return "subscriptionTerms." + error;
        }
        if (message.formattedName != null && message.hasOwnProperty("formattedName"))
            if (!$util.isString(message.formattedName))
                return "formattedName: string expected";
        if (message.formattedDescription != null && message.hasOwnProperty("formattedDescription"))
            if (!$util.isString(message.formattedDescription))
                return "formattedDescription: string expected";
        if (message.preorder != null && message.hasOwnProperty("preorder"))
            if (typeof message.preorder !== "boolean")
                return "preorder: boolean expected";
        if (message.onSaleDateDisplayTimeZoneOffsetMillis != null && message.hasOwnProperty("onSaleDateDisplayTimeZoneOffsetMillis"))
            if (!$util.isInteger(message.onSaleDateDisplayTimeZoneOffsetMillis))
                return "onSaleDateDisplayTimeZoneOffsetMillis: integer expected";
        if (message.licensedOfferType != null && message.hasOwnProperty("licensedOfferType"))
            if (!$util.isInteger(message.licensedOfferType))
                return "licensedOfferType: integer expected";
        if (message.subscriptionContentTerms != null && message.hasOwnProperty("subscriptionContentTerms")) {
            var error = $root.SubscriptionContentTerms.verify(message.subscriptionContentTerms);
            if (error)
                return "subscriptionContentTerms." + error;
        }
        if (message.offerId != null && message.hasOwnProperty("offerId"))
            if (!$util.isString(message.offerId))
                return "offerId: string expected";
        if (message.preorderFulfillmentDisplayDate != null && message.hasOwnProperty("preorderFulfillmentDisplayDate"))
            if (!$util.isInteger(message.preorderFulfillmentDisplayDate) && !(message.preorderFulfillmentDisplayDate && $util.isInteger(message.preorderFulfillmentDisplayDate.low) && $util.isInteger(message.preorderFulfillmentDisplayDate.high)))
                return "preorderFulfillmentDisplayDate: integer|Long expected";
        if (message.licenseTerms != null && message.hasOwnProperty("licenseTerms")) {
            var error = $root.LicenseTerms.verify(message.licenseTerms);
            if (error)
                return "licenseTerms." + error;
        }
        if (message.sale != null && message.hasOwnProperty("sale"))
            if (typeof message.sale !== "boolean")
                return "sale: boolean expected";
        if (message.voucherTerms != null && message.hasOwnProperty("voucherTerms")) {
            var error = $root.VoucherTerms.verify(message.voucherTerms);
            if (error)
                return "voucherTerms." + error;
        }
        if (message.offerPayment != null && message.hasOwnProperty("offerPayment")) {
            if (!Array.isArray(message.offerPayment))
                return "offerPayment: array expected";
            for (var i = 0; i < message.offerPayment.length; ++i) {
                var error = $root.OfferPayment.verify(message.offerPayment[i]);
                if (error)
                    return "offerPayment." + error;
            }
        }
        if (message.repeatLastPayment != null && message.hasOwnProperty("repeatLastPayment"))
            if (typeof message.repeatLastPayment !== "boolean")
                return "repeatLastPayment: boolean expected";
        if (message.buyButtonLabel != null && message.hasOwnProperty("buyButtonLabel"))
            if (!$util.isString(message.buyButtonLabel))
                return "buyButtonLabel: string expected";
        if (message.instantPurchaseEnabled != null && message.hasOwnProperty("instantPurchaseEnabled"))
            if (typeof message.instantPurchaseEnabled !== "boolean")
                return "instantPurchaseEnabled: boolean expected";
        if (message.saleEndTimestamp != null && message.hasOwnProperty("saleEndTimestamp"))
            if (!$util.isInteger(message.saleEndTimestamp) && !(message.saleEndTimestamp && $util.isInteger(message.saleEndTimestamp.low) && $util.isInteger(message.saleEndTimestamp.high)))
                return "saleEndTimestamp: integer|Long expected";
        if (message.saleMessage != null && message.hasOwnProperty("saleMessage"))
            if (!$util.isString(message.saleMessage))
                return "saleMessage: string expected";
        return null;
    };

    /**
     * Creates an Offer message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof Offer
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {Offer} Offer
     */
    Offer.fromObject = function fromObject(object) {
        if (object instanceof $root.Offer)
            return object;
        var message = new $root.Offer();
        if (object.micros != null)
            if ($util.Long)
                (message.micros = $util.Long.fromValue(object.micros)).unsigned = false;
            else if (typeof object.micros === "string")
                message.micros = parseInt(object.micros, 10);
            else if (typeof object.micros === "number")
                message.micros = object.micros;
            else if (typeof object.micros === "object")
                message.micros = new $util.LongBits(object.micros.low >>> 0, object.micros.high >>> 0).toNumber();
        if (object.currencyCode != null)
            message.currencyCode = String(object.currencyCode);
        if (object.formattedAmount != null)
            message.formattedAmount = String(object.formattedAmount);
        if (object.convertedPrice) {
            if (!Array.isArray(object.convertedPrice))
                throw TypeError(".Offer.convertedPrice: array expected");
            message.convertedPrice = [];
            for (var i = 0; i < object.convertedPrice.length; ++i) {
                if (typeof object.convertedPrice[i] !== "object")
                    throw TypeError(".Offer.convertedPrice: object expected");
                message.convertedPrice[i] = $root.Offer.fromObject(object.convertedPrice[i]);
            }
        }
        if (object.checkoutFlowRequired != null)
            message.checkoutFlowRequired = Boolean(object.checkoutFlowRequired);
        if (object.fullPriceMicros != null)
            if ($util.Long)
                (message.fullPriceMicros = $util.Long.fromValue(object.fullPriceMicros)).unsigned = false;
            else if (typeof object.fullPriceMicros === "string")
                message.fullPriceMicros = parseInt(object.fullPriceMicros, 10);
            else if (typeof object.fullPriceMicros === "number")
                message.fullPriceMicros = object.fullPriceMicros;
            else if (typeof object.fullPriceMicros === "object")
                message.fullPriceMicros = new $util.LongBits(object.fullPriceMicros.low >>> 0, object.fullPriceMicros.high >>> 0).toNumber();
        if (object.formattedFullAmount != null)
            message.formattedFullAmount = String(object.formattedFullAmount);
        if (object.offerType != null)
            message.offerType = object.offerType | 0;
        if (object.rentalTerms != null) {
            if (typeof object.rentalTerms !== "object")
                throw TypeError(".Offer.rentalTerms: object expected");
            message.rentalTerms = $root.RentalTerms.fromObject(object.rentalTerms);
        }
        if (object.onSaleDate != null)
            if ($util.Long)
                (message.onSaleDate = $util.Long.fromValue(object.onSaleDate)).unsigned = false;
            else if (typeof object.onSaleDate === "string")
                message.onSaleDate = parseInt(object.onSaleDate, 10);
            else if (typeof object.onSaleDate === "number")
                message.onSaleDate = object.onSaleDate;
            else if (typeof object.onSaleDate === "object")
                message.onSaleDate = new $util.LongBits(object.onSaleDate.low >>> 0, object.onSaleDate.high >>> 0).toNumber();
        if (object.promotionLabel) {
            if (!Array.isArray(object.promotionLabel))
                throw TypeError(".Offer.promotionLabel: array expected");
            message.promotionLabel = [];
            for (var i = 0; i < object.promotionLabel.length; ++i)
                message.promotionLabel[i] = String(object.promotionLabel[i]);
        }
        if (object.subscriptionTerms != null) {
            if (typeof object.subscriptionTerms !== "object")
                throw TypeError(".Offer.subscriptionTerms: object expected");
            message.subscriptionTerms = $root.SubscriptionTerms.fromObject(object.subscriptionTerms);
        }
        if (object.formattedName != null)
            message.formattedName = String(object.formattedName);
        if (object.formattedDescription != null)
            message.formattedDescription = String(object.formattedDescription);
        if (object.preorder != null)
            message.preorder = Boolean(object.preorder);
        if (object.onSaleDateDisplayTimeZoneOffsetMillis != null)
            message.onSaleDateDisplayTimeZoneOffsetMillis = object.onSaleDateDisplayTimeZoneOffsetMillis | 0;
        if (object.licensedOfferType != null)
            message.licensedOfferType = object.licensedOfferType | 0;
        if (object.subscriptionContentTerms != null) {
            if (typeof object.subscriptionContentTerms !== "object")
                throw TypeError(".Offer.subscriptionContentTerms: object expected");
            message.subscriptionContentTerms = $root.SubscriptionContentTerms.fromObject(object.subscriptionContentTerms);
        }
        if (object.offerId != null)
            message.offerId = String(object.offerId);
        if (object.preorderFulfillmentDisplayDate != null)
            if ($util.Long)
                (message.preorderFulfillmentDisplayDate = $util.Long.fromValue(object.preorderFulfillmentDisplayDate)).unsigned = false;
            else if (typeof object.preorderFulfillmentDisplayDate === "string")
                message.preorderFulfillmentDisplayDate = parseInt(object.preorderFulfillmentDisplayDate, 10);
            else if (typeof object.preorderFulfillmentDisplayDate === "number")
                message.preorderFulfillmentDisplayDate = object.preorderFulfillmentDisplayDate;
            else if (typeof object.preorderFulfillmentDisplayDate === "object")
                message.preorderFulfillmentDisplayDate = new $util.LongBits(object.preorderFulfillmentDisplayDate.low >>> 0, object.preorderFulfillmentDisplayDate.high >>> 0).toNumber();
        if (object.licenseTerms != null) {
            if (typeof object.licenseTerms !== "object")
                throw TypeError(".Offer.licenseTerms: object expected");
            message.licenseTerms = $root.LicenseTerms.fromObject(object.licenseTerms);
        }
        if (object.sale != null)
            message.sale = Boolean(object.sale);
        if (object.voucherTerms != null) {
            if (typeof object.voucherTerms !== "object")
                throw TypeError(".Offer.voucherTerms: object expected");
            message.voucherTerms = $root.VoucherTerms.fromObject(object.voucherTerms);
        }
        if (object.offerPayment) {
            if (!Array.isArray(object.offerPayment))
                throw TypeError(".Offer.offerPayment: array expected");
            message.offerPayment = [];
            for (var i = 0; i < object.offerPayment.length; ++i) {
                if (typeof object.offerPayment[i] !== "object")
                    throw TypeError(".Offer.offerPayment: object expected");
                message.offerPayment[i] = $root.OfferPayment.fromObject(object.offerPayment[i]);
            }
        }
        if (object.repeatLastPayment != null)
            message.repeatLastPayment = Boolean(object.repeatLastPayment);
        if (object.buyButtonLabel != null)
            message.buyButtonLabel = String(object.buyButtonLabel);
        if (object.instantPurchaseEnabled != null)
            message.instantPurchaseEnabled = Boolean(object.instantPurchaseEnabled);
        if (object.saleEndTimestamp != null)
            if ($util.Long)
                (message.saleEndTimestamp = $util.Long.fromValue(object.saleEndTimestamp)).unsigned = false;
            else if (typeof object.saleEndTimestamp === "string")
                message.saleEndTimestamp = parseInt(object.saleEndTimestamp, 10);
            else if (typeof object.saleEndTimestamp === "number")
                message.saleEndTimestamp = object.saleEndTimestamp;
            else if (typeof object.saleEndTimestamp === "object")
                message.saleEndTimestamp = new $util.LongBits(object.saleEndTimestamp.low >>> 0, object.saleEndTimestamp.high >>> 0).toNumber();
        if (object.saleMessage != null)
            message.saleMessage = String(object.saleMessage);
        return message;
    };

    /**
     * Creates a plain object from an Offer message. Also converts values to other types if specified.
     * @function toObject
     * @memberof Offer
     * @static
     * @param {Offer} message Offer
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    Offer.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        var object = {};
        if (options.arrays || options.defaults) {
            object.convertedPrice = [];
            object.promotionLabel = [];
            object.offerPayment = [];
        }
        if (options.defaults) {
            if ($util.Long) {
                var long = new $util.Long(0, 0, false);
                object.micros = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
            } else
                object.micros = options.longs === String ? "0" : 0;
            object.currencyCode = "";
            object.formattedAmount = "";
            object.checkoutFlowRequired = false;
            if ($util.Long) {
                var long = new $util.Long(0, 0, false);
                object.fullPriceMicros = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
            } else
                object.fullPriceMicros = options.longs === String ? "0" : 0;
            object.formattedFullAmount = "";
            object.offerType = 1;
            object.rentalTerms = null;
            if ($util.Long) {
                var long = new $util.Long(0, 0, false);
                object.onSaleDate = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
            } else
                object.onSaleDate = options.longs === String ? "0" : 0;
            object.subscriptionTerms = null;
            object.formattedName = "";
            object.formattedDescription = "";
            object.preorder = false;
            object.onSaleDateDisplayTimeZoneOffsetMillis = 0;
            object.licensedOfferType = 0;
            object.subscriptionContentTerms = null;
            object.offerId = "";
            if ($util.Long) {
                var long = new $util.Long(0, 0, false);
                object.preorderFulfillmentDisplayDate = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
            } else
                object.preorderFulfillmentDisplayDate = options.longs === String ? "0" : 0;
            object.licenseTerms = null;
            object.sale = false;
            object.voucherTerms = null;
            object.repeatLastPayment = false;
            object.buyButtonLabel = "";
            object.instantPurchaseEnabled = false;
            if ($util.Long) {
                var long = new $util.Long(0, 0, false);
                object.saleEndTimestamp = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
            } else
                object.saleEndTimestamp = options.longs === String ? "0" : 0;
            object.saleMessage = "";
        }
        if (message.micros != null && message.hasOwnProperty("micros"))
            if (typeof message.micros === "number")
                object.micros = options.longs === String ? String(message.micros) : message.micros;
            else
                object.micros = options.longs === String ? $util.Long.prototype.toString.call(message.micros) : options.longs === Number ? new $util.LongBits(message.micros.low >>> 0, message.micros.high >>> 0).toNumber() : message.micros;
        if (message.currencyCode != null && message.hasOwnProperty("currencyCode"))
            object.currencyCode = message.currencyCode;
        if (message.formattedAmount != null && message.hasOwnProperty("formattedAmount"))
            object.formattedAmount = message.formattedAmount;
        if (message.convertedPrice && message.convertedPrice.length) {
            object.convertedPrice = [];
            for (var j = 0; j < message.convertedPrice.length; ++j)
                object.convertedPrice[j] = $root.Offer.toObject(message.convertedPrice[j], options);
        }
        if (message.checkoutFlowRequired != null && message.hasOwnProperty("checkoutFlowRequired"))
            object.checkoutFlowRequired = message.checkoutFlowRequired;
        if (message.fullPriceMicros != null && message.hasOwnProperty("fullPriceMicros"))
            if (typeof message.fullPriceMicros === "number")
                object.fullPriceMicros = options.longs === String ? String(message.fullPriceMicros) : message.fullPriceMicros;
            else
                object.fullPriceMicros = options.longs === String ? $util.Long.prototype.toString.call(message.fullPriceMicros) : options.longs === Number ? new $util.LongBits(message.fullPriceMicros.low >>> 0, message.fullPriceMicros.high >>> 0).toNumber() : message.fullPriceMicros;
        if (message.formattedFullAmount != null && message.hasOwnProperty("formattedFullAmount"))
            object.formattedFullAmount = message.formattedFullAmount;
        if (message.offerType != null && message.hasOwnProperty("offerType"))
            object.offerType = message.offerType;
        if (message.rentalTerms != null && message.hasOwnProperty("rentalTerms"))
            object.rentalTerms = $root.RentalTerms.toObject(message.rentalTerms, options);
        if (message.onSaleDate != null && message.hasOwnProperty("onSaleDate"))
            if (typeof message.onSaleDate === "number")
                object.onSaleDate = options.longs === String ? String(message.onSaleDate) : message.onSaleDate;
            else
                object.onSaleDate = options.longs === String ? $util.Long.prototype.toString.call(message.onSaleDate) : options.longs === Number ? new $util.LongBits(message.onSaleDate.low >>> 0, message.onSaleDate.high >>> 0).toNumber() : message.onSaleDate;
        if (message.promotionLabel && message.promotionLabel.length) {
            object.promotionLabel = [];
            for (var j = 0; j < message.promotionLabel.length; ++j)
                object.promotionLabel[j] = message.promotionLabel[j];
        }
        if (message.subscriptionTerms != null && message.hasOwnProperty("subscriptionTerms"))
            object.subscriptionTerms = $root.SubscriptionTerms.toObject(message.subscriptionTerms, options);
        if (message.formattedName != null && message.hasOwnProperty("formattedName"))
            object.formattedName = message.formattedName;
        if (message.formattedDescription != null && message.hasOwnProperty("formattedDescription"))
            object.formattedDescription = message.formattedDescription;
        if (message.preorder != null && message.hasOwnProperty("preorder"))
            object.preorder = message.preorder;
        if (message.onSaleDateDisplayTimeZoneOffsetMillis != null && message.hasOwnProperty("onSaleDateDisplayTimeZoneOffsetMillis"))
            object.onSaleDateDisplayTimeZoneOffsetMillis = message.onSaleDateDisplayTimeZoneOffsetMillis;
        if (message.licensedOfferType != null && message.hasOwnProperty("licensedOfferType"))
            object.licensedOfferType = message.licensedOfferType;
        if (message.subscriptionContentTerms != null && message.hasOwnProperty("subscriptionContentTerms"))
            object.subscriptionContentTerms = $root.SubscriptionContentTerms.toObject(message.subscriptionContentTerms, options);
        if (message.offerId != null && message.hasOwnProperty("offerId"))
            object.offerId = message.offerId;
        if (message.preorderFulfillmentDisplayDate != null && message.hasOwnProperty("preorderFulfillmentDisplayDate"))
            if (typeof message.preorderFulfillmentDisplayDate === "number")
                object.preorderFulfillmentDisplayDate = options.longs === String ? String(message.preorderFulfillmentDisplayDate) : message.preorderFulfillmentDisplayDate;
            else
                object.preorderFulfillmentDisplayDate = options.longs === String ? $util.Long.prototype.toString.call(message.preorderFulfillmentDisplayDate) : options.longs === Number ? new $util.LongBits(message.preorderFulfillmentDisplayDate.low >>> 0, message.preorderFulfillmentDisplayDate.high >>> 0).toNumber() : message.preorderFulfillmentDisplayDate;
        if (message.licenseTerms != null && message.hasOwnProperty("licenseTerms"))
            object.licenseTerms = $root.LicenseTerms.toObject(message.licenseTerms, options);
        if (message.sale != null && message.hasOwnProperty("sale"))
            object.sale = message.sale;
        if (message.voucherTerms != null && message.hasOwnProperty("voucherTerms"))
            object.voucherTerms = $root.VoucherTerms.toObject(message.voucherTerms, options);
        if (message.offerPayment && message.offerPayment.length) {
            object.offerPayment = [];
            for (var j = 0; j < message.offerPayment.length; ++j)
                object.offerPayment[j] = $root.OfferPayment.toObject(message.offerPayment[j], options);
        }
        if (message.repeatLastPayment != null && message.hasOwnProperty("repeatLastPayment"))
            object.repeatLastPayment = message.repeatLastPayment;
        if (message.buyButtonLabel != null && message.hasOwnProperty("buyButtonLabel"))
            object.buyButtonLabel = message.buyButtonLabel;
        if (message.instantPurchaseEnabled != null && message.hasOwnProperty("instantPurchaseEnabled"))
            object.instantPurchaseEnabled = message.instantPurchaseEnabled;
        if (message.saleEndTimestamp != null && message.hasOwnProperty("saleEndTimestamp"))
            if (typeof message.saleEndTimestamp === "number")
                object.saleEndTimestamp = options.longs === String ? String(message.saleEndTimestamp) : message.saleEndTimestamp;
            else
                object.saleEndTimestamp = options.longs === String ? $util.Long.prototype.toString.call(message.saleEndTimestamp) : options.longs === Number ? new $util.LongBits(message.saleEndTimestamp.low >>> 0, message.saleEndTimestamp.high >>> 0).toNumber() : message.saleEndTimestamp;
        if (message.saleMessage != null && message.hasOwnProperty("saleMessage"))
            object.saleMessage = message.saleMessage;
        return object;
    };

    /**
     * Converts this Offer to JSON.
     * @function toJSON
     * @memberof Offer
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    Offer.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return Offer;
})();

$root.MonthAndDay = (function() {

    /**
     * Properties of a MonthAndDay.
     * @exports IMonthAndDay
     * @interface IMonthAndDay
     * @property {number|null} [month] MonthAndDay month
     * @property {number|null} [day] MonthAndDay day
     */

    /**
     * Constructs a new MonthAndDay.
     * @exports MonthAndDay
     * @classdesc Represents a MonthAndDay.
     * @implements IMonthAndDay
     * @constructor
     * @param {IMonthAndDay=} [properties] Properties to set
     */
    function MonthAndDay(properties) {
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * MonthAndDay month.
     * @member {number} month
     * @memberof MonthAndDay
     * @instance
     */
    MonthAndDay.prototype.month = 0;

    /**
     * MonthAndDay day.
     * @member {number} day
     * @memberof MonthAndDay
     * @instance
     */
    MonthAndDay.prototype.day = 0;

    /**
     * Creates a new MonthAndDay instance using the specified properties.
     * @function create
     * @memberof MonthAndDay
     * @static
     * @param {IMonthAndDay=} [properties] Properties to set
     * @returns {MonthAndDay} MonthAndDay instance
     */
    MonthAndDay.create = function create(properties) {
        return new MonthAndDay(properties);
    };

    /**
     * Encodes the specified MonthAndDay message. Does not implicitly {@link MonthAndDay.verify|verify} messages.
     * @function encode
     * @memberof MonthAndDay
     * @static
     * @param {IMonthAndDay} message MonthAndDay message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    MonthAndDay.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.month != null && Object.hasOwnProperty.call(message, "month"))
            writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.month);
        if (message.day != null && Object.hasOwnProperty.call(message, "day"))
            writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.day);
        return writer;
    };

    /**
     * Encodes the specified MonthAndDay message, length delimited. Does not implicitly {@link MonthAndDay.verify|verify} messages.
     * @function encodeDelimited
     * @memberof MonthAndDay
     * @static
     * @param {IMonthAndDay} message MonthAndDay message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    MonthAndDay.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a MonthAndDay message from the specified reader or buffer.
     * @function decode
     * @memberof MonthAndDay
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {MonthAndDay} MonthAndDay
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    MonthAndDay.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.MonthAndDay();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.month = reader.uint32();
                break;
            case 2:
                message.day = reader.uint32();
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a MonthAndDay message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof MonthAndDay
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {MonthAndDay} MonthAndDay
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    MonthAndDay.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a MonthAndDay message.
     * @function verify
     * @memberof MonthAndDay
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    MonthAndDay.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.month != null && message.hasOwnProperty("month"))
            if (!$util.isInteger(message.month))
                return "month: integer expected";
        if (message.day != null && message.hasOwnProperty("day"))
            if (!$util.isInteger(message.day))
                return "day: integer expected";
        return null;
    };

    /**
     * Creates a MonthAndDay message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof MonthAndDay
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {MonthAndDay} MonthAndDay
     */
    MonthAndDay.fromObject = function fromObject(object) {
        if (object instanceof $root.MonthAndDay)
            return object;
        var message = new $root.MonthAndDay();
        if (object.month != null)
            message.month = object.month >>> 0;
        if (object.day != null)
            message.day = object.day >>> 0;
        return message;
    };

    /**
     * Creates a plain object from a MonthAndDay message. Also converts values to other types if specified.
     * @function toObject
     * @memberof MonthAndDay
     * @static
     * @param {MonthAndDay} message MonthAndDay
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    MonthAndDay.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        var object = {};
        if (options.defaults) {
            object.month = 0;
            object.day = 0;
        }
        if (message.month != null && message.hasOwnProperty("month"))
            object.month = message.month;
        if (message.day != null && message.hasOwnProperty("day"))
            object.day = message.day;
        return object;
    };

    /**
     * Converts this MonthAndDay to JSON.
     * @function toJSON
     * @memberof MonthAndDay
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    MonthAndDay.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return MonthAndDay;
})();

$root.OfferPaymentPeriod = (function() {

    /**
     * Properties of an OfferPaymentPeriod.
     * @exports IOfferPaymentPeriod
     * @interface IOfferPaymentPeriod
     * @property {ITimePeriod|null} [duration] OfferPaymentPeriod duration
     * @property {IMonthAndDay|null} [start] OfferPaymentPeriod start
     * @property {IMonthAndDay|null} [end] OfferPaymentPeriod end
     */

    /**
     * Constructs a new OfferPaymentPeriod.
     * @exports OfferPaymentPeriod
     * @classdesc Represents an OfferPaymentPeriod.
     * @implements IOfferPaymentPeriod
     * @constructor
     * @param {IOfferPaymentPeriod=} [properties] Properties to set
     */
    function OfferPaymentPeriod(properties) {
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * OfferPaymentPeriod duration.
     * @member {ITimePeriod|null|undefined} duration
     * @memberof OfferPaymentPeriod
     * @instance
     */
    OfferPaymentPeriod.prototype.duration = null;

    /**
     * OfferPaymentPeriod start.
     * @member {IMonthAndDay|null|undefined} start
     * @memberof OfferPaymentPeriod
     * @instance
     */
    OfferPaymentPeriod.prototype.start = null;

    /**
     * OfferPaymentPeriod end.
     * @member {IMonthAndDay|null|undefined} end
     * @memberof OfferPaymentPeriod
     * @instance
     */
    OfferPaymentPeriod.prototype.end = null;

    /**
     * Creates a new OfferPaymentPeriod instance using the specified properties.
     * @function create
     * @memberof OfferPaymentPeriod
     * @static
     * @param {IOfferPaymentPeriod=} [properties] Properties to set
     * @returns {OfferPaymentPeriod} OfferPaymentPeriod instance
     */
    OfferPaymentPeriod.create = function create(properties) {
        return new OfferPaymentPeriod(properties);
    };

    /**
     * Encodes the specified OfferPaymentPeriod message. Does not implicitly {@link OfferPaymentPeriod.verify|verify} messages.
     * @function encode
     * @memberof OfferPaymentPeriod
     * @static
     * @param {IOfferPaymentPeriod} message OfferPaymentPeriod message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    OfferPaymentPeriod.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.duration != null && Object.hasOwnProperty.call(message, "duration"))
            $root.TimePeriod.encode(message.duration, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
        if (message.start != null && Object.hasOwnProperty.call(message, "start"))
            $root.MonthAndDay.encode(message.start, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
        if (message.end != null && Object.hasOwnProperty.call(message, "end"))
            $root.MonthAndDay.encode(message.end, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
        return writer;
    };

    /**
     * Encodes the specified OfferPaymentPeriod message, length delimited. Does not implicitly {@link OfferPaymentPeriod.verify|verify} messages.
     * @function encodeDelimited
     * @memberof OfferPaymentPeriod
     * @static
     * @param {IOfferPaymentPeriod} message OfferPaymentPeriod message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    OfferPaymentPeriod.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes an OfferPaymentPeriod message from the specified reader or buffer.
     * @function decode
     * @memberof OfferPaymentPeriod
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {OfferPaymentPeriod} OfferPaymentPeriod
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    OfferPaymentPeriod.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.OfferPaymentPeriod();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.duration = $root.TimePeriod.decode(reader, reader.uint32());
                break;
            case 2:
                message.start = $root.MonthAndDay.decode(reader, reader.uint32());
                break;
            case 3:
                message.end = $root.MonthAndDay.decode(reader, reader.uint32());
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes an OfferPaymentPeriod message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof OfferPaymentPeriod
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {OfferPaymentPeriod} OfferPaymentPeriod
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    OfferPaymentPeriod.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies an OfferPaymentPeriod message.
     * @function verify
     * @memberof OfferPaymentPeriod
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    OfferPaymentPeriod.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.duration != null && message.hasOwnProperty("duration")) {
            var error = $root.TimePeriod.verify(message.duration);
            if (error)
                return "duration." + error;
        }
        if (message.start != null && message.hasOwnProperty("start")) {
            var error = $root.MonthAndDay.verify(message.start);
            if (error)
                return "start." + error;
        }
        if (message.end != null && message.hasOwnProperty("end")) {
            var error = $root.MonthAndDay.verify(message.end);
            if (error)
                return "end." + error;
        }
        return null;
    };

    /**
     * Creates an OfferPaymentPeriod message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof OfferPaymentPeriod
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {OfferPaymentPeriod} OfferPaymentPeriod
     */
    OfferPaymentPeriod.fromObject = function fromObject(object) {
        if (object instanceof $root.OfferPaymentPeriod)
            return object;
        var message = new $root.OfferPaymentPeriod();
        if (object.duration != null) {
            if (typeof object.duration !== "object")
                throw TypeError(".OfferPaymentPeriod.duration: object expected");
            message.duration = $root.TimePeriod.fromObject(object.duration);
        }
        if (object.start != null) {
            if (typeof object.start !== "object")
                throw TypeError(".OfferPaymentPeriod.start: object expected");
            message.start = $root.MonthAndDay.fromObject(object.start);
        }
        if (object.end != null) {
            if (typeof object.end !== "object")
                throw TypeError(".OfferPaymentPeriod.end: object expected");
            message.end = $root.MonthAndDay.fromObject(object.end);
        }
        return message;
    };

    /**
     * Creates a plain object from an OfferPaymentPeriod message. Also converts values to other types if specified.
     * @function toObject
     * @memberof OfferPaymentPeriod
     * @static
     * @param {OfferPaymentPeriod} message OfferPaymentPeriod
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    OfferPaymentPeriod.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        var object = {};
        if (options.defaults) {
            object.duration = null;
            object.start = null;
            object.end = null;
        }
        if (message.duration != null && message.hasOwnProperty("duration"))
            object.duration = $root.TimePeriod.toObject(message.duration, options);
        if (message.start != null && message.hasOwnProperty("start"))
            object.start = $root.MonthAndDay.toObject(message.start, options);
        if (message.end != null && message.hasOwnProperty("end"))
            object.end = $root.MonthAndDay.toObject(message.end, options);
        return object;
    };

    /**
     * Converts this OfferPaymentPeriod to JSON.
     * @function toJSON
     * @memberof OfferPaymentPeriod
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    OfferPaymentPeriod.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return OfferPaymentPeriod;
})();

$root.OfferPaymentOverride = (function() {

    /**
     * Properties of an OfferPaymentOverride.
     * @exports IOfferPaymentOverride
     * @interface IOfferPaymentOverride
     * @property {number|Long|null} [micros] OfferPaymentOverride micros
     * @property {IMonthAndDay|null} [start] OfferPaymentOverride start
     * @property {IMonthAndDay|null} [end] OfferPaymentOverride end
     */

    /**
     * Constructs a new OfferPaymentOverride.
     * @exports OfferPaymentOverride
     * @classdesc Represents an OfferPaymentOverride.
     * @implements IOfferPaymentOverride
     * @constructor
     * @param {IOfferPaymentOverride=} [properties] Properties to set
     */
    function OfferPaymentOverride(properties) {
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * OfferPaymentOverride micros.
     * @member {number|Long} micros
     * @memberof OfferPaymentOverride
     * @instance
     */
    OfferPaymentOverride.prototype.micros = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

    /**
     * OfferPaymentOverride start.
     * @member {IMonthAndDay|null|undefined} start
     * @memberof OfferPaymentOverride
     * @instance
     */
    OfferPaymentOverride.prototype.start = null;

    /**
     * OfferPaymentOverride end.
     * @member {IMonthAndDay|null|undefined} end
     * @memberof OfferPaymentOverride
     * @instance
     */
    OfferPaymentOverride.prototype.end = null;

    /**
     * Creates a new OfferPaymentOverride instance using the specified properties.
     * @function create
     * @memberof OfferPaymentOverride
     * @static
     * @param {IOfferPaymentOverride=} [properties] Properties to set
     * @returns {OfferPaymentOverride} OfferPaymentOverride instance
     */
    OfferPaymentOverride.create = function create(properties) {
        return new OfferPaymentOverride(properties);
    };

    /**
     * Encodes the specified OfferPaymentOverride message. Does not implicitly {@link OfferPaymentOverride.verify|verify} messages.
     * @function encode
     * @memberof OfferPaymentOverride
     * @static
     * @param {IOfferPaymentOverride} message OfferPaymentOverride message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    OfferPaymentOverride.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.micros != null && Object.hasOwnProperty.call(message, "micros"))
            writer.uint32(/* id 1, wireType 0 =*/8).int64(message.micros);
        if (message.start != null && Object.hasOwnProperty.call(message, "start"))
            $root.MonthAndDay.encode(message.start, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
        if (message.end != null && Object.hasOwnProperty.call(message, "end"))
            $root.MonthAndDay.encode(message.end, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
        return writer;
    };

    /**
     * Encodes the specified OfferPaymentOverride message, length delimited. Does not implicitly {@link OfferPaymentOverride.verify|verify} messages.
     * @function encodeDelimited
     * @memberof OfferPaymentOverride
     * @static
     * @param {IOfferPaymentOverride} message OfferPaymentOverride message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    OfferPaymentOverride.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes an OfferPaymentOverride message from the specified reader or buffer.
     * @function decode
     * @memberof OfferPaymentOverride
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {OfferPaymentOverride} OfferPaymentOverride
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    OfferPaymentOverride.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.OfferPaymentOverride();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.micros = reader.int64();
                break;
            case 2:
                message.start = $root.MonthAndDay.decode(reader, reader.uint32());
                break;
            case 3:
                message.end = $root.MonthAndDay.decode(reader, reader.uint32());
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes an OfferPaymentOverride message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof OfferPaymentOverride
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {OfferPaymentOverride} OfferPaymentOverride
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    OfferPaymentOverride.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies an OfferPaymentOverride message.
     * @function verify
     * @memberof OfferPaymentOverride
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    OfferPaymentOverride.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.micros != null && message.hasOwnProperty("micros"))
            if (!$util.isInteger(message.micros) && !(message.micros && $util.isInteger(message.micros.low) && $util.isInteger(message.micros.high)))
                return "micros: integer|Long expected";
        if (message.start != null && message.hasOwnProperty("start")) {
            var error = $root.MonthAndDay.verify(message.start);
            if (error)
                return "start." + error;
        }
        if (message.end != null && message.hasOwnProperty("end")) {
            var error = $root.MonthAndDay.verify(message.end);
            if (error)
                return "end." + error;
        }
        return null;
    };

    /**
     * Creates an OfferPaymentOverride message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof OfferPaymentOverride
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {OfferPaymentOverride} OfferPaymentOverride
     */
    OfferPaymentOverride.fromObject = function fromObject(object) {
        if (object instanceof $root.OfferPaymentOverride)
            return object;
        var message = new $root.OfferPaymentOverride();
        if (object.micros != null)
            if ($util.Long)
                (message.micros = $util.Long.fromValue(object.micros)).unsigned = false;
            else if (typeof object.micros === "string")
                message.micros = parseInt(object.micros, 10);
            else if (typeof object.micros === "number")
                message.micros = object.micros;
            else if (typeof object.micros === "object")
                message.micros = new $util.LongBits(object.micros.low >>> 0, object.micros.high >>> 0).toNumber();
        if (object.start != null) {
            if (typeof object.start !== "object")
                throw TypeError(".OfferPaymentOverride.start: object expected");
            message.start = $root.MonthAndDay.fromObject(object.start);
        }
        if (object.end != null) {
            if (typeof object.end !== "object")
                throw TypeError(".OfferPaymentOverride.end: object expected");
            message.end = $root.MonthAndDay.fromObject(object.end);
        }
        return message;
    };

    /**
     * Creates a plain object from an OfferPaymentOverride message. Also converts values to other types if specified.
     * @function toObject
     * @memberof OfferPaymentOverride
     * @static
     * @param {OfferPaymentOverride} message OfferPaymentOverride
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    OfferPaymentOverride.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        var object = {};
        if (options.defaults) {
            if ($util.Long) {
                var long = new $util.Long(0, 0, false);
                object.micros = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
            } else
                object.micros = options.longs === String ? "0" : 0;
            object.start = null;
            object.end = null;
        }
        if (message.micros != null && message.hasOwnProperty("micros"))
            if (typeof message.micros === "number")
                object.micros = options.longs === String ? String(message.micros) : message.micros;
            else
                object.micros = options.longs === String ? $util.Long.prototype.toString.call(message.micros) : options.longs === Number ? new $util.LongBits(message.micros.low >>> 0, message.micros.high >>> 0).toNumber() : message.micros;
        if (message.start != null && message.hasOwnProperty("start"))
            object.start = $root.MonthAndDay.toObject(message.start, options);
        if (message.end != null && message.hasOwnProperty("end"))
            object.end = $root.MonthAndDay.toObject(message.end, options);
        return object;
    };

    /**
     * Converts this OfferPaymentOverride to JSON.
     * @function toJSON
     * @memberof OfferPaymentOverride
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    OfferPaymentOverride.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return OfferPaymentOverride;
})();

$root.OfferPayment = (function() {

    /**
     * Properties of an OfferPayment.
     * @exports IOfferPayment
     * @interface IOfferPayment
     * @property {number|Long|null} [micros] OfferPayment micros
     * @property {string|null} [currencyCode] OfferPayment currencyCode
     * @property {IOfferPaymentPeriod|null} [offerPaymentPeriod] OfferPayment offerPaymentPeriod
     * @property {Array.<IOfferPaymentOverride>|null} [offerPaymentOverride] OfferPayment offerPaymentOverride
     */

    /**
     * Constructs a new OfferPayment.
     * @exports OfferPayment
     * @classdesc Represents an OfferPayment.
     * @implements IOfferPayment
     * @constructor
     * @param {IOfferPayment=} [properties] Properties to set
     */
    function OfferPayment(properties) {
        this.offerPaymentOverride = [];
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * OfferPayment micros.
     * @member {number|Long} micros
     * @memberof OfferPayment
     * @instance
     */
    OfferPayment.prototype.micros = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

    /**
     * OfferPayment currencyCode.
     * @member {string} currencyCode
     * @memberof OfferPayment
     * @instance
     */
    OfferPayment.prototype.currencyCode = "";

    /**
     * OfferPayment offerPaymentPeriod.
     * @member {IOfferPaymentPeriod|null|undefined} offerPaymentPeriod
     * @memberof OfferPayment
     * @instance
     */
    OfferPayment.prototype.offerPaymentPeriod = null;

    /**
     * OfferPayment offerPaymentOverride.
     * @member {Array.<IOfferPaymentOverride>} offerPaymentOverride
     * @memberof OfferPayment
     * @instance
     */
    OfferPayment.prototype.offerPaymentOverride = $util.emptyArray;

    /**
     * Creates a new OfferPayment instance using the specified properties.
     * @function create
     * @memberof OfferPayment
     * @static
     * @param {IOfferPayment=} [properties] Properties to set
     * @returns {OfferPayment} OfferPayment instance
     */
    OfferPayment.create = function create(properties) {
        return new OfferPayment(properties);
    };

    /**
     * Encodes the specified OfferPayment message. Does not implicitly {@link OfferPayment.verify|verify} messages.
     * @function encode
     * @memberof OfferPayment
     * @static
     * @param {IOfferPayment} message OfferPayment message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    OfferPayment.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.micros != null && Object.hasOwnProperty.call(message, "micros"))
            writer.uint32(/* id 1, wireType 0 =*/8).int64(message.micros);
        if (message.currencyCode != null && Object.hasOwnProperty.call(message, "currencyCode"))
            writer.uint32(/* id 2, wireType 2 =*/18).string(message.currencyCode);
        if (message.offerPaymentPeriod != null && Object.hasOwnProperty.call(message, "offerPaymentPeriod"))
            $root.OfferPaymentPeriod.encode(message.offerPaymentPeriod, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
        if (message.offerPaymentOverride != null && message.offerPaymentOverride.length)
            for (var i = 0; i < message.offerPaymentOverride.length; ++i)
                $root.OfferPaymentOverride.encode(message.offerPaymentOverride[i], writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
        return writer;
    };

    /**
     * Encodes the specified OfferPayment message, length delimited. Does not implicitly {@link OfferPayment.verify|verify} messages.
     * @function encodeDelimited
     * @memberof OfferPayment
     * @static
     * @param {IOfferPayment} message OfferPayment message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    OfferPayment.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes an OfferPayment message from the specified reader or buffer.
     * @function decode
     * @memberof OfferPayment
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {OfferPayment} OfferPayment
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    OfferPayment.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.OfferPayment();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.micros = reader.int64();
                break;
            case 2:
                message.currencyCode = reader.string();
                break;
            case 3:
                message.offerPaymentPeriod = $root.OfferPaymentPeriod.decode(reader, reader.uint32());
                break;
            case 4:
                if (!(message.offerPaymentOverride && message.offerPaymentOverride.length))
                    message.offerPaymentOverride = [];
                message.offerPaymentOverride.push($root.OfferPaymentOverride.decode(reader, reader.uint32()));
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes an OfferPayment message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof OfferPayment
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {OfferPayment} OfferPayment
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    OfferPayment.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies an OfferPayment message.
     * @function verify
     * @memberof OfferPayment
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    OfferPayment.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.micros != null && message.hasOwnProperty("micros"))
            if (!$util.isInteger(message.micros) && !(message.micros && $util.isInteger(message.micros.low) && $util.isInteger(message.micros.high)))
                return "micros: integer|Long expected";
        if (message.currencyCode != null && message.hasOwnProperty("currencyCode"))
            if (!$util.isString(message.currencyCode))
                return "currencyCode: string expected";
        if (message.offerPaymentPeriod != null && message.hasOwnProperty("offerPaymentPeriod")) {
            var error = $root.OfferPaymentPeriod.verify(message.offerPaymentPeriod);
            if (error)
                return "offerPaymentPeriod." + error;
        }
        if (message.offerPaymentOverride != null && message.hasOwnProperty("offerPaymentOverride")) {
            if (!Array.isArray(message.offerPaymentOverride))
                return "offerPaymentOverride: array expected";
            for (var i = 0; i < message.offerPaymentOverride.length; ++i) {
                var error = $root.OfferPaymentOverride.verify(message.offerPaymentOverride[i]);
                if (error)
                    return "offerPaymentOverride." + error;
            }
        }
        return null;
    };

    /**
     * Creates an OfferPayment message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof OfferPayment
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {OfferPayment} OfferPayment
     */
    OfferPayment.fromObject = function fromObject(object) {
        if (object instanceof $root.OfferPayment)
            return object;
        var message = new $root.OfferPayment();
        if (object.micros != null)
            if ($util.Long)
                (message.micros = $util.Long.fromValue(object.micros)).unsigned = false;
            else if (typeof object.micros === "string")
                message.micros = parseInt(object.micros, 10);
            else if (typeof object.micros === "number")
                message.micros = object.micros;
            else if (typeof object.micros === "object")
                message.micros = new $util.LongBits(object.micros.low >>> 0, object.micros.high >>> 0).toNumber();
        if (object.currencyCode != null)
            message.currencyCode = String(object.currencyCode);
        if (object.offerPaymentPeriod != null) {
            if (typeof object.offerPaymentPeriod !== "object")
                throw TypeError(".OfferPayment.offerPaymentPeriod: object expected");
            message.offerPaymentPeriod = $root.OfferPaymentPeriod.fromObject(object.offerPaymentPeriod);
        }
        if (object.offerPaymentOverride) {
            if (!Array.isArray(object.offerPaymentOverride))
                throw TypeError(".OfferPayment.offerPaymentOverride: array expected");
            message.offerPaymentOverride = [];
            for (var i = 0; i < object.offerPaymentOverride.length; ++i) {
                if (typeof object.offerPaymentOverride[i] !== "object")
                    throw TypeError(".OfferPayment.offerPaymentOverride: object expected");
                message.offerPaymentOverride[i] = $root.OfferPaymentOverride.fromObject(object.offerPaymentOverride[i]);
            }
        }
        return message;
    };

    /**
     * Creates a plain object from an OfferPayment message. Also converts values to other types if specified.
     * @function toObject
     * @memberof OfferPayment
     * @static
     * @param {OfferPayment} message OfferPayment
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    OfferPayment.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        var object = {};
        if (options.arrays || options.defaults)
            object.offerPaymentOverride = [];
        if (options.defaults) {
            if ($util.Long) {
                var long = new $util.Long(0, 0, false);
                object.micros = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
            } else
                object.micros = options.longs === String ? "0" : 0;
            object.currencyCode = "";
            object.offerPaymentPeriod = null;
        }
        if (message.micros != null && message.hasOwnProperty("micros"))
            if (typeof message.micros === "number")
                object.micros = options.longs === String ? String(message.micros) : message.micros;
            else
                object.micros = options.longs === String ? $util.Long.prototype.toString.call(message.micros) : options.longs === Number ? new $util.LongBits(message.micros.low >>> 0, message.micros.high >>> 0).toNumber() : message.micros;
        if (message.currencyCode != null && message.hasOwnProperty("currencyCode"))
            object.currencyCode = message.currencyCode;
        if (message.offerPaymentPeriod != null && message.hasOwnProperty("offerPaymentPeriod"))
            object.offerPaymentPeriod = $root.OfferPaymentPeriod.toObject(message.offerPaymentPeriod, options);
        if (message.offerPaymentOverride && message.offerPaymentOverride.length) {
            object.offerPaymentOverride = [];
            for (var j = 0; j < message.offerPaymentOverride.length; ++j)
                object.offerPaymentOverride[j] = $root.OfferPaymentOverride.toObject(message.offerPaymentOverride[j], options);
        }
        return object;
    };

    /**
     * Converts this OfferPayment to JSON.
     * @function toJSON
     * @memberof OfferPayment
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    OfferPayment.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return OfferPayment;
})();

$root.VoucherTerms = (function() {

    /**
     * Properties of a VoucherTerms.
     * @exports IVoucherTerms
     * @interface IVoucherTerms
     */

    /**
     * Constructs a new VoucherTerms.
     * @exports VoucherTerms
     * @classdesc Represents a VoucherTerms.
     * @implements IVoucherTerms
     * @constructor
     * @param {IVoucherTerms=} [properties] Properties to set
     */
    function VoucherTerms(properties) {
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * Creates a new VoucherTerms instance using the specified properties.
     * @function create
     * @memberof VoucherTerms
     * @static
     * @param {IVoucherTerms=} [properties] Properties to set
     * @returns {VoucherTerms} VoucherTerms instance
     */
    VoucherTerms.create = function create(properties) {
        return new VoucherTerms(properties);
    };

    /**
     * Encodes the specified VoucherTerms message. Does not implicitly {@link VoucherTerms.verify|verify} messages.
     * @function encode
     * @memberof VoucherTerms
     * @static
     * @param {IVoucherTerms} message VoucherTerms message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    VoucherTerms.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        return writer;
    };

    /**
     * Encodes the specified VoucherTerms message, length delimited. Does not implicitly {@link VoucherTerms.verify|verify} messages.
     * @function encodeDelimited
     * @memberof VoucherTerms
     * @static
     * @param {IVoucherTerms} message VoucherTerms message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    VoucherTerms.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a VoucherTerms message from the specified reader or buffer.
     * @function decode
     * @memberof VoucherTerms
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {VoucherTerms} VoucherTerms
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    VoucherTerms.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.VoucherTerms();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a VoucherTerms message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof VoucherTerms
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {VoucherTerms} VoucherTerms
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    VoucherTerms.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a VoucherTerms message.
     * @function verify
     * @memberof VoucherTerms
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    VoucherTerms.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        return null;
    };

    /**
     * Creates a VoucherTerms message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof VoucherTerms
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {VoucherTerms} VoucherTerms
     */
    VoucherTerms.fromObject = function fromObject(object) {
        if (object instanceof $root.VoucherTerms)
            return object;
        return new $root.VoucherTerms();
    };

    /**
     * Creates a plain object from a VoucherTerms message. Also converts values to other types if specified.
     * @function toObject
     * @memberof VoucherTerms
     * @static
     * @param {VoucherTerms} message VoucherTerms
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    VoucherTerms.toObject = function toObject() {
        return {};
    };

    /**
     * Converts this VoucherTerms to JSON.
     * @function toJSON
     * @memberof VoucherTerms
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    VoucherTerms.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return VoucherTerms;
})();

$root.RentalTerms = (function() {

    /**
     * Properties of a RentalTerms.
     * @exports IRentalTerms
     * @interface IRentalTerms
     * @property {number|null} [dEPRECATEDGrantPeriodSeconds] RentalTerms dEPRECATEDGrantPeriodSeconds
     * @property {number|null} [dEPRECATEDActivatePeriodSeconds] RentalTerms dEPRECATEDActivatePeriodSeconds
     * @property {ITimePeriod|null} [grantPeriod] RentalTerms grantPeriod
     * @property {ITimePeriod|null} [activatePeriod] RentalTerms activatePeriod
     */

    /**
     * Constructs a new RentalTerms.
     * @exports RentalTerms
     * @classdesc Represents a RentalTerms.
     * @implements IRentalTerms
     * @constructor
     * @param {IRentalTerms=} [properties] Properties to set
     */
    function RentalTerms(properties) {
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * RentalTerms dEPRECATEDGrantPeriodSeconds.
     * @member {number} dEPRECATEDGrantPeriodSeconds
     * @memberof RentalTerms
     * @instance
     */
    RentalTerms.prototype.dEPRECATEDGrantPeriodSeconds = 0;

    /**
     * RentalTerms dEPRECATEDActivatePeriodSeconds.
     * @member {number} dEPRECATEDActivatePeriodSeconds
     * @memberof RentalTerms
     * @instance
     */
    RentalTerms.prototype.dEPRECATEDActivatePeriodSeconds = 0;

    /**
     * RentalTerms grantPeriod.
     * @member {ITimePeriod|null|undefined} grantPeriod
     * @memberof RentalTerms
     * @instance
     */
    RentalTerms.prototype.grantPeriod = null;

    /**
     * RentalTerms activatePeriod.
     * @member {ITimePeriod|null|undefined} activatePeriod
     * @memberof RentalTerms
     * @instance
     */
    RentalTerms.prototype.activatePeriod = null;

    /**
     * Creates a new RentalTerms instance using the specified properties.
     * @function create
     * @memberof RentalTerms
     * @static
     * @param {IRentalTerms=} [properties] Properties to set
     * @returns {RentalTerms} RentalTerms instance
     */
    RentalTerms.create = function create(properties) {
        return new RentalTerms(properties);
    };

    /**
     * Encodes the specified RentalTerms message. Does not implicitly {@link RentalTerms.verify|verify} messages.
     * @function encode
     * @memberof RentalTerms
     * @static
     * @param {IRentalTerms} message RentalTerms message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    RentalTerms.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.dEPRECATEDGrantPeriodSeconds != null && Object.hasOwnProperty.call(message, "dEPRECATEDGrantPeriodSeconds"))
            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.dEPRECATEDGrantPeriodSeconds);
        if (message.dEPRECATEDActivatePeriodSeconds != null && Object.hasOwnProperty.call(message, "dEPRECATEDActivatePeriodSeconds"))
            writer.uint32(/* id 2, wireType 0 =*/16).int32(message.dEPRECATEDActivatePeriodSeconds);
        if (message.grantPeriod != null && Object.hasOwnProperty.call(message, "grantPeriod"))
            $root.TimePeriod.encode(message.grantPeriod, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
        if (message.activatePeriod != null && Object.hasOwnProperty.call(message, "activatePeriod"))
            $root.TimePeriod.encode(message.activatePeriod, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
        return writer;
    };

    /**
     * Encodes the specified RentalTerms message, length delimited. Does not implicitly {@link RentalTerms.verify|verify} messages.
     * @function encodeDelimited
     * @memberof RentalTerms
     * @static
     * @param {IRentalTerms} message RentalTerms message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    RentalTerms.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a RentalTerms message from the specified reader or buffer.
     * @function decode
     * @memberof RentalTerms
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {RentalTerms} RentalTerms
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    RentalTerms.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.RentalTerms();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.dEPRECATEDGrantPeriodSeconds = reader.int32();
                break;
            case 2:
                message.dEPRECATEDActivatePeriodSeconds = reader.int32();
                break;
            case 3:
                message.grantPeriod = $root.TimePeriod.decode(reader, reader.uint32());
                break;
            case 4:
                message.activatePeriod = $root.TimePeriod.decode(reader, reader.uint32());
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a RentalTerms message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof RentalTerms
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {RentalTerms} RentalTerms
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    RentalTerms.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a RentalTerms message.
     * @function verify
     * @memberof RentalTerms
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    RentalTerms.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.dEPRECATEDGrantPeriodSeconds != null && message.hasOwnProperty("dEPRECATEDGrantPeriodSeconds"))
            if (!$util.isInteger(message.dEPRECATEDGrantPeriodSeconds))
                return "dEPRECATEDGrantPeriodSeconds: integer expected";
        if (message.dEPRECATEDActivatePeriodSeconds != null && message.hasOwnProperty("dEPRECATEDActivatePeriodSeconds"))
            if (!$util.isInteger(message.dEPRECATEDActivatePeriodSeconds))
                return "dEPRECATEDActivatePeriodSeconds: integer expected";
        if (message.grantPeriod != null && message.hasOwnProperty("grantPeriod")) {
            var error = $root.TimePeriod.verify(message.grantPeriod);
            if (error)
                return "grantPeriod." + error;
        }
        if (message.activatePeriod != null && message.hasOwnProperty("activatePeriod")) {
            var error = $root.TimePeriod.verify(message.activatePeriod);
            if (error)
                return "activatePeriod." + error;
        }
        return null;
    };

    /**
     * Creates a RentalTerms message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof RentalTerms
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {RentalTerms} RentalTerms
     */
    RentalTerms.fromObject = function fromObject(object) {
        if (object instanceof $root.RentalTerms)
            return object;
        var message = new $root.RentalTerms();
        if (object.dEPRECATEDGrantPeriodSeconds != null)
            message.dEPRECATEDGrantPeriodSeconds = object.dEPRECATEDGrantPeriodSeconds | 0;
        if (object.dEPRECATEDActivatePeriodSeconds != null)
            message.dEPRECATEDActivatePeriodSeconds = object.dEPRECATEDActivatePeriodSeconds | 0;
        if (object.grantPeriod != null) {
            if (typeof object.grantPeriod !== "object")
                throw TypeError(".RentalTerms.grantPeriod: object expected");
            message.grantPeriod = $root.TimePeriod.fromObject(object.grantPeriod);
        }
        if (object.activatePeriod != null) {
            if (typeof object.activatePeriod !== "object")
                throw TypeError(".RentalTerms.activatePeriod: object expected");
            message.activatePeriod = $root.TimePeriod.fromObject(object.activatePeriod);
        }
        return message;
    };

    /**
     * Creates a plain object from a RentalTerms message. Also converts values to other types if specified.
     * @function toObject
     * @memberof RentalTerms
     * @static
     * @param {RentalTerms} message RentalTerms
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    RentalTerms.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        var object = {};
        if (options.defaults) {
            object.dEPRECATEDGrantPeriodSeconds = 0;
            object.dEPRECATEDActivatePeriodSeconds = 0;
            object.grantPeriod = null;
            object.activatePeriod = null;
        }
        if (message.dEPRECATEDGrantPeriodSeconds != null && message.hasOwnProperty("dEPRECATEDGrantPeriodSeconds"))
            object.dEPRECATEDGrantPeriodSeconds = message.dEPRECATEDGrantPeriodSeconds;
        if (message.dEPRECATEDActivatePeriodSeconds != null && message.hasOwnProperty("dEPRECATEDActivatePeriodSeconds"))
            object.dEPRECATEDActivatePeriodSeconds = message.dEPRECATEDActivatePeriodSeconds;
        if (message.grantPeriod != null && message.hasOwnProperty("grantPeriod"))
            object.grantPeriod = $root.TimePeriod.toObject(message.grantPeriod, options);
        if (message.activatePeriod != null && message.hasOwnProperty("activatePeriod"))
            object.activatePeriod = $root.TimePeriod.toObject(message.activatePeriod, options);
        return object;
    };

    /**
     * Converts this RentalTerms to JSON.
     * @function toJSON
     * @memberof RentalTerms
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    RentalTerms.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return RentalTerms;
})();

$root.SignedData = (function() {

    /**
     * Properties of a SignedData.
     * @exports ISignedData
     * @interface ISignedData
     * @property {string|null} [signedData] SignedData signedData
     * @property {string|null} [signature] SignedData signature
     */

    /**
     * Constructs a new SignedData.
     * @exports SignedData
     * @classdesc Represents a SignedData.
     * @implements ISignedData
     * @constructor
     * @param {ISignedData=} [properties] Properties to set
     */
    function SignedData(properties) {
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * SignedData signedData.
     * @member {string} signedData
     * @memberof SignedData
     * @instance
     */
    SignedData.prototype.signedData = "";

    /**
     * SignedData signature.
     * @member {string} signature
     * @memberof SignedData
     * @instance
     */
    SignedData.prototype.signature = "";

    /**
     * Creates a new SignedData instance using the specified properties.
     * @function create
     * @memberof SignedData
     * @static
     * @param {ISignedData=} [properties] Properties to set
     * @returns {SignedData} SignedData instance
     */
    SignedData.create = function create(properties) {
        return new SignedData(properties);
    };

    /**
     * Encodes the specified SignedData message. Does not implicitly {@link SignedData.verify|verify} messages.
     * @function encode
     * @memberof SignedData
     * @static
     * @param {ISignedData} message SignedData message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    SignedData.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.signedData != null && Object.hasOwnProperty.call(message, "signedData"))
            writer.uint32(/* id 1, wireType 2 =*/10).string(message.signedData);
        if (message.signature != null && Object.hasOwnProperty.call(message, "signature"))
            writer.uint32(/* id 2, wireType 2 =*/18).string(message.signature);
        return writer;
    };

    /**
     * Encodes the specified SignedData message, length delimited. Does not implicitly {@link SignedData.verify|verify} messages.
     * @function encodeDelimited
     * @memberof SignedData
     * @static
     * @param {ISignedData} message SignedData message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    SignedData.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a SignedData message from the specified reader or buffer.
     * @function decode
     * @memberof SignedData
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {SignedData} SignedData
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    SignedData.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.SignedData();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.signedData = reader.string();
                break;
            case 2:
                message.signature = reader.string();
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a SignedData message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof SignedData
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {SignedData} SignedData
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    SignedData.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a SignedData message.
     * @function verify
     * @memberof SignedData
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    SignedData.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.signedData != null && message.hasOwnProperty("signedData"))
            if (!$util.isString(message.signedData))
                return "signedData: string expected";
        if (message.signature != null && message.hasOwnProperty("signature"))
            if (!$util.isString(message.signature))
                return "signature: string expected";
        return null;
    };

    /**
     * Creates a SignedData message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof SignedData
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {SignedData} SignedData
     */
    SignedData.fromObject = function fromObject(object) {
        if (object instanceof $root.SignedData)
            return object;
        var message = new $root.SignedData();
        if (object.signedData != null)
            message.signedData = String(object.signedData);
        if (object.signature != null)
            message.signature = String(object.signature);
        return message;
    };

    /**
     * Creates a plain object from a SignedData message. Also converts values to other types if specified.
     * @function toObject
     * @memberof SignedData
     * @static
     * @param {SignedData} message SignedData
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    SignedData.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        var object = {};
        if (options.defaults) {
            object.signedData = "";
            object.signature = "";
        }
        if (message.signedData != null && message.hasOwnProperty("signedData"))
            object.signedData = message.signedData;
        if (message.signature != null && message.hasOwnProperty("signature"))
            object.signature = message.signature;
        return object;
    };

    /**
     * Converts this SignedData to JSON.
     * @function toJSON
     * @memberof SignedData
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    SignedData.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return SignedData;
})();

$root.SubscriptionContentTerms = (function() {

    /**
     * Properties of a SubscriptionContentTerms.
     * @exports ISubscriptionContentTerms
     * @interface ISubscriptionContentTerms
     * @property {IDocId|null} [requiredSubscription] SubscriptionContentTerms requiredSubscription
     */

    /**
     * Constructs a new SubscriptionContentTerms.
     * @exports SubscriptionContentTerms
     * @classdesc Represents a SubscriptionContentTerms.
     * @implements ISubscriptionContentTerms
     * @constructor
     * @param {ISubscriptionContentTerms=} [properties] Properties to set
     */
    function SubscriptionContentTerms(properties) {
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * SubscriptionContentTerms requiredSubscription.
     * @member {IDocId|null|undefined} requiredSubscription
     * @memberof SubscriptionContentTerms
     * @instance
     */
    SubscriptionContentTerms.prototype.requiredSubscription = null;

    /**
     * Creates a new SubscriptionContentTerms instance using the specified properties.
     * @function create
     * @memberof SubscriptionContentTerms
     * @static
     * @param {ISubscriptionContentTerms=} [properties] Properties to set
     * @returns {SubscriptionContentTerms} SubscriptionContentTerms instance
     */
    SubscriptionContentTerms.create = function create(properties) {
        return new SubscriptionContentTerms(properties);
    };

    /**
     * Encodes the specified SubscriptionContentTerms message. Does not implicitly {@link SubscriptionContentTerms.verify|verify} messages.
     * @function encode
     * @memberof SubscriptionContentTerms
     * @static
     * @param {ISubscriptionContentTerms} message SubscriptionContentTerms message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    SubscriptionContentTerms.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.requiredSubscription != null && Object.hasOwnProperty.call(message, "requiredSubscription"))
            $root.DocId.encode(message.requiredSubscription, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
        return writer;
    };

    /**
     * Encodes the specified SubscriptionContentTerms message, length delimited. Does not implicitly {@link SubscriptionContentTerms.verify|verify} messages.
     * @function encodeDelimited
     * @memberof SubscriptionContentTerms
     * @static
     * @param {ISubscriptionContentTerms} message SubscriptionContentTerms message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    SubscriptionContentTerms.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a SubscriptionContentTerms message from the specified reader or buffer.
     * @function decode
     * @memberof SubscriptionContentTerms
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {SubscriptionContentTerms} SubscriptionContentTerms
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    SubscriptionContentTerms.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.SubscriptionContentTerms();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.requiredSubscription = $root.DocId.decode(reader, reader.uint32());
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a SubscriptionContentTerms message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof SubscriptionContentTerms
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {SubscriptionContentTerms} SubscriptionContentTerms
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    SubscriptionContentTerms.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a SubscriptionContentTerms message.
     * @function verify
     * @memberof SubscriptionContentTerms
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    SubscriptionContentTerms.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.requiredSubscription != null && message.hasOwnProperty("requiredSubscription")) {
            var error = $root.DocId.verify(message.requiredSubscription);
            if (error)
                return "requiredSubscription." + error;
        }
        return null;
    };

    /**
     * Creates a SubscriptionContentTerms message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof SubscriptionContentTerms
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {SubscriptionContentTerms} SubscriptionContentTerms
     */
    SubscriptionContentTerms.fromObject = function fromObject(object) {
        if (object instanceof $root.SubscriptionContentTerms)
            return object;
        var message = new $root.SubscriptionContentTerms();
        if (object.requiredSubscription != null) {
            if (typeof object.requiredSubscription !== "object")
                throw TypeError(".SubscriptionContentTerms.requiredSubscription: object expected");
            message.requiredSubscription = $root.DocId.fromObject(object.requiredSubscription);
        }
        return message;
    };

    /**
     * Creates a plain object from a SubscriptionContentTerms message. Also converts values to other types if specified.
     * @function toObject
     * @memberof SubscriptionContentTerms
     * @static
     * @param {SubscriptionContentTerms} message SubscriptionContentTerms
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    SubscriptionContentTerms.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        var object = {};
        if (options.defaults)
            object.requiredSubscription = null;
        if (message.requiredSubscription != null && message.hasOwnProperty("requiredSubscription"))
            object.requiredSubscription = $root.DocId.toObject(message.requiredSubscription, options);
        return object;
    };

    /**
     * Converts this SubscriptionContentTerms to JSON.
     * @function toJSON
     * @memberof SubscriptionContentTerms
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    SubscriptionContentTerms.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return SubscriptionContentTerms;
})();

$root.GroupLicenseInfo = (function() {

    /**
     * Properties of a GroupLicenseInfo.
     * @exports IGroupLicenseInfo
     * @interface IGroupLicenseInfo
     * @property {number|null} [licensedOfferType] GroupLicenseInfo licensedOfferType
     * @property {number|Long|null} [gaiaGroupId] GroupLicenseInfo gaiaGroupId
     */

    /**
     * Constructs a new GroupLicenseInfo.
     * @exports GroupLicenseInfo
     * @classdesc Represents a GroupLicenseInfo.
     * @implements IGroupLicenseInfo
     * @constructor
     * @param {IGroupLicenseInfo=} [properties] Properties to set
     */
    function GroupLicenseInfo(properties) {
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * GroupLicenseInfo licensedOfferType.
     * @member {number} licensedOfferType
     * @memberof GroupLicenseInfo
     * @instance
     */
    GroupLicenseInfo.prototype.licensedOfferType = 0;

    /**
     * GroupLicenseInfo gaiaGroupId.
     * @member {number|Long} gaiaGroupId
     * @memberof GroupLicenseInfo
     * @instance
     */
    GroupLicenseInfo.prototype.gaiaGroupId = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

    /**
     * Creates a new GroupLicenseInfo instance using the specified properties.
     * @function create
     * @memberof GroupLicenseInfo
     * @static
     * @param {IGroupLicenseInfo=} [properties] Properties to set
     * @returns {GroupLicenseInfo} GroupLicenseInfo instance
     */
    GroupLicenseInfo.create = function create(properties) {
        return new GroupLicenseInfo(properties);
    };

    /**
     * Encodes the specified GroupLicenseInfo message. Does not implicitly {@link GroupLicenseInfo.verify|verify} messages.
     * @function encode
     * @memberof GroupLicenseInfo
     * @static
     * @param {IGroupLicenseInfo} message GroupLicenseInfo message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    GroupLicenseInfo.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.licensedOfferType != null && Object.hasOwnProperty.call(message, "licensedOfferType"))
            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.licensedOfferType);
        if (message.gaiaGroupId != null && Object.hasOwnProperty.call(message, "gaiaGroupId"))
            writer.uint32(/* id 2, wireType 1 =*/17).fixed64(message.gaiaGroupId);
        return writer;
    };

    /**
     * Encodes the specified GroupLicenseInfo message, length delimited. Does not implicitly {@link GroupLicenseInfo.verify|verify} messages.
     * @function encodeDelimited
     * @memberof GroupLicenseInfo
     * @static
     * @param {IGroupLicenseInfo} message GroupLicenseInfo message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    GroupLicenseInfo.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a GroupLicenseInfo message from the specified reader or buffer.
     * @function decode
     * @memberof GroupLicenseInfo
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {GroupLicenseInfo} GroupLicenseInfo
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    GroupLicenseInfo.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.GroupLicenseInfo();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.licensedOfferType = reader.int32();
                break;
            case 2:
                message.gaiaGroupId = reader.fixed64();
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a GroupLicenseInfo message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof GroupLicenseInfo
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {GroupLicenseInfo} GroupLicenseInfo
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    GroupLicenseInfo.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a GroupLicenseInfo message.
     * @function verify
     * @memberof GroupLicenseInfo
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    GroupLicenseInfo.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.licensedOfferType != null && message.hasOwnProperty("licensedOfferType"))
            if (!$util.isInteger(message.licensedOfferType))
                return "licensedOfferType: integer expected";
        if (message.gaiaGroupId != null && message.hasOwnProperty("gaiaGroupId"))
            if (!$util.isInteger(message.gaiaGroupId) && !(message.gaiaGroupId && $util.isInteger(message.gaiaGroupId.low) && $util.isInteger(message.gaiaGroupId.high)))
                return "gaiaGroupId: integer|Long expected";
        return null;
    };

    /**
     * Creates a GroupLicenseInfo message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof GroupLicenseInfo
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {GroupLicenseInfo} GroupLicenseInfo
     */
    GroupLicenseInfo.fromObject = function fromObject(object) {
        if (object instanceof $root.GroupLicenseInfo)
            return object;
        var message = new $root.GroupLicenseInfo();
        if (object.licensedOfferType != null)
            message.licensedOfferType = object.licensedOfferType | 0;
        if (object.gaiaGroupId != null)
            if ($util.Long)
                (message.gaiaGroupId = $util.Long.fromValue(object.gaiaGroupId)).unsigned = false;
            else if (typeof object.gaiaGroupId === "string")
                message.gaiaGroupId = parseInt(object.gaiaGroupId, 10);
            else if (typeof object.gaiaGroupId === "number")
                message.gaiaGroupId = object.gaiaGroupId;
            else if (typeof object.gaiaGroupId === "object")
                message.gaiaGroupId = new $util.LongBits(object.gaiaGroupId.low >>> 0, object.gaiaGroupId.high >>> 0).toNumber();
        return message;
    };

    /**
     * Creates a plain object from a GroupLicenseInfo message. Also converts values to other types if specified.
     * @function toObject
     * @memberof GroupLicenseInfo
     * @static
     * @param {GroupLicenseInfo} message GroupLicenseInfo
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    GroupLicenseInfo.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        var object = {};
        if (options.defaults) {
            object.licensedOfferType = 0;
            if ($util.Long) {
                var long = new $util.Long(0, 0, false);
                object.gaiaGroupId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
            } else
                object.gaiaGroupId = options.longs === String ? "0" : 0;
        }
        if (message.licensedOfferType != null && message.hasOwnProperty("licensedOfferType"))
            object.licensedOfferType = message.licensedOfferType;
        if (message.gaiaGroupId != null && message.hasOwnProperty("gaiaGroupId"))
            if (typeof message.gaiaGroupId === "number")
                object.gaiaGroupId = options.longs === String ? String(message.gaiaGroupId) : message.gaiaGroupId;
            else
                object.gaiaGroupId = options.longs === String ? $util.Long.prototype.toString.call(message.gaiaGroupId) : options.longs === Number ? new $util.LongBits(message.gaiaGroupId.low >>> 0, message.gaiaGroupId.high >>> 0).toNumber() : message.gaiaGroupId;
        return object;
    };

    /**
     * Converts this GroupLicenseInfo to JSON.
     * @function toJSON
     * @memberof GroupLicenseInfo
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    GroupLicenseInfo.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return GroupLicenseInfo;
})();

$root.LicensedDocumentInfo = (function() {

    /**
     * Properties of a LicensedDocumentInfo.
     * @exports ILicensedDocumentInfo
     * @interface ILicensedDocumentInfo
     * @property {Array.<number|Long>|null} [gaiaGroupId] LicensedDocumentInfo gaiaGroupId
     */

    /**
     * Constructs a new LicensedDocumentInfo.
     * @exports LicensedDocumentInfo
     * @classdesc Represents a LicensedDocumentInfo.
     * @implements ILicensedDocumentInfo
     * @constructor
     * @param {ILicensedDocumentInfo=} [properties] Properties to set
     */
    function LicensedDocumentInfo(properties) {
        this.gaiaGroupId = [];
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * LicensedDocumentInfo gaiaGroupId.
     * @member {Array.<number|Long>} gaiaGroupId
     * @memberof LicensedDocumentInfo
     * @instance
     */
    LicensedDocumentInfo.prototype.gaiaGroupId = $util.emptyArray;

    /**
     * Creates a new LicensedDocumentInfo instance using the specified properties.
     * @function create
     * @memberof LicensedDocumentInfo
     * @static
     * @param {ILicensedDocumentInfo=} [properties] Properties to set
     * @returns {LicensedDocumentInfo} LicensedDocumentInfo instance
     */
    LicensedDocumentInfo.create = function create(properties) {
        return new LicensedDocumentInfo(properties);
    };

    /**
     * Encodes the specified LicensedDocumentInfo message. Does not implicitly {@link LicensedDocumentInfo.verify|verify} messages.
     * @function encode
     * @memberof LicensedDocumentInfo
     * @static
     * @param {ILicensedDocumentInfo} message LicensedDocumentInfo message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    LicensedDocumentInfo.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.gaiaGroupId != null && message.gaiaGroupId.length)
            for (var i = 0; i < message.gaiaGroupId.length; ++i)
                writer.uint32(/* id 1, wireType 1 =*/9).fixed64(message.gaiaGroupId[i]);
        return writer;
    };

    /**
     * Encodes the specified LicensedDocumentInfo message, length delimited. Does not implicitly {@link LicensedDocumentInfo.verify|verify} messages.
     * @function encodeDelimited
     * @memberof LicensedDocumentInfo
     * @static
     * @param {ILicensedDocumentInfo} message LicensedDocumentInfo message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    LicensedDocumentInfo.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a LicensedDocumentInfo message from the specified reader or buffer.
     * @function decode
     * @memberof LicensedDocumentInfo
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {LicensedDocumentInfo} LicensedDocumentInfo
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    LicensedDocumentInfo.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.LicensedDocumentInfo();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                if (!(message.gaiaGroupId && message.gaiaGroupId.length))
                    message.gaiaGroupId = [];
                if ((tag & 7) === 2) {
                    var end2 = reader.uint32() + reader.pos;
                    while (reader.pos < end2)
                        message.gaiaGroupId.push(reader.fixed64());
                } else
                    message.gaiaGroupId.push(reader.fixed64());
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a LicensedDocumentInfo message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof LicensedDocumentInfo
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {LicensedDocumentInfo} LicensedDocumentInfo
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    LicensedDocumentInfo.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a LicensedDocumentInfo message.
     * @function verify
     * @memberof LicensedDocumentInfo
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    LicensedDocumentInfo.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.gaiaGroupId != null && message.hasOwnProperty("gaiaGroupId")) {
            if (!Array.isArray(message.gaiaGroupId))
                return "gaiaGroupId: array expected";
            for (var i = 0; i < message.gaiaGroupId.length; ++i)
                if (!$util.isInteger(message.gaiaGroupId[i]) && !(message.gaiaGroupId[i] && $util.isInteger(message.gaiaGroupId[i].low) && $util.isInteger(message.gaiaGroupId[i].high)))
                    return "gaiaGroupId: integer|Long[] expected";
        }
        return null;
    };

    /**
     * Creates a LicensedDocumentInfo message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof LicensedDocumentInfo
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {LicensedDocumentInfo} LicensedDocumentInfo
     */
    LicensedDocumentInfo.fromObject = function fromObject(object) {
        if (object instanceof $root.LicensedDocumentInfo)
            return object;
        var message = new $root.LicensedDocumentInfo();
        if (object.gaiaGroupId) {
            if (!Array.isArray(object.gaiaGroupId))
                throw TypeError(".LicensedDocumentInfo.gaiaGroupId: array expected");
            message.gaiaGroupId = [];
            for (var i = 0; i < object.gaiaGroupId.length; ++i)
                if ($util.Long)
                    (message.gaiaGroupId[i] = $util.Long.fromValue(object.gaiaGroupId[i])).unsigned = false;
                else if (typeof object.gaiaGroupId[i] === "string")
                    message.gaiaGroupId[i] = parseInt(object.gaiaGroupId[i], 10);
                else if (typeof object.gaiaGroupId[i] === "number")
                    message.gaiaGroupId[i] = object.gaiaGroupId[i];
                else if (typeof object.gaiaGroupId[i] === "object")
                    message.gaiaGroupId[i] = new $util.LongBits(object.gaiaGroupId[i].low >>> 0, object.gaiaGroupId[i].high >>> 0).toNumber();
        }
        return message;
    };

    /**
     * Creates a plain object from a LicensedDocumentInfo message. Also converts values to other types if specified.
     * @function toObject
     * @memberof LicensedDocumentInfo
     * @static
     * @param {LicensedDocumentInfo} message LicensedDocumentInfo
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    LicensedDocumentInfo.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        var object = {};
        if (options.arrays || options.defaults)
            object.gaiaGroupId = [];
        if (message.gaiaGroupId && message.gaiaGroupId.length) {
            object.gaiaGroupId = [];
            for (var j = 0; j < message.gaiaGroupId.length; ++j)
                if (typeof message.gaiaGroupId[j] === "number")
                    object.gaiaGroupId[j] = options.longs === String ? String(message.gaiaGroupId[j]) : message.gaiaGroupId[j];
                else
                    object.gaiaGroupId[j] = options.longs === String ? $util.Long.prototype.toString.call(message.gaiaGroupId[j]) : options.longs === Number ? new $util.LongBits(message.gaiaGroupId[j].low >>> 0, message.gaiaGroupId[j].high >>> 0).toNumber() : message.gaiaGroupId[j];
        }
        return object;
    };

    /**
     * Converts this LicensedDocumentInfo to JSON.
     * @function toJSON
     * @memberof LicensedDocumentInfo
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    LicensedDocumentInfo.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return LicensedDocumentInfo;
})();

$root.OwnershipInfo = (function() {

    /**
     * Properties of an OwnershipInfo.
     * @exports IOwnershipInfo
     * @interface IOwnershipInfo
     * @property {number|Long|null} [initiationTimestamp] OwnershipInfo initiationTimestamp
     * @property {number|Long|null} [validUntilTimestamp] OwnershipInfo validUntilTimestamp
     * @property {boolean|null} [autoRenewing] OwnershipInfo autoRenewing
     * @property {number|Long|null} [refundTimeoutTimestamp] OwnershipInfo refundTimeoutTimestamp
     * @property {number|Long|null} [postDeliveryRefundWindowMillis] OwnershipInfo postDeliveryRefundWindowMillis
     * @property {ISignedData|null} [developerPurchaseInfo] OwnershipInfo developerPurchaseInfo
     * @property {boolean|null} [preOrdered] OwnershipInfo preOrdered
     * @property {boolean|null} [hidden] OwnershipInfo hidden
     * @property {IRentalTerms|null} [rentalTerms] OwnershipInfo rentalTerms
     * @property {IGroupLicenseInfo|null} [groupLicenseInfo] OwnershipInfo groupLicenseInfo
     * @property {ILicensedDocumentInfo|null} [licensedDocumentInfo] OwnershipInfo licensedDocumentInfo
     * @property {number|null} [quantity] OwnershipInfo quantity
     * @property {number|Long|null} [libraryExpirationTimestamp] OwnershipInfo libraryExpirationTimestamp
     */

    /**
     * Constructs a new OwnershipInfo.
     * @exports OwnershipInfo
     * @classdesc Represents an OwnershipInfo.
     * @implements IOwnershipInfo
     * @constructor
     * @param {IOwnershipInfo=} [properties] Properties to set
     */
    function OwnershipInfo(properties) {
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * OwnershipInfo initiationTimestamp.
     * @member {number|Long} initiationTimestamp
     * @memberof OwnershipInfo
     * @instance
     */
    OwnershipInfo.prototype.initiationTimestamp = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

    /**
     * OwnershipInfo validUntilTimestamp.
     * @member {number|Long} validUntilTimestamp
     * @memberof OwnershipInfo
     * @instance
     */
    OwnershipInfo.prototype.validUntilTimestamp = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

    /**
     * OwnershipInfo autoRenewing.
     * @member {boolean} autoRenewing
     * @memberof OwnershipInfo
     * @instance
     */
    OwnershipInfo.prototype.autoRenewing = false;

    /**
     * OwnershipInfo refundTimeoutTimestamp.
     * @member {number|Long} refundTimeoutTimestamp
     * @memberof OwnershipInfo
     * @instance
     */
    OwnershipInfo.prototype.refundTimeoutTimestamp = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

    /**
     * OwnershipInfo postDeliveryRefundWindowMillis.
     * @member {number|Long} postDeliveryRefundWindowMillis
     * @memberof OwnershipInfo
     * @instance
     */
    OwnershipInfo.prototype.postDeliveryRefundWindowMillis = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

    /**
     * OwnershipInfo developerPurchaseInfo.
     * @member {ISignedData|null|undefined} developerPurchaseInfo
     * @memberof OwnershipInfo
     * @instance
     */
    OwnershipInfo.prototype.developerPurchaseInfo = null;

    /**
     * OwnershipInfo preOrdered.
     * @member {boolean} preOrdered
     * @memberof OwnershipInfo
     * @instance
     */
    OwnershipInfo.prototype.preOrdered = false;

    /**
     * OwnershipInfo hidden.
     * @member {boolean} hidden
     * @memberof OwnershipInfo
     * @instance
     */
    OwnershipInfo.prototype.hidden = false;

    /**
     * OwnershipInfo rentalTerms.
     * @member {IRentalTerms|null|undefined} rentalTerms
     * @memberof OwnershipInfo
     * @instance
     */
    OwnershipInfo.prototype.rentalTerms = null;

    /**
     * OwnershipInfo groupLicenseInfo.
     * @member {IGroupLicenseInfo|null|undefined} groupLicenseInfo
     * @memberof OwnershipInfo
     * @instance
     */
    OwnershipInfo.prototype.groupLicenseInfo = null;

    /**
     * OwnershipInfo licensedDocumentInfo.
     * @member {ILicensedDocumentInfo|null|undefined} licensedDocumentInfo
     * @memberof OwnershipInfo
     * @instance
     */
    OwnershipInfo.prototype.licensedDocumentInfo = null;

    /**
     * OwnershipInfo quantity.
     * @member {number} quantity
     * @memberof OwnershipInfo
     * @instance
     */
    OwnershipInfo.prototype.quantity = 0;

    /**
     * OwnershipInfo libraryExpirationTimestamp.
     * @member {number|Long} libraryExpirationTimestamp
     * @memberof OwnershipInfo
     * @instance
     */
    OwnershipInfo.prototype.libraryExpirationTimestamp = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

    /**
     * Creates a new OwnershipInfo instance using the specified properties.
     * @function create
     * @memberof OwnershipInfo
     * @static
     * @param {IOwnershipInfo=} [properties] Properties to set
     * @returns {OwnershipInfo} OwnershipInfo instance
     */
    OwnershipInfo.create = function create(properties) {
        return new OwnershipInfo(properties);
    };

    /**
     * Encodes the specified OwnershipInfo message. Does not implicitly {@link OwnershipInfo.verify|verify} messages.
     * @function encode
     * @memberof OwnershipInfo
     * @static
     * @param {IOwnershipInfo} message OwnershipInfo message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    OwnershipInfo.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.initiationTimestamp != null && Object.hasOwnProperty.call(message, "initiationTimestamp"))
            writer.uint32(/* id 1, wireType 0 =*/8).int64(message.initiationTimestamp);
        if (message.validUntilTimestamp != null && Object.hasOwnProperty.call(message, "validUntilTimestamp"))
            writer.uint32(/* id 2, wireType 0 =*/16).int64(message.validUntilTimestamp);
        if (message.autoRenewing != null && Object.hasOwnProperty.call(message, "autoRenewing"))
            writer.uint32(/* id 3, wireType 0 =*/24).bool(message.autoRenewing);
        if (message.refundTimeoutTimestamp != null && Object.hasOwnProperty.call(message, "refundTimeoutTimestamp"))
            writer.uint32(/* id 4, wireType 0 =*/32).int64(message.refundTimeoutTimestamp);
        if (message.postDeliveryRefundWindowMillis != null && Object.hasOwnProperty.call(message, "postDeliveryRefundWindowMillis"))
            writer.uint32(/* id 5, wireType 0 =*/40).int64(message.postDeliveryRefundWindowMillis);
        if (message.developerPurchaseInfo != null && Object.hasOwnProperty.call(message, "developerPurchaseInfo"))
            $root.SignedData.encode(message.developerPurchaseInfo, writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
        if (message.preOrdered != null && Object.hasOwnProperty.call(message, "preOrdered"))
            writer.uint32(/* id 7, wireType 0 =*/56).bool(message.preOrdered);
        if (message.hidden != null && Object.hasOwnProperty.call(message, "hidden"))
            writer.uint32(/* id 8, wireType 0 =*/64).bool(message.hidden);
        if (message.rentalTerms != null && Object.hasOwnProperty.call(message, "rentalTerms"))
            $root.RentalTerms.encode(message.rentalTerms, writer.uint32(/* id 9, wireType 2 =*/74).fork()).ldelim();
        if (message.groupLicenseInfo != null && Object.hasOwnProperty.call(message, "groupLicenseInfo"))
            $root.GroupLicenseInfo.encode(message.groupLicenseInfo, writer.uint32(/* id 10, wireType 2 =*/82).fork()).ldelim();
        if (message.licensedDocumentInfo != null && Object.hasOwnProperty.call(message, "licensedDocumentInfo"))
            $root.LicensedDocumentInfo.encode(message.licensedDocumentInfo, writer.uint32(/* id 11, wireType 2 =*/90).fork()).ldelim();
        if (message.quantity != null && Object.hasOwnProperty.call(message, "quantity"))
            writer.uint32(/* id 12, wireType 0 =*/96).int32(message.quantity);
        if (message.libraryExpirationTimestamp != null && Object.hasOwnProperty.call(message, "libraryExpirationTimestamp"))
            writer.uint32(/* id 14, wireType 0 =*/112).int64(message.libraryExpirationTimestamp);
        return writer;
    };

    /**
     * Encodes the specified OwnershipInfo message, length delimited. Does not implicitly {@link OwnershipInfo.verify|verify} messages.
     * @function encodeDelimited
     * @memberof OwnershipInfo
     * @static
     * @param {IOwnershipInfo} message OwnershipInfo message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    OwnershipInfo.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes an OwnershipInfo message from the specified reader or buffer.
     * @function decode
     * @memberof OwnershipInfo
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {OwnershipInfo} OwnershipInfo
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    OwnershipInfo.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.OwnershipInfo();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.initiationTimestamp = reader.int64();
                break;
            case 2:
                message.validUntilTimestamp = reader.int64();
                break;
            case 3:
                message.autoRenewing = reader.bool();
                break;
            case 4:
                message.refundTimeoutTimestamp = reader.int64();
                break;
            case 5:
                message.postDeliveryRefundWindowMillis = reader.int64();
                break;
            case 6:
                message.developerPurchaseInfo = $root.SignedData.decode(reader, reader.uint32());
                break;
            case 7:
                message.preOrdered = reader.bool();
                break;
            case 8:
                message.hidden = reader.bool();
                break;
            case 9:
                message.rentalTerms = $root.RentalTerms.decode(reader, reader.uint32());
                break;
            case 10:
                message.groupLicenseInfo = $root.GroupLicenseInfo.decode(reader, reader.uint32());
                break;
            case 11:
                message.licensedDocumentInfo = $root.LicensedDocumentInfo.decode(reader, reader.uint32());
                break;
            case 12:
                message.quantity = reader.int32();
                break;
            case 14:
                message.libraryExpirationTimestamp = reader.int64();
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes an OwnershipInfo message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof OwnershipInfo
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {OwnershipInfo} OwnershipInfo
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    OwnershipInfo.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies an OwnershipInfo message.
     * @function verify
     * @memberof OwnershipInfo
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    OwnershipInfo.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.initiationTimestamp != null && message.hasOwnProperty("initiationTimestamp"))
            if (!$util.isInteger(message.initiationTimestamp) && !(message.initiationTimestamp && $util.isInteger(message.initiationTimestamp.low) && $util.isInteger(message.initiationTimestamp.high)))
                return "initiationTimestamp: integer|Long expected";
        if (message.validUntilTimestamp != null && message.hasOwnProperty("validUntilTimestamp"))
            if (!$util.isInteger(message.validUntilTimestamp) && !(message.validUntilTimestamp && $util.isInteger(message.validUntilTimestamp.low) && $util.isInteger(message.validUntilTimestamp.high)))
                return "validUntilTimestamp: integer|Long expected";
        if (message.autoRenewing != null && message.hasOwnProperty("autoRenewing"))
            if (typeof message.autoRenewing !== "boolean")
                return "autoRenewing: boolean expected";
        if (message.refundTimeoutTimestamp != null && message.hasOwnProperty("refundTimeoutTimestamp"))
            if (!$util.isInteger(message.refundTimeoutTimestamp) && !(message.refundTimeoutTimestamp && $util.isInteger(message.refundTimeoutTimestamp.low) && $util.isInteger(message.refundTimeoutTimestamp.high)))
                return "refundTimeoutTimestamp: integer|Long expected";
        if (message.postDeliveryRefundWindowMillis != null && message.hasOwnProperty("postDeliveryRefundWindowMillis"))
            if (!$util.isInteger(message.postDeliveryRefundWindowMillis) && !(message.postDeliveryRefundWindowMillis && $util.isInteger(message.postDeliveryRefundWindowMillis.low) && $util.isInteger(message.postDeliveryRefundWindowMillis.high)))
                return "postDeliveryRefundWindowMillis: integer|Long expected";
        if (message.developerPurchaseInfo != null && message.hasOwnProperty("developerPurchaseInfo")) {
            var error = $root.SignedData.verify(message.developerPurchaseInfo);
            if (error)
                return "developerPurchaseInfo." + error;
        }
        if (message.preOrdered != null && message.hasOwnProperty("preOrdered"))
            if (typeof message.preOrdered !== "boolean")
                return "preOrdered: boolean expected";
        if (message.hidden != null && message.hasOwnProperty("hidden"))
            if (typeof message.hidden !== "boolean")
                return "hidden: boolean expected";
        if (message.rentalTerms != null && message.hasOwnProperty("rentalTerms")) {
            var error = $root.RentalTerms.verify(message.rentalTerms);
            if (error)
                return "rentalTerms." + error;
        }
        if (message.groupLicenseInfo != null && message.hasOwnProperty("groupLicenseInfo")) {
            var error = $root.GroupLicenseInfo.verify(message.groupLicenseInfo);
            if (error)
                return "groupLicenseInfo." + error;
        }
        if (message.licensedDocumentInfo != null && message.hasOwnProperty("licensedDocumentInfo")) {
            var error = $root.LicensedDocumentInfo.verify(message.licensedDocumentInfo);
            if (error)
                return "licensedDocumentInfo." + error;
        }
        if (message.quantity != null && message.hasOwnProperty("quantity"))
            if (!$util.isInteger(message.quantity))
                return "quantity: integer expected";
        if (message.libraryExpirationTimestamp != null && message.hasOwnProperty("libraryExpirationTimestamp"))
            if (!$util.isInteger(message.libraryExpirationTimestamp) && !(message.libraryExpirationTimestamp && $util.isInteger(message.libraryExpirationTimestamp.low) && $util.isInteger(message.libraryExpirationTimestamp.high)))
                return "libraryExpirationTimestamp: integer|Long expected";
        return null;
    };

    /**
     * Creates an OwnershipInfo message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof OwnershipInfo
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {OwnershipInfo} OwnershipInfo
     */
    OwnershipInfo.fromObject = function fromObject(object) {
        if (object instanceof $root.OwnershipInfo)
            return object;
        var message = new $root.OwnershipInfo();
        if (object.initiationTimestamp != null)
            if ($util.Long)
                (message.initiationTimestamp = $util.Long.fromValue(object.initiationTimestamp)).unsigned = false;
            else if (typeof object.initiationTimestamp === "string")
                message.initiationTimestamp = parseInt(object.initiationTimestamp, 10);
            else if (typeof object.initiationTimestamp === "number")
                message.initiationTimestamp = object.initiationTimestamp;
            else if (typeof object.initiationTimestamp === "object")
                message.initiationTimestamp = new $util.LongBits(object.initiationTimestamp.low >>> 0, object.initiationTimestamp.high >>> 0).toNumber();
        if (object.validUntilTimestamp != null)
            if ($util.Long)
                (message.validUntilTimestamp = $util.Long.fromValue(object.validUntilTimestamp)).unsigned = false;
            else if (typeof object.validUntilTimestamp === "string")
                message.validUntilTimestamp = parseInt(object.validUntilTimestamp, 10);
            else if (typeof object.validUntilTimestamp === "number")
                message.validUntilTimestamp = object.validUntilTimestamp;
            else if (typeof object.validUntilTimestamp === "object")
                message.validUntilTimestamp = new $util.LongBits(object.validUntilTimestamp.low >>> 0, object.validUntilTimestamp.high >>> 0).toNumber();
        if (object.autoRenewing != null)
            message.autoRenewing = Boolean(object.autoRenewing);
        if (object.refundTimeoutTimestamp != null)
            if ($util.Long)
                (message.refundTimeoutTimestamp = $util.Long.fromValue(object.refundTimeoutTimestamp)).unsigned = false;
            else if (typeof object.refundTimeoutTimestamp === "string")
                message.refundTimeoutTimestamp = parseInt(object.refundTimeoutTimestamp, 10);
            else if (typeof object.refundTimeoutTimestamp === "number")
                message.refundTimeoutTimestamp = object.refundTimeoutTimestamp;
            else if (typeof object.refundTimeoutTimestamp === "object")
                message.refundTimeoutTimestamp = new $util.LongBits(object.refundTimeoutTimestamp.low >>> 0, object.refundTimeoutTimestamp.high >>> 0).toNumber();
        if (object.postDeliveryRefundWindowMillis != null)
            if ($util.Long)
                (message.postDeliveryRefundWindowMillis = $util.Long.fromValue(object.postDeliveryRefundWindowMillis)).unsigned = false;
            else if (typeof object.postDeliveryRefundWindowMillis === "string")
                message.postDeliveryRefundWindowMillis = parseInt(object.postDeliveryRefundWindowMillis, 10);
            else if (typeof object.postDeliveryRefundWindowMillis === "number")
                message.postDeliveryRefundWindowMillis = object.postDeliveryRefundWindowMillis;
            else if (typeof object.postDeliveryRefundWindowMillis === "object")
                message.postDeliveryRefundWindowMillis = new $util.LongBits(object.postDeliveryRefundWindowMillis.low >>> 0, object.postDeliveryRefundWindowMillis.high >>> 0).toNumber();
        if (object.developerPurchaseInfo != null) {
            if (typeof object.developerPurchaseInfo !== "object")
                throw TypeError(".OwnershipInfo.developerPurchaseInfo: object expected");
            message.developerPurchaseInfo = $root.SignedData.fromObject(object.developerPurchaseInfo);
        }
        if (object.preOrdered != null)
            message.preOrdered = Boolean(object.preOrdered);
        if (object.hidden != null)
            message.hidden = Boolean(object.hidden);
        if (object.rentalTerms != null) {
            if (typeof object.rentalTerms !== "object")
                throw TypeError(".OwnershipInfo.rentalTerms: object expected");
            message.rentalTerms = $root.RentalTerms.fromObject(object.rentalTerms);
        }
        if (object.groupLicenseInfo != null) {
            if (typeof object.groupLicenseInfo !== "object")
                throw TypeError(".OwnershipInfo.groupLicenseInfo: object expected");
            message.groupLicenseInfo = $root.GroupLicenseInfo.fromObject(object.groupLicenseInfo);
        }
        if (object.licensedDocumentInfo != null) {
            if (typeof object.licensedDocumentInfo !== "object")
                throw TypeError(".OwnershipInfo.licensedDocumentInfo: object expected");
            message.licensedDocumentInfo = $root.LicensedDocumentInfo.fromObject(object.licensedDocumentInfo);
        }
        if (object.quantity != null)
            message.quantity = object.quantity | 0;
        if (object.libraryExpirationTimestamp != null)
            if ($util.Long)
                (message.libraryExpirationTimestamp = $util.Long.fromValue(object.libraryExpirationTimestamp)).unsigned = false;
            else if (typeof object.libraryExpirationTimestamp === "string")
                message.libraryExpirationTimestamp = parseInt(object.libraryExpirationTimestamp, 10);
            else if (typeof object.libraryExpirationTimestamp === "number")
                message.libraryExpirationTimestamp = object.libraryExpirationTimestamp;
            else if (typeof object.libraryExpirationTimestamp === "object")
                message.libraryExpirationTimestamp = new $util.LongBits(object.libraryExpirationTimestamp.low >>> 0, object.libraryExpirationTimestamp.high >>> 0).toNumber();
        return message;
    };

    /**
     * Creates a plain object from an OwnershipInfo message. Also converts values to other types if specified.
     * @function toObject
     * @memberof OwnershipInfo
     * @static
     * @param {OwnershipInfo} message OwnershipInfo
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    OwnershipInfo.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        var object = {};
        if (options.defaults) {
            if ($util.Long) {
                var long = new $util.Long(0, 0, false);
                object.initiationTimestamp = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
            } else
                object.initiationTimestamp = options.longs === String ? "0" : 0;
            if ($util.Long) {
                var long = new $util.Long(0, 0, false);
                object.validUntilTimestamp = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
            } else
                object.validUntilTimestamp = options.longs === String ? "0" : 0;
            object.autoRenewing = false;
            if ($util.Long) {
                var long = new $util.Long(0, 0, false);
                object.refundTimeoutTimestamp = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
            } else
                object.refundTimeoutTimestamp = options.longs === String ? "0" : 0;
            if ($util.Long) {
                var long = new $util.Long(0, 0, false);
                object.postDeliveryRefundWindowMillis = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
            } else
                object.postDeliveryRefundWindowMillis = options.longs === String ? "0" : 0;
            object.developerPurchaseInfo = null;
            object.preOrdered = false;
            object.hidden = false;
            object.rentalTerms = null;
            object.groupLicenseInfo = null;
            object.licensedDocumentInfo = null;
            object.quantity = 0;
            if ($util.Long) {
                var long = new $util.Long(0, 0, false);
                object.libraryExpirationTimestamp = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
            } else
                object.libraryExpirationTimestamp = options.longs === String ? "0" : 0;
        }
        if (message.initiationTimestamp != null && message.hasOwnProperty("initiationTimestamp"))
            if (typeof message.initiationTimestamp === "number")
                object.initiationTimestamp = options.longs === String ? String(message.initiationTimestamp) : message.initiationTimestamp;
            else
                object.initiationTimestamp = options.longs === String ? $util.Long.prototype.toString.call(message.initiationTimestamp) : options.longs === Number ? new $util.LongBits(message.initiationTimestamp.low >>> 0, message.initiationTimestamp.high >>> 0).toNumber() : message.initiationTimestamp;
        if (message.validUntilTimestamp != null && message.hasOwnProperty("validUntilTimestamp"))
            if (typeof message.validUntilTimestamp === "number")
                object.validUntilTimestamp = options.longs === String ? String(message.validUntilTimestamp) : message.validUntilTimestamp;
            else
                object.validUntilTimestamp = options.longs === String ? $util.Long.prototype.toString.call(message.validUntilTimestamp) : options.longs === Number ? new $util.LongBits(message.validUntilTimestamp.low >>> 0, message.validUntilTimestamp.high >>> 0).toNumber() : message.validUntilTimestamp;
        if (message.autoRenewing != null && message.hasOwnProperty("autoRenewing"))
            object.autoRenewing = message.autoRenewing;
        if (message.refundTimeoutTimestamp != null && message.hasOwnProperty("refundTimeoutTimestamp"))
            if (typeof message.refundTimeoutTimestamp === "number")
                object.refundTimeoutTimestamp = options.longs === String ? String(message.refundTimeoutTimestamp) : message.refundTimeoutTimestamp;
            else
                object.refundTimeoutTimestamp = options.longs === String ? $util.Long.prototype.toString.call(message.refundTimeoutTimestamp) : options.longs === Number ? new $util.LongBits(message.refundTimeoutTimestamp.low >>> 0, message.refundTimeoutTimestamp.high >>> 0).toNumber() : message.refundTimeoutTimestamp;
        if (message.postDeliveryRefundWindowMillis != null && message.hasOwnProperty("postDeliveryRefundWindowMillis"))
            if (typeof message.postDeliveryRefundWindowMillis === "number")
                object.postDeliveryRefundWindowMillis = options.longs === String ? String(message.postDeliveryRefundWindowMillis) : message.postDeliveryRefundWindowMillis;
            else
                object.postDeliveryRefundWindowMillis = options.longs === String ? $util.Long.prototype.toString.call(message.postDeliveryRefundWindowMillis) : options.longs === Number ? new $util.LongBits(message.postDeliveryRefundWindowMillis.low >>> 0, message.postDeliveryRefundWindowMillis.high >>> 0).toNumber() : message.postDeliveryRefundWindowMillis;
        if (message.developerPurchaseInfo != null && message.hasOwnProperty("developerPurchaseInfo"))
            object.developerPurchaseInfo = $root.SignedData.toObject(message.developerPurchaseInfo, options);
        if (message.preOrdered != null && message.hasOwnProperty("preOrdered"))
            object.preOrdered = message.preOrdered;
        if (message.hidden != null && message.hasOwnProperty("hidden"))
            object.hidden = message.hidden;
        if (message.rentalTerms != null && message.hasOwnProperty("rentalTerms"))
            object.rentalTerms = $root.RentalTerms.toObject(message.rentalTerms, options);
        if (message.groupLicenseInfo != null && message.hasOwnProperty("groupLicenseInfo"))
            object.groupLicenseInfo = $root.GroupLicenseInfo.toObject(message.groupLicenseInfo, options);
        if (message.licensedDocumentInfo != null && message.hasOwnProperty("licensedDocumentInfo"))
            object.licensedDocumentInfo = $root.LicensedDocumentInfo.toObject(message.licensedDocumentInfo, options);
        if (message.quantity != null && message.hasOwnProperty("quantity"))
            object.quantity = message.quantity;
        if (message.libraryExpirationTimestamp != null && message.hasOwnProperty("libraryExpirationTimestamp"))
            if (typeof message.libraryExpirationTimestamp === "number")
                object.libraryExpirationTimestamp = options.longs === String ? String(message.libraryExpirationTimestamp) : message.libraryExpirationTimestamp;
            else
                object.libraryExpirationTimestamp = options.longs === String ? $util.Long.prototype.toString.call(message.libraryExpirationTimestamp) : options.longs === Number ? new $util.LongBits(message.libraryExpirationTimestamp.low >>> 0, message.libraryExpirationTimestamp.high >>> 0).toNumber() : message.libraryExpirationTimestamp;
        return object;
    };

    /**
     * Converts this OwnershipInfo to JSON.
     * @function toJSON
     * @memberof OwnershipInfo
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    OwnershipInfo.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return OwnershipInfo;
})();

$root.SubscriptionTerms = (function() {

    /**
     * Properties of a SubscriptionTerms.
     * @exports ISubscriptionTerms
     * @interface ISubscriptionTerms
     * @property {ITimePeriod|null} [recurringPeriod] SubscriptionTerms recurringPeriod
     * @property {ITimePeriod|null} [trialPeriod] SubscriptionTerms trialPeriod
     */

    /**
     * Constructs a new SubscriptionTerms.
     * @exports SubscriptionTerms
     * @classdesc Represents a SubscriptionTerms.
     * @implements ISubscriptionTerms
     * @constructor
     * @param {ISubscriptionTerms=} [properties] Properties to set
     */
    function SubscriptionTerms(properties) {
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * SubscriptionTerms recurringPeriod.
     * @member {ITimePeriod|null|undefined} recurringPeriod
     * @memberof SubscriptionTerms
     * @instance
     */
    SubscriptionTerms.prototype.recurringPeriod = null;

    /**
     * SubscriptionTerms trialPeriod.
     * @member {ITimePeriod|null|undefined} trialPeriod
     * @memberof SubscriptionTerms
     * @instance
     */
    SubscriptionTerms.prototype.trialPeriod = null;

    /**
     * Creates a new SubscriptionTerms instance using the specified properties.
     * @function create
     * @memberof SubscriptionTerms
     * @static
     * @param {ISubscriptionTerms=} [properties] Properties to set
     * @returns {SubscriptionTerms} SubscriptionTerms instance
     */
    SubscriptionTerms.create = function create(properties) {
        return new SubscriptionTerms(properties);
    };

    /**
     * Encodes the specified SubscriptionTerms message. Does not implicitly {@link SubscriptionTerms.verify|verify} messages.
     * @function encode
     * @memberof SubscriptionTerms
     * @static
     * @param {ISubscriptionTerms} message SubscriptionTerms message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    SubscriptionTerms.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.recurringPeriod != null && Object.hasOwnProperty.call(message, "recurringPeriod"))
            $root.TimePeriod.encode(message.recurringPeriod, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
        if (message.trialPeriod != null && Object.hasOwnProperty.call(message, "trialPeriod"))
            $root.TimePeriod.encode(message.trialPeriod, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
        return writer;
    };

    /**
     * Encodes the specified SubscriptionTerms message, length delimited. Does not implicitly {@link SubscriptionTerms.verify|verify} messages.
     * @function encodeDelimited
     * @memberof SubscriptionTerms
     * @static
     * @param {ISubscriptionTerms} message SubscriptionTerms message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    SubscriptionTerms.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a SubscriptionTerms message from the specified reader or buffer.
     * @function decode
     * @memberof SubscriptionTerms
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {SubscriptionTerms} SubscriptionTerms
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    SubscriptionTerms.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.SubscriptionTerms();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.recurringPeriod = $root.TimePeriod.decode(reader, reader.uint32());
                break;
            case 2:
                message.trialPeriod = $root.TimePeriod.decode(reader, reader.uint32());
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a SubscriptionTerms message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof SubscriptionTerms
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {SubscriptionTerms} SubscriptionTerms
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    SubscriptionTerms.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a SubscriptionTerms message.
     * @function verify
     * @memberof SubscriptionTerms
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    SubscriptionTerms.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.recurringPeriod != null && message.hasOwnProperty("recurringPeriod")) {
            var error = $root.TimePeriod.verify(message.recurringPeriod);
            if (error)
                return "recurringPeriod." + error;
        }
        if (message.trialPeriod != null && message.hasOwnProperty("trialPeriod")) {
            var error = $root.TimePeriod.verify(message.trialPeriod);
            if (error)
                return "trialPeriod." + error;
        }
        return null;
    };

    /**
     * Creates a SubscriptionTerms message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof SubscriptionTerms
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {SubscriptionTerms} SubscriptionTerms
     */
    SubscriptionTerms.fromObject = function fromObject(object) {
        if (object instanceof $root.SubscriptionTerms)
            return object;
        var message = new $root.SubscriptionTerms();
        if (object.recurringPeriod != null) {
            if (typeof object.recurringPeriod !== "object")
                throw TypeError(".SubscriptionTerms.recurringPeriod: object expected");
            message.recurringPeriod = $root.TimePeriod.fromObject(object.recurringPeriod);
        }
        if (object.trialPeriod != null) {
            if (typeof object.trialPeriod !== "object")
                throw TypeError(".SubscriptionTerms.trialPeriod: object expected");
            message.trialPeriod = $root.TimePeriod.fromObject(object.trialPeriod);
        }
        return message;
    };

    /**
     * Creates a plain object from a SubscriptionTerms message. Also converts values to other types if specified.
     * @function toObject
     * @memberof SubscriptionTerms
     * @static
     * @param {SubscriptionTerms} message SubscriptionTerms
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    SubscriptionTerms.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        var object = {};
        if (options.defaults) {
            object.recurringPeriod = null;
            object.trialPeriod = null;
        }
        if (message.recurringPeriod != null && message.hasOwnProperty("recurringPeriod"))
            object.recurringPeriod = $root.TimePeriod.toObject(message.recurringPeriod, options);
        if (message.trialPeriod != null && message.hasOwnProperty("trialPeriod"))
            object.trialPeriod = $root.TimePeriod.toObject(message.trialPeriod, options);
        return object;
    };

    /**
     * Converts this SubscriptionTerms to JSON.
     * @function toJSON
     * @memberof SubscriptionTerms
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    SubscriptionTerms.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return SubscriptionTerms;
})();

$root.TimePeriod = (function() {

    /**
     * Properties of a TimePeriod.
     * @exports ITimePeriod
     * @interface ITimePeriod
     * @property {number|null} [unit] TimePeriod unit
     * @property {number|null} [count] TimePeriod count
     */

    /**
     * Constructs a new TimePeriod.
     * @exports TimePeriod
     * @classdesc Represents a TimePeriod.
     * @implements ITimePeriod
     * @constructor
     * @param {ITimePeriod=} [properties] Properties to set
     */
    function TimePeriod(properties) {
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * TimePeriod unit.
     * @member {number} unit
     * @memberof TimePeriod
     * @instance
     */
    TimePeriod.prototype.unit = 0;

    /**
     * TimePeriod count.
     * @member {number} count
     * @memberof TimePeriod
     * @instance
     */
    TimePeriod.prototype.count = 0;

    /**
     * Creates a new TimePeriod instance using the specified properties.
     * @function create
     * @memberof TimePeriod
     * @static
     * @param {ITimePeriod=} [properties] Properties to set
     * @returns {TimePeriod} TimePeriod instance
     */
    TimePeriod.create = function create(properties) {
        return new TimePeriod(properties);
    };

    /**
     * Encodes the specified TimePeriod message. Does not implicitly {@link TimePeriod.verify|verify} messages.
     * @function encode
     * @memberof TimePeriod
     * @static
     * @param {ITimePeriod} message TimePeriod message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    TimePeriod.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.unit != null && Object.hasOwnProperty.call(message, "unit"))
            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.unit);
        if (message.count != null && Object.hasOwnProperty.call(message, "count"))
            writer.uint32(/* id 2, wireType 0 =*/16).int32(message.count);
        return writer;
    };

    /**
     * Encodes the specified TimePeriod message, length delimited. Does not implicitly {@link TimePeriod.verify|verify} messages.
     * @function encodeDelimited
     * @memberof TimePeriod
     * @static
     * @param {ITimePeriod} message TimePeriod message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    TimePeriod.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a TimePeriod message from the specified reader or buffer.
     * @function decode
     * @memberof TimePeriod
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {TimePeriod} TimePeriod
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    TimePeriod.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.TimePeriod();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.unit = reader.int32();
                break;
            case 2:
                message.count = reader.int32();
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a TimePeriod message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof TimePeriod
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {TimePeriod} TimePeriod
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    TimePeriod.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a TimePeriod message.
     * @function verify
     * @memberof TimePeriod
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    TimePeriod.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.unit != null && message.hasOwnProperty("unit"))
            if (!$util.isInteger(message.unit))
                return "unit: integer expected";
        if (message.count != null && message.hasOwnProperty("count"))
            if (!$util.isInteger(message.count))
                return "count: integer expected";
        return null;
    };

    /**
     * Creates a TimePeriod message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof TimePeriod
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {TimePeriod} TimePeriod
     */
    TimePeriod.fromObject = function fromObject(object) {
        if (object instanceof $root.TimePeriod)
            return object;
        var message = new $root.TimePeriod();
        if (object.unit != null)
            message.unit = object.unit | 0;
        if (object.count != null)
            message.count = object.count | 0;
        return message;
    };

    /**
     * Creates a plain object from a TimePeriod message. Also converts values to other types if specified.
     * @function toObject
     * @memberof TimePeriod
     * @static
     * @param {TimePeriod} message TimePeriod
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    TimePeriod.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        var object = {};
        if (options.defaults) {
            object.unit = 0;
            object.count = 0;
        }
        if (message.unit != null && message.hasOwnProperty("unit"))
            object.unit = message.unit;
        if (message.count != null && message.hasOwnProperty("count"))
            object.count = message.count;
        return object;
    };

    /**
     * Converts this TimePeriod to JSON.
     * @function toJSON
     * @memberof TimePeriod
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    TimePeriod.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return TimePeriod;
})();

$root.BillingAddressSpec = (function() {

    /**
     * Properties of a BillingAddressSpec.
     * @exports IBillingAddressSpec
     * @interface IBillingAddressSpec
     * @property {number|null} [billingAddressType] BillingAddressSpec billingAddressType
     * @property {Array.<number>|null} [requiredField] BillingAddressSpec requiredField
     */

    /**
     * Constructs a new BillingAddressSpec.
     * @exports BillingAddressSpec
     * @classdesc Represents a BillingAddressSpec.
     * @implements IBillingAddressSpec
     * @constructor
     * @param {IBillingAddressSpec=} [properties] Properties to set
     */
    function BillingAddressSpec(properties) {
        this.requiredField = [];
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * BillingAddressSpec billingAddressType.
     * @member {number} billingAddressType
     * @memberof BillingAddressSpec
     * @instance
     */
    BillingAddressSpec.prototype.billingAddressType = 0;

    /**
     * BillingAddressSpec requiredField.
     * @member {Array.<number>} requiredField
     * @memberof BillingAddressSpec
     * @instance
     */
    BillingAddressSpec.prototype.requiredField = $util.emptyArray;

    /**
     * Creates a new BillingAddressSpec instance using the specified properties.
     * @function create
     * @memberof BillingAddressSpec
     * @static
     * @param {IBillingAddressSpec=} [properties] Properties to set
     * @returns {BillingAddressSpec} BillingAddressSpec instance
     */
    BillingAddressSpec.create = function create(properties) {
        return new BillingAddressSpec(properties);
    };

    /**
     * Encodes the specified BillingAddressSpec message. Does not implicitly {@link BillingAddressSpec.verify|verify} messages.
     * @function encode
     * @memberof BillingAddressSpec
     * @static
     * @param {IBillingAddressSpec} message BillingAddressSpec message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    BillingAddressSpec.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.billingAddressType != null && Object.hasOwnProperty.call(message, "billingAddressType"))
            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.billingAddressType);
        if (message.requiredField != null && message.requiredField.length)
            for (var i = 0; i < message.requiredField.length; ++i)
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.requiredField[i]);
        return writer;
    };

    /**
     * Encodes the specified BillingAddressSpec message, length delimited. Does not implicitly {@link BillingAddressSpec.verify|verify} messages.
     * @function encodeDelimited
     * @memberof BillingAddressSpec
     * @static
     * @param {IBillingAddressSpec} message BillingAddressSpec message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    BillingAddressSpec.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a BillingAddressSpec message from the specified reader or buffer.
     * @function decode
     * @memberof BillingAddressSpec
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {BillingAddressSpec} BillingAddressSpec
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    BillingAddressSpec.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.BillingAddressSpec();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.billingAddressType = reader.int32();
                break;
            case 2:
                if (!(message.requiredField && message.requiredField.length))
                    message.requiredField = [];
                if ((tag & 7) === 2) {
                    var end2 = reader.uint32() + reader.pos;
                    while (reader.pos < end2)
                        message.requiredField.push(reader.int32());
                } else
                    message.requiredField.push(reader.int32());
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a BillingAddressSpec message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof BillingAddressSpec
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {BillingAddressSpec} BillingAddressSpec
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    BillingAddressSpec.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a BillingAddressSpec message.
     * @function verify
     * @memberof BillingAddressSpec
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    BillingAddressSpec.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.billingAddressType != null && message.hasOwnProperty("billingAddressType"))
            if (!$util.isInteger(message.billingAddressType))
                return "billingAddressType: integer expected";
        if (message.requiredField != null && message.hasOwnProperty("requiredField")) {
            if (!Array.isArray(message.requiredField))
                return "requiredField: array expected";
            for (var i = 0; i < message.requiredField.length; ++i)
                if (!$util.isInteger(message.requiredField[i]))
                    return "requiredField: integer[] expected";
        }
        return null;
    };

    /**
     * Creates a BillingAddressSpec message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof BillingAddressSpec
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {BillingAddressSpec} BillingAddressSpec
     */
    BillingAddressSpec.fromObject = function fromObject(object) {
        if (object instanceof $root.BillingAddressSpec)
            return object;
        var message = new $root.BillingAddressSpec();
        if (object.billingAddressType != null)
            message.billingAddressType = object.billingAddressType | 0;
        if (object.requiredField) {
            if (!Array.isArray(object.requiredField))
                throw TypeError(".BillingAddressSpec.requiredField: array expected");
            message.requiredField = [];
            for (var i = 0; i < object.requiredField.length; ++i)
                message.requiredField[i] = object.requiredField[i] | 0;
        }
        return message;
    };

    /**
     * Creates a plain object from a BillingAddressSpec message. Also converts values to other types if specified.
     * @function toObject
     * @memberof BillingAddressSpec
     * @static
     * @param {BillingAddressSpec} message BillingAddressSpec
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    BillingAddressSpec.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        var object = {};
        if (options.arrays || options.defaults)
            object.requiredField = [];
        if (options.defaults)
            object.billingAddressType = 0;
        if (message.billingAddressType != null && message.hasOwnProperty("billingAddressType"))
            object.billingAddressType = message.billingAddressType;
        if (message.requiredField && message.requiredField.length) {
            object.requiredField = [];
            for (var j = 0; j < message.requiredField.length; ++j)
                object.requiredField[j] = message.requiredField[j];
        }
        return object;
    };

    /**
     * Converts this BillingAddressSpec to JSON.
     * @function toJSON
     * @memberof BillingAddressSpec
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    BillingAddressSpec.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return BillingAddressSpec;
})();

$root.BillingProfile = (function() {

    /**
     * Properties of a BillingProfile.
     * @exports IBillingProfile
     * @interface IBillingProfile
     * @property {Array.<IInstrument>|null} [instrument] BillingProfile instrument
     * @property {string|null} [selectedExternalInstrumentId] BillingProfile selectedExternalInstrumentId
     * @property {Array.<IBillingProfileOption>|null} [billingProfileOption] BillingProfile billingProfileOption
     */

    /**
     * Constructs a new BillingProfile.
     * @exports BillingProfile
     * @classdesc Represents a BillingProfile.
     * @implements IBillingProfile
     * @constructor
     * @param {IBillingProfile=} [properties] Properties to set
     */
    function BillingProfile(properties) {
        this.instrument = [];
        this.billingProfileOption = [];
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * BillingProfile instrument.
     * @member {Array.<IInstrument>} instrument
     * @memberof BillingProfile
     * @instance
     */
    BillingProfile.prototype.instrument = $util.emptyArray;

    /**
     * BillingProfile selectedExternalInstrumentId.
     * @member {string} selectedExternalInstrumentId
     * @memberof BillingProfile
     * @instance
     */
    BillingProfile.prototype.selectedExternalInstrumentId = "";

    /**
     * BillingProfile billingProfileOption.
     * @member {Array.<IBillingProfileOption>} billingProfileOption
     * @memberof BillingProfile
     * @instance
     */
    BillingProfile.prototype.billingProfileOption = $util.emptyArray;

    /**
     * Creates a new BillingProfile instance using the specified properties.
     * @function create
     * @memberof BillingProfile
     * @static
     * @param {IBillingProfile=} [properties] Properties to set
     * @returns {BillingProfile} BillingProfile instance
     */
    BillingProfile.create = function create(properties) {
        return new BillingProfile(properties);
    };

    /**
     * Encodes the specified BillingProfile message. Does not implicitly {@link BillingProfile.verify|verify} messages.
     * @function encode
     * @memberof BillingProfile
     * @static
     * @param {IBillingProfile} message BillingProfile message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    BillingProfile.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.instrument != null && message.instrument.length)
            for (var i = 0; i < message.instrument.length; ++i)
                $root.Instrument.encode(message.instrument[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
        if (message.selectedExternalInstrumentId != null && Object.hasOwnProperty.call(message, "selectedExternalInstrumentId"))
            writer.uint32(/* id 2, wireType 2 =*/18).string(message.selectedExternalInstrumentId);
        if (message.billingProfileOption != null && message.billingProfileOption.length)
            for (var i = 0; i < message.billingProfileOption.length; ++i)
                $root.BillingProfileOption.encode(message.billingProfileOption[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
        return writer;
    };

    /**
     * Encodes the specified BillingProfile message, length delimited. Does not implicitly {@link BillingProfile.verify|verify} messages.
     * @function encodeDelimited
     * @memberof BillingProfile
     * @static
     * @param {IBillingProfile} message BillingProfile message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    BillingProfile.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a BillingProfile message from the specified reader or buffer.
     * @function decode
     * @memberof BillingProfile
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {BillingProfile} BillingProfile
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    BillingProfile.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.BillingProfile();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                if (!(message.instrument && message.instrument.length))
                    message.instrument = [];
                message.instrument.push($root.Instrument.decode(reader, reader.uint32()));
                break;
            case 2:
                message.selectedExternalInstrumentId = reader.string();
                break;
            case 3:
                if (!(message.billingProfileOption && message.billingProfileOption.length))
                    message.billingProfileOption = [];
                message.billingProfileOption.push($root.BillingProfileOption.decode(reader, reader.uint32()));
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a BillingProfile message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof BillingProfile
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {BillingProfile} BillingProfile
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    BillingProfile.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a BillingProfile message.
     * @function verify
     * @memberof BillingProfile
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    BillingProfile.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.instrument != null && message.hasOwnProperty("instrument")) {
            if (!Array.isArray(message.instrument))
                return "instrument: array expected";
            for (var i = 0; i < message.instrument.length; ++i) {
                var error = $root.Instrument.verify(message.instrument[i]);
                if (error)
                    return "instrument." + error;
            }
        }
        if (message.selectedExternalInstrumentId != null && message.hasOwnProperty("selectedExternalInstrumentId"))
            if (!$util.isString(message.selectedExternalInstrumentId))
                return "selectedExternalInstrumentId: string expected";
        if (message.billingProfileOption != null && message.hasOwnProperty("billingProfileOption")) {
            if (!Array.isArray(message.billingProfileOption))
                return "billingProfileOption: array expected";
            for (var i = 0; i < message.billingProfileOption.length; ++i) {
                var error = $root.BillingProfileOption.verify(message.billingProfileOption[i]);
                if (error)
                    return "billingProfileOption." + error;
            }
        }
        return null;
    };

    /**
     * Creates a BillingProfile message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof BillingProfile
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {BillingProfile} BillingProfile
     */
    BillingProfile.fromObject = function fromObject(object) {
        if (object instanceof $root.BillingProfile)
            return object;
        var message = new $root.BillingProfile();
        if (object.instrument) {
            if (!Array.isArray(object.instrument))
                throw TypeError(".BillingProfile.instrument: array expected");
            message.instrument = [];
            for (var i = 0; i < object.instrument.length; ++i) {
                if (typeof object.instrument[i] !== "object")
                    throw TypeError(".BillingProfile.instrument: object expected");
                message.instrument[i] = $root.Instrument.fromObject(object.instrument[i]);
            }
        }
        if (object.selectedExternalInstrumentId != null)
            message.selectedExternalInstrumentId = String(object.selectedExternalInstrumentId);
        if (object.billingProfileOption) {
            if (!Array.isArray(object.billingProfileOption))
                throw TypeError(".BillingProfile.billingProfileOption: array expected");
            message.billingProfileOption = [];
            for (var i = 0; i < object.billingProfileOption.length; ++i) {
                if (typeof object.billingProfileOption[i] !== "object")
                    throw TypeError(".BillingProfile.billingProfileOption: object expected");
                message.billingProfileOption[i] = $root.BillingProfileOption.fromObject(object.billingProfileOption[i]);
            }
        }
        return message;
    };

    /**
     * Creates a plain object from a BillingProfile message. Also converts values to other types if specified.
     * @function toObject
     * @memberof BillingProfile
     * @static
     * @param {BillingProfile} message BillingProfile
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    BillingProfile.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        var object = {};
        if (options.arrays || options.defaults) {
            object.instrument = [];
            object.billingProfileOption = [];
        }
        if (options.defaults)
            object.selectedExternalInstrumentId = "";
        if (message.instrument && message.instrument.length) {
            object.instrument = [];
            for (var j = 0; j < message.instrument.length; ++j)
                object.instrument[j] = $root.Instrument.toObject(message.instrument[j], options);
        }
        if (message.selectedExternalInstrumentId != null && message.hasOwnProperty("selectedExternalInstrumentId"))
            object.selectedExternalInstrumentId = message.selectedExternalInstrumentId;
        if (message.billingProfileOption && message.billingProfileOption.length) {
            object.billingProfileOption = [];
            for (var j = 0; j < message.billingProfileOption.length; ++j)
                object.billingProfileOption[j] = $root.BillingProfileOption.toObject(message.billingProfileOption[j], options);
        }
        return object;
    };

    /**
     * Converts this BillingProfile to JSON.
     * @function toJSON
     * @memberof BillingProfile
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    BillingProfile.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return BillingProfile;
})();

$root.BillingProfileOption = (function() {

    /**
     * Properties of a BillingProfileOption.
     * @exports IBillingProfileOption
     * @interface IBillingProfileOption
     * @property {number|null} [type] BillingProfileOption type
     * @property {string|null} [displayTitle] BillingProfileOption displayTitle
     * @property {string|null} [externalInstrumentId] BillingProfileOption externalInstrumentId
     * @property {ITopupInfo|null} [topupInfo] BillingProfileOption topupInfo
     * @property {ICarrierBillingInstrumentStatus|null} [carrierBillingInstrumentStatus] BillingProfileOption carrierBillingInstrumentStatus
     */

    /**
     * Constructs a new BillingProfileOption.
     * @exports BillingProfileOption
     * @classdesc Represents a BillingProfileOption.
     * @implements IBillingProfileOption
     * @constructor
     * @param {IBillingProfileOption=} [properties] Properties to set
     */
    function BillingProfileOption(properties) {
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * BillingProfileOption type.
     * @member {number} type
     * @memberof BillingProfileOption
     * @instance
     */
    BillingProfileOption.prototype.type = 0;

    /**
     * BillingProfileOption displayTitle.
     * @member {string} displayTitle
     * @memberof BillingProfileOption
     * @instance
     */
    BillingProfileOption.prototype.displayTitle = "";

    /**
     * BillingProfileOption externalInstrumentId.
     * @member {string} externalInstrumentId
     * @memberof BillingProfileOption
     * @instance
     */
    BillingProfileOption.prototype.externalInstrumentId = "";

    /**
     * BillingProfileOption topupInfo.
     * @member {ITopupInfo|null|undefined} topupInfo
     * @memberof BillingProfileOption
     * @instance
     */
    BillingProfileOption.prototype.topupInfo = null;

    /**
     * BillingProfileOption carrierBillingInstrumentStatus.
     * @member {ICarrierBillingInstrumentStatus|null|undefined} carrierBillingInstrumentStatus
     * @memberof BillingProfileOption
     * @instance
     */
    BillingProfileOption.prototype.carrierBillingInstrumentStatus = null;

    /**
     * Creates a new BillingProfileOption instance using the specified properties.
     * @function create
     * @memberof BillingProfileOption
     * @static
     * @param {IBillingProfileOption=} [properties] Properties to set
     * @returns {BillingProfileOption} BillingProfileOption instance
     */
    BillingProfileOption.create = function create(properties) {
        return new BillingProfileOption(properties);
    };

    /**
     * Encodes the specified BillingProfileOption message. Does not implicitly {@link BillingProfileOption.verify|verify} messages.
     * @function encode
     * @memberof BillingProfileOption
     * @static
     * @param {IBillingProfileOption} message BillingProfileOption message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    BillingProfileOption.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.type != null && Object.hasOwnProperty.call(message, "type"))
            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.type);
        if (message.displayTitle != null && Object.hasOwnProperty.call(message, "displayTitle"))
            writer.uint32(/* id 2, wireType 2 =*/18).string(message.displayTitle);
        if (message.externalInstrumentId != null && Object.hasOwnProperty.call(message, "externalInstrumentId"))
            writer.uint32(/* id 3, wireType 2 =*/26).string(message.externalInstrumentId);
        if (message.topupInfo != null && Object.hasOwnProperty.call(message, "topupInfo"))
            $root.TopupInfo.encode(message.topupInfo, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
        if (message.carrierBillingInstrumentStatus != null && Object.hasOwnProperty.call(message, "carrierBillingInstrumentStatus"))
            $root.CarrierBillingInstrumentStatus.encode(message.carrierBillingInstrumentStatus, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
        return writer;
    };

    /**
     * Encodes the specified BillingProfileOption message, length delimited. Does not implicitly {@link BillingProfileOption.verify|verify} messages.
     * @function encodeDelimited
     * @memberof BillingProfileOption
     * @static
     * @param {IBillingProfileOption} message BillingProfileOption message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    BillingProfileOption.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a BillingProfileOption message from the specified reader or buffer.
     * @function decode
     * @memberof BillingProfileOption
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {BillingProfileOption} BillingProfileOption
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    BillingProfileOption.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.BillingProfileOption();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.type = reader.int32();
                break;
            case 2:
                message.displayTitle = reader.string();
                break;
            case 3:
                message.externalInstrumentId = reader.string();
                break;
            case 4:
                message.topupInfo = $root.TopupInfo.decode(reader, reader.uint32());
                break;
            case 5:
                message.carrierBillingInstrumentStatus = $root.CarrierBillingInstrumentStatus.decode(reader, reader.uint32());
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a BillingProfileOption message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof BillingProfileOption
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {BillingProfileOption} BillingProfileOption
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    BillingProfileOption.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a BillingProfileOption message.
     * @function verify
     * @memberof BillingProfileOption
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    BillingProfileOption.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.type != null && message.hasOwnProperty("type"))
            if (!$util.isInteger(message.type))
                return "type: integer expected";
        if (message.displayTitle != null && message.hasOwnProperty("displayTitle"))
            if (!$util.isString(message.displayTitle))
                return "displayTitle: string expected";
        if (message.externalInstrumentId != null && message.hasOwnProperty("externalInstrumentId"))
            if (!$util.isString(message.externalInstrumentId))
                return "externalInstrumentId: string expected";
        if (message.topupInfo != null && message.hasOwnProperty("topupInfo")) {
            var error = $root.TopupInfo.verify(message.topupInfo);
            if (error)
                return "topupInfo." + error;
        }
        if (message.carrierBillingInstrumentStatus != null && message.hasOwnProperty("carrierBillingInstrumentStatus")) {
            var error = $root.CarrierBillingInstrumentStatus.verify(message.carrierBillingInstrumentStatus);
            if (error)
                return "carrierBillingInstrumentStatus." + error;
        }
        return null;
    };

    /**
     * Creates a BillingProfileOption message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof BillingProfileOption
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {BillingProfileOption} BillingProfileOption
     */
    BillingProfileOption.fromObject = function fromObject(object) {
        if (object instanceof $root.BillingProfileOption)
            return object;
        var message = new $root.BillingProfileOption();
        if (object.type != null)
            message.type = object.type | 0;
        if (object.displayTitle != null)
            message.displayTitle = String(object.displayTitle);
        if (object.externalInstrumentId != null)
            message.externalInstrumentId = String(object.externalInstrumentId);
        if (object.topupInfo != null) {
            if (typeof object.topupInfo !== "object")
                throw TypeError(".BillingProfileOption.topupInfo: object expected");
            message.topupInfo = $root.TopupInfo.fromObject(object.topupInfo);
        }
        if (object.carrierBillingInstrumentStatus != null) {
            if (typeof object.carrierBillingInstrumentStatus !== "object")
                throw TypeError(".BillingProfileOption.carrierBillingInstrumentStatus: object expected");
            message.carrierBillingInstrumentStatus = $root.CarrierBillingInstrumentStatus.fromObject(object.carrierBillingInstrumentStatus);
        }
        return message;
    };

    /**
     * Creates a plain object from a BillingProfileOption message. Also converts values to other types if specified.
     * @function toObject
     * @memberof BillingProfileOption
     * @static
     * @param {BillingProfileOption} message BillingProfileOption
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    BillingProfileOption.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        var object = {};
        if (options.defaults) {
            object.type = 0;
            object.displayTitle = "";
            object.externalInstrumentId = "";
            object.topupInfo = null;
            object.carrierBillingInstrumentStatus = null;
        }
        if (message.type != null && message.hasOwnProperty("type"))
            object.type = message.type;
        if (message.displayTitle != null && message.hasOwnProperty("displayTitle"))
            object.displayTitle = message.displayTitle;
        if (message.externalInstrumentId != null && message.hasOwnProperty("externalInstrumentId"))
            object.externalInstrumentId = message.externalInstrumentId;
        if (message.topupInfo != null && message.hasOwnProperty("topupInfo"))
            object.topupInfo = $root.TopupInfo.toObject(message.topupInfo, options);
        if (message.carrierBillingInstrumentStatus != null && message.hasOwnProperty("carrierBillingInstrumentStatus"))
            object.carrierBillingInstrumentStatus = $root.CarrierBillingInstrumentStatus.toObject(message.carrierBillingInstrumentStatus, options);
        return object;
    };

    /**
     * Converts this BillingProfileOption to JSON.
     * @function toJSON
     * @memberof BillingProfileOption
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    BillingProfileOption.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return BillingProfileOption;
})();

$root.CarrierBillingCredentials = (function() {

    /**
     * Properties of a CarrierBillingCredentials.
     * @exports ICarrierBillingCredentials
     * @interface ICarrierBillingCredentials
     * @property {string|null} [value] CarrierBillingCredentials value
     * @property {number|Long|null} [expiration] CarrierBillingCredentials expiration
     */

    /**
     * Constructs a new CarrierBillingCredentials.
     * @exports CarrierBillingCredentials
     * @classdesc Represents a CarrierBillingCredentials.
     * @implements ICarrierBillingCredentials
     * @constructor
     * @param {ICarrierBillingCredentials=} [properties] Properties to set
     */
    function CarrierBillingCredentials(properties) {
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * CarrierBillingCredentials value.
     * @member {string} value
     * @memberof CarrierBillingCredentials
     * @instance
     */
    CarrierBillingCredentials.prototype.value = "";

    /**
     * CarrierBillingCredentials expiration.
     * @member {number|Long} expiration
     * @memberof CarrierBillingCredentials
     * @instance
     */
    CarrierBillingCredentials.prototype.expiration = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

    /**
     * Creates a new CarrierBillingCredentials instance using the specified properties.
     * @function create
     * @memberof CarrierBillingCredentials
     * @static
     * @param {ICarrierBillingCredentials=} [properties] Properties to set
     * @returns {CarrierBillingCredentials} CarrierBillingCredentials instance
     */
    CarrierBillingCredentials.create = function create(properties) {
        return new CarrierBillingCredentials(properties);
    };

    /**
     * Encodes the specified CarrierBillingCredentials message. Does not implicitly {@link CarrierBillingCredentials.verify|verify} messages.
     * @function encode
     * @memberof CarrierBillingCredentials
     * @static
     * @param {ICarrierBillingCredentials} message CarrierBillingCredentials message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    CarrierBillingCredentials.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.value != null && Object.hasOwnProperty.call(message, "value"))
            writer.uint32(/* id 1, wireType 2 =*/10).string(message.value);
        if (message.expiration != null && Object.hasOwnProperty.call(message, "expiration"))
            writer.uint32(/* id 2, wireType 0 =*/16).int64(message.expiration);
        return writer;
    };

    /**
     * Encodes the specified CarrierBillingCredentials message, length delimited. Does not implicitly {@link CarrierBillingCredentials.verify|verify} messages.
     * @function encodeDelimited
     * @memberof CarrierBillingCredentials
     * @static
     * @param {ICarrierBillingCredentials} message CarrierBillingCredentials message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    CarrierBillingCredentials.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a CarrierBillingCredentials message from the specified reader or buffer.
     * @function decode
     * @memberof CarrierBillingCredentials
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CarrierBillingCredentials} CarrierBillingCredentials
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CarrierBillingCredentials.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CarrierBillingCredentials();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.value = reader.string();
                break;
            case 2:
                message.expiration = reader.int64();
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a CarrierBillingCredentials message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof CarrierBillingCredentials
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {CarrierBillingCredentials} CarrierBillingCredentials
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CarrierBillingCredentials.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a CarrierBillingCredentials message.
     * @function verify
     * @memberof CarrierBillingCredentials
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    CarrierBillingCredentials.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.value != null && message.hasOwnProperty("value"))
            if (!$util.isString(message.value))
                return "value: string expected";
        if (message.expiration != null && message.hasOwnProperty("expiration"))
            if (!$util.isInteger(message.expiration) && !(message.expiration && $util.isInteger(message.expiration.low) && $util.isInteger(message.expiration.high)))
                return "expiration: integer|Long expected";
        return null;
    };

    /**
     * Creates a CarrierBillingCredentials message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof CarrierBillingCredentials
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {CarrierBillingCredentials} CarrierBillingCredentials
     */
    CarrierBillingCredentials.fromObject = function fromObject(object) {
        if (object instanceof $root.CarrierBillingCredentials)
            return object;
        var message = new $root.CarrierBillingCredentials();
        if (object.value != null)
            message.value = String(object.value);
        if (object.expiration != null)
            if ($util.Long)
                (message.expiration = $util.Long.fromValue(object.expiration)).unsigned = false;
            else if (typeof object.expiration === "string")
                message.expiration = parseInt(object.expiration, 10);
            else if (typeof object.expiration === "number")
                message.expiration = object.expiration;
            else if (typeof object.expiration === "object")
                message.expiration = new $util.LongBits(object.expiration.low >>> 0, object.expiration.high >>> 0).toNumber();
        return message;
    };

    /**
     * Creates a plain object from a CarrierBillingCredentials message. Also converts values to other types if specified.
     * @function toObject
     * @memberof CarrierBillingCredentials
     * @static
     * @param {CarrierBillingCredentials} message CarrierBillingCredentials
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    CarrierBillingCredentials.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        var object = {};
        if (options.defaults) {
            object.value = "";
            if ($util.Long) {
                var long = new $util.Long(0, 0, false);
                object.expiration = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
            } else
                object.expiration = options.longs === String ? "0" : 0;
        }
        if (message.value != null && message.hasOwnProperty("value"))
            object.value = message.value;
        if (message.expiration != null && message.hasOwnProperty("expiration"))
            if (typeof message.expiration === "number")
                object.expiration = options.longs === String ? String(message.expiration) : message.expiration;
            else
                object.expiration = options.longs === String ? $util.Long.prototype.toString.call(message.expiration) : options.longs === Number ? new $util.LongBits(message.expiration.low >>> 0, message.expiration.high >>> 0).toNumber() : message.expiration;
        return object;
    };

    /**
     * Converts this CarrierBillingCredentials to JSON.
     * @function toJSON
     * @memberof CarrierBillingCredentials
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    CarrierBillingCredentials.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return CarrierBillingCredentials;
})();

$root.CarrierBillingInstrument = (function() {

    /**
     * Properties of a CarrierBillingInstrument.
     * @exports ICarrierBillingInstrument
     * @interface ICarrierBillingInstrument
     * @property {string|null} [instrumentKey] CarrierBillingInstrument instrumentKey
     * @property {string|null} [accountType] CarrierBillingInstrument accountType
     * @property {string|null} [currencyCode] CarrierBillingInstrument currencyCode
     * @property {number|Long|null} [transactionLimit] CarrierBillingInstrument transactionLimit
     * @property {string|null} [subscriberIdentifier] CarrierBillingInstrument subscriberIdentifier
     * @property {IEncryptedSubscriberInfo|null} [encryptedSubscriberInfo] CarrierBillingInstrument encryptedSubscriberInfo
     * @property {ICarrierBillingCredentials|null} [credentials] CarrierBillingInstrument credentials
     * @property {ICarrierTos|null} [acceptedCarrierTos] CarrierBillingInstrument acceptedCarrierTos
     */

    /**
     * Constructs a new CarrierBillingInstrument.
     * @exports CarrierBillingInstrument
     * @classdesc Represents a CarrierBillingInstrument.
     * @implements ICarrierBillingInstrument
     * @constructor
     * @param {ICarrierBillingInstrument=} [properties] Properties to set
     */
    function CarrierBillingInstrument(properties) {
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * CarrierBillingInstrument instrumentKey.
     * @member {string} instrumentKey
     * @memberof CarrierBillingInstrument
     * @instance
     */
    CarrierBillingInstrument.prototype.instrumentKey = "";

    /**
     * CarrierBillingInstrument accountType.
     * @member {string} accountType
     * @memberof CarrierBillingInstrument
     * @instance
     */
    CarrierBillingInstrument.prototype.accountType = "";

    /**
     * CarrierBillingInstrument currencyCode.
     * @member {string} currencyCode
     * @memberof CarrierBillingInstrument
     * @instance
     */
    CarrierBillingInstrument.prototype.currencyCode = "";

    /**
     * CarrierBillingInstrument transactionLimit.
     * @member {number|Long} transactionLimit
     * @memberof CarrierBillingInstrument
     * @instance
     */
    CarrierBillingInstrument.prototype.transactionLimit = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

    /**
     * CarrierBillingInstrument subscriberIdentifier.
     * @member {string} subscriberIdentifier
     * @memberof CarrierBillingInstrument
     * @instance
     */
    CarrierBillingInstrument.prototype.subscriberIdentifier = "";

    /**
     * CarrierBillingInstrument encryptedSubscriberInfo.
     * @member {IEncryptedSubscriberInfo|null|undefined} encryptedSubscriberInfo
     * @memberof CarrierBillingInstrument
     * @instance
     */
    CarrierBillingInstrument.prototype.encryptedSubscriberInfo = null;

    /**
     * CarrierBillingInstrument credentials.
     * @member {ICarrierBillingCredentials|null|undefined} credentials
     * @memberof CarrierBillingInstrument
     * @instance
     */
    CarrierBillingInstrument.prototype.credentials = null;

    /**
     * CarrierBillingInstrument acceptedCarrierTos.
     * @member {ICarrierTos|null|undefined} acceptedCarrierTos
     * @memberof CarrierBillingInstrument
     * @instance
     */
    CarrierBillingInstrument.prototype.acceptedCarrierTos = null;

    /**
     * Creates a new CarrierBillingInstrument instance using the specified properties.
     * @function create
     * @memberof CarrierBillingInstrument
     * @static
     * @param {ICarrierBillingInstrument=} [properties] Properties to set
     * @returns {CarrierBillingInstrument} CarrierBillingInstrument instance
     */
    CarrierBillingInstrument.create = function create(properties) {
        return new CarrierBillingInstrument(properties);
    };

    /**
     * Encodes the specified CarrierBillingInstrument message. Does not implicitly {@link CarrierBillingInstrument.verify|verify} messages.
     * @function encode
     * @memberof CarrierBillingInstrument
     * @static
     * @param {ICarrierBillingInstrument} message CarrierBillingInstrument message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    CarrierBillingInstrument.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.instrumentKey != null && Object.hasOwnProperty.call(message, "instrumentKey"))
            writer.uint32(/* id 1, wireType 2 =*/10).string(message.instrumentKey);
        if (message.accountType != null && Object.hasOwnProperty.call(message, "accountType"))
            writer.uint32(/* id 2, wireType 2 =*/18).string(message.accountType);
        if (message.currencyCode != null && Object.hasOwnProperty.call(message, "currencyCode"))
            writer.uint32(/* id 3, wireType 2 =*/26).string(message.currencyCode);
        if (message.transactionLimit != null && Object.hasOwnProperty.call(message, "transactionLimit"))
            writer.uint32(/* id 4, wireType 0 =*/32).int64(message.transactionLimit);
        if (message.subscriberIdentifier != null && Object.hasOwnProperty.call(message, "subscriberIdentifier"))
            writer.uint32(/* id 5, wireType 2 =*/42).string(message.subscriberIdentifier);
        if (message.encryptedSubscriberInfo != null && Object.hasOwnProperty.call(message, "encryptedSubscriberInfo"))
            $root.EncryptedSubscriberInfo.encode(message.encryptedSubscriberInfo, writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
        if (message.credentials != null && Object.hasOwnProperty.call(message, "credentials"))
            $root.CarrierBillingCredentials.encode(message.credentials, writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
        if (message.acceptedCarrierTos != null && Object.hasOwnProperty.call(message, "acceptedCarrierTos"))
            $root.CarrierTos.encode(message.acceptedCarrierTos, writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();
        return writer;
    };

    /**
     * Encodes the specified CarrierBillingInstrument message, length delimited. Does not implicitly {@link CarrierBillingInstrument.verify|verify} messages.
     * @function encodeDelimited
     * @memberof CarrierBillingInstrument
     * @static
     * @param {ICarrierBillingInstrument} message CarrierBillingInstrument message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    CarrierBillingInstrument.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a CarrierBillingInstrument message from the specified reader or buffer.
     * @function decode
     * @memberof CarrierBillingInstrument
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CarrierBillingInstrument} CarrierBillingInstrument
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CarrierBillingInstrument.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CarrierBillingInstrument();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.instrumentKey = reader.string();
                break;
            case 2:
                message.accountType = reader.string();
                break;
            case 3:
                message.currencyCode = reader.string();
                break;
            case 4:
                message.transactionLimit = reader.int64();
                break;
            case 5:
                message.subscriberIdentifier = reader.string();
                break;
            case 6:
                message.encryptedSubscriberInfo = $root.EncryptedSubscriberInfo.decode(reader, reader.uint32());
                break;
            case 7:
                message.credentials = $root.CarrierBillingCredentials.decode(reader, reader.uint32());
                break;
            case 8:
                message.acceptedCarrierTos = $root.CarrierTos.decode(reader, reader.uint32());
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a CarrierBillingInstrument message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof CarrierBillingInstrument
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {CarrierBillingInstrument} CarrierBillingInstrument
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CarrierBillingInstrument.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a CarrierBillingInstrument message.
     * @function verify
     * @memberof CarrierBillingInstrument
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    CarrierBillingInstrument.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.instrumentKey != null && message.hasOwnProperty("instrumentKey"))
            if (!$util.isString(message.instrumentKey))
                return "instrumentKey: string expected";
        if (message.accountType != null && message.hasOwnProperty("accountType"))
            if (!$util.isString(message.accountType))
                return "accountType: string expected";
        if (message.currencyCode != null && message.hasOwnProperty("currencyCode"))
            if (!$util.isString(message.currencyCode))
                return "currencyCode: string expected";
        if (message.transactionLimit != null && message.hasOwnProperty("transactionLimit"))
            if (!$util.isInteger(message.transactionLimit) && !(message.transactionLimit && $util.isInteger(message.transactionLimit.low) && $util.isInteger(message.transactionLimit.high)))
                return "transactionLimit: integer|Long expected";
        if (message.subscriberIdentifier != null && message.hasOwnProperty("subscriberIdentifier"))
            if (!$util.isString(message.subscriberIdentifier))
                return "subscriberIdentifier: string expected";
        if (message.encryptedSubscriberInfo != null && message.hasOwnProperty("encryptedSubscriberInfo")) {
            var error = $root.EncryptedSubscriberInfo.verify(message.encryptedSubscriberInfo);
            if (error)
                return "encryptedSubscriberInfo." + error;
        }
        if (message.credentials != null && message.hasOwnProperty("credentials")) {
            var error = $root.CarrierBillingCredentials.verify(message.credentials);
            if (error)
                return "credentials." + error;
        }
        if (message.acceptedCarrierTos != null && message.hasOwnProperty("acceptedCarrierTos")) {
            var error = $root.CarrierTos.verify(message.acceptedCarrierTos);
            if (error)
                return "acceptedCarrierTos." + error;
        }
        return null;
    };

    /**
     * Creates a CarrierBillingInstrument message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof CarrierBillingInstrument
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {CarrierBillingInstrument} CarrierBillingInstrument
     */
    CarrierBillingInstrument.fromObject = function fromObject(object) {
        if (object instanceof $root.CarrierBillingInstrument)
            return object;
        var message = new $root.CarrierBillingInstrument();
        if (object.instrumentKey != null)
            message.instrumentKey = String(object.instrumentKey);
        if (object.accountType != null)
            message.accountType = String(object.accountType);
        if (object.currencyCode != null)
            message.currencyCode = String(object.currencyCode);
        if (object.transactionLimit != null)
            if ($util.Long)
                (message.transactionLimit = $util.Long.fromValue(object.transactionLimit)).unsigned = false;
            else if (typeof object.transactionLimit === "string")
                message.transactionLimit = parseInt(object.transactionLimit, 10);
            else if (typeof object.transactionLimit === "number")
                message.transactionLimit = object.transactionLimit;
            else if (typeof object.transactionLimit === "object")
                message.transactionLimit = new $util.LongBits(object.transactionLimit.low >>> 0, object.transactionLimit.high >>> 0).toNumber();
        if (object.subscriberIdentifier != null)
            message.subscriberIdentifier = String(object.subscriberIdentifier);
        if (object.encryptedSubscriberInfo != null) {
            if (typeof object.encryptedSubscriberInfo !== "object")
                throw TypeError(".CarrierBillingInstrument.encryptedSubscriberInfo: object expected");
            message.encryptedSubscriberInfo = $root.EncryptedSubscriberInfo.fromObject(object.encryptedSubscriberInfo);
        }
        if (object.credentials != null) {
            if (typeof object.credentials !== "object")
                throw TypeError(".CarrierBillingInstrument.credentials: object expected");
            message.credentials = $root.CarrierBillingCredentials.fromObject(object.credentials);
        }
        if (object.acceptedCarrierTos != null) {
            if (typeof object.acceptedCarrierTos !== "object")
                throw TypeError(".CarrierBillingInstrument.acceptedCarrierTos: object expected");
            message.acceptedCarrierTos = $root.CarrierTos.fromObject(object.acceptedCarrierTos);
        }
        return message;
    };

    /**
     * Creates a plain object from a CarrierBillingInstrument message. Also converts values to other types if specified.
     * @function toObject
     * @memberof CarrierBillingInstrument
     * @static
     * @param {CarrierBillingInstrument} message CarrierBillingInstrument
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    CarrierBillingInstrument.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        var object = {};
        if (options.defaults) {
            object.instrumentKey = "";
            object.accountType = "";
            object.currencyCode = "";
            if ($util.Long) {
                var long = new $util.Long(0, 0, false);
                object.transactionLimit = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
            } else
                object.transactionLimit = options.longs === String ? "0" : 0;
            object.subscriberIdentifier = "";
            object.encryptedSubscriberInfo = null;
            object.credentials = null;
            object.acceptedCarrierTos = null;
        }
        if (message.instrumentKey != null && message.hasOwnProperty("instrumentKey"))
            object.instrumentKey = message.instrumentKey;
        if (message.accountType != null && message.hasOwnProperty("accountType"))
            object.accountType = message.accountType;
        if (message.currencyCode != null && message.hasOwnProperty("currencyCode"))
            object.currencyCode = message.currencyCode;
        if (message.transactionLimit != null && message.hasOwnProperty("transactionLimit"))
            if (typeof message.transactionLimit === "number")
                object.transactionLimit = options.longs === String ? String(message.transactionLimit) : message.transactionLimit;
            else
                object.transactionLimit = options.longs === String ? $util.Long.prototype.toString.call(message.transactionLimit) : options.longs === Number ? new $util.LongBits(message.transactionLimit.low >>> 0, message.transactionLimit.high >>> 0).toNumber() : message.transactionLimit;
        if (message.subscriberIdentifier != null && message.hasOwnProperty("subscriberIdentifier"))
            object.subscriberIdentifier = message.subscriberIdentifier;
        if (message.encryptedSubscriberInfo != null && message.hasOwnProperty("encryptedSubscriberInfo"))
            object.encryptedSubscriberInfo = $root.EncryptedSubscriberInfo.toObject(message.encryptedSubscriberInfo, options);
        if (message.credentials != null && message.hasOwnProperty("credentials"))
            object.credentials = $root.CarrierBillingCredentials.toObject(message.credentials, options);
        if (message.acceptedCarrierTos != null && message.hasOwnProperty("acceptedCarrierTos"))
            object.acceptedCarrierTos = $root.CarrierTos.toObject(message.acceptedCarrierTos, options);
        return object;
    };

    /**
     * Converts this CarrierBillingInstrument to JSON.
     * @function toJSON
     * @memberof CarrierBillingInstrument
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    CarrierBillingInstrument.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return CarrierBillingInstrument;
})();

$root.CarrierBillingInstrumentStatus = (function() {

    /**
     * Properties of a CarrierBillingInstrumentStatus.
     * @exports ICarrierBillingInstrumentStatus
     * @interface ICarrierBillingInstrumentStatus
     * @property {ICarrierTos|null} [carrierTos] CarrierBillingInstrumentStatus carrierTos
     * @property {boolean|null} [associationRequired] CarrierBillingInstrumentStatus associationRequired
     * @property {boolean|null} [passwordRequired] CarrierBillingInstrumentStatus passwordRequired
     * @property {IPasswordPrompt|null} [carrierPasswordPrompt] CarrierBillingInstrumentStatus carrierPasswordPrompt
     * @property {number|null} [apiVersion] CarrierBillingInstrumentStatus apiVersion
     * @property {string|null} [name] CarrierBillingInstrumentStatus name
     * @property {IDeviceAssociation|null} [deviceAssociation] CarrierBillingInstrumentStatus deviceAssociation
     * @property {string|null} [carrierSupportPhoneNumber] CarrierBillingInstrumentStatus carrierSupportPhoneNumber
     */

    /**
     * Constructs a new CarrierBillingInstrumentStatus.
     * @exports CarrierBillingInstrumentStatus
     * @classdesc Represents a CarrierBillingInstrumentStatus.
     * @implements ICarrierBillingInstrumentStatus
     * @constructor
     * @param {ICarrierBillingInstrumentStatus=} [properties] Properties to set
     */
    function CarrierBillingInstrumentStatus(properties) {
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * CarrierBillingInstrumentStatus carrierTos.
     * @member {ICarrierTos|null|undefined} carrierTos
     * @memberof CarrierBillingInstrumentStatus
     * @instance
     */
    CarrierBillingInstrumentStatus.prototype.carrierTos = null;

    /**
     * CarrierBillingInstrumentStatus associationRequired.
     * @member {boolean} associationRequired
     * @memberof CarrierBillingInstrumentStatus
     * @instance
     */
    CarrierBillingInstrumentStatus.prototype.associationRequired = false;

    /**
     * CarrierBillingInstrumentStatus passwordRequired.
     * @member {boolean} passwordRequired
     * @memberof CarrierBillingInstrumentStatus
     * @instance
     */
    CarrierBillingInstrumentStatus.prototype.passwordRequired = false;

    /**
     * CarrierBillingInstrumentStatus carrierPasswordPrompt.
     * @member {IPasswordPrompt|null|undefined} carrierPasswordPrompt
     * @memberof CarrierBillingInstrumentStatus
     * @instance
     */
    CarrierBillingInstrumentStatus.prototype.carrierPasswordPrompt = null;

    /**
     * CarrierBillingInstrumentStatus apiVersion.
     * @member {number} apiVersion
     * @memberof CarrierBillingInstrumentStatus
     * @instance
     */
    CarrierBillingInstrumentStatus.prototype.apiVersion = 0;

    /**
     * CarrierBillingInstrumentStatus name.
     * @member {string} name
     * @memberof CarrierBillingInstrumentStatus
     * @instance
     */
    CarrierBillingInstrumentStatus.prototype.name = "";

    /**
     * CarrierBillingInstrumentStatus deviceAssociation.
     * @member {IDeviceAssociation|null|undefined} deviceAssociation
     * @memberof CarrierBillingInstrumentStatus
     * @instance
     */
    CarrierBillingInstrumentStatus.prototype.deviceAssociation = null;

    /**
     * CarrierBillingInstrumentStatus carrierSupportPhoneNumber.
     * @member {string} carrierSupportPhoneNumber
     * @memberof CarrierBillingInstrumentStatus
     * @instance
     */
    CarrierBillingInstrumentStatus.prototype.carrierSupportPhoneNumber = "";

    /**
     * Creates a new CarrierBillingInstrumentStatus instance using the specified properties.
     * @function create
     * @memberof CarrierBillingInstrumentStatus
     * @static
     * @param {ICarrierBillingInstrumentStatus=} [properties] Properties to set
     * @returns {CarrierBillingInstrumentStatus} CarrierBillingInstrumentStatus instance
     */
    CarrierBillingInstrumentStatus.create = function create(properties) {
        return new CarrierBillingInstrumentStatus(properties);
    };

    /**
     * Encodes the specified CarrierBillingInstrumentStatus message. Does not implicitly {@link CarrierBillingInstrumentStatus.verify|verify} messages.
     * @function encode
     * @memberof CarrierBillingInstrumentStatus
     * @static
     * @param {ICarrierBillingInstrumentStatus} message CarrierBillingInstrumentStatus message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    CarrierBillingInstrumentStatus.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.carrierTos != null && Object.hasOwnProperty.call(message, "carrierTos"))
            $root.CarrierTos.encode(message.carrierTos, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
        if (message.associationRequired != null && Object.hasOwnProperty.call(message, "associationRequired"))
            writer.uint32(/* id 2, wireType 0 =*/16).bool(message.associationRequired);
        if (message.passwordRequired != null && Object.hasOwnProperty.call(message, "passwordRequired"))
            writer.uint32(/* id 3, wireType 0 =*/24).bool(message.passwordRequired);
        if (message.carrierPasswordPrompt != null && Object.hasOwnProperty.call(message, "carrierPasswordPrompt"))
            $root.PasswordPrompt.encode(message.carrierPasswordPrompt, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
        if (message.apiVersion != null && Object.hasOwnProperty.call(message, "apiVersion"))
            writer.uint32(/* id 5, wireType 0 =*/40).int32(message.apiVersion);
        if (message.name != null && Object.hasOwnProperty.call(message, "name"))
            writer.uint32(/* id 6, wireType 2 =*/50).string(message.name);
        if (message.deviceAssociation != null && Object.hasOwnProperty.call(message, "deviceAssociation"))
            $root.DeviceAssociation.encode(message.deviceAssociation, writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
        if (message.carrierSupportPhoneNumber != null && Object.hasOwnProperty.call(message, "carrierSupportPhoneNumber"))
            writer.uint32(/* id 8, wireType 2 =*/66).string(message.carrierSupportPhoneNumber);
        return writer;
    };

    /**
     * Encodes the specified CarrierBillingInstrumentStatus message, length delimited. Does not implicitly {@link CarrierBillingInstrumentStatus.verify|verify} messages.
     * @function encodeDelimited
     * @memberof CarrierBillingInstrumentStatus
     * @static
     * @param {ICarrierBillingInstrumentStatus} message CarrierBillingInstrumentStatus message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    CarrierBillingInstrumentStatus.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a CarrierBillingInstrumentStatus message from the specified reader or buffer.
     * @function decode
     * @memberof CarrierBillingInstrumentStatus
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CarrierBillingInstrumentStatus} CarrierBillingInstrumentStatus
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CarrierBillingInstrumentStatus.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CarrierBillingInstrumentStatus();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.carrierTos = $root.CarrierTos.decode(reader, reader.uint32());
                break;
            case 2:
                message.associationRequired = reader.bool();
                break;
            case 3:
                message.passwordRequired = reader.bool();
                break;
            case 4:
                message.carrierPasswordPrompt = $root.PasswordPrompt.decode(reader, reader.uint32());
                break;
            case 5:
                message.apiVersion = reader.int32();
                break;
            case 6:
                message.name = reader.string();
                break;
            case 7:
                message.deviceAssociation = $root.DeviceAssociation.decode(reader, reader.uint32());
                break;
            case 8:
                message.carrierSupportPhoneNumber = reader.string();
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a CarrierBillingInstrumentStatus message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof CarrierBillingInstrumentStatus
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {CarrierBillingInstrumentStatus} CarrierBillingInstrumentStatus
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CarrierBillingInstrumentStatus.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a CarrierBillingInstrumentStatus message.
     * @function verify
     * @memberof CarrierBillingInstrumentStatus
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    CarrierBillingInstrumentStatus.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.carrierTos != null && message.hasOwnProperty("carrierTos")) {
            var error = $root.CarrierTos.verify(message.carrierTos);
            if (error)
                return "carrierTos." + error;
        }
        if (message.associationRequired != null && message.hasOwnProperty("associationRequired"))
            if (typeof message.associationRequired !== "boolean")
                return "associationRequired: boolean expected";
        if (message.passwordRequired != null && message.hasOwnProperty("passwordRequired"))
            if (typeof message.passwordRequired !== "boolean")
                return "passwordRequired: boolean expected";
        if (message.carrierPasswordPrompt != null && message.hasOwnProperty("carrierPasswordPrompt")) {
            var error = $root.PasswordPrompt.verify(message.carrierPasswordPrompt);
            if (error)
                return "carrierPasswordPrompt." + error;
        }
        if (message.apiVersion != null && message.hasOwnProperty("apiVersion"))
            if (!$util.isInteger(message.apiVersion))
                return "apiVersion: integer expected";
        if (message.name != null && message.hasOwnProperty("name"))
            if (!$util.isString(message.name))
                return "name: string expected";
        if (message.deviceAssociation != null && message.hasOwnProperty("deviceAssociation")) {
            var error = $root.DeviceAssociation.verify(message.deviceAssociation);
            if (error)
                return "deviceAssociation." + error;
        }
        if (message.carrierSupportPhoneNumber != null && message.hasOwnProperty("carrierSupportPhoneNumber"))
            if (!$util.isString(message.carrierSupportPhoneNumber))
                return "carrierSupportPhoneNumber: string expected";
        return null;
    };

    /**
     * Creates a CarrierBillingInstrumentStatus message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof CarrierBillingInstrumentStatus
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {CarrierBillingInstrumentStatus} CarrierBillingInstrumentStatus
     */
    CarrierBillingInstrumentStatus.fromObject = function fromObject(object) {
        if (object instanceof $root.CarrierBillingInstrumentStatus)
            return object;
        var message = new $root.CarrierBillingInstrumentStatus();
        if (object.carrierTos != null) {
            if (typeof object.carrierTos !== "object")
                throw TypeError(".CarrierBillingInstrumentStatus.carrierTos: object expected");
            message.carrierTos = $root.CarrierTos.fromObject(object.carrierTos);
        }
        if (object.associationRequired != null)
            message.associationRequired = Boolean(object.associationRequired);
        if (object.passwordRequired != null)
            message.passwordRequired = Boolean(object.passwordRequired);
        if (object.carrierPasswordPrompt != null) {
            if (typeof object.carrierPasswordPrompt !== "object")
                throw TypeError(".CarrierBillingInstrumentStatus.carrierPasswordPrompt: object expected");
            message.carrierPasswordPrompt = $root.PasswordPrompt.fromObject(object.carrierPasswordPrompt);
        }
        if (object.apiVersion != null)
            message.apiVersion = object.apiVersion | 0;
        if (object.name != null)
            message.name = String(object.name);
        if (object.deviceAssociation != null) {
            if (typeof object.deviceAssociation !== "object")
                throw TypeError(".CarrierBillingInstrumentStatus.deviceAssociation: object expected");
            message.deviceAssociation = $root.DeviceAssociation.fromObject(object.deviceAssociation);
        }
        if (object.carrierSupportPhoneNumber != null)
            message.carrierSupportPhoneNumber = String(object.carrierSupportPhoneNumber);
        return message;
    };

    /**
     * Creates a plain object from a CarrierBillingInstrumentStatus message. Also converts values to other types if specified.
     * @function toObject
     * @memberof CarrierBillingInstrumentStatus
     * @static
     * @param {CarrierBillingInstrumentStatus} message CarrierBillingInstrumentStatus
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    CarrierBillingInstrumentStatus.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        var object = {};
        if (options.defaults) {
            object.carrierTos = null;
            object.associationRequired = false;
            object.passwordRequired = false;
            object.carrierPasswordPrompt = null;
            object.apiVersion = 0;
            object.name = "";
            object.deviceAssociation = null;
            object.carrierSupportPhoneNumber = "";
        }
        if (message.carrierTos != null && message.hasOwnProperty("carrierTos"))
            object.carrierTos = $root.CarrierTos.toObject(message.carrierTos, options);
        if (message.associationRequired != null && message.hasOwnProperty("associationRequired"))
            object.associationRequired = message.associationRequired;
        if (message.passwordRequired != null && message.hasOwnProperty("passwordRequired"))
            object.passwordRequired = message.passwordRequired;
        if (message.carrierPasswordPrompt != null && message.hasOwnProperty("carrierPasswordPrompt"))
            object.carrierPasswordPrompt = $root.PasswordPrompt.toObject(message.carrierPasswordPrompt, options);
        if (message.apiVersion != null && message.hasOwnProperty("apiVersion"))
            object.apiVersion = message.apiVersion;
        if (message.name != null && message.hasOwnProperty("name"))
            object.name = message.name;
        if (message.deviceAssociation != null && message.hasOwnProperty("deviceAssociation"))
            object.deviceAssociation = $root.DeviceAssociation.toObject(message.deviceAssociation, options);
        if (message.carrierSupportPhoneNumber != null && message.hasOwnProperty("carrierSupportPhoneNumber"))
            object.carrierSupportPhoneNumber = message.carrierSupportPhoneNumber;
        return object;
    };

    /**
     * Converts this CarrierBillingInstrumentStatus to JSON.
     * @function toJSON
     * @memberof CarrierBillingInstrumentStatus
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    CarrierBillingInstrumentStatus.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return CarrierBillingInstrumentStatus;
})();

$root.CarrierTos = (function() {

    /**
     * Properties of a CarrierTos.
     * @exports ICarrierTos
     * @interface ICarrierTos
     * @property {ICarrierTosEntry|null} [dcbTos] CarrierTos dcbTos
     * @property {ICarrierTosEntry|null} [piiTos] CarrierTos piiTos
     * @property {boolean|null} [needsDcbTosAcceptance] CarrierTos needsDcbTosAcceptance
     * @property {boolean|null} [needsPiiTosAcceptance] CarrierTos needsPiiTosAcceptance
     */

    /**
     * Constructs a new CarrierTos.
     * @exports CarrierTos
     * @classdesc Represents a CarrierTos.
     * @implements ICarrierTos
     * @constructor
     * @param {ICarrierTos=} [properties] Properties to set
     */
    function CarrierTos(properties) {
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * CarrierTos dcbTos.
     * @member {ICarrierTosEntry|null|undefined} dcbTos
     * @memberof CarrierTos
     * @instance
     */
    CarrierTos.prototype.dcbTos = null;

    /**
     * CarrierTos piiTos.
     * @member {ICarrierTosEntry|null|undefined} piiTos
     * @memberof CarrierTos
     * @instance
     */
    CarrierTos.prototype.piiTos = null;

    /**
     * CarrierTos needsDcbTosAcceptance.
     * @member {boolean} needsDcbTosAcceptance
     * @memberof CarrierTos
     * @instance
     */
    CarrierTos.prototype.needsDcbTosAcceptance = false;

    /**
     * CarrierTos needsPiiTosAcceptance.
     * @member {boolean} needsPiiTosAcceptance
     * @memberof CarrierTos
     * @instance
     */
    CarrierTos.prototype.needsPiiTosAcceptance = false;

    /**
     * Creates a new CarrierTos instance using the specified properties.
     * @function create
     * @memberof CarrierTos
     * @static
     * @param {ICarrierTos=} [properties] Properties to set
     * @returns {CarrierTos} CarrierTos instance
     */
    CarrierTos.create = function create(properties) {
        return new CarrierTos(properties);
    };

    /**
     * Encodes the specified CarrierTos message. Does not implicitly {@link CarrierTos.verify|verify} messages.
     * @function encode
     * @memberof CarrierTos
     * @static
     * @param {ICarrierTos} message CarrierTos message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    CarrierTos.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.dcbTos != null && Object.hasOwnProperty.call(message, "dcbTos"))
            $root.CarrierTosEntry.encode(message.dcbTos, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
        if (message.piiTos != null && Object.hasOwnProperty.call(message, "piiTos"))
            $root.CarrierTosEntry.encode(message.piiTos, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
        if (message.needsDcbTosAcceptance != null && Object.hasOwnProperty.call(message, "needsDcbTosAcceptance"))
            writer.uint32(/* id 3, wireType 0 =*/24).bool(message.needsDcbTosAcceptance);
        if (message.needsPiiTosAcceptance != null && Object.hasOwnProperty.call(message, "needsPiiTosAcceptance"))
            writer.uint32(/* id 4, wireType 0 =*/32).bool(message.needsPiiTosAcceptance);
        return writer;
    };

    /**
     * Encodes the specified CarrierTos message, length delimited. Does not implicitly {@link CarrierTos.verify|verify} messages.
     * @function encodeDelimited
     * @memberof CarrierTos
     * @static
     * @param {ICarrierTos} message CarrierTos message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    CarrierTos.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a CarrierTos message from the specified reader or buffer.
     * @function decode
     * @memberof CarrierTos
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CarrierTos} CarrierTos
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CarrierTos.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CarrierTos();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.dcbTos = $root.CarrierTosEntry.decode(reader, reader.uint32());
                break;
            case 2:
                message.piiTos = $root.CarrierTosEntry.decode(reader, reader.uint32());
                break;
            case 3:
                message.needsDcbTosAcceptance = reader.bool();
                break;
            case 4:
                message.needsPiiTosAcceptance = reader.bool();
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a CarrierTos message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof CarrierTos
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {CarrierTos} CarrierTos
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CarrierTos.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a CarrierTos message.
     * @function verify
     * @memberof CarrierTos
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    CarrierTos.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.dcbTos != null && message.hasOwnProperty("dcbTos")) {
            var error = $root.CarrierTosEntry.verify(message.dcbTos);
            if (error)
                return "dcbTos." + error;
        }
        if (message.piiTos != null && message.hasOwnProperty("piiTos")) {
            var error = $root.CarrierTosEntry.verify(message.piiTos);
            if (error)
                return "piiTos." + error;
        }
        if (message.needsDcbTosAcceptance != null && message.hasOwnProperty("needsDcbTosAcceptance"))
            if (typeof message.needsDcbTosAcceptance !== "boolean")
                return "needsDcbTosAcceptance: boolean expected";
        if (message.needsPiiTosAcceptance != null && message.hasOwnProperty("needsPiiTosAcceptance"))
            if (typeof message.needsPiiTosAcceptance !== "boolean")
                return "needsPiiTosAcceptance: boolean expected";
        return null;
    };

    /**
     * Creates a CarrierTos message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof CarrierTos
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {CarrierTos} CarrierTos
     */
    CarrierTos.fromObject = function fromObject(object) {
        if (object instanceof $root.CarrierTos)
            return object;
        var message = new $root.CarrierTos();
        if (object.dcbTos != null) {
            if (typeof object.dcbTos !== "object")
                throw TypeError(".CarrierTos.dcbTos: object expected");
            message.dcbTos = $root.CarrierTosEntry.fromObject(object.dcbTos);
        }
        if (object.piiTos != null) {
            if (typeof object.piiTos !== "object")
                throw TypeError(".CarrierTos.piiTos: object expected");
            message.piiTos = $root.CarrierTosEntry.fromObject(object.piiTos);
        }
        if (object.needsDcbTosAcceptance != null)
            message.needsDcbTosAcceptance = Boolean(object.needsDcbTosAcceptance);
        if (object.needsPiiTosAcceptance != null)
            message.needsPiiTosAcceptance = Boolean(object.needsPiiTosAcceptance);
        return message;
    };

    /**
     * Creates a plain object from a CarrierTos message. Also converts values to other types if specified.
     * @function toObject
     * @memberof CarrierTos
     * @static
     * @param {CarrierTos} message CarrierTos
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    CarrierTos.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        var object = {};
        if (options.defaults) {
            object.dcbTos = null;
            object.piiTos = null;
            object.needsDcbTosAcceptance = false;
            object.needsPiiTosAcceptance = false;
        }
        if (message.dcbTos != null && message.hasOwnProperty("dcbTos"))
            object.dcbTos = $root.CarrierTosEntry.toObject(message.dcbTos, options);
        if (message.piiTos != null && message.hasOwnProperty("piiTos"))
            object.piiTos = $root.CarrierTosEntry.toObject(message.piiTos, options);
        if (message.needsDcbTosAcceptance != null && message.hasOwnProperty("needsDcbTosAcceptance"))
            object.needsDcbTosAcceptance = message.needsDcbTosAcceptance;
        if (message.needsPiiTosAcceptance != null && message.hasOwnProperty("needsPiiTosAcceptance"))
            object.needsPiiTosAcceptance = message.needsPiiTosAcceptance;
        return object;
    };

    /**
     * Converts this CarrierTos to JSON.
     * @function toJSON
     * @memberof CarrierTos
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    CarrierTos.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return CarrierTos;
})();

$root.CarrierTosEntry = (function() {

    /**
     * Properties of a CarrierTosEntry.
     * @exports ICarrierTosEntry
     * @interface ICarrierTosEntry
     * @property {string|null} [url] CarrierTosEntry url
     * @property {string|null} [version] CarrierTosEntry version
     */

    /**
     * Constructs a new CarrierTosEntry.
     * @exports CarrierTosEntry
     * @classdesc Represents a CarrierTosEntry.
     * @implements ICarrierTosEntry
     * @constructor
     * @param {ICarrierTosEntry=} [properties] Properties to set
     */
    function CarrierTosEntry(properties) {
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * CarrierTosEntry url.
     * @member {string} url
     * @memberof CarrierTosEntry
     * @instance
     */
    CarrierTosEntry.prototype.url = "";

    /**
     * CarrierTosEntry version.
     * @member {string} version
     * @memberof CarrierTosEntry
     * @instance
     */
    CarrierTosEntry.prototype.version = "";

    /**
     * Creates a new CarrierTosEntry instance using the specified properties.
     * @function create
     * @memberof CarrierTosEntry
     * @static
     * @param {ICarrierTosEntry=} [properties] Properties to set
     * @returns {CarrierTosEntry} CarrierTosEntry instance
     */
    CarrierTosEntry.create = function create(properties) {
        return new CarrierTosEntry(properties);
    };

    /**
     * Encodes the specified CarrierTosEntry message. Does not implicitly {@link CarrierTosEntry.verify|verify} messages.
     * @function encode
     * @memberof CarrierTosEntry
     * @static
     * @param {ICarrierTosEntry} message CarrierTosEntry message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    CarrierTosEntry.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.url != null && Object.hasOwnProperty.call(message, "url"))
            writer.uint32(/* id 1, wireType 2 =*/10).string(message.url);
        if (message.version != null && Object.hasOwnProperty.call(message, "version"))
            writer.uint32(/* id 2, wireType 2 =*/18).string(message.version);
        return writer;
    };

    /**
     * Encodes the specified CarrierTosEntry message, length delimited. Does not implicitly {@link CarrierTosEntry.verify|verify} messages.
     * @function encodeDelimited
     * @memberof CarrierTosEntry
     * @static
     * @param {ICarrierTosEntry} message CarrierTosEntry message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    CarrierTosEntry.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a CarrierTosEntry message from the specified reader or buffer.
     * @function decode
     * @memberof CarrierTosEntry
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CarrierTosEntry} CarrierTosEntry
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CarrierTosEntry.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CarrierTosEntry();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.url = reader.string();
                break;
            case 2:
                message.version = reader.string();
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a CarrierTosEntry message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof CarrierTosEntry
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {CarrierTosEntry} CarrierTosEntry
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CarrierTosEntry.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a CarrierTosEntry message.
     * @function verify
     * @memberof CarrierTosEntry
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    CarrierTosEntry.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.url != null && message.hasOwnProperty("url"))
            if (!$util.isString(message.url))
                return "url: string expected";
        if (message.version != null && message.hasOwnProperty("version"))
            if (!$util.isString(message.version))
                return "version: string expected";
        return null;
    };

    /**
     * Creates a CarrierTosEntry message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof CarrierTosEntry
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {CarrierTosEntry} CarrierTosEntry
     */
    CarrierTosEntry.fromObject = function fromObject(object) {
        if (object instanceof $root.CarrierTosEntry)
            return object;
        var message = new $root.CarrierTosEntry();
        if (object.url != null)
            message.url = String(object.url);
        if (object.version != null)
            message.version = String(object.version);
        return message;
    };

    /**
     * Creates a plain object from a CarrierTosEntry message. Also converts values to other types if specified.
     * @function toObject
     * @memberof CarrierTosEntry
     * @static
     * @param {CarrierTosEntry} message CarrierTosEntry
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    CarrierTosEntry.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        var object = {};
        if (options.defaults) {
            object.url = "";
            object.version = "";
        }
        if (message.url != null && message.hasOwnProperty("url"))
            object.url = message.url;
        if (message.version != null && message.hasOwnProperty("version"))
            object.version = message.version;
        return object;
    };

    /**
     * Converts this CarrierTosEntry to JSON.
     * @function toJSON
     * @memberof CarrierTosEntry
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    CarrierTosEntry.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return CarrierTosEntry;
})();

$root.CreditCardInstrument = (function() {

    /**
     * Properties of a CreditCardInstrument.
     * @exports ICreditCardInstrument
     * @interface ICreditCardInstrument
     * @property {number|null} [type] CreditCardInstrument type
     * @property {string|null} [escrowHandle] CreditCardInstrument escrowHandle
     * @property {string|null} [lastDigits] CreditCardInstrument lastDigits
     * @property {number|null} [expirationMonth] CreditCardInstrument expirationMonth
     * @property {number|null} [expirationYear] CreditCardInstrument expirationYear
     * @property {Array.<IEfeParam>|null} [escrowEfeParam] CreditCardInstrument escrowEfeParam
     */

    /**
     * Constructs a new CreditCardInstrument.
     * @exports CreditCardInstrument
     * @classdesc Represents a CreditCardInstrument.
     * @implements ICreditCardInstrument
     * @constructor
     * @param {ICreditCardInstrument=} [properties] Properties to set
     */
    function CreditCardInstrument(properties) {
        this.escrowEfeParam = [];
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * CreditCardInstrument type.
     * @member {number} type
     * @memberof CreditCardInstrument
     * @instance
     */
    CreditCardInstrument.prototype.type = 0;

    /**
     * CreditCardInstrument escrowHandle.
     * @member {string} escrowHandle
     * @memberof CreditCardInstrument
     * @instance
     */
    CreditCardInstrument.prototype.escrowHandle = "";

    /**
     * CreditCardInstrument lastDigits.
     * @member {string} lastDigits
     * @memberof CreditCardInstrument
     * @instance
     */
    CreditCardInstrument.prototype.lastDigits = "";

    /**
     * CreditCardInstrument expirationMonth.
     * @member {number} expirationMonth
     * @memberof CreditCardInstrument
     * @instance
     */
    CreditCardInstrument.prototype.expirationMonth = 0;

    /**
     * CreditCardInstrument expirationYear.
     * @member {number} expirationYear
     * @memberof CreditCardInstrument
     * @instance
     */
    CreditCardInstrument.prototype.expirationYear = 0;

    /**
     * CreditCardInstrument escrowEfeParam.
     * @member {Array.<IEfeParam>} escrowEfeParam
     * @memberof CreditCardInstrument
     * @instance
     */
    CreditCardInstrument.prototype.escrowEfeParam = $util.emptyArray;

    /**
     * Creates a new CreditCardInstrument instance using the specified properties.
     * @function create
     * @memberof CreditCardInstrument
     * @static
     * @param {ICreditCardInstrument=} [properties] Properties to set
     * @returns {CreditCardInstrument} CreditCardInstrument instance
     */
    CreditCardInstrument.create = function create(properties) {
        return new CreditCardInstrument(properties);
    };

    /**
     * Encodes the specified CreditCardInstrument message. Does not implicitly {@link CreditCardInstrument.verify|verify} messages.
     * @function encode
     * @memberof CreditCardInstrument
     * @static
     * @param {ICreditCardInstrument} message CreditCardInstrument message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    CreditCardInstrument.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.type != null && Object.hasOwnProperty.call(message, "type"))
            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.type);
        if (message.escrowHandle != null && Object.hasOwnProperty.call(message, "escrowHandle"))
            writer.uint32(/* id 2, wireType 2 =*/18).string(message.escrowHandle);
        if (message.lastDigits != null && Object.hasOwnProperty.call(message, "lastDigits"))
            writer.uint32(/* id 3, wireType 2 =*/26).string(message.lastDigits);
        if (message.expirationMonth != null && Object.hasOwnProperty.call(message, "expirationMonth"))
            writer.uint32(/* id 4, wireType 0 =*/32).int32(message.expirationMonth);
        if (message.expirationYear != null && Object.hasOwnProperty.call(message, "expirationYear"))
            writer.uint32(/* id 5, wireType 0 =*/40).int32(message.expirationYear);
        if (message.escrowEfeParam != null && message.escrowEfeParam.length)
            for (var i = 0; i < message.escrowEfeParam.length; ++i)
                $root.EfeParam.encode(message.escrowEfeParam[i], writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
        return writer;
    };

    /**
     * Encodes the specified CreditCardInstrument message, length delimited. Does not implicitly {@link CreditCardInstrument.verify|verify} messages.
     * @function encodeDelimited
     * @memberof CreditCardInstrument
     * @static
     * @param {ICreditCardInstrument} message CreditCardInstrument message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    CreditCardInstrument.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a CreditCardInstrument message from the specified reader or buffer.
     * @function decode
     * @memberof CreditCardInstrument
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CreditCardInstrument} CreditCardInstrument
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CreditCardInstrument.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CreditCardInstrument();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.type = reader.int32();
                break;
            case 2:
                message.escrowHandle = reader.string();
                break;
            case 3:
                message.lastDigits = reader.string();
                break;
            case 4:
                message.expirationMonth = reader.int32();
                break;
            case 5:
                message.expirationYear = reader.int32();
                break;
            case 6:
                if (!(message.escrowEfeParam && message.escrowEfeParam.length))
                    message.escrowEfeParam = [];
                message.escrowEfeParam.push($root.EfeParam.decode(reader, reader.uint32()));
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a CreditCardInstrument message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof CreditCardInstrument
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {CreditCardInstrument} CreditCardInstrument
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CreditCardInstrument.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a CreditCardInstrument message.
     * @function verify
     * @memberof CreditCardInstrument
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    CreditCardInstrument.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.type != null && message.hasOwnProperty("type"))
            if (!$util.isInteger(message.type))
                return "type: integer expected";
        if (message.escrowHandle != null && message.hasOwnProperty("escrowHandle"))
            if (!$util.isString(message.escrowHandle))
                return "escrowHandle: string expected";
        if (message.lastDigits != null && message.hasOwnProperty("lastDigits"))
            if (!$util.isString(message.lastDigits))
                return "lastDigits: string expected";
        if (message.expirationMonth != null && message.hasOwnProperty("expirationMonth"))
            if (!$util.isInteger(message.expirationMonth))
                return "expirationMonth: integer expected";
        if (message.expirationYear != null && message.hasOwnProperty("expirationYear"))
            if (!$util.isInteger(message.expirationYear))
                return "expirationYear: integer expected";
        if (message.escrowEfeParam != null && message.hasOwnProperty("escrowEfeParam")) {
            if (!Array.isArray(message.escrowEfeParam))
                return "escrowEfeParam: array expected";
            for (var i = 0; i < message.escrowEfeParam.length; ++i) {
                var error = $root.EfeParam.verify(message.escrowEfeParam[i]);
                if (error)
                    return "escrowEfeParam." + error;
            }
        }
        return null;
    };

    /**
     * Creates a CreditCardInstrument message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof CreditCardInstrument
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {CreditCardInstrument} CreditCardInstrument
     */
    CreditCardInstrument.fromObject = function fromObject(object) {
        if (object instanceof $root.CreditCardInstrument)
            return object;
        var message = new $root.CreditCardInstrument();
        if (object.type != null)
            message.type = object.type | 0;
        if (object.escrowHandle != null)
            message.escrowHandle = String(object.escrowHandle);
        if (object.lastDigits != null)
            message.lastDigits = String(object.lastDigits);
        if (object.expirationMonth != null)
            message.expirationMonth = object.expirationMonth | 0;
        if (object.expirationYear != null)
            message.expirationYear = object.expirationYear | 0;
        if (object.escrowEfeParam) {
            if (!Array.isArray(object.escrowEfeParam))
                throw TypeError(".CreditCardInstrument.escrowEfeParam: array expected");
            message.escrowEfeParam = [];
            for (var i = 0; i < object.escrowEfeParam.length; ++i) {
                if (typeof object.escrowEfeParam[i] !== "object")
                    throw TypeError(".CreditCardInstrument.escrowEfeParam: object expected");
                message.escrowEfeParam[i] = $root.EfeParam.fromObject(object.escrowEfeParam[i]);
            }
        }
        return message;
    };

    /**
     * Creates a plain object from a CreditCardInstrument message. Also converts values to other types if specified.
     * @function toObject
     * @memberof CreditCardInstrument
     * @static
     * @param {CreditCardInstrument} message CreditCardInstrument
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    CreditCardInstrument.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        var object = {};
        if (options.arrays || options.defaults)
            object.escrowEfeParam = [];
        if (options.defaults) {
            object.type = 0;
            object.escrowHandle = "";
            object.lastDigits = "";
            object.expirationMonth = 0;
            object.expirationYear = 0;
        }
        if (message.type != null && message.hasOwnProperty("type"))
            object.type = message.type;
        if (message.escrowHandle != null && message.hasOwnProperty("escrowHandle"))
            object.escrowHandle = message.escrowHandle;
        if (message.lastDigits != null && message.hasOwnProperty("lastDigits"))
            object.lastDigits = message.lastDigits;
        if (message.expirationMonth != null && message.hasOwnProperty("expirationMonth"))
            object.expirationMonth = message.expirationMonth;
        if (message.expirationYear != null && message.hasOwnProperty("expirationYear"))
            object.expirationYear = message.expirationYear;
        if (message.escrowEfeParam && message.escrowEfeParam.length) {
            object.escrowEfeParam = [];
            for (var j = 0; j < message.escrowEfeParam.length; ++j)
                object.escrowEfeParam[j] = $root.EfeParam.toObject(message.escrowEfeParam[j], options);
        }
        return object;
    };

    /**
     * Converts this CreditCardInstrument to JSON.
     * @function toJSON
     * @memberof CreditCardInstrument
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    CreditCardInstrument.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return CreditCardInstrument;
})();

$root.DeviceAssociation = (function() {

    /**
     * Properties of a DeviceAssociation.
     * @exports IDeviceAssociation
     * @interface IDeviceAssociation
     * @property {string|null} [userTokenRequestMessage] DeviceAssociation userTokenRequestMessage
     * @property {string|null} [userTokenRequestAddress] DeviceAssociation userTokenRequestAddress
     */

    /**
     * Constructs a new DeviceAssociation.
     * @exports DeviceAssociation
     * @classdesc Represents a DeviceAssociation.
     * @implements IDeviceAssociation
     * @constructor
     * @param {IDeviceAssociation=} [properties] Properties to set
     */
    function DeviceAssociation(properties) {
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * DeviceAssociation userTokenRequestMessage.
     * @member {string} userTokenRequestMessage
     * @memberof DeviceAssociation
     * @instance
     */
    DeviceAssociation.prototype.userTokenRequestMessage = "";

    /**
     * DeviceAssociation userTokenRequestAddress.
     * @member {string} userTokenRequestAddress
     * @memberof DeviceAssociation
     * @instance
     */
    DeviceAssociation.prototype.userTokenRequestAddress = "";

    /**
     * Creates a new DeviceAssociation instance using the specified properties.
     * @function create
     * @memberof DeviceAssociation
     * @static
     * @param {IDeviceAssociation=} [properties] Properties to set
     * @returns {DeviceAssociation} DeviceAssociation instance
     */
    DeviceAssociation.create = function create(properties) {
        return new DeviceAssociation(properties);
    };

    /**
     * Encodes the specified DeviceAssociation message. Does not implicitly {@link DeviceAssociation.verify|verify} messages.
     * @function encode
     * @memberof DeviceAssociation
     * @static
     * @param {IDeviceAssociation} message DeviceAssociation message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    DeviceAssociation.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.userTokenRequestMessage != null && Object.hasOwnProperty.call(message, "userTokenRequestMessage"))
            writer.uint32(/* id 1, wireType 2 =*/10).string(message.userTokenRequestMessage);
        if (message.userTokenRequestAddress != null && Object.hasOwnProperty.call(message, "userTokenRequestAddress"))
            writer.uint32(/* id 2, wireType 2 =*/18).string(message.userTokenRequestAddress);
        return writer;
    };

    /**
     * Encodes the specified DeviceAssociation message, length delimited. Does not implicitly {@link DeviceAssociation.verify|verify} messages.
     * @function encodeDelimited
     * @memberof DeviceAssociation
     * @static
     * @param {IDeviceAssociation} message DeviceAssociation message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    DeviceAssociation.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a DeviceAssociation message from the specified reader or buffer.
     * @function decode
     * @memberof DeviceAssociation
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {DeviceAssociation} DeviceAssociation
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    DeviceAssociation.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.DeviceAssociation();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.userTokenRequestMessage = reader.string();
                break;
            case 2:
                message.userTokenRequestAddress = reader.string();
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a DeviceAssociation message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof DeviceAssociation
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {DeviceAssociation} DeviceAssociation
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    DeviceAssociation.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a DeviceAssociation message.
     * @function verify
     * @memberof DeviceAssociation
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    DeviceAssociation.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.userTokenRequestMessage != null && message.hasOwnProperty("userTokenRequestMessage"))
            if (!$util.isString(message.userTokenRequestMessage))
                return "userTokenRequestMessage: string expected";
        if (message.userTokenRequestAddress != null && message.hasOwnProperty("userTokenRequestAddress"))
            if (!$util.isString(message.userTokenRequestAddress))
                return "userTokenRequestAddress: string expected";
        return null;
    };

    /**
     * Creates a DeviceAssociation message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof DeviceAssociation
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {DeviceAssociation} DeviceAssociation
     */
    DeviceAssociation.fromObject = function fromObject(object) {
        if (object instanceof $root.DeviceAssociation)
            return object;
        var message = new $root.DeviceAssociation();
        if (object.userTokenRequestMessage != null)
            message.userTokenRequestMessage = String(object.userTokenRequestMessage);
        if (object.userTokenRequestAddress != null)
            message.userTokenRequestAddress = String(object.userTokenRequestAddress);
        return message;
    };

    /**
     * Creates a plain object from a DeviceAssociation message. Also converts values to other types if specified.
     * @function toObject
     * @memberof DeviceAssociation
     * @static
     * @param {DeviceAssociation} message DeviceAssociation
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    DeviceAssociation.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        var object = {};
        if (options.defaults) {
            object.userTokenRequestMessage = "";
            object.userTokenRequestAddress = "";
        }
        if (message.userTokenRequestMessage != null && message.hasOwnProperty("userTokenRequestMessage"))
            object.userTokenRequestMessage = message.userTokenRequestMessage;
        if (message.userTokenRequestAddress != null && message.hasOwnProperty("userTokenRequestAddress"))
            object.userTokenRequestAddress = message.userTokenRequestAddress;
        return object;
    };

    /**
     * Converts this DeviceAssociation to JSON.
     * @function toJSON
     * @memberof DeviceAssociation
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    DeviceAssociation.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return DeviceAssociation;
})();

$root.DisabledInfo = (function() {

    /**
     * Properties of a DisabledInfo.
     * @exports IDisabledInfo
     * @interface IDisabledInfo
     * @property {number|null} [disabledReason] DisabledInfo disabledReason
     * @property {string|null} [disabledMessageHtml] DisabledInfo disabledMessageHtml
     * @property {string|null} [errorMessage] DisabledInfo errorMessage
     */

    /**
     * Constructs a new DisabledInfo.
     * @exports DisabledInfo
     * @classdesc Represents a DisabledInfo.
     * @implements IDisabledInfo
     * @constructor
     * @param {IDisabledInfo=} [properties] Properties to set
     */
    function DisabledInfo(properties) {
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * DisabledInfo disabledReason.
     * @member {number} disabledReason
     * @memberof DisabledInfo
     * @instance
     */
    DisabledInfo.prototype.disabledReason = 0;

    /**
     * DisabledInfo disabledMessageHtml.
     * @member {string} disabledMessageHtml
     * @memberof DisabledInfo
     * @instance
     */
    DisabledInfo.prototype.disabledMessageHtml = "";

    /**
     * DisabledInfo errorMessage.
     * @member {string} errorMessage
     * @memberof DisabledInfo
     * @instance
     */
    DisabledInfo.prototype.errorMessage = "";

    /**
     * Creates a new DisabledInfo instance using the specified properties.
     * @function create
     * @memberof DisabledInfo
     * @static
     * @param {IDisabledInfo=} [properties] Properties to set
     * @returns {DisabledInfo} DisabledInfo instance
     */
    DisabledInfo.create = function create(properties) {
        return new DisabledInfo(properties);
    };

    /**
     * Encodes the specified DisabledInfo message. Does not implicitly {@link DisabledInfo.verify|verify} messages.
     * @function encode
     * @memberof DisabledInfo
     * @static
     * @param {IDisabledInfo} message DisabledInfo message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    DisabledInfo.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.disabledReason != null && Object.hasOwnProperty.call(message, "disabledReason"))
            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.disabledReason);
        if (message.disabledMessageHtml != null && Object.hasOwnProperty.call(message, "disabledMessageHtml"))
            writer.uint32(/* id 2, wireType 2 =*/18).string(message.disabledMessageHtml);
        if (message.errorMessage != null && Object.hasOwnProperty.call(message, "errorMessage"))
            writer.uint32(/* id 3, wireType 2 =*/26).string(message.errorMessage);
        return writer;
    };

    /**
     * Encodes the specified DisabledInfo message, length delimited. Does not implicitly {@link DisabledInfo.verify|verify} messages.
     * @function encodeDelimited
     * @memberof DisabledInfo
     * @static
     * @param {IDisabledInfo} message DisabledInfo message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    DisabledInfo.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a DisabledInfo message from the specified reader or buffer.
     * @function decode
     * @memberof DisabledInfo
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {DisabledInfo} DisabledInfo
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    DisabledInfo.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.DisabledInfo();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.disabledReason = reader.int32();
                break;
            case 2:
                message.disabledMessageHtml = reader.string();
                break;
            case 3:
                message.errorMessage = reader.string();
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a DisabledInfo message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof DisabledInfo
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {DisabledInfo} DisabledInfo
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    DisabledInfo.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a DisabledInfo message.
     * @function verify
     * @memberof DisabledInfo
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    DisabledInfo.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.disabledReason != null && message.hasOwnProperty("disabledReason"))
            if (!$util.isInteger(message.disabledReason))
                return "disabledReason: integer expected";
        if (message.disabledMessageHtml != null && message.hasOwnProperty("disabledMessageHtml"))
            if (!$util.isString(message.disabledMessageHtml))
                return "disabledMessageHtml: string expected";
        if (message.errorMessage != null && message.hasOwnProperty("errorMessage"))
            if (!$util.isString(message.errorMessage))
                return "errorMessage: string expected";
        return null;
    };

    /**
     * Creates a DisabledInfo message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof DisabledInfo
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {DisabledInfo} DisabledInfo
     */
    DisabledInfo.fromObject = function fromObject(object) {
        if (object instanceof $root.DisabledInfo)
            return object;
        var message = new $root.DisabledInfo();
        if (object.disabledReason != null)
            message.disabledReason = object.disabledReason | 0;
        if (object.disabledMessageHtml != null)
            message.disabledMessageHtml = String(object.disabledMessageHtml);
        if (object.errorMessage != null)
            message.errorMessage = String(object.errorMessage);
        return message;
    };

    /**
     * Creates a plain object from a DisabledInfo message. Also converts values to other types if specified.
     * @function toObject
     * @memberof DisabledInfo
     * @static
     * @param {DisabledInfo} message DisabledInfo
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    DisabledInfo.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        var object = {};
        if (options.defaults) {
            object.disabledReason = 0;
            object.disabledMessageHtml = "";
            object.errorMessage = "";
        }
        if (message.disabledReason != null && message.hasOwnProperty("disabledReason"))
            object.disabledReason = message.disabledReason;
        if (message.disabledMessageHtml != null && message.hasOwnProperty("disabledMessageHtml"))
            object.disabledMessageHtml = message.disabledMessageHtml;
        if (message.errorMessage != null && message.hasOwnProperty("errorMessage"))
            object.errorMessage = message.errorMessage;
        return object;
    };

    /**
     * Converts this DisabledInfo to JSON.
     * @function toJSON
     * @memberof DisabledInfo
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    DisabledInfo.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return DisabledInfo;
})();

$root.EfeParam = (function() {

    /**
     * Properties of an EfeParam.
     * @exports IEfeParam
     * @interface IEfeParam
     * @property {number|null} [key] EfeParam key
     * @property {string|null} [value] EfeParam value
     */

    /**
     * Constructs a new EfeParam.
     * @exports EfeParam
     * @classdesc Represents an EfeParam.
     * @implements IEfeParam
     * @constructor
     * @param {IEfeParam=} [properties] Properties to set
     */
    function EfeParam(properties) {
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * EfeParam key.
     * @member {number} key
     * @memberof EfeParam
     * @instance
     */
    EfeParam.prototype.key = 0;

    /**
     * EfeParam value.
     * @member {string} value
     * @memberof EfeParam
     * @instance
     */
    EfeParam.prototype.value = "";

    /**
     * Creates a new EfeParam instance using the specified properties.
     * @function create
     * @memberof EfeParam
     * @static
     * @param {IEfeParam=} [properties] Properties to set
     * @returns {EfeParam} EfeParam instance
     */
    EfeParam.create = function create(properties) {
        return new EfeParam(properties);
    };

    /**
     * Encodes the specified EfeParam message. Does not implicitly {@link EfeParam.verify|verify} messages.
     * @function encode
     * @memberof EfeParam
     * @static
     * @param {IEfeParam} message EfeParam message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    EfeParam.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.key != null && Object.hasOwnProperty.call(message, "key"))
            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.key);
        if (message.value != null && Object.hasOwnProperty.call(message, "value"))
            writer.uint32(/* id 2, wireType 2 =*/18).string(message.value);
        return writer;
    };

    /**
     * Encodes the specified EfeParam message, length delimited. Does not implicitly {@link EfeParam.verify|verify} messages.
     * @function encodeDelimited
     * @memberof EfeParam
     * @static
     * @param {IEfeParam} message EfeParam message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    EfeParam.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes an EfeParam message from the specified reader or buffer.
     * @function decode
     * @memberof EfeParam
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {EfeParam} EfeParam
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    EfeParam.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.EfeParam();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.key = reader.int32();
                break;
            case 2:
                message.value = reader.string();
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes an EfeParam message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof EfeParam
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {EfeParam} EfeParam
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    EfeParam.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies an EfeParam message.
     * @function verify
     * @memberof EfeParam
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    EfeParam.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.key != null && message.hasOwnProperty("key"))
            if (!$util.isInteger(message.key))
                return "key: integer expected";
        if (message.value != null && message.hasOwnProperty("value"))
            if (!$util.isString(message.value))
                return "value: string expected";
        return null;
    };

    /**
     * Creates an EfeParam message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof EfeParam
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {EfeParam} EfeParam
     */
    EfeParam.fromObject = function fromObject(object) {
        if (object instanceof $root.EfeParam)
            return object;
        var message = new $root.EfeParam();
        if (object.key != null)
            message.key = object.key | 0;
        if (object.value != null)
            message.value = String(object.value);
        return message;
    };

    /**
     * Creates a plain object from an EfeParam message. Also converts values to other types if specified.
     * @function toObject
     * @memberof EfeParam
     * @static
     * @param {EfeParam} message EfeParam
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    EfeParam.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        var object = {};
        if (options.defaults) {
            object.key = 0;
            object.value = "";
        }
        if (message.key != null && message.hasOwnProperty("key"))
            object.key = message.key;
        if (message.value != null && message.hasOwnProperty("value"))
            object.value = message.value;
        return object;
    };

    /**
     * Converts this EfeParam to JSON.
     * @function toJSON
     * @memberof EfeParam
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    EfeParam.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return EfeParam;
})();

$root.Instrument = (function() {

    /**
     * Properties of an Instrument.
     * @exports IInstrument
     * @interface IInstrument
     * @property {string|null} [instrumentId] Instrument instrumentId
     * @property {IAddress|null} [billingAddress] Instrument billingAddress
     * @property {ICreditCardInstrument|null} [creditCard] Instrument creditCard
     * @property {ICarrierBillingInstrument|null} [carrierBilling] Instrument carrierBilling
     * @property {IBillingAddressSpec|null} [billingAddressSpec] Instrument billingAddressSpec
     * @property {number|null} [instrumentFamily] Instrument instrumentFamily
     * @property {ICarrierBillingInstrumentStatus|null} [carrierBillingStatus] Instrument carrierBillingStatus
     * @property {string|null} [displayTitle] Instrument displayTitle
     * @property {ITopupInfo|null} [topupInfoDeprecated] Instrument topupInfoDeprecated
     * @property {number|null} [version] Instrument version
     * @property {IStoredValueInstrument|null} [storedValue] Instrument storedValue
     * @property {Array.<IDisabledInfo>|null} [disabledInfo] Instrument disabledInfo
     */

    /**
     * Constructs a new Instrument.
     * @exports Instrument
     * @classdesc Represents an Instrument.
     * @implements IInstrument
     * @constructor
     * @param {IInstrument=} [properties] Properties to set
     */
    function Instrument(properties) {
        this.disabledInfo = [];
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * Instrument instrumentId.
     * @member {string} instrumentId
     * @memberof Instrument
     * @instance
     */
    Instrument.prototype.instrumentId = "";

    /**
     * Instrument billingAddress.
     * @member {IAddress|null|undefined} billingAddress
     * @memberof Instrument
     * @instance
     */
    Instrument.prototype.billingAddress = null;

    /**
     * Instrument creditCard.
     * @member {ICreditCardInstrument|null|undefined} creditCard
     * @memberof Instrument
     * @instance
     */
    Instrument.prototype.creditCard = null;

    /**
     * Instrument carrierBilling.
     * @member {ICarrierBillingInstrument|null|undefined} carrierBilling
     * @memberof Instrument
     * @instance
     */
    Instrument.prototype.carrierBilling = null;

    /**
     * Instrument billingAddressSpec.
     * @member {IBillingAddressSpec|null|undefined} billingAddressSpec
     * @memberof Instrument
     * @instance
     */
    Instrument.prototype.billingAddressSpec = null;

    /**
     * Instrument instrumentFamily.
     * @member {number} instrumentFamily
     * @memberof Instrument
     * @instance
     */
    Instrument.prototype.instrumentFamily = 0;

    /**
     * Instrument carrierBillingStatus.
     * @member {ICarrierBillingInstrumentStatus|null|undefined} carrierBillingStatus
     * @memberof Instrument
     * @instance
     */
    Instrument.prototype.carrierBillingStatus = null;

    /**
     * Instrument displayTitle.
     * @member {string} displayTitle
     * @memberof Instrument
     * @instance
     */
    Instrument.prototype.displayTitle = "";

    /**
     * Instrument topupInfoDeprecated.
     * @member {ITopupInfo|null|undefined} topupInfoDeprecated
     * @memberof Instrument
     * @instance
     */
    Instrument.prototype.topupInfoDeprecated = null;

    /**
     * Instrument version.
     * @member {number} version
     * @memberof Instrument
     * @instance
     */
    Instrument.prototype.version = 0;

    /**
     * Instrument storedValue.
     * @member {IStoredValueInstrument|null|undefined} storedValue
     * @memberof Instrument
     * @instance
     */
    Instrument.prototype.storedValue = null;

    /**
     * Instrument disabledInfo.
     * @member {Array.<IDisabledInfo>} disabledInfo
     * @memberof Instrument
     * @instance
     */
    Instrument.prototype.disabledInfo = $util.emptyArray;

    /**
     * Creates a new Instrument instance using the specified properties.
     * @function create
     * @memberof Instrument
     * @static
     * @param {IInstrument=} [properties] Properties to set
     * @returns {Instrument} Instrument instance
     */
    Instrument.create = function create(properties) {
        return new Instrument(properties);
    };

    /**
     * Encodes the specified Instrument message. Does not implicitly {@link Instrument.verify|verify} messages.
     * @function encode
     * @memberof Instrument
     * @static
     * @param {IInstrument} message Instrument message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    Instrument.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.instrumentId != null && Object.hasOwnProperty.call(message, "instrumentId"))
            writer.uint32(/* id 1, wireType 2 =*/10).string(message.instrumentId);
        if (message.billingAddress != null && Object.hasOwnProperty.call(message, "billingAddress"))
            $root.Address.encode(message.billingAddress, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
        if (message.creditCard != null && Object.hasOwnProperty.call(message, "creditCard"))
            $root.CreditCardInstrument.encode(message.creditCard, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
        if (message.carrierBilling != null && Object.hasOwnProperty.call(message, "carrierBilling"))
            $root.CarrierBillingInstrument.encode(message.carrierBilling, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
        if (message.billingAddressSpec != null && Object.hasOwnProperty.call(message, "billingAddressSpec"))
            $root.BillingAddressSpec.encode(message.billingAddressSpec, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
        if (message.instrumentFamily != null && Object.hasOwnProperty.call(message, "instrumentFamily"))
            writer.uint32(/* id 6, wireType 0 =*/48).int32(message.instrumentFamily);
        if (message.carrierBillingStatus != null && Object.hasOwnProperty.call(message, "carrierBillingStatus"))
            $root.CarrierBillingInstrumentStatus.encode(message.carrierBillingStatus, writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
        if (message.displayTitle != null && Object.hasOwnProperty.call(message, "displayTitle"))
            writer.uint32(/* id 8, wireType 2 =*/66).string(message.displayTitle);
        if (message.topupInfoDeprecated != null && Object.hasOwnProperty.call(message, "topupInfoDeprecated"))
            $root.TopupInfo.encode(message.topupInfoDeprecated, writer.uint32(/* id 9, wireType 2 =*/74).fork()).ldelim();
        if (message.version != null && Object.hasOwnProperty.call(message, "version"))
            writer.uint32(/* id 10, wireType 0 =*/80).int32(message.version);
        if (message.storedValue != null && Object.hasOwnProperty.call(message, "storedValue"))
            $root.StoredValueInstrument.encode(message.storedValue, writer.uint32(/* id 11, wireType 2 =*/90).fork()).ldelim();
        if (message.disabledInfo != null && message.disabledInfo.length)
            for (var i = 0; i < message.disabledInfo.length; ++i)
                $root.DisabledInfo.encode(message.disabledInfo[i], writer.uint32(/* id 12, wireType 2 =*/98).fork()).ldelim();
        return writer;
    };

    /**
     * Encodes the specified Instrument message, length delimited. Does not implicitly {@link Instrument.verify|verify} messages.
     * @function encodeDelimited
     * @memberof Instrument
     * @static
     * @param {IInstrument} message Instrument message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    Instrument.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes an Instrument message from the specified reader or buffer.
     * @function decode
     * @memberof Instrument
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {Instrument} Instrument
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    Instrument.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Instrument();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.instrumentId = reader.string();
                break;
            case 2:
                message.billingAddress = $root.Address.decode(reader, reader.uint32());
                break;
            case 3:
                message.creditCard = $root.CreditCardInstrument.decode(reader, reader.uint32());
                break;
            case 4:
                message.carrierBilling = $root.CarrierBillingInstrument.decode(reader, reader.uint32());
                break;
            case 5:
                message.billingAddressSpec = $root.BillingAddressSpec.decode(reader, reader.uint32());
                break;
            case 6:
                message.instrumentFamily = reader.int32();
                break;
            case 7:
                message.carrierBillingStatus = $root.CarrierBillingInstrumentStatus.decode(reader, reader.uint32());
                break;
            case 8:
                message.displayTitle = reader.string();
                break;
            case 9:
                message.topupInfoDeprecated = $root.TopupInfo.decode(reader, reader.uint32());
                break;
            case 10:
                message.version = reader.int32();
                break;
            case 11:
                message.storedValue = $root.StoredValueInstrument.decode(reader, reader.uint32());
                break;
            case 12:
                if (!(message.disabledInfo && message.disabledInfo.length))
                    message.disabledInfo = [];
                message.disabledInfo.push($root.DisabledInfo.decode(reader, reader.uint32()));
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes an Instrument message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof Instrument
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {Instrument} Instrument
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    Instrument.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies an Instrument message.
     * @function verify
     * @memberof Instrument
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    Instrument.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.instrumentId != null && message.hasOwnProperty("instrumentId"))
            if (!$util.isString(message.instrumentId))
                return "instrumentId: string expected";
        if (message.billingAddress != null && message.hasOwnProperty("billingAddress")) {
            var error = $root.Address.verify(message.billingAddress);
            if (error)
                return "billingAddress." + error;
        }
        if (message.creditCard != null && message.hasOwnProperty("creditCard")) {
            var error = $root.CreditCardInstrument.verify(message.creditCard);
            if (error)
                return "creditCard." + error;
        }
        if (message.carrierBilling != null && message.hasOwnProperty("carrierBilling")) {
            var error = $root.CarrierBillingInstrument.verify(message.carrierBilling);
            if (error)
                return "carrierBilling." + error;
        }
        if (message.billingAddressSpec != null && message.hasOwnProperty("billingAddressSpec")) {
            var error = $root.BillingAddressSpec.verify(message.billingAddressSpec);
            if (error)
                return "billingAddressSpec." + error;
        }
        if (message.instrumentFamily != null && message.hasOwnProperty("instrumentFamily"))
            if (!$util.isInteger(message.instrumentFamily))
                return "instrumentFamily: integer expected";
        if (message.carrierBillingStatus != null && message.hasOwnProperty("carrierBillingStatus")) {
            var error = $root.CarrierBillingInstrumentStatus.verify(message.carrierBillingStatus);
            if (error)
                return "carrierBillingStatus." + error;
        }
        if (message.displayTitle != null && message.hasOwnProperty("displayTitle"))
            if (!$util.isString(message.displayTitle))
                return "displayTitle: string expected";
        if (message.topupInfoDeprecated != null && message.hasOwnProperty("topupInfoDeprecated")) {
            var error = $root.TopupInfo.verify(message.topupInfoDeprecated);
            if (error)
                return "topupInfoDeprecated." + error;
        }
        if (message.version != null && message.hasOwnProperty("version"))
            if (!$util.isInteger(message.version))
                return "version: integer expected";
        if (message.storedValue != null && message.hasOwnProperty("storedValue")) {
            var error = $root.StoredValueInstrument.verify(message.storedValue);
            if (error)
                return "storedValue." + error;
        }
        if (message.disabledInfo != null && message.hasOwnProperty("disabledInfo")) {
            if (!Array.isArray(message.disabledInfo))
                return "disabledInfo: array expected";
            for (var i = 0; i < message.disabledInfo.length; ++i) {
                var error = $root.DisabledInfo.verify(message.disabledInfo[i]);
                if (error)
                    return "disabledInfo." + error;
            }
        }
        return null;
    };

    /**
     * Creates an Instrument message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof Instrument
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {Instrument} Instrument
     */
    Instrument.fromObject = function fromObject(object) {
        if (object instanceof $root.Instrument)
            return object;
        var message = new $root.Instrument();
        if (object.instrumentId != null)
            message.instrumentId = String(object.instrumentId);
        if (object.billingAddress != null) {
            if (typeof object.billingAddress !== "object")
                throw TypeError(".Instrument.billingAddress: object expected");
            message.billingAddress = $root.Address.fromObject(object.billingAddress);
        }
        if (object.creditCard != null) {
            if (typeof object.creditCard !== "object")
                throw TypeError(".Instrument.creditCard: object expected");
            message.creditCard = $root.CreditCardInstrument.fromObject(object.creditCard);
        }
        if (object.carrierBilling != null) {
            if (typeof object.carrierBilling !== "object")
                throw TypeError(".Instrument.carrierBilling: object expected");
            message.carrierBilling = $root.CarrierBillingInstrument.fromObject(object.carrierBilling);
        }
        if (object.billingAddressSpec != null) {
            if (typeof object.billingAddressSpec !== "object")
                throw TypeError(".Instrument.billingAddressSpec: object expected");
            message.billingAddressSpec = $root.BillingAddressSpec.fromObject(object.billingAddressSpec);
        }
        if (object.instrumentFamily != null)
            message.instrumentFamily = object.instrumentFamily | 0;
        if (object.carrierBillingStatus != null) {
            if (typeof object.carrierBillingStatus !== "object")
                throw TypeError(".Instrument.carrierBillingStatus: object expected");
            message.carrierBillingStatus = $root.CarrierBillingInstrumentStatus.fromObject(object.carrierBillingStatus);
        }
        if (object.displayTitle != null)
            message.displayTitle = String(object.displayTitle);
        if (object.topupInfoDeprecated != null) {
            if (typeof object.topupInfoDeprecated !== "object")
                throw TypeError(".Instrument.topupInfoDeprecated: object expected");
            message.topupInfoDeprecated = $root.TopupInfo.fromObject(object.topupInfoDeprecated);
        }
        if (object.version != null)
            message.version = object.version | 0;
        if (object.storedValue != null) {
            if (typeof object.storedValue !== "object")
                throw TypeError(".Instrument.storedValue: object expected");
            message.storedValue = $root.StoredValueInstrument.fromObject(object.storedValue);
        }
        if (object.disabledInfo) {
            if (!Array.isArray(object.disabledInfo))
                throw TypeError(".Instrument.disabledInfo: array expected");
            message.disabledInfo = [];
            for (var i = 0; i < object.disabledInfo.length; ++i) {
                if (typeof object.disabledInfo[i] !== "object")
                    throw TypeError(".Instrument.disabledInfo: object expected");
                message.disabledInfo[i] = $root.DisabledInfo.fromObject(object.disabledInfo[i]);
            }
        }
        return message;
    };

    /**
     * Creates a plain object from an Instrument message. Also converts values to other types if specified.
     * @function toObject
     * @memberof Instrument
     * @static
     * @param {Instrument} message Instrument
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    Instrument.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        var object = {};
        if (options.arrays || options.defaults)
            object.disabledInfo = [];
        if (options.defaults) {
            object.instrumentId = "";
            object.billingAddress = null;
            object.creditCard = null;
            object.carrierBilling = null;
            object.billingAddressSpec = null;
            object.instrumentFamily = 0;
            object.carrierBillingStatus = null;
            object.displayTitle = "";
            object.topupInfoDeprecated = null;
            object.version = 0;
            object.storedValue = null;
        }
        if (message.instrumentId != null && message.hasOwnProperty("instrumentId"))
            object.instrumentId = message.instrumentId;
        if (message.billingAddress != null && message.hasOwnProperty("billingAddress"))
            object.billingAddress = $root.Address.toObject(message.billingAddress, options);
        if (message.creditCard != null && message.hasOwnProperty("creditCard"))
            object.creditCard = $root.CreditCardInstrument.toObject(message.creditCard, options);
        if (message.carrierBilling != null && message.hasOwnProperty("carrierBilling"))
            object.carrierBilling = $root.CarrierBillingInstrument.toObject(message.carrierBilling, options);
        if (message.billingAddressSpec != null && message.hasOwnProperty("billingAddressSpec"))
            object.billingAddressSpec = $root.BillingAddressSpec.toObject(message.billingAddressSpec, options);
        if (message.instrumentFamily != null && message.hasOwnProperty("instrumentFamily"))
            object.instrumentFamily = message.instrumentFamily;
        if (message.carrierBillingStatus != null && message.hasOwnProperty("carrierBillingStatus"))
            object.carrierBillingStatus = $root.CarrierBillingInstrumentStatus.toObject(message.carrierBillingStatus, options);
        if (message.displayTitle != null && message.hasOwnProperty("displayTitle"))
            object.displayTitle = message.displayTitle;
        if (message.topupInfoDeprecated != null && message.hasOwnProperty("topupInfoDeprecated"))
            object.topupInfoDeprecated = $root.TopupInfo.toObject(message.topupInfoDeprecated, options);
        if (message.version != null && message.hasOwnProperty("version"))
            object.version = message.version;
        if (message.storedValue != null && message.hasOwnProperty("storedValue"))
            object.storedValue = $root.StoredValueInstrument.toObject(message.storedValue, options);
        if (message.disabledInfo && message.disabledInfo.length) {
            object.disabledInfo = [];
            for (var j = 0; j < message.disabledInfo.length; ++j)
                object.disabledInfo[j] = $root.DisabledInfo.toObject(message.disabledInfo[j], options);
        }
        return object;
    };

    /**
     * Converts this Instrument to JSON.
     * @function toJSON
     * @memberof Instrument
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    Instrument.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return Instrument;
})();

$root.InstrumentSetupInfo = (function() {

    /**
     * Properties of an InstrumentSetupInfo.
     * @exports IInstrumentSetupInfo
     * @interface IInstrumentSetupInfo
     * @property {number|null} [instrumentFamily] InstrumentSetupInfo instrumentFamily
     * @property {boolean|null} [supported] InstrumentSetupInfo supported
     * @property {IAddressChallenge|null} [addressChallenge] InstrumentSetupInfo addressChallenge
     * @property {IMoney|null} [balance] InstrumentSetupInfo balance
     * @property {Array.<string>|null} [footerHtml] InstrumentSetupInfo footerHtml
     */

    /**
     * Constructs a new InstrumentSetupInfo.
     * @exports InstrumentSetupInfo
     * @classdesc Represents an InstrumentSetupInfo.
     * @implements IInstrumentSetupInfo
     * @constructor
     * @param {IInstrumentSetupInfo=} [properties] Properties to set
     */
    function InstrumentSetupInfo(properties) {
        this.footerHtml = [];
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * InstrumentSetupInfo instrumentFamily.
     * @member {number} instrumentFamily
     * @memberof InstrumentSetupInfo
     * @instance
     */
    InstrumentSetupInfo.prototype.instrumentFamily = 0;

    /**
     * InstrumentSetupInfo supported.
     * @member {boolean} supported
     * @memberof InstrumentSetupInfo
     * @instance
     */
    InstrumentSetupInfo.prototype.supported = false;

    /**
     * InstrumentSetupInfo addressChallenge.
     * @member {IAddressChallenge|null|undefined} addressChallenge
     * @memberof InstrumentSetupInfo
     * @instance
     */
    InstrumentSetupInfo.prototype.addressChallenge = null;

    /**
     * InstrumentSetupInfo balance.
     * @member {IMoney|null|undefined} balance
     * @memberof InstrumentSetupInfo
     * @instance
     */
    InstrumentSetupInfo.prototype.balance = null;

    /**
     * InstrumentSetupInfo footerHtml.
     * @member {Array.<string>} footerHtml
     * @memberof InstrumentSetupInfo
     * @instance
     */
    InstrumentSetupInfo.prototype.footerHtml = $util.emptyArray;

    /**
     * Creates a new InstrumentSetupInfo instance using the specified properties.
     * @function create
     * @memberof InstrumentSetupInfo
     * @static
     * @param {IInstrumentSetupInfo=} [properties] Properties to set
     * @returns {InstrumentSetupInfo} InstrumentSetupInfo instance
     */
    InstrumentSetupInfo.create = function create(properties) {
        return new InstrumentSetupInfo(properties);
    };

    /**
     * Encodes the specified InstrumentSetupInfo message. Does not implicitly {@link InstrumentSetupInfo.verify|verify} messages.
     * @function encode
     * @memberof InstrumentSetupInfo
     * @static
     * @param {IInstrumentSetupInfo} message InstrumentSetupInfo message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    InstrumentSetupInfo.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.instrumentFamily != null && Object.hasOwnProperty.call(message, "instrumentFamily"))
            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.instrumentFamily);
        if (message.supported != null && Object.hasOwnProperty.call(message, "supported"))
            writer.uint32(/* id 2, wireType 0 =*/16).bool(message.supported);
        if (message.addressChallenge != null && Object.hasOwnProperty.call(message, "addressChallenge"))
            $root.AddressChallenge.encode(message.addressChallenge, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
        if (message.balance != null && Object.hasOwnProperty.call(message, "balance"))
            $root.Money.encode(message.balance, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
        if (message.footerHtml != null && message.footerHtml.length)
            for (var i = 0; i < message.footerHtml.length; ++i)
                writer.uint32(/* id 5, wireType 2 =*/42).string(message.footerHtml[i]);
        return writer;
    };

    /**
     * Encodes the specified InstrumentSetupInfo message, length delimited. Does not implicitly {@link InstrumentSetupInfo.verify|verify} messages.
     * @function encodeDelimited
     * @memberof InstrumentSetupInfo
     * @static
     * @param {IInstrumentSetupInfo} message InstrumentSetupInfo message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    InstrumentSetupInfo.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes an InstrumentSetupInfo message from the specified reader or buffer.
     * @function decode
     * @memberof InstrumentSetupInfo
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {InstrumentSetupInfo} InstrumentSetupInfo
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    InstrumentSetupInfo.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.InstrumentSetupInfo();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.instrumentFamily = reader.int32();
                break;
            case 2:
                message.supported = reader.bool();
                break;
            case 3:
                message.addressChallenge = $root.AddressChallenge.decode(reader, reader.uint32());
                break;
            case 4:
                message.balance = $root.Money.decode(reader, reader.uint32());
                break;
            case 5:
                if (!(message.footerHtml && message.footerHtml.length))
                    message.footerHtml = [];
                message.footerHtml.push(reader.string());
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes an InstrumentSetupInfo message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof InstrumentSetupInfo
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {InstrumentSetupInfo} InstrumentSetupInfo
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    InstrumentSetupInfo.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies an InstrumentSetupInfo message.
     * @function verify
     * @memberof InstrumentSetupInfo
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    InstrumentSetupInfo.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.instrumentFamily != null && message.hasOwnProperty("instrumentFamily"))
            if (!$util.isInteger(message.instrumentFamily))
                return "instrumentFamily: integer expected";
        if (message.supported != null && message.hasOwnProperty("supported"))
            if (typeof message.supported !== "boolean")
                return "supported: boolean expected";
        if (message.addressChallenge != null && message.hasOwnProperty("addressChallenge")) {
            var error = $root.AddressChallenge.verify(message.addressChallenge);
            if (error)
                return "addressChallenge." + error;
        }
        if (message.balance != null && message.hasOwnProperty("balance")) {
            var error = $root.Money.verify(message.balance);
            if (error)
                return "balance." + error;
        }
        if (message.footerHtml != null && message.hasOwnProperty("footerHtml")) {
            if (!Array.isArray(message.footerHtml))
                return "footerHtml: array expected";
            for (var i = 0; i < message.footerHtml.length; ++i)
                if (!$util.isString(message.footerHtml[i]))
                    return "footerHtml: string[] expected";
        }
        return null;
    };

    /**
     * Creates an InstrumentSetupInfo message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof InstrumentSetupInfo
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {InstrumentSetupInfo} InstrumentSetupInfo
     */
    InstrumentSetupInfo.fromObject = function fromObject(object) {
        if (object instanceof $root.InstrumentSetupInfo)
            return object;
        var message = new $root.InstrumentSetupInfo();
        if (object.instrumentFamily != null)
            message.instrumentFamily = object.instrumentFamily | 0;
        if (object.supported != null)
            message.supported = Boolean(object.supported);
        if (object.addressChallenge != null) {
            if (typeof object.addressChallenge !== "object")
                throw TypeError(".InstrumentSetupInfo.addressChallenge: object expected");
            message.addressChallenge = $root.AddressChallenge.fromObject(object.addressChallenge);
        }
        if (object.balance != null) {
            if (typeof object.balance !== "object")
                throw TypeError(".InstrumentSetupInfo.balance: object expected");
            message.balance = $root.Money.fromObject(object.balance);
        }
        if (object.footerHtml) {
            if (!Array.isArray(object.footerHtml))
                throw TypeError(".InstrumentSetupInfo.footerHtml: array expected");
            message.footerHtml = [];
            for (var i = 0; i < object.footerHtml.length; ++i)
                message.footerHtml[i] = String(object.footerHtml[i]);
        }
        return message;
    };

    /**
     * Creates a plain object from an InstrumentSetupInfo message. Also converts values to other types if specified.
     * @function toObject
     * @memberof InstrumentSetupInfo
     * @static
     * @param {InstrumentSetupInfo} message InstrumentSetupInfo
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    InstrumentSetupInfo.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        var object = {};
        if (options.arrays || options.defaults)
            object.footerHtml = [];
        if (options.defaults) {
            object.instrumentFamily = 0;
            object.supported = false;
            object.addressChallenge = null;
            object.balance = null;
        }
        if (message.instrumentFamily != null && message.hasOwnProperty("instrumentFamily"))
            object.instrumentFamily = message.instrumentFamily;
        if (message.supported != null && message.hasOwnProperty("supported"))
            object.supported = message.supported;
        if (message.addressChallenge != null && message.hasOwnProperty("addressChallenge"))
            object.addressChallenge = $root.AddressChallenge.toObject(message.addressChallenge, options);
        if (message.balance != null && message.hasOwnProperty("balance"))
            object.balance = $root.Money.toObject(message.balance, options);
        if (message.footerHtml && message.footerHtml.length) {
            object.footerHtml = [];
            for (var j = 0; j < message.footerHtml.length; ++j)
                object.footerHtml[j] = message.footerHtml[j];
        }
        return object;
    };

    /**
     * Converts this InstrumentSetupInfo to JSON.
     * @function toJSON
     * @memberof InstrumentSetupInfo
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    InstrumentSetupInfo.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return InstrumentSetupInfo;
})();

$root.PasswordPrompt = (function() {

    /**
     * Properties of a PasswordPrompt.
     * @exports IPasswordPrompt
     * @interface IPasswordPrompt
     * @property {string|null} [prompt] PasswordPrompt prompt
     * @property {string|null} [forgotPasswordUrl] PasswordPrompt forgotPasswordUrl
     */

    /**
     * Constructs a new PasswordPrompt.
     * @exports PasswordPrompt
     * @classdesc Represents a PasswordPrompt.
     * @implements IPasswordPrompt
     * @constructor
     * @param {IPasswordPrompt=} [properties] Properties to set
     */
    function PasswordPrompt(properties) {
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * PasswordPrompt prompt.
     * @member {string} prompt
     * @memberof PasswordPrompt
     * @instance
     */
    PasswordPrompt.prototype.prompt = "";

    /**
     * PasswordPrompt forgotPasswordUrl.
     * @member {string} forgotPasswordUrl
     * @memberof PasswordPrompt
     * @instance
     */
    PasswordPrompt.prototype.forgotPasswordUrl = "";

    /**
     * Creates a new PasswordPrompt instance using the specified properties.
     * @function create
     * @memberof PasswordPrompt
     * @static
     * @param {IPasswordPrompt=} [properties] Properties to set
     * @returns {PasswordPrompt} PasswordPrompt instance
     */
    PasswordPrompt.create = function create(properties) {
        return new PasswordPrompt(properties);
    };

    /**
     * Encodes the specified PasswordPrompt message. Does not implicitly {@link PasswordPrompt.verify|verify} messages.
     * @function encode
     * @memberof PasswordPrompt
     * @static
     * @param {IPasswordPrompt} message PasswordPrompt message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    PasswordPrompt.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.prompt != null && Object.hasOwnProperty.call(message, "prompt"))
            writer.uint32(/* id 1, wireType 2 =*/10).string(message.prompt);
        if (message.forgotPasswordUrl != null && Object.hasOwnProperty.call(message, "forgotPasswordUrl"))
            writer.uint32(/* id 2, wireType 2 =*/18).string(message.forgotPasswordUrl);
        return writer;
    };

    /**
     * Encodes the specified PasswordPrompt message, length delimited. Does not implicitly {@link PasswordPrompt.verify|verify} messages.
     * @function encodeDelimited
     * @memberof PasswordPrompt
     * @static
     * @param {IPasswordPrompt} message PasswordPrompt message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    PasswordPrompt.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a PasswordPrompt message from the specified reader or buffer.
     * @function decode
     * @memberof PasswordPrompt
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {PasswordPrompt} PasswordPrompt
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    PasswordPrompt.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.PasswordPrompt();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.prompt = reader.string();
                break;
            case 2:
                message.forgotPasswordUrl = reader.string();
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a PasswordPrompt message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof PasswordPrompt
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {PasswordPrompt} PasswordPrompt
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    PasswordPrompt.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a PasswordPrompt message.
     * @function verify
     * @memberof PasswordPrompt
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    PasswordPrompt.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.prompt != null && message.hasOwnProperty("prompt"))
            if (!$util.isString(message.prompt))
                return "prompt: string expected";
        if (message.forgotPasswordUrl != null && message.hasOwnProperty("forgotPasswordUrl"))
            if (!$util.isString(message.forgotPasswordUrl))
                return "forgotPasswordUrl: string expected";
        return null;
    };

    /**
     * Creates a PasswordPrompt message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof PasswordPrompt
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {PasswordPrompt} PasswordPrompt
     */
    PasswordPrompt.fromObject = function fromObject(object) {
        if (object instanceof $root.PasswordPrompt)
            return object;
        var message = new $root.PasswordPrompt();
        if (object.prompt != null)
            message.prompt = String(object.prompt);
        if (object.forgotPasswordUrl != null)
            message.forgotPasswordUrl = String(object.forgotPasswordUrl);
        return message;
    };

    /**
     * Creates a plain object from a PasswordPrompt message. Also converts values to other types if specified.
     * @function toObject
     * @memberof PasswordPrompt
     * @static
     * @param {PasswordPrompt} message PasswordPrompt
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    PasswordPrompt.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        var object = {};
        if (options.defaults) {
            object.prompt = "";
            object.forgotPasswordUrl = "";
        }
        if (message.prompt != null && message.hasOwnProperty("prompt"))
            object.prompt = message.prompt;
        if (message.forgotPasswordUrl != null && message.hasOwnProperty("forgotPasswordUrl"))
            object.forgotPasswordUrl = message.forgotPasswordUrl;
        return object;
    };

    /**
     * Converts this PasswordPrompt to JSON.
     * @function toJSON
     * @memberof PasswordPrompt
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    PasswordPrompt.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return PasswordPrompt;
})();

$root.StoredValueInstrument = (function() {

    /**
     * Properties of a StoredValueInstrument.
     * @exports IStoredValueInstrument
     * @interface IStoredValueInstrument
     * @property {number|null} [type] StoredValueInstrument type
     * @property {IMoney|null} [balance] StoredValueInstrument balance
     * @property {ITopupInfo|null} [topupInfo] StoredValueInstrument topupInfo
     */

    /**
     * Constructs a new StoredValueInstrument.
     * @exports StoredValueInstrument
     * @classdesc Represents a StoredValueInstrument.
     * @implements IStoredValueInstrument
     * @constructor
     * @param {IStoredValueInstrument=} [properties] Properties to set
     */
    function StoredValueInstrument(properties) {
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * StoredValueInstrument type.
     * @member {number} type
     * @memberof StoredValueInstrument
     * @instance
     */
    StoredValueInstrument.prototype.type = 0;

    /**
     * StoredValueInstrument balance.
     * @member {IMoney|null|undefined} balance
     * @memberof StoredValueInstrument
     * @instance
     */
    StoredValueInstrument.prototype.balance = null;

    /**
     * StoredValueInstrument topupInfo.
     * @member {ITopupInfo|null|undefined} topupInfo
     * @memberof StoredValueInstrument
     * @instance
     */
    StoredValueInstrument.prototype.topupInfo = null;

    /**
     * Creates a new StoredValueInstrument instance using the specified properties.
     * @function create
     * @memberof StoredValueInstrument
     * @static
     * @param {IStoredValueInstrument=} [properties] Properties to set
     * @returns {StoredValueInstrument} StoredValueInstrument instance
     */
    StoredValueInstrument.create = function create(properties) {
        return new StoredValueInstrument(properties);
    };

    /**
     * Encodes the specified StoredValueInstrument message. Does not implicitly {@link StoredValueInstrument.verify|verify} messages.
     * @function encode
     * @memberof StoredValueInstrument
     * @static
     * @param {IStoredValueInstrument} message StoredValueInstrument message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    StoredValueInstrument.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.type != null && Object.hasOwnProperty.call(message, "type"))
            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.type);
        if (message.balance != null && Object.hasOwnProperty.call(message, "balance"))
            $root.Money.encode(message.balance, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
        if (message.topupInfo != null && Object.hasOwnProperty.call(message, "topupInfo"))
            $root.TopupInfo.encode(message.topupInfo, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
        return writer;
    };

    /**
     * Encodes the specified StoredValueInstrument message, length delimited. Does not implicitly {@link StoredValueInstrument.verify|verify} messages.
     * @function encodeDelimited
     * @memberof StoredValueInstrument
     * @static
     * @param {IStoredValueInstrument} message StoredValueInstrument message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    StoredValueInstrument.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a StoredValueInstrument message from the specified reader or buffer.
     * @function decode
     * @memberof StoredValueInstrument
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {StoredValueInstrument} StoredValueInstrument
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    StoredValueInstrument.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.StoredValueInstrument();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.type = reader.int32();
                break;
            case 2:
                message.balance = $root.Money.decode(reader, reader.uint32());
                break;
            case 3:
                message.topupInfo = $root.TopupInfo.decode(reader, reader.uint32());
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a StoredValueInstrument message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof StoredValueInstrument
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {StoredValueInstrument} StoredValueInstrument
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    StoredValueInstrument.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a StoredValueInstrument message.
     * @function verify
     * @memberof StoredValueInstrument
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    StoredValueInstrument.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.type != null && message.hasOwnProperty("type"))
            if (!$util.isInteger(message.type))
                return "type: integer expected";
        if (message.balance != null && message.hasOwnProperty("balance")) {
            var error = $root.Money.verify(message.balance);
            if (error)
                return "balance." + error;
        }
        if (message.topupInfo != null && message.hasOwnProperty("topupInfo")) {
            var error = $root.TopupInfo.verify(message.topupInfo);
            if (error)
                return "topupInfo." + error;
        }
        return null;
    };

    /**
     * Creates a StoredValueInstrument message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof StoredValueInstrument
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {StoredValueInstrument} StoredValueInstrument
     */
    StoredValueInstrument.fromObject = function fromObject(object) {
        if (object instanceof $root.StoredValueInstrument)
            return object;
        var message = new $root.StoredValueInstrument();
        if (object.type != null)
            message.type = object.type | 0;
        if (object.balance != null) {
            if (typeof object.balance !== "object")
                throw TypeError(".StoredValueInstrument.balance: object expected");
            message.balance = $root.Money.fromObject(object.balance);
        }
        if (object.topupInfo != null) {
            if (typeof object.topupInfo !== "object")
                throw TypeError(".StoredValueInstrument.topupInfo: object expected");
            message.topupInfo = $root.TopupInfo.fromObject(object.topupInfo);
        }
        return message;
    };

    /**
     * Creates a plain object from a StoredValueInstrument message. Also converts values to other types if specified.
     * @function toObject
     * @memberof StoredValueInstrument
     * @static
     * @param {StoredValueInstrument} message StoredValueInstrument
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    StoredValueInstrument.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        var object = {};
        if (options.defaults) {
            object.type = 0;
            object.balance = null;
            object.topupInfo = null;
        }
        if (message.type != null && message.hasOwnProperty("type"))
            object.type = message.type;
        if (message.balance != null && message.hasOwnProperty("balance"))
            object.balance = $root.Money.toObject(message.balance, options);
        if (message.topupInfo != null && message.hasOwnProperty("topupInfo"))
            object.topupInfo = $root.TopupInfo.toObject(message.topupInfo, options);
        return object;
    };

    /**
     * Converts this StoredValueInstrument to JSON.
     * @function toJSON
     * @memberof StoredValueInstrument
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    StoredValueInstrument.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return StoredValueInstrument;
})();

$root.TopupInfo = (function() {

    /**
     * Properties of a TopupInfo.
     * @exports ITopupInfo
     * @interface ITopupInfo
     * @property {string|null} [optionsContainerDocIdDeprecated] TopupInfo optionsContainerDocIdDeprecated
     * @property {string|null} [optionsListUrl] TopupInfo optionsListUrl
     * @property {string|null} [subtitle] TopupInfo subtitle
     * @property {IDocId|null} [optionsContainerDocId] TopupInfo optionsContainerDocId
     */

    /**
     * Constructs a new TopupInfo.
     * @exports TopupInfo
     * @classdesc Represents a TopupInfo.
     * @implements ITopupInfo
     * @constructor
     * @param {ITopupInfo=} [properties] Properties to set
     */
    function TopupInfo(properties) {
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * TopupInfo optionsContainerDocIdDeprecated.
     * @member {string} optionsContainerDocIdDeprecated
     * @memberof TopupInfo
     * @instance
     */
    TopupInfo.prototype.optionsContainerDocIdDeprecated = "";

    /**
     * TopupInfo optionsListUrl.
     * @member {string} optionsListUrl
     * @memberof TopupInfo
     * @instance
     */
    TopupInfo.prototype.optionsListUrl = "";

    /**
     * TopupInfo subtitle.
     * @member {string} subtitle
     * @memberof TopupInfo
     * @instance
     */
    TopupInfo.prototype.subtitle = "";

    /**
     * TopupInfo optionsContainerDocId.
     * @member {IDocId|null|undefined} optionsContainerDocId
     * @memberof TopupInfo
     * @instance
     */
    TopupInfo.prototype.optionsContainerDocId = null;

    /**
     * Creates a new TopupInfo instance using the specified properties.
     * @function create
     * @memberof TopupInfo
     * @static
     * @param {ITopupInfo=} [properties] Properties to set
     * @returns {TopupInfo} TopupInfo instance
     */
    TopupInfo.create = function create(properties) {
        return new TopupInfo(properties);
    };

    /**
     * Encodes the specified TopupInfo message. Does not implicitly {@link TopupInfo.verify|verify} messages.
     * @function encode
     * @memberof TopupInfo
     * @static
     * @param {ITopupInfo} message TopupInfo message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    TopupInfo.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.optionsContainerDocIdDeprecated != null && Object.hasOwnProperty.call(message, "optionsContainerDocIdDeprecated"))
            writer.uint32(/* id 1, wireType 2 =*/10).string(message.optionsContainerDocIdDeprecated);
        if (message.optionsListUrl != null && Object.hasOwnProperty.call(message, "optionsListUrl"))
            writer.uint32(/* id 2, wireType 2 =*/18).string(message.optionsListUrl);
        if (message.subtitle != null && Object.hasOwnProperty.call(message, "subtitle"))
            writer.uint32(/* id 3, wireType 2 =*/26).string(message.subtitle);
        if (message.optionsContainerDocId != null && Object.hasOwnProperty.call(message, "optionsContainerDocId"))
            $root.DocId.encode(message.optionsContainerDocId, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
        return writer;
    };

    /**
     * Encodes the specified TopupInfo message, length delimited. Does not implicitly {@link TopupInfo.verify|verify} messages.
     * @function encodeDelimited
     * @memberof TopupInfo
     * @static
     * @param {ITopupInfo} message TopupInfo message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    TopupInfo.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a TopupInfo message from the specified reader or buffer.
     * @function decode
     * @memberof TopupInfo
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {TopupInfo} TopupInfo
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    TopupInfo.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.TopupInfo();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.optionsContainerDocIdDeprecated = reader.string();
                break;
            case 2:
                message.optionsListUrl = reader.string();
                break;
            case 3:
                message.subtitle = reader.string();
                break;
            case 4:
                message.optionsContainerDocId = $root.DocId.decode(reader, reader.uint32());
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a TopupInfo message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof TopupInfo
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {TopupInfo} TopupInfo
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    TopupInfo.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a TopupInfo message.
     * @function verify
     * @memberof TopupInfo
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    TopupInfo.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.optionsContainerDocIdDeprecated != null && message.hasOwnProperty("optionsContainerDocIdDeprecated"))
            if (!$util.isString(message.optionsContainerDocIdDeprecated))
                return "optionsContainerDocIdDeprecated: string expected";
        if (message.optionsListUrl != null && message.hasOwnProperty("optionsListUrl"))
            if (!$util.isString(message.optionsListUrl))
                return "optionsListUrl: string expected";
        if (message.subtitle != null && message.hasOwnProperty("subtitle"))
            if (!$util.isString(message.subtitle))
                return "subtitle: string expected";
        if (message.optionsContainerDocId != null && message.hasOwnProperty("optionsContainerDocId")) {
            var error = $root.DocId.verify(message.optionsContainerDocId);
            if (error)
                return "optionsContainerDocId." + error;
        }
        return null;
    };

    /**
     * Creates a TopupInfo message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof TopupInfo
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {TopupInfo} TopupInfo
     */
    TopupInfo.fromObject = function fromObject(object) {
        if (object instanceof $root.TopupInfo)
            return object;
        var message = new $root.TopupInfo();
        if (object.optionsContainerDocIdDeprecated != null)
            message.optionsContainerDocIdDeprecated = String(object.optionsContainerDocIdDeprecated);
        if (object.optionsListUrl != null)
            message.optionsListUrl = String(object.optionsListUrl);
        if (object.subtitle != null)
            message.subtitle = String(object.subtitle);
        if (object.optionsContainerDocId != null) {
            if (typeof object.optionsContainerDocId !== "object")
                throw TypeError(".TopupInfo.optionsContainerDocId: object expected");
            message.optionsContainerDocId = $root.DocId.fromObject(object.optionsContainerDocId);
        }
        return message;
    };

    /**
     * Creates a plain object from a TopupInfo message. Also converts values to other types if specified.
     * @function toObject
     * @memberof TopupInfo
     * @static
     * @param {TopupInfo} message TopupInfo
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    TopupInfo.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        var object = {};
        if (options.defaults) {
            object.optionsContainerDocIdDeprecated = "";
            object.optionsListUrl = "";
            object.subtitle = "";
            object.optionsContainerDocId = null;
        }
        if (message.optionsContainerDocIdDeprecated != null && message.hasOwnProperty("optionsContainerDocIdDeprecated"))
            object.optionsContainerDocIdDeprecated = message.optionsContainerDocIdDeprecated;
        if (message.optionsListUrl != null && message.hasOwnProperty("optionsListUrl"))
            object.optionsListUrl = message.optionsListUrl;
        if (message.subtitle != null && message.hasOwnProperty("subtitle"))
            object.subtitle = message.subtitle;
        if (message.optionsContainerDocId != null && message.hasOwnProperty("optionsContainerDocId"))
            object.optionsContainerDocId = $root.DocId.toObject(message.optionsContainerDocId, options);
        return object;
    };

    /**
     * Converts this TopupInfo to JSON.
     * @function toJSON
     * @memberof TopupInfo
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    TopupInfo.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return TopupInfo;
})();

$root.ConsumePurchaseResponse = (function() {

    /**
     * Properties of a ConsumePurchaseResponse.
     * @exports IConsumePurchaseResponse
     * @interface IConsumePurchaseResponse
     * @property {ILibraryUpdate|null} [libraryUpdate] ConsumePurchaseResponse libraryUpdate
     * @property {number|null} [status] ConsumePurchaseResponse status
     */

    /**
     * Constructs a new ConsumePurchaseResponse.
     * @exports ConsumePurchaseResponse
     * @classdesc Represents a ConsumePurchaseResponse.
     * @implements IConsumePurchaseResponse
     * @constructor
     * @param {IConsumePurchaseResponse=} [properties] Properties to set
     */
    function ConsumePurchaseResponse(properties) {
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * ConsumePurchaseResponse libraryUpdate.
     * @member {ILibraryUpdate|null|undefined} libraryUpdate
     * @memberof ConsumePurchaseResponse
     * @instance
     */
    ConsumePurchaseResponse.prototype.libraryUpdate = null;

    /**
     * ConsumePurchaseResponse status.
     * @member {number} status
     * @memberof ConsumePurchaseResponse
     * @instance
     */
    ConsumePurchaseResponse.prototype.status = 0;

    /**
     * Creates a new ConsumePurchaseResponse instance using the specified properties.
     * @function create
     * @memberof ConsumePurchaseResponse
     * @static
     * @param {IConsumePurchaseResponse=} [properties] Properties to set
     * @returns {ConsumePurchaseResponse} ConsumePurchaseResponse instance
     */
    ConsumePurchaseResponse.create = function create(properties) {
        return new ConsumePurchaseResponse(properties);
    };

    /**
     * Encodes the specified ConsumePurchaseResponse message. Does not implicitly {@link ConsumePurchaseResponse.verify|verify} messages.
     * @function encode
     * @memberof ConsumePurchaseResponse
     * @static
     * @param {IConsumePurchaseResponse} message ConsumePurchaseResponse message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    ConsumePurchaseResponse.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.libraryUpdate != null && Object.hasOwnProperty.call(message, "libraryUpdate"))
            $root.LibraryUpdate.encode(message.libraryUpdate, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
        if (message.status != null && Object.hasOwnProperty.call(message, "status"))
            writer.uint32(/* id 2, wireType 0 =*/16).int32(message.status);
        return writer;
    };

    /**
     * Encodes the specified ConsumePurchaseResponse message, length delimited. Does not implicitly {@link ConsumePurchaseResponse.verify|verify} messages.
     * @function encodeDelimited
     * @memberof ConsumePurchaseResponse
     * @static
     * @param {IConsumePurchaseResponse} message ConsumePurchaseResponse message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    ConsumePurchaseResponse.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a ConsumePurchaseResponse message from the specified reader or buffer.
     * @function decode
     * @memberof ConsumePurchaseResponse
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {ConsumePurchaseResponse} ConsumePurchaseResponse
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    ConsumePurchaseResponse.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ConsumePurchaseResponse();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.libraryUpdate = $root.LibraryUpdate.decode(reader, reader.uint32());
                break;
            case 2:
                message.status = reader.int32();
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a ConsumePurchaseResponse message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof ConsumePurchaseResponse
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {ConsumePurchaseResponse} ConsumePurchaseResponse
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    ConsumePurchaseResponse.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a ConsumePurchaseResponse message.
     * @function verify
     * @memberof ConsumePurchaseResponse
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    ConsumePurchaseResponse.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.libraryUpdate != null && message.hasOwnProperty("libraryUpdate")) {
            var error = $root.LibraryUpdate.verify(message.libraryUpdate);
            if (error)
                return "libraryUpdate." + error;
        }
        if (message.status != null && message.hasOwnProperty("status"))
            if (!$util.isInteger(message.status))
                return "status: integer expected";
        return null;
    };

    /**
     * Creates a ConsumePurchaseResponse message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof ConsumePurchaseResponse
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {ConsumePurchaseResponse} ConsumePurchaseResponse
     */
    ConsumePurchaseResponse.fromObject = function fromObject(object) {
        if (object instanceof $root.ConsumePurchaseResponse)
            return object;
        var message = new $root.ConsumePurchaseResponse();
        if (object.libraryUpdate != null) {
            if (typeof object.libraryUpdate !== "object")
                throw TypeError(".ConsumePurchaseResponse.libraryUpdate: object expected");
            message.libraryUpdate = $root.LibraryUpdate.fromObject(object.libraryUpdate);
        }
        if (object.status != null)
            message.status = object.status | 0;
        return message;
    };

    /**
     * Creates a plain object from a ConsumePurchaseResponse message. Also converts values to other types if specified.
     * @function toObject
     * @memberof ConsumePurchaseResponse
     * @static
     * @param {ConsumePurchaseResponse} message ConsumePurchaseResponse
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    ConsumePurchaseResponse.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        var object = {};
        if (options.defaults) {
            object.libraryUpdate = null;
            object.status = 0;
        }
        if (message.libraryUpdate != null && message.hasOwnProperty("libraryUpdate"))
            object.libraryUpdate = $root.LibraryUpdate.toObject(message.libraryUpdate, options);
        if (message.status != null && message.hasOwnProperty("status"))
            object.status = message.status;
        return object;
    };

    /**
     * Converts this ConsumePurchaseResponse to JSON.
     * @function toJSON
     * @memberof ConsumePurchaseResponse
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    ConsumePurchaseResponse.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return ConsumePurchaseResponse;
})();

$root.ContainerMetadata = (function() {

    /**
     * Properties of a ContainerMetadata.
     * @exports IContainerMetadata
     * @interface IContainerMetadata
     * @property {string|null} [browseUrl] ContainerMetadata browseUrl
     * @property {string|null} [nextPageUrl] ContainerMetadata nextPageUrl
     * @property {number|null} [relevance] ContainerMetadata relevance
     * @property {number|Long|null} [estimatedResults] ContainerMetadata estimatedResults
     * @property {string|null} [analyticsCookie] ContainerMetadata analyticsCookie
     * @property {boolean|null} [ordered] ContainerMetadata ordered
     * @property {Array.<IContainerView>|null} [containerView] ContainerMetadata containerView
     * @property {IImage|null} [leftIcon] ContainerMetadata leftIcon
     */

    /**
     * Constructs a new ContainerMetadata.
     * @exports ContainerMetadata
     * @classdesc Represents a ContainerMetadata.
     * @implements IContainerMetadata
     * @constructor
     * @param {IContainerMetadata=} [properties] Properties to set
     */
    function ContainerMetadata(properties) {
        this.containerView = [];
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * ContainerMetadata browseUrl.
     * @member {string} browseUrl
     * @memberof ContainerMetadata
     * @instance
     */
    ContainerMetadata.prototype.browseUrl = "";

    /**
     * ContainerMetadata nextPageUrl.
     * @member {string} nextPageUrl
     * @memberof ContainerMetadata
     * @instance
     */
    ContainerMetadata.prototype.nextPageUrl = "";

    /**
     * ContainerMetadata relevance.
     * @member {number} relevance
     * @memberof ContainerMetadata
     * @instance
     */
    ContainerMetadata.prototype.relevance = 0;

    /**
     * ContainerMetadata estimatedResults.
     * @member {number|Long} estimatedResults
     * @memberof ContainerMetadata
     * @instance
     */
    ContainerMetadata.prototype.estimatedResults = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

    /**
     * ContainerMetadata analyticsCookie.
     * @member {string} analyticsCookie
     * @memberof ContainerMetadata
     * @instance
     */
    ContainerMetadata.prototype.analyticsCookie = "";

    /**
     * ContainerMetadata ordered.
     * @member {boolean} ordered
     * @memberof ContainerMetadata
     * @instance
     */
    ContainerMetadata.prototype.ordered = false;

    /**
     * ContainerMetadata containerView.
     * @member {Array.<IContainerView>} containerView
     * @memberof ContainerMetadata
     * @instance
     */
    ContainerMetadata.prototype.containerView = $util.emptyArray;

    /**
     * ContainerMetadata leftIcon.
     * @member {IImage|null|undefined} leftIcon
     * @memberof ContainerMetadata
     * @instance
     */
    ContainerMetadata.prototype.leftIcon = null;

    /**
     * Creates a new ContainerMetadata instance using the specified properties.
     * @function create
     * @memberof ContainerMetadata
     * @static
     * @param {IContainerMetadata=} [properties] Properties to set
     * @returns {ContainerMetadata} ContainerMetadata instance
     */
    ContainerMetadata.create = function create(properties) {
        return new ContainerMetadata(properties);
    };

    /**
     * Encodes the specified ContainerMetadata message. Does not implicitly {@link ContainerMetadata.verify|verify} messages.
     * @function encode
     * @memberof ContainerMetadata
     * @static
     * @param {IContainerMetadata} message ContainerMetadata message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    ContainerMetadata.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.browseUrl != null && Object.hasOwnProperty.call(message, "browseUrl"))
            writer.uint32(/* id 1, wireType 2 =*/10).string(message.browseUrl);
        if (message.nextPageUrl != null && Object.hasOwnProperty.call(message, "nextPageUrl"))
            writer.uint32(/* id 2, wireType 2 =*/18).string(message.nextPageUrl);
        if (message.relevance != null && Object.hasOwnProperty.call(message, "relevance"))
            writer.uint32(/* id 3, wireType 1 =*/25).double(message.relevance);
        if (message.estimatedResults != null && Object.hasOwnProperty.call(message, "estimatedResults"))
            writer.uint32(/* id 4, wireType 0 =*/32).int64(message.estimatedResults);
        if (message.analyticsCookie != null && Object.hasOwnProperty.call(message, "analyticsCookie"))
            writer.uint32(/* id 5, wireType 2 =*/42).string(message.analyticsCookie);
        if (message.ordered != null && Object.hasOwnProperty.call(message, "ordered"))
            writer.uint32(/* id 6, wireType 0 =*/48).bool(message.ordered);
        if (message.containerView != null && message.containerView.length)
            for (var i = 0; i < message.containerView.length; ++i)
                $root.ContainerView.encode(message.containerView[i], writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
        if (message.leftIcon != null && Object.hasOwnProperty.call(message, "leftIcon"))
            $root.Image.encode(message.leftIcon, writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();
        return writer;
    };

    /**
     * Encodes the specified ContainerMetadata message, length delimited. Does not implicitly {@link ContainerMetadata.verify|verify} messages.
     * @function encodeDelimited
     * @memberof ContainerMetadata
     * @static
     * @param {IContainerMetadata} message ContainerMetadata message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    ContainerMetadata.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a ContainerMetadata message from the specified reader or buffer.
     * @function decode
     * @memberof ContainerMetadata
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {ContainerMetadata} ContainerMetadata
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    ContainerMetadata.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ContainerMetadata();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.browseUrl = reader.string();
                break;
            case 2:
                message.nextPageUrl = reader.string();
                break;
            case 3:
                message.relevance = reader.double();
                break;
            case 4:
                message.estimatedResults = reader.int64();
                break;
            case 5:
                message.analyticsCookie = reader.string();
                break;
            case 6:
                message.ordered = reader.bool();
                break;
            case 7:
                if (!(message.containerView && message.containerView.length))
                    message.containerView = [];
                message.containerView.push($root.ContainerView.decode(reader, reader.uint32()));
                break;
            case 8:
                message.leftIcon = $root.Image.decode(reader, reader.uint32());
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a ContainerMetadata message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof ContainerMetadata
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {ContainerMetadata} ContainerMetadata
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    ContainerMetadata.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a ContainerMetadata message.
     * @function verify
     * @memberof ContainerMetadata
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    ContainerMetadata.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.browseUrl != null && message.hasOwnProperty("browseUrl"))
            if (!$util.isString(message.browseUrl))
                return "browseUrl: string expected";
        if (message.nextPageUrl != null && message.hasOwnProperty("nextPageUrl"))
            if (!$util.isString(message.nextPageUrl))
                return "nextPageUrl: string expected";
        if (message.relevance != null && message.hasOwnProperty("relevance"))
            if (typeof message.relevance !== "number")
                return "relevance: number expected";
        if (message.estimatedResults != null && message.hasOwnProperty("estimatedResults"))
            if (!$util.isInteger(message.estimatedResults) && !(message.estimatedResults && $util.isInteger(message.estimatedResults.low) && $util.isInteger(message.estimatedResults.high)))
                return "estimatedResults: integer|Long expected";
        if (message.analyticsCookie != null && message.hasOwnProperty("analyticsCookie"))
            if (!$util.isString(message.analyticsCookie))
                return "analyticsCookie: string expected";
        if (message.ordered != null && message.hasOwnProperty("ordered"))
            if (typeof message.ordered !== "boolean")
                return "ordered: boolean expected";
        if (message.containerView != null && message.hasOwnProperty("containerView")) {
            if (!Array.isArray(message.containerView))
                return "containerView: array expected";
            for (var i = 0; i < message.containerView.length; ++i) {
                var error = $root.ContainerView.verify(message.containerView[i]);
                if (error)
                    return "containerView." + error;
            }
        }
        if (message.leftIcon != null && message.hasOwnProperty("leftIcon")) {
            var error = $root.Image.verify(message.leftIcon);
            if (error)
                return "leftIcon." + error;
        }
        return null;
    };

    /**
     * Creates a ContainerMetadata message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof ContainerMetadata
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {ContainerMetadata} ContainerMetadata
     */
    ContainerMetadata.fromObject = function fromObject(object) {
        if (object instanceof $root.ContainerMetadata)
            return object;
        var message = new $root.ContainerMetadata();
        if (object.browseUrl != null)
            message.browseUrl = String(object.browseUrl);
        if (object.nextPageUrl != null)
            message.nextPageUrl = String(object.nextPageUrl);
        if (object.relevance != null)
            message.relevance = Number(object.relevance);
        if (object.estimatedResults != null)
            if ($util.Long)
                (message.estimatedResults = $util.Long.fromValue(object.estimatedResults)).unsigned = false;
            else if (typeof object.estimatedResults === "string")
                message.estimatedResults = parseInt(object.estimatedResults, 10);
            else if (typeof object.estimatedResults === "number")
                message.estimatedResults = object.estimatedResults;
            else if (typeof object.estimatedResults === "object")
                message.estimatedResults = new $util.LongBits(object.estimatedResults.low >>> 0, object.estimatedResults.high >>> 0).toNumber();
        if (object.analyticsCookie != null)
            message.analyticsCookie = String(object.analyticsCookie);
        if (object.ordered != null)
            message.ordered = Boolean(object.ordered);
        if (object.containerView) {
            if (!Array.isArray(object.containerView))
                throw TypeError(".ContainerMetadata.containerView: array expected");
            message.containerView = [];
            for (var i = 0; i < object.containerView.length; ++i) {
                if (typeof object.containerView[i] !== "object")
                    throw TypeError(".ContainerMetadata.containerView: object expected");
                message.containerView[i] = $root.ContainerView.fromObject(object.containerView[i]);
            }
        }
        if (object.leftIcon != null) {
            if (typeof object.leftIcon !== "object")
                throw TypeError(".ContainerMetadata.leftIcon: object expected");
            message.leftIcon = $root.Image.fromObject(object.leftIcon);
        }
        return message;
    };

    /**
     * Creates a plain object from a ContainerMetadata message. Also converts values to other types if specified.
     * @function toObject
     * @memberof ContainerMetadata
     * @static
     * @param {ContainerMetadata} message ContainerMetadata
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    ContainerMetadata.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        var object = {};
        if (options.arrays || options.defaults)
            object.containerView = [];
        if (options.defaults) {
            object.browseUrl = "";
            object.nextPageUrl = "";
            object.relevance = 0;
            if ($util.Long) {
                var long = new $util.Long(0, 0, false);
                object.estimatedResults = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
            } else
                object.estimatedResults = options.longs === String ? "0" : 0;
            object.analyticsCookie = "";
            object.ordered = false;
            object.leftIcon = null;
        }
        if (message.browseUrl != null && message.hasOwnProperty("browseUrl"))
            object.browseUrl = message.browseUrl;
        if (message.nextPageUrl != null && message.hasOwnProperty("nextPageUrl"))
            object.nextPageUrl = message.nextPageUrl;
        if (message.relevance != null && message.hasOwnProperty("relevance"))
            object.relevance = options.json && !isFinite(message.relevance) ? String(message.relevance) : message.relevance;
        if (message.estimatedResults != null && message.hasOwnProperty("estimatedResults"))
            if (typeof message.estimatedResults === "number")
                object.estimatedResults = options.longs === String ? String(message.estimatedResults) : message.estimatedResults;
            else
                object.estimatedResults = options.longs === String ? $util.Long.prototype.toString.call(message.estimatedResults) : options.longs === Number ? new $util.LongBits(message.estimatedResults.low >>> 0, message.estimatedResults.high >>> 0).toNumber() : message.estimatedResults;
        if (message.analyticsCookie != null && message.hasOwnProperty("analyticsCookie"))
            object.analyticsCookie = message.analyticsCookie;
        if (message.ordered != null && message.hasOwnProperty("ordered"))
            object.ordered = message.ordered;
        if (message.containerView && message.containerView.length) {
            object.containerView = [];
            for (var j = 0; j < message.containerView.length; ++j)
                object.containerView[j] = $root.ContainerView.toObject(message.containerView[j], options);
        }
        if (message.leftIcon != null && message.hasOwnProperty("leftIcon"))
            object.leftIcon = $root.Image.toObject(message.leftIcon, options);
        return object;
    };

    /**
     * Converts this ContainerMetadata to JSON.
     * @function toJSON
     * @memberof ContainerMetadata
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    ContainerMetadata.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return ContainerMetadata;
})();

$root.ContainerView = (function() {

    /**
     * Properties of a ContainerView.
     * @exports IContainerView
     * @interface IContainerView
     * @property {boolean|null} [selected] ContainerView selected
     * @property {string|null} [title] ContainerView title
     * @property {string|null} [listUrl] ContainerView listUrl
     * @property {Uint8Array|null} [serverLogsCookie] ContainerView serverLogsCookie
     */

    /**
     * Constructs a new ContainerView.
     * @exports ContainerView
     * @classdesc Represents a ContainerView.
     * @implements IContainerView
     * @constructor
     * @param {IContainerView=} [properties] Properties to set
     */
    function ContainerView(properties) {
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * ContainerView selected.
     * @member {boolean} selected
     * @memberof ContainerView
     * @instance
     */
    ContainerView.prototype.selected = false;

    /**
     * ContainerView title.
     * @member {string} title
     * @memberof ContainerView
     * @instance
     */
    ContainerView.prototype.title = "";

    /**
     * ContainerView listUrl.
     * @member {string} listUrl
     * @memberof ContainerView
     * @instance
     */
    ContainerView.prototype.listUrl = "";

    /**
     * ContainerView serverLogsCookie.
     * @member {Uint8Array} serverLogsCookie
     * @memberof ContainerView
     * @instance
     */
    ContainerView.prototype.serverLogsCookie = $util.newBuffer([]);

    /**
     * Creates a new ContainerView instance using the specified properties.
     * @function create
     * @memberof ContainerView
     * @static
     * @param {IContainerView=} [properties] Properties to set
     * @returns {ContainerView} ContainerView instance
     */
    ContainerView.create = function create(properties) {
        return new ContainerView(properties);
    };

    /**
     * Encodes the specified ContainerView message. Does not implicitly {@link ContainerView.verify|verify} messages.
     * @function encode
     * @memberof ContainerView
     * @static
     * @param {IContainerView} message ContainerView message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    ContainerView.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.selected != null && Object.hasOwnProperty.call(message, "selected"))
            writer.uint32(/* id 1, wireType 0 =*/8).bool(message.selected);
        if (message.title != null && Object.hasOwnProperty.call(message, "title"))
            writer.uint32(/* id 2, wireType 2 =*/18).string(message.title);
        if (message.listUrl != null && Object.hasOwnProperty.call(message, "listUrl"))
            writer.uint32(/* id 3, wireType 2 =*/26).string(message.listUrl);
        if (message.serverLogsCookie != null && Object.hasOwnProperty.call(message, "serverLogsCookie"))
            writer.uint32(/* id 4, wireType 2 =*/34).bytes(message.serverLogsCookie);
        return writer;
    };

    /**
     * Encodes the specified ContainerView message, length delimited. Does not implicitly {@link ContainerView.verify|verify} messages.
     * @function encodeDelimited
     * @memberof ContainerView
     * @static
     * @param {IContainerView} message ContainerView message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    ContainerView.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a ContainerView message from the specified reader or buffer.
     * @function decode
     * @memberof ContainerView
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {ContainerView} ContainerView
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    ContainerView.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ContainerView();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.selected = reader.bool();
                break;
            case 2:
                message.title = reader.string();
                break;
            case 3:
                message.listUrl = reader.string();
                break;
            case 4:
                message.serverLogsCookie = reader.bytes();
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a ContainerView message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof ContainerView
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {ContainerView} ContainerView
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    ContainerView.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a ContainerView message.
     * @function verify
     * @memberof ContainerView
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    ContainerView.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.selected != null && message.hasOwnProperty("selected"))
            if (typeof message.selected !== "boolean")
                return "selected: boolean expected";
        if (message.title != null && message.hasOwnProperty("title"))
            if (!$util.isString(message.title))
                return "title: string expected";
        if (message.listUrl != null && message.hasOwnProperty("listUrl"))
            if (!$util.isString(message.listUrl))
                return "listUrl: string expected";
        if (message.serverLogsCookie != null && message.hasOwnProperty("serverLogsCookie"))
            if (!(message.serverLogsCookie && typeof message.serverLogsCookie.length === "number" || $util.isString(message.serverLogsCookie)))
                return "serverLogsCookie: buffer expected";
        return null;
    };

    /**
     * Creates a ContainerView message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof ContainerView
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {ContainerView} ContainerView
     */
    ContainerView.fromObject = function fromObject(object) {
        if (object instanceof $root.ContainerView)
            return object;
        var message = new $root.ContainerView();
        if (object.selected != null)
            message.selected = Boolean(object.selected);
        if (object.title != null)
            message.title = String(object.title);
        if (object.listUrl != null)
            message.listUrl = String(object.listUrl);
        if (object.serverLogsCookie != null)
            if (typeof object.serverLogsCookie === "string")
                $util.base64.decode(object.serverLogsCookie, message.serverLogsCookie = $util.newBuffer($util.base64.length(object.serverLogsCookie)), 0);
            else if (object.serverLogsCookie.length)
                message.serverLogsCookie = object.serverLogsCookie;
        return message;
    };

    /**
     * Creates a plain object from a ContainerView message. Also converts values to other types if specified.
     * @function toObject
     * @memberof ContainerView
     * @static
     * @param {ContainerView} message ContainerView
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    ContainerView.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        var object = {};
        if (options.defaults) {
            object.selected = false;
            object.title = "";
            object.listUrl = "";
            if (options.bytes === String)
                object.serverLogsCookie = "";
            else {
                object.serverLogsCookie = [];
                if (options.bytes !== Array)
                    object.serverLogsCookie = $util.newBuffer(object.serverLogsCookie);
            }
        }
        if (message.selected != null && message.hasOwnProperty("selected"))
            object.selected = message.selected;
        if (message.title != null && message.hasOwnProperty("title"))
            object.title = message.title;
        if (message.listUrl != null && message.hasOwnProperty("listUrl"))
            object.listUrl = message.listUrl;
        if (message.serverLogsCookie != null && message.hasOwnProperty("serverLogsCookie"))
            object.serverLogsCookie = options.bytes === String ? $util.base64.encode(message.serverLogsCookie, 0, message.serverLogsCookie.length) : options.bytes === Array ? Array.prototype.slice.call(message.serverLogsCookie) : message.serverLogsCookie;
        return object;
    };

    /**
     * Converts this ContainerView to JSON.
     * @function toJSON
     * @memberof ContainerView
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    ContainerView.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return ContainerView;
})();

$root.FlagContentResponse = (function() {

    /**
     * Properties of a FlagContentResponse.
     * @exports IFlagContentResponse
     * @interface IFlagContentResponse
     */

    /**
     * Constructs a new FlagContentResponse.
     * @exports FlagContentResponse
     * @classdesc Represents a FlagContentResponse.
     * @implements IFlagContentResponse
     * @constructor
     * @param {IFlagContentResponse=} [properties] Properties to set
     */
    function FlagContentResponse(properties) {
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * Creates a new FlagContentResponse instance using the specified properties.
     * @function create
     * @memberof FlagContentResponse
     * @static
     * @param {IFlagContentResponse=} [properties] Properties to set
     * @returns {FlagContentResponse} FlagContentResponse instance
     */
    FlagContentResponse.create = function create(properties) {
        return new FlagContentResponse(properties);
    };

    /**
     * Encodes the specified FlagContentResponse message. Does not implicitly {@link FlagContentResponse.verify|verify} messages.
     * @function encode
     * @memberof FlagContentResponse
     * @static
     * @param {IFlagContentResponse} message FlagContentResponse message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    FlagContentResponse.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        return writer;
    };

    /**
     * Encodes the specified FlagContentResponse message, length delimited. Does not implicitly {@link FlagContentResponse.verify|verify} messages.
     * @function encodeDelimited
     * @memberof FlagContentResponse
     * @static
     * @param {IFlagContentResponse} message FlagContentResponse message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    FlagContentResponse.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a FlagContentResponse message from the specified reader or buffer.
     * @function decode
     * @memberof FlagContentResponse
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {FlagContentResponse} FlagContentResponse
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    FlagContentResponse.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.FlagContentResponse();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a FlagContentResponse message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof FlagContentResponse
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {FlagContentResponse} FlagContentResponse
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    FlagContentResponse.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a FlagContentResponse message.
     * @function verify
     * @memberof FlagContentResponse
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    FlagContentResponse.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        return null;
    };

    /**
     * Creates a FlagContentResponse message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof FlagContentResponse
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {FlagContentResponse} FlagContentResponse
     */
    FlagContentResponse.fromObject = function fromObject(object) {
        if (object instanceof $root.FlagContentResponse)
            return object;
        return new $root.FlagContentResponse();
    };

    /**
     * Creates a plain object from a FlagContentResponse message. Also converts values to other types if specified.
     * @function toObject
     * @memberof FlagContentResponse
     * @static
     * @param {FlagContentResponse} message FlagContentResponse
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    FlagContentResponse.toObject = function toObject() {
        return {};
    };

    /**
     * Converts this FlagContentResponse to JSON.
     * @function toJSON
     * @memberof FlagContentResponse
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    FlagContentResponse.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return FlagContentResponse;
})();

$root.ClientDownloadRequest = (function() {

    /**
     * Properties of a ClientDownloadRequest.
     * @exports IClientDownloadRequest
     * @interface IClientDownloadRequest
     * @property {string|null} [url] ClientDownloadRequest url
     * @property {ClientDownloadRequest.IDigests|null} [digests] ClientDownloadRequest digests
     * @property {number|Long|null} [length] ClientDownloadRequest length
     * @property {Array.<ClientDownloadRequest.IResource>|null} [resources] ClientDownloadRequest resources
     * @property {ClientDownloadRequest.ISignatureInfo|null} [signature] ClientDownloadRequest signature
     * @property {boolean|null} [userInitiated] ClientDownloadRequest userInitiated
     * @property {Array.<string>|null} [clientAsn] ClientDownloadRequest clientAsn
     * @property {string|null} [fileBasename] ClientDownloadRequest fileBasename
     * @property {number|null} [downloadType] ClientDownloadRequest downloadType
     * @property {string|null} [locale] ClientDownloadRequest locale
     * @property {ClientDownloadRequest.IApkInfo|null} [apkInfo] ClientDownloadRequest apkInfo
     * @property {number|Long|null} [androidId] ClientDownloadRequest androidId
     * @property {Array.<string>|null} [originatingPackages] ClientDownloadRequest originatingPackages
     * @property {ClientDownloadRequest.ISignatureInfo|null} [originatingSignature] ClientDownloadRequest originatingSignature
     */

    /**
     * Constructs a new ClientDownloadRequest.
     * @exports ClientDownloadRequest
     * @classdesc Represents a ClientDownloadRequest.
     * @implements IClientDownloadRequest
     * @constructor
     * @param {IClientDownloadRequest=} [properties] Properties to set
     */
    function ClientDownloadRequest(properties) {
        this.resources = [];
        this.clientAsn = [];
        this.originatingPackages = [];
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * ClientDownloadRequest url.
     * @member {string} url
     * @memberof ClientDownloadRequest
     * @instance
     */
    ClientDownloadRequest.prototype.url = "";

    /**
     * ClientDownloadRequest digests.
     * @member {ClientDownloadRequest.IDigests|null|undefined} digests
     * @memberof ClientDownloadRequest
     * @instance
     */
    ClientDownloadRequest.prototype.digests = null;

    /**
     * ClientDownloadRequest length.
     * @member {number|Long} length
     * @memberof ClientDownloadRequest
     * @instance
     */
    ClientDownloadRequest.prototype.length = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

    /**
     * ClientDownloadRequest resources.
     * @member {Array.<ClientDownloadRequest.IResource>} resources
     * @memberof ClientDownloadRequest
     * @instance
     */
    ClientDownloadRequest.prototype.resources = $util.emptyArray;

    /**
     * ClientDownloadRequest signature.
     * @member {ClientDownloadRequest.ISignatureInfo|null|undefined} signature
     * @memberof ClientDownloadRequest
     * @instance
     */
    ClientDownloadRequest.prototype.signature = null;

    /**
     * ClientDownloadRequest userInitiated.
     * @member {boolean} userInitiated
     * @memberof ClientDownloadRequest
     * @instance
     */
    ClientDownloadRequest.prototype.userInitiated = false;

    /**
     * ClientDownloadRequest clientAsn.
     * @member {Array.<string>} clientAsn
     * @memberof ClientDownloadRequest
     * @instance
     */
    ClientDownloadRequest.prototype.clientAsn = $util.emptyArray;

    /**
     * ClientDownloadRequest fileBasename.
     * @member {string} fileBasename
     * @memberof ClientDownloadRequest
     * @instance
     */
    ClientDownloadRequest.prototype.fileBasename = "";

    /**
     * ClientDownloadRequest downloadType.
     * @member {number} downloadType
     * @memberof ClientDownloadRequest
     * @instance
     */
    ClientDownloadRequest.prototype.downloadType = 0;

    /**
     * ClientDownloadRequest locale.
     * @member {string} locale
     * @memberof ClientDownloadRequest
     * @instance
     */
    ClientDownloadRequest.prototype.locale = "";

    /**
     * ClientDownloadRequest apkInfo.
     * @member {ClientDownloadRequest.IApkInfo|null|undefined} apkInfo
     * @memberof ClientDownloadRequest
     * @instance
     */
    ClientDownloadRequest.prototype.apkInfo = null;

    /**
     * ClientDownloadRequest androidId.
     * @member {number|Long} androidId
     * @memberof ClientDownloadRequest
     * @instance
     */
    ClientDownloadRequest.prototype.androidId = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

    /**
     * ClientDownloadRequest originatingPackages.
     * @member {Array.<string>} originatingPackages
     * @memberof ClientDownloadRequest
     * @instance
     */
    ClientDownloadRequest.prototype.originatingPackages = $util.emptyArray;

    /**
     * ClientDownloadRequest originatingSignature.
     * @member {ClientDownloadRequest.ISignatureInfo|null|undefined} originatingSignature
     * @memberof ClientDownloadRequest
     * @instance
     */
    ClientDownloadRequest.prototype.originatingSignature = null;

    /**
     * Creates a new ClientDownloadRequest instance using the specified properties.
     * @function create
     * @memberof ClientDownloadRequest
     * @static
     * @param {IClientDownloadRequest=} [properties] Properties to set
     * @returns {ClientDownloadRequest} ClientDownloadRequest instance
     */
    ClientDownloadRequest.create = function create(properties) {
        return new ClientDownloadRequest(properties);
    };

    /**
     * Encodes the specified ClientDownloadRequest message. Does not implicitly {@link ClientDownloadRequest.verify|verify} messages.
     * @function encode
     * @memberof ClientDownloadRequest
     * @static
     * @param {IClientDownloadRequest} message ClientDownloadRequest message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    ClientDownloadRequest.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.url != null && Object.hasOwnProperty.call(message, "url"))
            writer.uint32(/* id 1, wireType 2 =*/10).string(message.url);
        if (message.digests != null && Object.hasOwnProperty.call(message, "digests"))
            $root.ClientDownloadRequest.Digests.encode(message.digests, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
        if (message.length != null && Object.hasOwnProperty.call(message, "length"))
            writer.uint32(/* id 3, wireType 0 =*/24).int64(message.length);
        if (message.resources != null && message.resources.length)
            for (var i = 0; i < message.resources.length; ++i)
                $root.ClientDownloadRequest.Resource.encode(message.resources[i], writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
        if (message.signature != null && Object.hasOwnProperty.call(message, "signature"))
            $root.ClientDownloadRequest.SignatureInfo.encode(message.signature, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
        if (message.userInitiated != null && Object.hasOwnProperty.call(message, "userInitiated"))
            writer.uint32(/* id 6, wireType 0 =*/48).bool(message.userInitiated);
        if (message.clientAsn != null && message.clientAsn.length)
            for (var i = 0; i < message.clientAsn.length; ++i)
                writer.uint32(/* id 8, wireType 2 =*/66).string(message.clientAsn[i]);
        if (message.fileBasename != null && Object.hasOwnProperty.call(message, "fileBasename"))
            writer.uint32(/* id 9, wireType 2 =*/74).string(message.fileBasename);
        if (message.downloadType != null && Object.hasOwnProperty.call(message, "downloadType"))
            writer.uint32(/* id 10, wireType 0 =*/80).int32(message.downloadType);
        if (message.locale != null && Object.hasOwnProperty.call(message, "locale"))
            writer.uint32(/* id 11, wireType 2 =*/90).string(message.locale);
        if (message.apkInfo != null && Object.hasOwnProperty.call(message, "apkInfo"))
            $root.ClientDownloadRequest.ApkInfo.encode(message.apkInfo, writer.uint32(/* id 12, wireType 2 =*/98).fork()).ldelim();
        if (message.androidId != null && Object.hasOwnProperty.call(message, "androidId"))
            writer.uint32(/* id 13, wireType 1 =*/105).fixed64(message.androidId);
        if (message.originatingPackages != null && message.originatingPackages.length)
            for (var i = 0; i < message.originatingPackages.length; ++i)
                writer.uint32(/* id 15, wireType 2 =*/122).string(message.originatingPackages[i]);
        if (message.originatingSignature != null && Object.hasOwnProperty.call(message, "originatingSignature"))
            $root.ClientDownloadRequest.SignatureInfo.encode(message.originatingSignature, writer.uint32(/* id 17, wireType 2 =*/138).fork()).ldelim();
        return writer;
    };

    /**
     * Encodes the specified ClientDownloadRequest message, length delimited. Does not implicitly {@link ClientDownloadRequest.verify|verify} messages.
     * @function encodeDelimited
     * @memberof ClientDownloadRequest
     * @static
     * @param {IClientDownloadRequest} message ClientDownloadRequest message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    ClientDownloadRequest.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a ClientDownloadRequest message from the specified reader or buffer.
     * @function decode
     * @memberof ClientDownloadRequest
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {ClientDownloadRequest} ClientDownloadRequest
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    ClientDownloadRequest.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ClientDownloadRequest();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.url = reader.string();
                break;
            case 2:
                message.digests = $root.ClientDownloadRequest.Digests.decode(reader, reader.uint32());
                break;
            case 3:
                message.length = reader.int64();
                break;
            case 4:
                if (!(message.resources && message.resources.length))
                    message.resources = [];
                message.resources.push($root.ClientDownloadRequest.Resource.decode(reader, reader.uint32()));
                break;
            case 5:
                message.signature = $root.ClientDownloadRequest.SignatureInfo.decode(reader, reader.uint32());
                break;
            case 6:
                message.userInitiated = reader.bool();
                break;
            case 8:
                if (!(message.clientAsn && message.clientAsn.length))
                    message.clientAsn = [];
                message.clientAsn.push(reader.string());
                break;
            case 9:
                message.fileBasename = reader.string();
                break;
            case 10:
                message.downloadType = reader.int32();
                break;
            case 11:
                message.locale = reader.string();
                break;
            case 12:
                message.apkInfo = $root.ClientDownloadRequest.ApkInfo.decode(reader, reader.uint32());
                break;
            case 13:
                message.androidId = reader.fixed64();
                break;
            case 15:
                if (!(message.originatingPackages && message.originatingPackages.length))
                    message.originatingPackages = [];
                message.originatingPackages.push(reader.string());
                break;
            case 17:
                message.originatingSignature = $root.ClientDownloadRequest.SignatureInfo.decode(reader, reader.uint32());
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a ClientDownloadRequest message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof ClientDownloadRequest
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {ClientDownloadRequest} ClientDownloadRequest
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    ClientDownloadRequest.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a ClientDownloadRequest message.
     * @function verify
     * @memberof ClientDownloadRequest
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    ClientDownloadRequest.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.url != null && message.hasOwnProperty("url"))
            if (!$util.isString(message.url))
                return "url: string expected";
        if (message.digests != null && message.hasOwnProperty("digests")) {
            var error = $root.ClientDownloadRequest.Digests.verify(message.digests);
            if (error)
                return "digests." + error;
        }
        if (message.length != null && message.hasOwnProperty("length"))
            if (!$util.isInteger(message.length) && !(message.length && $util.isInteger(message.length.low) && $util.isInteger(message.length.high)))
                return "length: integer|Long expected";
        if (message.resources != null && message.hasOwnProperty("resources")) {
            if (!Array.isArray(message.resources))
                return "resources: array expected";
            for (var i = 0; i < message.resources.length; ++i) {
                var error = $root.ClientDownloadRequest.Resource.verify(message.resources[i]);
                if (error)
                    return "resources." + error;
            }
        }
        if (message.signature != null && message.hasOwnProperty("signature")) {
            var error = $root.ClientDownloadRequest.SignatureInfo.verify(message.signature);
            if (error)
                return "signature." + error;
        }
        if (message.userInitiated != null && message.hasOwnProperty("userInitiated"))
            if (typeof message.userInitiated !== "boolean")
                return "userInitiated: boolean expected";
        if (message.clientAsn != null && message.hasOwnProperty("clientAsn")) {
            if (!Array.isArray(message.clientAsn))
                return "clientAsn: array expected";
            for (var i = 0; i < message.clientAsn.length; ++i)
                if (!$util.isString(message.clientAsn[i]))
                    return "clientAsn: string[] expected";
        }
        if (message.fileBasename != null && message.hasOwnProperty("fileBasename"))
            if (!$util.isString(message.fileBasename))
                return "fileBasename: string expected";
        if (message.downloadType != null && message.hasOwnProperty("downloadType"))
            if (!$util.isInteger(message.downloadType))
                return "downloadType: integer expected";
        if (message.locale != null && message.hasOwnProperty("locale"))
            if (!$util.isString(message.locale))
                return "locale: string expected";
        if (message.apkInfo != null && message.hasOwnProperty("apkInfo")) {
            var error = $root.ClientDownloadRequest.ApkInfo.verify(message.apkInfo);
            if (error)
                return "apkInfo." + error;
        }
        if (message.androidId != null && message.hasOwnProperty("androidId"))
            if (!$util.isInteger(message.androidId) && !(message.androidId && $util.isInteger(message.androidId.low) && $util.isInteger(message.androidId.high)))
                return "androidId: integer|Long expected";
        if (message.originatingPackages != null && message.hasOwnProperty("originatingPackages")) {
            if (!Array.isArray(message.originatingPackages))
                return "originatingPackages: array expected";
            for (var i = 0; i < message.originatingPackages.length; ++i)
                if (!$util.isString(message.originatingPackages[i]))
                    return "originatingPackages: string[] expected";
        }
        if (message.originatingSignature != null && message.hasOwnProperty("originatingSignature")) {
            var error = $root.ClientDownloadRequest.SignatureInfo.verify(message.originatingSignature);
            if (error)
                return "originatingSignature." + error;
        }
        return null;
    };

    /**
     * Creates a ClientDownloadRequest message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof ClientDownloadRequest
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {ClientDownloadRequest} ClientDownloadRequest
     */
    ClientDownloadRequest.fromObject = function fromObject(object) {
        if (object instanceof $root.ClientDownloadRequest)
            return object;
        var message = new $root.ClientDownloadRequest();
        if (object.url != null)
            message.url = String(object.url);
        if (object.digests != null) {
            if (typeof object.digests !== "object")
                throw TypeError(".ClientDownloadRequest.digests: object expected");
            message.digests = $root.ClientDownloadRequest.Digests.fromObject(object.digests);
        }
        if (object.length != null)
            if ($util.Long)
                (message.length = $util.Long.fromValue(object.length)).unsigned = false;
            else if (typeof object.length === "string")
                message.length = parseInt(object.length, 10);
            else if (typeof object.length === "number")
                message.length = object.length;
            else if (typeof object.length === "object")
                message.length = new $util.LongBits(object.length.low >>> 0, object.length.high >>> 0).toNumber();
        if (object.resources) {
            if (!Array.isArray(object.resources))
                throw TypeError(".ClientDownloadRequest.resources: array expected");
            message.resources = [];
            for (var i = 0; i < object.resources.length; ++i) {
                if (typeof object.resources[i] !== "object")
                    throw TypeError(".ClientDownloadRequest.resources: object expected");
                message.resources[i] = $root.ClientDownloadRequest.Resource.fromObject(object.resources[i]);
            }
        }
        if (object.signature != null) {
            if (typeof object.signature !== "object")
                throw TypeError(".ClientDownloadRequest.signature: object expected");
            message.signature = $root.ClientDownloadRequest.SignatureInfo.fromObject(object.signature);
        }
        if (object.userInitiated != null)
            message.userInitiated = Boolean(object.userInitiated);
        if (object.clientAsn) {
            if (!Array.isArray(object.clientAsn))
                throw TypeError(".ClientDownloadRequest.clientAsn: array expected");
            message.clientAsn = [];
            for (var i = 0; i < object.clientAsn.length; ++i)
                message.clientAsn[i] = String(object.clientAsn[i]);
        }
        if (object.fileBasename != null)
            message.fileBasename = String(object.fileBasename);
        if (object.downloadType != null)
            message.downloadType = object.downloadType | 0;
        if (object.locale != null)
            message.locale = String(object.locale);
        if (object.apkInfo != null) {
            if (typeof object.apkInfo !== "object")
                throw TypeError(".ClientDownloadRequest.apkInfo: object expected");
            message.apkInfo = $root.ClientDownloadRequest.ApkInfo.fromObject(object.apkInfo);
        }
        if (object.androidId != null)
            if ($util.Long)
                (message.androidId = $util.Long.fromValue(object.androidId)).unsigned = false;
            else if (typeof object.androidId === "string")
                message.androidId = parseInt(object.androidId, 10);
            else if (typeof object.androidId === "number")
                message.androidId = object.androidId;
            else if (typeof object.androidId === "object")
                message.androidId = new $util.LongBits(object.androidId.low >>> 0, object.androidId.high >>> 0).toNumber();
        if (object.originatingPackages) {
            if (!Array.isArray(object.originatingPackages))
                throw TypeError(".ClientDownloadRequest.originatingPackages: array expected");
            message.originatingPackages = [];
            for (var i = 0; i < object.originatingPackages.length; ++i)
                message.originatingPackages[i] = String(object.originatingPackages[i]);
        }
        if (object.originatingSignature != null) {
            if (typeof object.originatingSignature !== "object")
                throw TypeError(".ClientDownloadRequest.originatingSignature: object expected");
            message.originatingSignature = $root.ClientDownloadRequest.SignatureInfo.fromObject(object.originatingSignature);
        }
        return message;
    };

    /**
     * Creates a plain object from a ClientDownloadRequest message. Also converts values to other types if specified.
     * @function toObject
     * @memberof ClientDownloadRequest
     * @static
     * @param {ClientDownloadRequest} message ClientDownloadRequest
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    ClientDownloadRequest.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        var object = {};
        if (options.arrays || options.defaults) {
            object.resources = [];
            object.clientAsn = [];
            object.originatingPackages = [];
        }
        if (options.defaults) {
            object.url = "";
            object.digests = null;
            if ($util.Long) {
                var long = new $util.Long(0, 0, false);
                object.length = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
            } else
                object.length = options.longs === String ? "0" : 0;
            object.signature = null;
            object.userInitiated = false;
            object.fileBasename = "";
            object.downloadType = 0;
            object.locale = "";
            object.apkInfo = null;
            if ($util.Long) {
                var long = new $util.Long(0, 0, false);
                object.androidId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
            } else
                object.androidId = options.longs === String ? "0" : 0;
            object.originatingSignature = null;
        }
        if (message.url != null && message.hasOwnProperty("url"))
            object.url = message.url;
        if (message.digests != null && message.hasOwnProperty("digests"))
            object.digests = $root.ClientDownloadRequest.Digests.toObject(message.digests, options);
        if (message.length != null && message.hasOwnProperty("length"))
            if (typeof message.length === "number")
                object.length = options.longs === String ? String(message.length) : message.length;
            else
                object.length = options.longs === String ? $util.Long.prototype.toString.call(message.length) : options.longs === Number ? new $util.LongBits(message.length.low >>> 0, message.length.high >>> 0).toNumber() : message.length;
        if (message.resources && message.resources.length) {
            object.resources = [];
            for (var j = 0; j < message.resources.length; ++j)
                object.resources[j] = $root.ClientDownloadRequest.Resource.toObject(message.resources[j], options);
        }
        if (message.signature != null && message.hasOwnProperty("signature"))
            object.signature = $root.ClientDownloadRequest.SignatureInfo.toObject(message.signature, options);
        if (message.userInitiated != null && message.hasOwnProperty("userInitiated"))
            object.userInitiated = message.userInitiated;
        if (message.clientAsn && message.clientAsn.length) {
            object.clientAsn = [];
            for (var j = 0; j < message.clientAsn.length; ++j)
                object.clientAsn[j] = message.clientAsn[j];
        }
        if (message.fileBasename != null && message.hasOwnProperty("fileBasename"))
            object.fileBasename = message.fileBasename;
        if (message.downloadType != null && message.hasOwnProperty("downloadType"))
            object.downloadType = message.downloadType;
        if (message.locale != null && message.hasOwnProperty("locale"))
            object.locale = message.locale;
        if (message.apkInfo != null && message.hasOwnProperty("apkInfo"))
            object.apkInfo = $root.ClientDownloadRequest.ApkInfo.toObject(message.apkInfo, options);
        if (message.androidId != null && message.hasOwnProperty("androidId"))
            if (typeof message.androidId === "number")
                object.androidId = options.longs === String ? String(message.androidId) : message.androidId;
            else
                object.androidId = options.longs === String ? $util.Long.prototype.toString.call(message.androidId) : options.longs === Number ? new $util.LongBits(message.androidId.low >>> 0, message.androidId.high >>> 0).toNumber() : message.androidId;
        if (message.originatingPackages && message.originatingPackages.length) {
            object.originatingPackages = [];
            for (var j = 0; j < message.originatingPackages.length; ++j)
                object.originatingPackages[j] = message.originatingPackages[j];
        }
        if (message.originatingSignature != null && message.hasOwnProperty("originatingSignature"))
            object.originatingSignature = $root.ClientDownloadRequest.SignatureInfo.toObject(message.originatingSignature, options);
        return object;
    };

    /**
     * Converts this ClientDownloadRequest to JSON.
     * @function toJSON
     * @memberof ClientDownloadRequest
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    ClientDownloadRequest.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    ClientDownloadRequest.ApkInfo = (function() {

        /**
         * Properties of an ApkInfo.
         * @memberof ClientDownloadRequest
         * @interface IApkInfo
         * @property {string|null} [packageName] ApkInfo packageName
         * @property {number|null} [versionCode] ApkInfo versionCode
         */

        /**
         * Constructs a new ApkInfo.
         * @memberof ClientDownloadRequest
         * @classdesc Represents an ApkInfo.
         * @implements IApkInfo
         * @constructor
         * @param {ClientDownloadRequest.IApkInfo=} [properties] Properties to set
         */
        function ApkInfo(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ApkInfo packageName.
         * @member {string} packageName
         * @memberof ClientDownloadRequest.ApkInfo
         * @instance
         */
        ApkInfo.prototype.packageName = "";

        /**
         * ApkInfo versionCode.
         * @member {number} versionCode
         * @memberof ClientDownloadRequest.ApkInfo
         * @instance
         */
        ApkInfo.prototype.versionCode = 0;

        /**
         * Creates a new ApkInfo instance using the specified properties.
         * @function create
         * @memberof ClientDownloadRequest.ApkInfo
         * @static
         * @param {ClientDownloadRequest.IApkInfo=} [properties] Properties to set
         * @returns {ClientDownloadRequest.ApkInfo} ApkInfo instance
         */
        ApkInfo.create = function create(properties) {
            return new ApkInfo(properties);
        };

        /**
         * Encodes the specified ApkInfo message. Does not implicitly {@link ClientDownloadRequest.ApkInfo.verify|verify} messages.
         * @function encode
         * @memberof ClientDownloadRequest.ApkInfo
         * @static
         * @param {ClientDownloadRequest.IApkInfo} message ApkInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ApkInfo.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.packageName != null && Object.hasOwnProperty.call(message, "packageName"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.packageName);
            if (message.versionCode != null && Object.hasOwnProperty.call(message, "versionCode"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.versionCode);
            return writer;
        };

        /**
         * Encodes the specified ApkInfo message, length delimited. Does not implicitly {@link ClientDownloadRequest.ApkInfo.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ClientDownloadRequest.ApkInfo
         * @static
         * @param {ClientDownloadRequest.IApkInfo} message ApkInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ApkInfo.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an ApkInfo message from the specified reader or buffer.
         * @function decode
         * @memberof ClientDownloadRequest.ApkInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ClientDownloadRequest.ApkInfo} ApkInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ApkInfo.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ClientDownloadRequest.ApkInfo();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.packageName = reader.string();
                    break;
                case 2:
                    message.versionCode = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an ApkInfo message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ClientDownloadRequest.ApkInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ClientDownloadRequest.ApkInfo} ApkInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ApkInfo.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an ApkInfo message.
         * @function verify
         * @memberof ClientDownloadRequest.ApkInfo
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ApkInfo.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.packageName != null && message.hasOwnProperty("packageName"))
                if (!$util.isString(message.packageName))
                    return "packageName: string expected";
            if (message.versionCode != null && message.hasOwnProperty("versionCode"))
                if (!$util.isInteger(message.versionCode))
                    return "versionCode: integer expected";
            return null;
        };

        /**
         * Creates an ApkInfo message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ClientDownloadRequest.ApkInfo
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ClientDownloadRequest.ApkInfo} ApkInfo
         */
        ApkInfo.fromObject = function fromObject(object) {
            if (object instanceof $root.ClientDownloadRequest.ApkInfo)
                return object;
            var message = new $root.ClientDownloadRequest.ApkInfo();
            if (object.packageName != null)
                message.packageName = String(object.packageName);
            if (object.versionCode != null)
                message.versionCode = object.versionCode | 0;
            return message;
        };

        /**
         * Creates a plain object from an ApkInfo message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ClientDownloadRequest.ApkInfo
         * @static
         * @param {ClientDownloadRequest.ApkInfo} message ApkInfo
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ApkInfo.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.packageName = "";
                object.versionCode = 0;
            }
            if (message.packageName != null && message.hasOwnProperty("packageName"))
                object.packageName = message.packageName;
            if (message.versionCode != null && message.hasOwnProperty("versionCode"))
                object.versionCode = message.versionCode;
            return object;
        };

        /**
         * Converts this ApkInfo to JSON.
         * @function toJSON
         * @memberof ClientDownloadRequest.ApkInfo
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ApkInfo.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ApkInfo;
    })();

    ClientDownloadRequest.CertificateChain = (function() {

        /**
         * Properties of a CertificateChain.
         * @memberof ClientDownloadRequest
         * @interface ICertificateChain
         * @property {Array.<ClientDownloadRequest.CertificateChain.IElement>|null} [element] CertificateChain element
         */

        /**
         * Constructs a new CertificateChain.
         * @memberof ClientDownloadRequest
         * @classdesc Represents a CertificateChain.
         * @implements ICertificateChain
         * @constructor
         * @param {ClientDownloadRequest.ICertificateChain=} [properties] Properties to set
         */
        function CertificateChain(properties) {
            this.element = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * CertificateChain element.
         * @member {Array.<ClientDownloadRequest.CertificateChain.IElement>} element
         * @memberof ClientDownloadRequest.CertificateChain
         * @instance
         */
        CertificateChain.prototype.element = $util.emptyArray;

        /**
         * Creates a new CertificateChain instance using the specified properties.
         * @function create
         * @memberof ClientDownloadRequest.CertificateChain
         * @static
         * @param {ClientDownloadRequest.ICertificateChain=} [properties] Properties to set
         * @returns {ClientDownloadRequest.CertificateChain} CertificateChain instance
         */
        CertificateChain.create = function create(properties) {
            return new CertificateChain(properties);
        };

        /**
         * Encodes the specified CertificateChain message. Does not implicitly {@link ClientDownloadRequest.CertificateChain.verify|verify} messages.
         * @function encode
         * @memberof ClientDownloadRequest.CertificateChain
         * @static
         * @param {ClientDownloadRequest.ICertificateChain} message CertificateChain message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CertificateChain.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.element != null && message.element.length)
                for (var i = 0; i < message.element.length; ++i)
                    $root.ClientDownloadRequest.CertificateChain.Element.encode(message.element[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified CertificateChain message, length delimited. Does not implicitly {@link ClientDownloadRequest.CertificateChain.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ClientDownloadRequest.CertificateChain
         * @static
         * @param {ClientDownloadRequest.ICertificateChain} message CertificateChain message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CertificateChain.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a CertificateChain message from the specified reader or buffer.
         * @function decode
         * @memberof ClientDownloadRequest.CertificateChain
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ClientDownloadRequest.CertificateChain} CertificateChain
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CertificateChain.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ClientDownloadRequest.CertificateChain();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.element && message.element.length))
                        message.element = [];
                    message.element.push($root.ClientDownloadRequest.CertificateChain.Element.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a CertificateChain message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ClientDownloadRequest.CertificateChain
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ClientDownloadRequest.CertificateChain} CertificateChain
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CertificateChain.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a CertificateChain message.
         * @function verify
         * @memberof ClientDownloadRequest.CertificateChain
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CertificateChain.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.element != null && message.hasOwnProperty("element")) {
                if (!Array.isArray(message.element))
                    return "element: array expected";
                for (var i = 0; i < message.element.length; ++i) {
                    var error = $root.ClientDownloadRequest.CertificateChain.Element.verify(message.element[i]);
                    if (error)
                        return "element." + error;
                }
            }
            return null;
        };

        /**
         * Creates a CertificateChain message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ClientDownloadRequest.CertificateChain
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ClientDownloadRequest.CertificateChain} CertificateChain
         */
        CertificateChain.fromObject = function fromObject(object) {
            if (object instanceof $root.ClientDownloadRequest.CertificateChain)
                return object;
            var message = new $root.ClientDownloadRequest.CertificateChain();
            if (object.element) {
                if (!Array.isArray(object.element))
                    throw TypeError(".ClientDownloadRequest.CertificateChain.element: array expected");
                message.element = [];
                for (var i = 0; i < object.element.length; ++i) {
                    if (typeof object.element[i] !== "object")
                        throw TypeError(".ClientDownloadRequest.CertificateChain.element: object expected");
                    message.element[i] = $root.ClientDownloadRequest.CertificateChain.Element.fromObject(object.element[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a CertificateChain message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ClientDownloadRequest.CertificateChain
         * @static
         * @param {ClientDownloadRequest.CertificateChain} message CertificateChain
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CertificateChain.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.element = [];
            if (message.element && message.element.length) {
                object.element = [];
                for (var j = 0; j < message.element.length; ++j)
                    object.element[j] = $root.ClientDownloadRequest.CertificateChain.Element.toObject(message.element[j], options);
            }
            return object;
        };

        /**
         * Converts this CertificateChain to JSON.
         * @function toJSON
         * @memberof ClientDownloadRequest.CertificateChain
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CertificateChain.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        CertificateChain.Element = (function() {

            /**
             * Properties of an Element.
             * @memberof ClientDownloadRequest.CertificateChain
             * @interface IElement
             * @property {Uint8Array|null} [certificate] Element certificate
             * @property {boolean|null} [parsedSuccessfully] Element parsedSuccessfully
             * @property {Uint8Array|null} [subject] Element subject
             * @property {Uint8Array|null} [issuer] Element issuer
             * @property {Uint8Array|null} [fingerprint] Element fingerprint
             * @property {number|Long|null} [expiryTime] Element expiryTime
             * @property {number|Long|null} [startTime] Element startTime
             */

            /**
             * Constructs a new Element.
             * @memberof ClientDownloadRequest.CertificateChain
             * @classdesc Represents an Element.
             * @implements IElement
             * @constructor
             * @param {ClientDownloadRequest.CertificateChain.IElement=} [properties] Properties to set
             */
            function Element(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Element certificate.
             * @member {Uint8Array} certificate
             * @memberof ClientDownloadRequest.CertificateChain.Element
             * @instance
             */
            Element.prototype.certificate = $util.newBuffer([]);

            /**
             * Element parsedSuccessfully.
             * @member {boolean} parsedSuccessfully
             * @memberof ClientDownloadRequest.CertificateChain.Element
             * @instance
             */
            Element.prototype.parsedSuccessfully = false;

            /**
             * Element subject.
             * @member {Uint8Array} subject
             * @memberof ClientDownloadRequest.CertificateChain.Element
             * @instance
             */
            Element.prototype.subject = $util.newBuffer([]);

            /**
             * Element issuer.
             * @member {Uint8Array} issuer
             * @memberof ClientDownloadRequest.CertificateChain.Element
             * @instance
             */
            Element.prototype.issuer = $util.newBuffer([]);

            /**
             * Element fingerprint.
             * @member {Uint8Array} fingerprint
             * @memberof ClientDownloadRequest.CertificateChain.Element
             * @instance
             */
            Element.prototype.fingerprint = $util.newBuffer([]);

            /**
             * Element expiryTime.
             * @member {number|Long} expiryTime
             * @memberof ClientDownloadRequest.CertificateChain.Element
             * @instance
             */
            Element.prototype.expiryTime = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * Element startTime.
             * @member {number|Long} startTime
             * @memberof ClientDownloadRequest.CertificateChain.Element
             * @instance
             */
            Element.prototype.startTime = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * Creates a new Element instance using the specified properties.
             * @function create
             * @memberof ClientDownloadRequest.CertificateChain.Element
             * @static
             * @param {ClientDownloadRequest.CertificateChain.IElement=} [properties] Properties to set
             * @returns {ClientDownloadRequest.CertificateChain.Element} Element instance
             */
            Element.create = function create(properties) {
                return new Element(properties);
            };

            /**
             * Encodes the specified Element message. Does not implicitly {@link ClientDownloadRequest.CertificateChain.Element.verify|verify} messages.
             * @function encode
             * @memberof ClientDownloadRequest.CertificateChain.Element
             * @static
             * @param {ClientDownloadRequest.CertificateChain.IElement} message Element message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Element.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.certificate != null && Object.hasOwnProperty.call(message, "certificate"))
                    writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.certificate);
                if (message.parsedSuccessfully != null && Object.hasOwnProperty.call(message, "parsedSuccessfully"))
                    writer.uint32(/* id 2, wireType 0 =*/16).bool(message.parsedSuccessfully);
                if (message.subject != null && Object.hasOwnProperty.call(message, "subject"))
                    writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.subject);
                if (message.issuer != null && Object.hasOwnProperty.call(message, "issuer"))
                    writer.uint32(/* id 4, wireType 2 =*/34).bytes(message.issuer);
                if (message.fingerprint != null && Object.hasOwnProperty.call(message, "fingerprint"))
                    writer.uint32(/* id 5, wireType 2 =*/42).bytes(message.fingerprint);
                if (message.expiryTime != null && Object.hasOwnProperty.call(message, "expiryTime"))
                    writer.uint32(/* id 6, wireType 0 =*/48).int64(message.expiryTime);
                if (message.startTime != null && Object.hasOwnProperty.call(message, "startTime"))
                    writer.uint32(/* id 7, wireType 0 =*/56).int64(message.startTime);
                return writer;
            };

            /**
             * Encodes the specified Element message, length delimited. Does not implicitly {@link ClientDownloadRequest.CertificateChain.Element.verify|verify} messages.
             * @function encodeDelimited
             * @memberof ClientDownloadRequest.CertificateChain.Element
             * @static
             * @param {ClientDownloadRequest.CertificateChain.IElement} message Element message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Element.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an Element message from the specified reader or buffer.
             * @function decode
             * @memberof ClientDownloadRequest.CertificateChain.Element
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {ClientDownloadRequest.CertificateChain.Element} Element
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Element.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ClientDownloadRequest.CertificateChain.Element();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.certificate = reader.bytes();
                        break;
                    case 2:
                        message.parsedSuccessfully = reader.bool();
                        break;
                    case 3:
                        message.subject = reader.bytes();
                        break;
                    case 4:
                        message.issuer = reader.bytes();
                        break;
                    case 5:
                        message.fingerprint = reader.bytes();
                        break;
                    case 6:
                        message.expiryTime = reader.int64();
                        break;
                    case 7:
                        message.startTime = reader.int64();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an Element message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof ClientDownloadRequest.CertificateChain.Element
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {ClientDownloadRequest.CertificateChain.Element} Element
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Element.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an Element message.
             * @function verify
             * @memberof ClientDownloadRequest.CertificateChain.Element
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Element.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.certificate != null && message.hasOwnProperty("certificate"))
                    if (!(message.certificate && typeof message.certificate.length === "number" || $util.isString(message.certificate)))
                        return "certificate: buffer expected";
                if (message.parsedSuccessfully != null && message.hasOwnProperty("parsedSuccessfully"))
                    if (typeof message.parsedSuccessfully !== "boolean")
                        return "parsedSuccessfully: boolean expected";
                if (message.subject != null && message.hasOwnProperty("subject"))
                    if (!(message.subject && typeof message.subject.length === "number" || $util.isString(message.subject)))
                        return "subject: buffer expected";
                if (message.issuer != null && message.hasOwnProperty("issuer"))
                    if (!(message.issuer && typeof message.issuer.length === "number" || $util.isString(message.issuer)))
                        return "issuer: buffer expected";
                if (message.fingerprint != null && message.hasOwnProperty("fingerprint"))
                    if (!(message.fingerprint && typeof message.fingerprint.length === "number" || $util.isString(message.fingerprint)))
                        return "fingerprint: buffer expected";
                if (message.expiryTime != null && message.hasOwnProperty("expiryTime"))
                    if (!$util.isInteger(message.expiryTime) && !(message.expiryTime && $util.isInteger(message.expiryTime.low) && $util.isInteger(message.expiryTime.high)))
                        return "expiryTime: integer|Long expected";
                if (message.startTime != null && message.hasOwnProperty("startTime"))
                    if (!$util.isInteger(message.startTime) && !(message.startTime && $util.isInteger(message.startTime.low) && $util.isInteger(message.startTime.high)))
                        return "startTime: integer|Long expected";
                return null;
            };

            /**
             * Creates an Element message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof ClientDownloadRequest.CertificateChain.Element
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {ClientDownloadRequest.CertificateChain.Element} Element
             */
            Element.fromObject = function fromObject(object) {
                if (object instanceof $root.ClientDownloadRequest.CertificateChain.Element)
                    return object;
                var message = new $root.ClientDownloadRequest.CertificateChain.Element();
                if (object.certificate != null)
                    if (typeof object.certificate === "string")
                        $util.base64.decode(object.certificate, message.certificate = $util.newBuffer($util.base64.length(object.certificate)), 0);
                    else if (object.certificate.length)
                        message.certificate = object.certificate;
                if (object.parsedSuccessfully != null)
                    message.parsedSuccessfully = Boolean(object.parsedSuccessfully);
                if (object.subject != null)
                    if (typeof object.subject === "string")
                        $util.base64.decode(object.subject, message.subject = $util.newBuffer($util.base64.length(object.subject)), 0);
                    else if (object.subject.length)
                        message.subject = object.subject;
                if (object.issuer != null)
                    if (typeof object.issuer === "string")
                        $util.base64.decode(object.issuer, message.issuer = $util.newBuffer($util.base64.length(object.issuer)), 0);
                    else if (object.issuer.length)
                        message.issuer = object.issuer;
                if (object.fingerprint != null)
                    if (typeof object.fingerprint === "string")
                        $util.base64.decode(object.fingerprint, message.fingerprint = $util.newBuffer($util.base64.length(object.fingerprint)), 0);
                    else if (object.fingerprint.length)
                        message.fingerprint = object.fingerprint;
                if (object.expiryTime != null)
                    if ($util.Long)
                        (message.expiryTime = $util.Long.fromValue(object.expiryTime)).unsigned = false;
                    else if (typeof object.expiryTime === "string")
                        message.expiryTime = parseInt(object.expiryTime, 10);
                    else if (typeof object.expiryTime === "number")
                        message.expiryTime = object.expiryTime;
                    else if (typeof object.expiryTime === "object")
                        message.expiryTime = new $util.LongBits(object.expiryTime.low >>> 0, object.expiryTime.high >>> 0).toNumber();
                if (object.startTime != null)
                    if ($util.Long)
                        (message.startTime = $util.Long.fromValue(object.startTime)).unsigned = false;
                    else if (typeof object.startTime === "string")
                        message.startTime = parseInt(object.startTime, 10);
                    else if (typeof object.startTime === "number")
                        message.startTime = object.startTime;
                    else if (typeof object.startTime === "object")
                        message.startTime = new $util.LongBits(object.startTime.low >>> 0, object.startTime.high >>> 0).toNumber();
                return message;
            };

            /**
             * Creates a plain object from an Element message. Also converts values to other types if specified.
             * @function toObject
             * @memberof ClientDownloadRequest.CertificateChain.Element
             * @static
             * @param {ClientDownloadRequest.CertificateChain.Element} message Element
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Element.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    if (options.bytes === String)
                        object.certificate = "";
                    else {
                        object.certificate = [];
                        if (options.bytes !== Array)
                            object.certificate = $util.newBuffer(object.certificate);
                    }
                    object.parsedSuccessfully = false;
                    if (options.bytes === String)
                        object.subject = "";
                    else {
                        object.subject = [];
                        if (options.bytes !== Array)
                            object.subject = $util.newBuffer(object.subject);
                    }
                    if (options.bytes === String)
                        object.issuer = "";
                    else {
                        object.issuer = [];
                        if (options.bytes !== Array)
                            object.issuer = $util.newBuffer(object.issuer);
                    }
                    if (options.bytes === String)
                        object.fingerprint = "";
                    else {
                        object.fingerprint = [];
                        if (options.bytes !== Array)
                            object.fingerprint = $util.newBuffer(object.fingerprint);
                    }
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, false);
                        object.expiryTime = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.expiryTime = options.longs === String ? "0" : 0;
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, false);
                        object.startTime = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.startTime = options.longs === String ? "0" : 0;
                }
                if (message.certificate != null && message.hasOwnProperty("certificate"))
                    object.certificate = options.bytes === String ? $util.base64.encode(message.certificate, 0, message.certificate.length) : options.bytes === Array ? Array.prototype.slice.call(message.certificate) : message.certificate;
                if (message.parsedSuccessfully != null && message.hasOwnProperty("parsedSuccessfully"))
                    object.parsedSuccessfully = message.parsedSuccessfully;
                if (message.subject != null && message.hasOwnProperty("subject"))
                    object.subject = options.bytes === String ? $util.base64.encode(message.subject, 0, message.subject.length) : options.bytes === Array ? Array.prototype.slice.call(message.subject) : message.subject;
                if (message.issuer != null && message.hasOwnProperty("issuer"))
                    object.issuer = options.bytes === String ? $util.base64.encode(message.issuer, 0, message.issuer.length) : options.bytes === Array ? Array.prototype.slice.call(message.issuer) : message.issuer;
                if (message.fingerprint != null && message.hasOwnProperty("fingerprint"))
                    object.fingerprint = options.bytes === String ? $util.base64.encode(message.fingerprint, 0, message.fingerprint.length) : options.bytes === Array ? Array.prototype.slice.call(message.fingerprint) : message.fingerprint;
                if (message.expiryTime != null && message.hasOwnProperty("expiryTime"))
                    if (typeof message.expiryTime === "number")
                        object.expiryTime = options.longs === String ? String(message.expiryTime) : message.expiryTime;
                    else
                        object.expiryTime = options.longs === String ? $util.Long.prototype.toString.call(message.expiryTime) : options.longs === Number ? new $util.LongBits(message.expiryTime.low >>> 0, message.expiryTime.high >>> 0).toNumber() : message.expiryTime;
                if (message.startTime != null && message.hasOwnProperty("startTime"))
                    if (typeof message.startTime === "number")
                        object.startTime = options.longs === String ? String(message.startTime) : message.startTime;
                    else
                        object.startTime = options.longs === String ? $util.Long.prototype.toString.call(message.startTime) : options.longs === Number ? new $util.LongBits(message.startTime.low >>> 0, message.startTime.high >>> 0).toNumber() : message.startTime;
                return object;
            };

            /**
             * Converts this Element to JSON.
             * @function toJSON
             * @memberof ClientDownloadRequest.CertificateChain.Element
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Element.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return Element;
        })();

        return CertificateChain;
    })();

    ClientDownloadRequest.Digests = (function() {

        /**
         * Properties of a Digests.
         * @memberof ClientDownloadRequest
         * @interface IDigests
         * @property {Uint8Array|null} [sha256] Digests sha256
         * @property {Uint8Array|null} [sha1] Digests sha1
         * @property {Uint8Array|null} [md5] Digests md5
         */

        /**
         * Constructs a new Digests.
         * @memberof ClientDownloadRequest
         * @classdesc Represents a Digests.
         * @implements IDigests
         * @constructor
         * @param {ClientDownloadRequest.IDigests=} [properties] Properties to set
         */
        function Digests(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Digests sha256.
         * @member {Uint8Array} sha256
         * @memberof ClientDownloadRequest.Digests
         * @instance
         */
        Digests.prototype.sha256 = $util.newBuffer([]);

        /**
         * Digests sha1.
         * @member {Uint8Array} sha1
         * @memberof ClientDownloadRequest.Digests
         * @instance
         */
        Digests.prototype.sha1 = $util.newBuffer([]);

        /**
         * Digests md5.
         * @member {Uint8Array} md5
         * @memberof ClientDownloadRequest.Digests
         * @instance
         */
        Digests.prototype.md5 = $util.newBuffer([]);

        /**
         * Creates a new Digests instance using the specified properties.
         * @function create
         * @memberof ClientDownloadRequest.Digests
         * @static
         * @param {ClientDownloadRequest.IDigests=} [properties] Properties to set
         * @returns {ClientDownloadRequest.Digests} Digests instance
         */
        Digests.create = function create(properties) {
            return new Digests(properties);
        };

        /**
         * Encodes the specified Digests message. Does not implicitly {@link ClientDownloadRequest.Digests.verify|verify} messages.
         * @function encode
         * @memberof ClientDownloadRequest.Digests
         * @static
         * @param {ClientDownloadRequest.IDigests} message Digests message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Digests.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.sha256 != null && Object.hasOwnProperty.call(message, "sha256"))
                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.sha256);
            if (message.sha1 != null && Object.hasOwnProperty.call(message, "sha1"))
                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.sha1);
            if (message.md5 != null && Object.hasOwnProperty.call(message, "md5"))
                writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.md5);
            return writer;
        };

        /**
         * Encodes the specified Digests message, length delimited. Does not implicitly {@link ClientDownloadRequest.Digests.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ClientDownloadRequest.Digests
         * @static
         * @param {ClientDownloadRequest.IDigests} message Digests message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Digests.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Digests message from the specified reader or buffer.
         * @function decode
         * @memberof ClientDownloadRequest.Digests
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ClientDownloadRequest.Digests} Digests
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Digests.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ClientDownloadRequest.Digests();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.sha256 = reader.bytes();
                    break;
                case 2:
                    message.sha1 = reader.bytes();
                    break;
                case 3:
                    message.md5 = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a Digests message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ClientDownloadRequest.Digests
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ClientDownloadRequest.Digests} Digests
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Digests.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Digests message.
         * @function verify
         * @memberof ClientDownloadRequest.Digests
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Digests.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.sha256 != null && message.hasOwnProperty("sha256"))
                if (!(message.sha256 && typeof message.sha256.length === "number" || $util.isString(message.sha256)))
                    return "sha256: buffer expected";
            if (message.sha1 != null && message.hasOwnProperty("sha1"))
                if (!(message.sha1 && typeof message.sha1.length === "number" || $util.isString(message.sha1)))
                    return "sha1: buffer expected";
            if (message.md5 != null && message.hasOwnProperty("md5"))
                if (!(message.md5 && typeof message.md5.length === "number" || $util.isString(message.md5)))
                    return "md5: buffer expected";
            return null;
        };

        /**
         * Creates a Digests message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ClientDownloadRequest.Digests
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ClientDownloadRequest.Digests} Digests
         */
        Digests.fromObject = function fromObject(object) {
            if (object instanceof $root.ClientDownloadRequest.Digests)
                return object;
            var message = new $root.ClientDownloadRequest.Digests();
            if (object.sha256 != null)
                if (typeof object.sha256 === "string")
                    $util.base64.decode(object.sha256, message.sha256 = $util.newBuffer($util.base64.length(object.sha256)), 0);
                else if (object.sha256.length)
                    message.sha256 = object.sha256;
            if (object.sha1 != null)
                if (typeof object.sha1 === "string")
                    $util.base64.decode(object.sha1, message.sha1 = $util.newBuffer($util.base64.length(object.sha1)), 0);
                else if (object.sha1.length)
                    message.sha1 = object.sha1;
            if (object.md5 != null)
                if (typeof object.md5 === "string")
                    $util.base64.decode(object.md5, message.md5 = $util.newBuffer($util.base64.length(object.md5)), 0);
                else if (object.md5.length)
                    message.md5 = object.md5;
            return message;
        };

        /**
         * Creates a plain object from a Digests message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ClientDownloadRequest.Digests
         * @static
         * @param {ClientDownloadRequest.Digests} message Digests
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Digests.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                if (options.bytes === String)
                    object.sha256 = "";
                else {
                    object.sha256 = [];
                    if (options.bytes !== Array)
                        object.sha256 = $util.newBuffer(object.sha256);
                }
                if (options.bytes === String)
                    object.sha1 = "";
                else {
                    object.sha1 = [];
                    if (options.bytes !== Array)
                        object.sha1 = $util.newBuffer(object.sha1);
                }
                if (options.bytes === String)
                    object.md5 = "";
                else {
                    object.md5 = [];
                    if (options.bytes !== Array)
                        object.md5 = $util.newBuffer(object.md5);
                }
            }
            if (message.sha256 != null && message.hasOwnProperty("sha256"))
                object.sha256 = options.bytes === String ? $util.base64.encode(message.sha256, 0, message.sha256.length) : options.bytes === Array ? Array.prototype.slice.call(message.sha256) : message.sha256;
            if (message.sha1 != null && message.hasOwnProperty("sha1"))
                object.sha1 = options.bytes === String ? $util.base64.encode(message.sha1, 0, message.sha1.length) : options.bytes === Array ? Array.prototype.slice.call(message.sha1) : message.sha1;
            if (message.md5 != null && message.hasOwnProperty("md5"))
                object.md5 = options.bytes === String ? $util.base64.encode(message.md5, 0, message.md5.length) : options.bytes === Array ? Array.prototype.slice.call(message.md5) : message.md5;
            return object;
        };

        /**
         * Converts this Digests to JSON.
         * @function toJSON
         * @memberof ClientDownloadRequest.Digests
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Digests.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Digests;
    })();

    ClientDownloadRequest.Resource = (function() {

        /**
         * Properties of a Resource.
         * @memberof ClientDownloadRequest
         * @interface IResource
         * @property {string|null} [url] Resource url
         * @property {number|null} [type] Resource type
         * @property {Uint8Array|null} [remoteIp] Resource remoteIp
         * @property {string|null} [referrer] Resource referrer
         */

        /**
         * Constructs a new Resource.
         * @memberof ClientDownloadRequest
         * @classdesc Represents a Resource.
         * @implements IResource
         * @constructor
         * @param {ClientDownloadRequest.IResource=} [properties] Properties to set
         */
        function Resource(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Resource url.
         * @member {string} url
         * @memberof ClientDownloadRequest.Resource
         * @instance
         */
        Resource.prototype.url = "";

        /**
         * Resource type.
         * @member {number} type
         * @memberof ClientDownloadRequest.Resource
         * @instance
         */
        Resource.prototype.type = 0;

        /**
         * Resource remoteIp.
         * @member {Uint8Array} remoteIp
         * @memberof ClientDownloadRequest.Resource
         * @instance
         */
        Resource.prototype.remoteIp = $util.newBuffer([]);

        /**
         * Resource referrer.
         * @member {string} referrer
         * @memberof ClientDownloadRequest.Resource
         * @instance
         */
        Resource.prototype.referrer = "";

        /**
         * Creates a new Resource instance using the specified properties.
         * @function create
         * @memberof ClientDownloadRequest.Resource
         * @static
         * @param {ClientDownloadRequest.IResource=} [properties] Properties to set
         * @returns {ClientDownloadRequest.Resource} Resource instance
         */
        Resource.create = function create(properties) {
            return new Resource(properties);
        };

        /**
         * Encodes the specified Resource message. Does not implicitly {@link ClientDownloadRequest.Resource.verify|verify} messages.
         * @function encode
         * @memberof ClientDownloadRequest.Resource
         * @static
         * @param {ClientDownloadRequest.IResource} message Resource message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Resource.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.url != null && Object.hasOwnProperty.call(message, "url"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.url);
            if (message.type != null && Object.hasOwnProperty.call(message, "type"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.type);
            if (message.remoteIp != null && Object.hasOwnProperty.call(message, "remoteIp"))
                writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.remoteIp);
            if (message.referrer != null && Object.hasOwnProperty.call(message, "referrer"))
                writer.uint32(/* id 4, wireType 2 =*/34).string(message.referrer);
            return writer;
        };

        /**
         * Encodes the specified Resource message, length delimited. Does not implicitly {@link ClientDownloadRequest.Resource.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ClientDownloadRequest.Resource
         * @static
         * @param {ClientDownloadRequest.IResource} message Resource message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Resource.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Resource message from the specified reader or buffer.
         * @function decode
         * @memberof ClientDownloadRequest.Resource
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ClientDownloadRequest.Resource} Resource
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Resource.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ClientDownloadRequest.Resource();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.url = reader.string();
                    break;
                case 2:
                    message.type = reader.int32();
                    break;
                case 3:
                    message.remoteIp = reader.bytes();
                    break;
                case 4:
                    message.referrer = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a Resource message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ClientDownloadRequest.Resource
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ClientDownloadRequest.Resource} Resource
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Resource.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Resource message.
         * @function verify
         * @memberof ClientDownloadRequest.Resource
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Resource.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.url != null && message.hasOwnProperty("url"))
                if (!$util.isString(message.url))
                    return "url: string expected";
            if (message.type != null && message.hasOwnProperty("type"))
                if (!$util.isInteger(message.type))
                    return "type: integer expected";
            if (message.remoteIp != null && message.hasOwnProperty("remoteIp"))
                if (!(message.remoteIp && typeof message.remoteIp.length === "number" || $util.isString(message.remoteIp)))
                    return "remoteIp: buffer expected";
            if (message.referrer != null && message.hasOwnProperty("referrer"))
                if (!$util.isString(message.referrer))
                    return "referrer: string expected";
            return null;
        };

        /**
         * Creates a Resource message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ClientDownloadRequest.Resource
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ClientDownloadRequest.Resource} Resource
         */
        Resource.fromObject = function fromObject(object) {
            if (object instanceof $root.ClientDownloadRequest.Resource)
                return object;
            var message = new $root.ClientDownloadRequest.Resource();
            if (object.url != null)
                message.url = String(object.url);
            if (object.type != null)
                message.type = object.type | 0;
            if (object.remoteIp != null)
                if (typeof object.remoteIp === "string")
                    $util.base64.decode(object.remoteIp, message.remoteIp = $util.newBuffer($util.base64.length(object.remoteIp)), 0);
                else if (object.remoteIp.length)
                    message.remoteIp = object.remoteIp;
            if (object.referrer != null)
                message.referrer = String(object.referrer);
            return message;
        };

        /**
         * Creates a plain object from a Resource message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ClientDownloadRequest.Resource
         * @static
         * @param {ClientDownloadRequest.Resource} message Resource
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Resource.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.url = "";
                object.type = 0;
                if (options.bytes === String)
                    object.remoteIp = "";
                else {
                    object.remoteIp = [];
                    if (options.bytes !== Array)
                        object.remoteIp = $util.newBuffer(object.remoteIp);
                }
                object.referrer = "";
            }
            if (message.url != null && message.hasOwnProperty("url"))
                object.url = message.url;
            if (message.type != null && message.hasOwnProperty("type"))
                object.type = message.type;
            if (message.remoteIp != null && message.hasOwnProperty("remoteIp"))
                object.remoteIp = options.bytes === String ? $util.base64.encode(message.remoteIp, 0, message.remoteIp.length) : options.bytes === Array ? Array.prototype.slice.call(message.remoteIp) : message.remoteIp;
            if (message.referrer != null && message.hasOwnProperty("referrer"))
                object.referrer = message.referrer;
            return object;
        };

        /**
         * Converts this Resource to JSON.
         * @function toJSON
         * @memberof ClientDownloadRequest.Resource
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Resource.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Resource;
    })();

    ClientDownloadRequest.SignatureInfo = (function() {

        /**
         * Properties of a SignatureInfo.
         * @memberof ClientDownloadRequest
         * @interface ISignatureInfo
         * @property {Array.<ClientDownloadRequest.ICertificateChain>|null} [certificateChain] SignatureInfo certificateChain
         * @property {boolean|null} [trusted] SignatureInfo trusted
         */

        /**
         * Constructs a new SignatureInfo.
         * @memberof ClientDownloadRequest
         * @classdesc Represents a SignatureInfo.
         * @implements ISignatureInfo
         * @constructor
         * @param {ClientDownloadRequest.ISignatureInfo=} [properties] Properties to set
         */
        function SignatureInfo(properties) {
            this.certificateChain = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * SignatureInfo certificateChain.
         * @member {Array.<ClientDownloadRequest.ICertificateChain>} certificateChain
         * @memberof ClientDownloadRequest.SignatureInfo
         * @instance
         */
        SignatureInfo.prototype.certificateChain = $util.emptyArray;

        /**
         * SignatureInfo trusted.
         * @member {boolean} trusted
         * @memberof ClientDownloadRequest.SignatureInfo
         * @instance
         */
        SignatureInfo.prototype.trusted = false;

        /**
         * Creates a new SignatureInfo instance using the specified properties.
         * @function create
         * @memberof ClientDownloadRequest.SignatureInfo
         * @static
         * @param {ClientDownloadRequest.ISignatureInfo=} [properties] Properties to set
         * @returns {ClientDownloadRequest.SignatureInfo} SignatureInfo instance
         */
        SignatureInfo.create = function create(properties) {
            return new SignatureInfo(properties);
        };

        /**
         * Encodes the specified SignatureInfo message. Does not implicitly {@link ClientDownloadRequest.SignatureInfo.verify|verify} messages.
         * @function encode
         * @memberof ClientDownloadRequest.SignatureInfo
         * @static
         * @param {ClientDownloadRequest.ISignatureInfo} message SignatureInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SignatureInfo.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.certificateChain != null && message.certificateChain.length)
                for (var i = 0; i < message.certificateChain.length; ++i)
                    $root.ClientDownloadRequest.CertificateChain.encode(message.certificateChain[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.trusted != null && Object.hasOwnProperty.call(message, "trusted"))
                writer.uint32(/* id 2, wireType 0 =*/16).bool(message.trusted);
            return writer;
        };

        /**
         * Encodes the specified SignatureInfo message, length delimited. Does not implicitly {@link ClientDownloadRequest.SignatureInfo.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ClientDownloadRequest.SignatureInfo
         * @static
         * @param {ClientDownloadRequest.ISignatureInfo} message SignatureInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SignatureInfo.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a SignatureInfo message from the specified reader or buffer.
         * @function decode
         * @memberof ClientDownloadRequest.SignatureInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ClientDownloadRequest.SignatureInfo} SignatureInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SignatureInfo.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ClientDownloadRequest.SignatureInfo();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.certificateChain && message.certificateChain.length))
                        message.certificateChain = [];
                    message.certificateChain.push($root.ClientDownloadRequest.CertificateChain.decode(reader, reader.uint32()));
                    break;
                case 2:
                    message.trusted = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a SignatureInfo message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ClientDownloadRequest.SignatureInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ClientDownloadRequest.SignatureInfo} SignatureInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SignatureInfo.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a SignatureInfo message.
         * @function verify
         * @memberof ClientDownloadRequest.SignatureInfo
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        SignatureInfo.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.certificateChain != null && message.hasOwnProperty("certificateChain")) {
                if (!Array.isArray(message.certificateChain))
                    return "certificateChain: array expected";
                for (var i = 0; i < message.certificateChain.length; ++i) {
                    var error = $root.ClientDownloadRequest.CertificateChain.verify(message.certificateChain[i]);
                    if (error)
                        return "certificateChain." + error;
                }
            }
            if (message.trusted != null && message.hasOwnProperty("trusted"))
                if (typeof message.trusted !== "boolean")
                    return "trusted: boolean expected";
            return null;
        };

        /**
         * Creates a SignatureInfo message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ClientDownloadRequest.SignatureInfo
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ClientDownloadRequest.SignatureInfo} SignatureInfo
         */
        SignatureInfo.fromObject = function fromObject(object) {
            if (object instanceof $root.ClientDownloadRequest.SignatureInfo)
                return object;
            var message = new $root.ClientDownloadRequest.SignatureInfo();
            if (object.certificateChain) {
                if (!Array.isArray(object.certificateChain))
                    throw TypeError(".ClientDownloadRequest.SignatureInfo.certificateChain: array expected");
                message.certificateChain = [];
                for (var i = 0; i < object.certificateChain.length; ++i) {
                    if (typeof object.certificateChain[i] !== "object")
                        throw TypeError(".ClientDownloadRequest.SignatureInfo.certificateChain: object expected");
                    message.certificateChain[i] = $root.ClientDownloadRequest.CertificateChain.fromObject(object.certificateChain[i]);
                }
            }
            if (object.trusted != null)
                message.trusted = Boolean(object.trusted);
            return message;
        };

        /**
         * Creates a plain object from a SignatureInfo message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ClientDownloadRequest.SignatureInfo
         * @static
         * @param {ClientDownloadRequest.SignatureInfo} message SignatureInfo
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        SignatureInfo.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.certificateChain = [];
            if (options.defaults)
                object.trusted = false;
            if (message.certificateChain && message.certificateChain.length) {
                object.certificateChain = [];
                for (var j = 0; j < message.certificateChain.length; ++j)
                    object.certificateChain[j] = $root.ClientDownloadRequest.CertificateChain.toObject(message.certificateChain[j], options);
            }
            if (message.trusted != null && message.hasOwnProperty("trusted"))
                object.trusted = message.trusted;
            return object;
        };

        /**
         * Converts this SignatureInfo to JSON.
         * @function toJSON
         * @memberof ClientDownloadRequest.SignatureInfo
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        SignatureInfo.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return SignatureInfo;
    })();

    return ClientDownloadRequest;
})();

$root.ClientDownloadResponse = (function() {

    /**
     * Properties of a ClientDownloadResponse.
     * @exports IClientDownloadResponse
     * @interface IClientDownloadResponse
     * @property {number|null} [verdict] ClientDownloadResponse verdict
     * @property {ClientDownloadResponse.IMoreInfo|null} [moreInfo] ClientDownloadResponse moreInfo
     * @property {Uint8Array|null} [token] ClientDownloadResponse token
     */

    /**
     * Constructs a new ClientDownloadResponse.
     * @exports ClientDownloadResponse
     * @classdesc Represents a ClientDownloadResponse.
     * @implements IClientDownloadResponse
     * @constructor
     * @param {IClientDownloadResponse=} [properties] Properties to set
     */
    function ClientDownloadResponse(properties) {
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * ClientDownloadResponse verdict.
     * @member {number} verdict
     * @memberof ClientDownloadResponse
     * @instance
     */
    ClientDownloadResponse.prototype.verdict = 0;

    /**
     * ClientDownloadResponse moreInfo.
     * @member {ClientDownloadResponse.IMoreInfo|null|undefined} moreInfo
     * @memberof ClientDownloadResponse
     * @instance
     */
    ClientDownloadResponse.prototype.moreInfo = null;

    /**
     * ClientDownloadResponse token.
     * @member {Uint8Array} token
     * @memberof ClientDownloadResponse
     * @instance
     */
    ClientDownloadResponse.prototype.token = $util.newBuffer([]);

    /**
     * Creates a new ClientDownloadResponse instance using the specified properties.
     * @function create
     * @memberof ClientDownloadResponse
     * @static
     * @param {IClientDownloadResponse=} [properties] Properties to set
     * @returns {ClientDownloadResponse} ClientDownloadResponse instance
     */
    ClientDownloadResponse.create = function create(properties) {
        return new ClientDownloadResponse(properties);
    };

    /**
     * Encodes the specified ClientDownloadResponse message. Does not implicitly {@link ClientDownloadResponse.verify|verify} messages.
     * @function encode
     * @memberof ClientDownloadResponse
     * @static
     * @param {IClientDownloadResponse} message ClientDownloadResponse message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    ClientDownloadResponse.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.verdict != null && Object.hasOwnProperty.call(message, "verdict"))
            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.verdict);
        if (message.moreInfo != null && Object.hasOwnProperty.call(message, "moreInfo"))
            $root.ClientDownloadResponse.MoreInfo.encode(message.moreInfo, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
        if (message.token != null && Object.hasOwnProperty.call(message, "token"))
            writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.token);
        return writer;
    };

    /**
     * Encodes the specified ClientDownloadResponse message, length delimited. Does not implicitly {@link ClientDownloadResponse.verify|verify} messages.
     * @function encodeDelimited
     * @memberof ClientDownloadResponse
     * @static
     * @param {IClientDownloadResponse} message ClientDownloadResponse message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    ClientDownloadResponse.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a ClientDownloadResponse message from the specified reader or buffer.
     * @function decode
     * @memberof ClientDownloadResponse
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {ClientDownloadResponse} ClientDownloadResponse
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    ClientDownloadResponse.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ClientDownloadResponse();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.verdict = reader.int32();
                break;
            case 2:
                message.moreInfo = $root.ClientDownloadResponse.MoreInfo.decode(reader, reader.uint32());
                break;
            case 3:
                message.token = reader.bytes();
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a ClientDownloadResponse message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof ClientDownloadResponse
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {ClientDownloadResponse} ClientDownloadResponse
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    ClientDownloadResponse.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a ClientDownloadResponse message.
     * @function verify
     * @memberof ClientDownloadResponse
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    ClientDownloadResponse.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.verdict != null && message.hasOwnProperty("verdict"))
            if (!$util.isInteger(message.verdict))
                return "verdict: integer expected";
        if (message.moreInfo != null && message.hasOwnProperty("moreInfo")) {
            var error = $root.ClientDownloadResponse.MoreInfo.verify(message.moreInfo);
            if (error)
                return "moreInfo." + error;
        }
        if (message.token != null && message.hasOwnProperty("token"))
            if (!(message.token && typeof message.token.length === "number" || $util.isString(message.token)))
                return "token: buffer expected";
        return null;
    };

    /**
     * Creates a ClientDownloadResponse message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof ClientDownloadResponse
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {ClientDownloadResponse} ClientDownloadResponse
     */
    ClientDownloadResponse.fromObject = function fromObject(object) {
        if (object instanceof $root.ClientDownloadResponse)
            return object;
        var message = new $root.ClientDownloadResponse();
        if (object.verdict != null)
            message.verdict = object.verdict | 0;
        if (object.moreInfo != null) {
            if (typeof object.moreInfo !== "object")
                throw TypeError(".ClientDownloadResponse.moreInfo: object expected");
            message.moreInfo = $root.ClientDownloadResponse.MoreInfo.fromObject(object.moreInfo);
        }
        if (object.token != null)
            if (typeof object.token === "string")
                $util.base64.decode(object.token, message.token = $util.newBuffer($util.base64.length(object.token)), 0);
            else if (object.token.length)
                message.token = object.token;
        return message;
    };

    /**
     * Creates a plain object from a ClientDownloadResponse message. Also converts values to other types if specified.
     * @function toObject
     * @memberof ClientDownloadResponse
     * @static
     * @param {ClientDownloadResponse} message ClientDownloadResponse
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    ClientDownloadResponse.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        var object = {};
        if (options.defaults) {
            object.verdict = 0;
            object.moreInfo = null;
            if (options.bytes === String)
                object.token = "";
            else {
                object.token = [];
                if (options.bytes !== Array)
                    object.token = $util.newBuffer(object.token);
            }
        }
        if (message.verdict != null && message.hasOwnProperty("verdict"))
            object.verdict = message.verdict;
        if (message.moreInfo != null && message.hasOwnProperty("moreInfo"))
            object.moreInfo = $root.ClientDownloadResponse.MoreInfo.toObject(message.moreInfo, options);
        if (message.token != null && message.hasOwnProperty("token"))
            object.token = options.bytes === String ? $util.base64.encode(message.token, 0, message.token.length) : options.bytes === Array ? Array.prototype.slice.call(message.token) : message.token;
        return object;
    };

    /**
     * Converts this ClientDownloadResponse to JSON.
     * @function toJSON
     * @memberof ClientDownloadResponse
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    ClientDownloadResponse.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    ClientDownloadResponse.MoreInfo = (function() {

        /**
         * Properties of a MoreInfo.
         * @memberof ClientDownloadResponse
         * @interface IMoreInfo
         * @property {string|null} [description] MoreInfo description
         * @property {string|null} [url] MoreInfo url
         */

        /**
         * Constructs a new MoreInfo.
         * @memberof ClientDownloadResponse
         * @classdesc Represents a MoreInfo.
         * @implements IMoreInfo
         * @constructor
         * @param {ClientDownloadResponse.IMoreInfo=} [properties] Properties to set
         */
        function MoreInfo(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * MoreInfo description.
         * @member {string} description
         * @memberof ClientDownloadResponse.MoreInfo
         * @instance
         */
        MoreInfo.prototype.description = "";

        /**
         * MoreInfo url.
         * @member {string} url
         * @memberof ClientDownloadResponse.MoreInfo
         * @instance
         */
        MoreInfo.prototype.url = "";

        /**
         * Creates a new MoreInfo instance using the specified properties.
         * @function create
         * @memberof ClientDownloadResponse.MoreInfo
         * @static
         * @param {ClientDownloadResponse.IMoreInfo=} [properties] Properties to set
         * @returns {ClientDownloadResponse.MoreInfo} MoreInfo instance
         */
        MoreInfo.create = function create(properties) {
            return new MoreInfo(properties);
        };

        /**
         * Encodes the specified MoreInfo message. Does not implicitly {@link ClientDownloadResponse.MoreInfo.verify|verify} messages.
         * @function encode
         * @memberof ClientDownloadResponse.MoreInfo
         * @static
         * @param {ClientDownloadResponse.IMoreInfo} message MoreInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        MoreInfo.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.description != null && Object.hasOwnProperty.call(message, "description"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.description);
            if (message.url != null && Object.hasOwnProperty.call(message, "url"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.url);
            return writer;
        };

        /**
         * Encodes the specified MoreInfo message, length delimited. Does not implicitly {@link ClientDownloadResponse.MoreInfo.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ClientDownloadResponse.MoreInfo
         * @static
         * @param {ClientDownloadResponse.IMoreInfo} message MoreInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        MoreInfo.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a MoreInfo message from the specified reader or buffer.
         * @function decode
         * @memberof ClientDownloadResponse.MoreInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ClientDownloadResponse.MoreInfo} MoreInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        MoreInfo.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ClientDownloadResponse.MoreInfo();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.description = reader.string();
                    break;
                case 2:
                    message.url = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a MoreInfo message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ClientDownloadResponse.MoreInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ClientDownloadResponse.MoreInfo} MoreInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        MoreInfo.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a MoreInfo message.
         * @function verify
         * @memberof ClientDownloadResponse.MoreInfo
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        MoreInfo.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.description != null && message.hasOwnProperty("description"))
                if (!$util.isString(message.description))
                    return "description: string expected";
            if (message.url != null && message.hasOwnProperty("url"))
                if (!$util.isString(message.url))
                    return "url: string expected";
            return null;
        };

        /**
         * Creates a MoreInfo message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ClientDownloadResponse.MoreInfo
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ClientDownloadResponse.MoreInfo} MoreInfo
         */
        MoreInfo.fromObject = function fromObject(object) {
            if (object instanceof $root.ClientDownloadResponse.MoreInfo)
                return object;
            var message = new $root.ClientDownloadResponse.MoreInfo();
            if (object.description != null)
                message.description = String(object.description);
            if (object.url != null)
                message.url = String(object.url);
            return message;
        };

        /**
         * Creates a plain object from a MoreInfo message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ClientDownloadResponse.MoreInfo
         * @static
         * @param {ClientDownloadResponse.MoreInfo} message MoreInfo
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        MoreInfo.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.description = "";
                object.url = "";
            }
            if (message.description != null && message.hasOwnProperty("description"))
                object.description = message.description;
            if (message.url != null && message.hasOwnProperty("url"))
                object.url = message.url;
            return object;
        };

        /**
         * Converts this MoreInfo to JSON.
         * @function toJSON
         * @memberof ClientDownloadResponse.MoreInfo
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        MoreInfo.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return MoreInfo;
    })();

    return ClientDownloadResponse;
})();

$root.ClientDownloadStatsRequest = (function() {

    /**
     * Properties of a ClientDownloadStatsRequest.
     * @exports IClientDownloadStatsRequest
     * @interface IClientDownloadStatsRequest
     * @property {number|null} [userDecision] ClientDownloadStatsRequest userDecision
     * @property {Uint8Array|null} [token] ClientDownloadStatsRequest token
     */

    /**
     * Constructs a new ClientDownloadStatsRequest.
     * @exports ClientDownloadStatsRequest
     * @classdesc Represents a ClientDownloadStatsRequest.
     * @implements IClientDownloadStatsRequest
     * @constructor
     * @param {IClientDownloadStatsRequest=} [properties] Properties to set
     */
    function ClientDownloadStatsRequest(properties) {
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * ClientDownloadStatsRequest userDecision.
     * @member {number} userDecision
     * @memberof ClientDownloadStatsRequest
     * @instance
     */
    ClientDownloadStatsRequest.prototype.userDecision = 0;

    /**
     * ClientDownloadStatsRequest token.
     * @member {Uint8Array} token
     * @memberof ClientDownloadStatsRequest
     * @instance
     */
    ClientDownloadStatsRequest.prototype.token = $util.newBuffer([]);

    /**
     * Creates a new ClientDownloadStatsRequest instance using the specified properties.
     * @function create
     * @memberof ClientDownloadStatsRequest
     * @static
     * @param {IClientDownloadStatsRequest=} [properties] Properties to set
     * @returns {ClientDownloadStatsRequest} ClientDownloadStatsRequest instance
     */
    ClientDownloadStatsRequest.create = function create(properties) {
        return new ClientDownloadStatsRequest(properties);
    };

    /**
     * Encodes the specified ClientDownloadStatsRequest message. Does not implicitly {@link ClientDownloadStatsRequest.verify|verify} messages.
     * @function encode
     * @memberof ClientDownloadStatsRequest
     * @static
     * @param {IClientDownloadStatsRequest} message ClientDownloadStatsRequest message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    ClientDownloadStatsRequest.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.userDecision != null && Object.hasOwnProperty.call(message, "userDecision"))
            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.userDecision);
        if (message.token != null && Object.hasOwnProperty.call(message, "token"))
            writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.token);
        return writer;
    };

    /**
     * Encodes the specified ClientDownloadStatsRequest message, length delimited. Does not implicitly {@link ClientDownloadStatsRequest.verify|verify} messages.
     * @function encodeDelimited
     * @memberof ClientDownloadStatsRequest
     * @static
     * @param {IClientDownloadStatsRequest} message ClientDownloadStatsRequest message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    ClientDownloadStatsRequest.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a ClientDownloadStatsRequest message from the specified reader or buffer.
     * @function decode
     * @memberof ClientDownloadStatsRequest
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {ClientDownloadStatsRequest} ClientDownloadStatsRequest
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    ClientDownloadStatsRequest.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ClientDownloadStatsRequest();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.userDecision = reader.int32();
                break;
            case 2:
                message.token = reader.bytes();
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a ClientDownloadStatsRequest message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof ClientDownloadStatsRequest
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {ClientDownloadStatsRequest} ClientDownloadStatsRequest
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    ClientDownloadStatsRequest.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a ClientDownloadStatsRequest message.
     * @function verify
     * @memberof ClientDownloadStatsRequest
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    ClientDownloadStatsRequest.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.userDecision != null && message.hasOwnProperty("userDecision"))
            if (!$util.isInteger(message.userDecision))
                return "userDecision: integer expected";
        if (message.token != null && message.hasOwnProperty("token"))
            if (!(message.token && typeof message.token.length === "number" || $util.isString(message.token)))
                return "token: buffer expected";
        return null;
    };

    /**
     * Creates a ClientDownloadStatsRequest message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof ClientDownloadStatsRequest
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {ClientDownloadStatsRequest} ClientDownloadStatsRequest
     */
    ClientDownloadStatsRequest.fromObject = function fromObject(object) {
        if (object instanceof $root.ClientDownloadStatsRequest)
            return object;
        var message = new $root.ClientDownloadStatsRequest();
        if (object.userDecision != null)
            message.userDecision = object.userDecision | 0;
        if (object.token != null)
            if (typeof object.token === "string")
                $util.base64.decode(object.token, message.token = $util.newBuffer($util.base64.length(object.token)), 0);
            else if (object.token.length)
                message.token = object.token;
        return message;
    };

    /**
     * Creates a plain object from a ClientDownloadStatsRequest message. Also converts values to other types if specified.
     * @function toObject
     * @memberof ClientDownloadStatsRequest
     * @static
     * @param {ClientDownloadStatsRequest} message ClientDownloadStatsRequest
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    ClientDownloadStatsRequest.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        var object = {};
        if (options.defaults) {
            object.userDecision = 0;
            if (options.bytes === String)
                object.token = "";
            else {
                object.token = [];
                if (options.bytes !== Array)
                    object.token = $util.newBuffer(object.token);
            }
        }
        if (message.userDecision != null && message.hasOwnProperty("userDecision"))
            object.userDecision = message.userDecision;
        if (message.token != null && message.hasOwnProperty("token"))
            object.token = options.bytes === String ? $util.base64.encode(message.token, 0, message.token.length) : options.bytes === Array ? Array.prototype.slice.call(message.token) : message.token;
        return object;
    };

    /**
     * Converts this ClientDownloadStatsRequest to JSON.
     * @function toJSON
     * @memberof ClientDownloadStatsRequest
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    ClientDownloadStatsRequest.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return ClientDownloadStatsRequest;
})();

$root.DebugInfo = (function() {

    /**
     * Properties of a DebugInfo.
     * @exports IDebugInfo
     * @interface IDebugInfo
     * @property {Array.<string>|null} [message] DebugInfo message
     * @property {Array.<DebugInfo.ITiming>|null} [timing] DebugInfo timing
     */

    /**
     * Constructs a new DebugInfo.
     * @exports DebugInfo
     * @classdesc Represents a DebugInfo.
     * @implements IDebugInfo
     * @constructor
     * @param {IDebugInfo=} [properties] Properties to set
     */
    function DebugInfo(properties) {
        this.message = [];
        this.timing = [];
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * DebugInfo message.
     * @member {Array.<string>} message
     * @memberof DebugInfo
     * @instance
     */
    DebugInfo.prototype.message = $util.emptyArray;

    /**
     * DebugInfo timing.
     * @member {Array.<DebugInfo.ITiming>} timing
     * @memberof DebugInfo
     * @instance
     */
    DebugInfo.prototype.timing = $util.emptyArray;

    /**
     * Creates a new DebugInfo instance using the specified properties.
     * @function create
     * @memberof DebugInfo
     * @static
     * @param {IDebugInfo=} [properties] Properties to set
     * @returns {DebugInfo} DebugInfo instance
     */
    DebugInfo.create = function create(properties) {
        return new DebugInfo(properties);
    };

    /**
     * Encodes the specified DebugInfo message. Does not implicitly {@link DebugInfo.verify|verify} messages.
     * @function encode
     * @memberof DebugInfo
     * @static
     * @param {IDebugInfo} message DebugInfo message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    DebugInfo.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.message != null && message.message.length)
            for (var i = 0; i < message.message.length; ++i)
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.message[i]);
        if (message.timing != null && message.timing.length)
            for (var i = 0; i < message.timing.length; ++i)
                $root.DebugInfo.Timing.encode(message.timing[i], writer.uint32(/* id 2, wireType 3 =*/19)).uint32(/* id 2, wireType 4 =*/20);
        return writer;
    };

    /**
     * Encodes the specified DebugInfo message, length delimited. Does not implicitly {@link DebugInfo.verify|verify} messages.
     * @function encodeDelimited
     * @memberof DebugInfo
     * @static
     * @param {IDebugInfo} message DebugInfo message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    DebugInfo.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a DebugInfo message from the specified reader or buffer.
     * @function decode
     * @memberof DebugInfo
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {DebugInfo} DebugInfo
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    DebugInfo.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.DebugInfo();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                if (!(message.message && message.message.length))
                    message.message = [];
                message.message.push(reader.string());
                break;
            case 2:
                if (!(message.timing && message.timing.length))
                    message.timing = [];
                message.timing.push($root.DebugInfo.Timing.decode(reader));
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a DebugInfo message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof DebugInfo
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {DebugInfo} DebugInfo
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    DebugInfo.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a DebugInfo message.
     * @function verify
     * @memberof DebugInfo
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    DebugInfo.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.message != null && message.hasOwnProperty("message")) {
            if (!Array.isArray(message.message))
                return "message: array expected";
            for (var i = 0; i < message.message.length; ++i)
                if (!$util.isString(message.message[i]))
                    return "message: string[] expected";
        }
        if (message.timing != null && message.hasOwnProperty("timing")) {
            if (!Array.isArray(message.timing))
                return "timing: array expected";
            for (var i = 0; i < message.timing.length; ++i) {
                var error = $root.DebugInfo.Timing.verify(message.timing[i]);
                if (error)
                    return "timing." + error;
            }
        }
        return null;
    };

    /**
     * Creates a DebugInfo message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof DebugInfo
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {DebugInfo} DebugInfo
     */
    DebugInfo.fromObject = function fromObject(object) {
        if (object instanceof $root.DebugInfo)
            return object;
        var message = new $root.DebugInfo();
        if (object.message) {
            if (!Array.isArray(object.message))
                throw TypeError(".DebugInfo.message: array expected");
            message.message = [];
            for (var i = 0; i < object.message.length; ++i)
                message.message[i] = String(object.message[i]);
        }
        if (object.timing) {
            if (!Array.isArray(object.timing))
                throw TypeError(".DebugInfo.timing: array expected");
            message.timing = [];
            for (var i = 0; i < object.timing.length; ++i) {
                if (typeof object.timing[i] !== "object")
                    throw TypeError(".DebugInfo.timing: object expected");
                message.timing[i] = $root.DebugInfo.Timing.fromObject(object.timing[i]);
            }
        }
        return message;
    };

    /**
     * Creates a plain object from a DebugInfo message. Also converts values to other types if specified.
     * @function toObject
     * @memberof DebugInfo
     * @static
     * @param {DebugInfo} message DebugInfo
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    DebugInfo.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        var object = {};
        if (options.arrays || options.defaults) {
            object.message = [];
            object.timing = [];
        }
        if (message.message && message.message.length) {
            object.message = [];
            for (var j = 0; j < message.message.length; ++j)
                object.message[j] = message.message[j];
        }
        if (message.timing && message.timing.length) {
            object.timing = [];
            for (var j = 0; j < message.timing.length; ++j)
                object.timing[j] = $root.DebugInfo.Timing.toObject(message.timing[j], options);
        }
        return object;
    };

    /**
     * Converts this DebugInfo to JSON.
     * @function toJSON
     * @memberof DebugInfo
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    DebugInfo.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    DebugInfo.Timing = (function() {

        /**
         * Properties of a Timing.
         * @memberof DebugInfo
         * @interface ITiming
         * @property {string|null} [name] Timing name
         * @property {number|null} [timeInMs] Timing timeInMs
         */

        /**
         * Constructs a new Timing.
         * @memberof DebugInfo
         * @classdesc Represents a Timing.
         * @implements ITiming
         * @constructor
         * @param {DebugInfo.ITiming=} [properties] Properties to set
         */
        function Timing(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Timing name.
         * @member {string} name
         * @memberof DebugInfo.Timing
         * @instance
         */
        Timing.prototype.name = "";

        /**
         * Timing timeInMs.
         * @member {number} timeInMs
         * @memberof DebugInfo.Timing
         * @instance
         */
        Timing.prototype.timeInMs = 0;

        /**
         * Creates a new Timing instance using the specified properties.
         * @function create
         * @memberof DebugInfo.Timing
         * @static
         * @param {DebugInfo.ITiming=} [properties] Properties to set
         * @returns {DebugInfo.Timing} Timing instance
         */
        Timing.create = function create(properties) {
            return new Timing(properties);
        };

        /**
         * Encodes the specified Timing message. Does not implicitly {@link DebugInfo.Timing.verify|verify} messages.
         * @function encode
         * @memberof DebugInfo.Timing
         * @static
         * @param {DebugInfo.ITiming} message Timing message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Timing.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.name);
            if (message.timeInMs != null && Object.hasOwnProperty.call(message, "timeInMs"))
                writer.uint32(/* id 4, wireType 1 =*/33).double(message.timeInMs);
            return writer;
        };

        /**
         * Encodes the specified Timing message, length delimited. Does not implicitly {@link DebugInfo.Timing.verify|verify} messages.
         * @function encodeDelimited
         * @memberof DebugInfo.Timing
         * @static
         * @param {DebugInfo.ITiming} message Timing message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Timing.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Timing message from the specified reader or buffer.
         * @function decode
         * @memberof DebugInfo.Timing
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {DebugInfo.Timing} Timing
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Timing.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.DebugInfo.Timing();
            while (reader.pos < end) {
                var tag = reader.uint32();
                if ((tag & 7) === 4)
                    break;
                switch (tag >>> 3) {
                case 3:
                    message.name = reader.string();
                    break;
                case 4:
                    message.timeInMs = reader.double();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a Timing message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof DebugInfo.Timing
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {DebugInfo.Timing} Timing
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Timing.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Timing message.
         * @function verify
         * @memberof DebugInfo.Timing
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Timing.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.name != null && message.hasOwnProperty("name"))
                if (!$util.isString(message.name))
                    return "name: string expected";
            if (message.timeInMs != null && message.hasOwnProperty("timeInMs"))
                if (typeof message.timeInMs !== "number")
                    return "timeInMs: number expected";
            return null;
        };

        /**
         * Creates a Timing message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof DebugInfo.Timing
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {DebugInfo.Timing} Timing
         */
        Timing.fromObject = function fromObject(object) {
            if (object instanceof $root.DebugInfo.Timing)
                return object;
            var message = new $root.DebugInfo.Timing();
            if (object.name != null)
                message.name = String(object.name);
            if (object.timeInMs != null)
                message.timeInMs = Number(object.timeInMs);
            return message;
        };

        /**
         * Creates a plain object from a Timing message. Also converts values to other types if specified.
         * @function toObject
         * @memberof DebugInfo.Timing
         * @static
         * @param {DebugInfo.Timing} message Timing
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Timing.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.name = "";
                object.timeInMs = 0;
            }
            if (message.name != null && message.hasOwnProperty("name"))
                object.name = message.name;
            if (message.timeInMs != null && message.hasOwnProperty("timeInMs"))
                object.timeInMs = options.json && !isFinite(message.timeInMs) ? String(message.timeInMs) : message.timeInMs;
            return object;
        };

        /**
         * Converts this Timing to JSON.
         * @function toJSON
         * @memberof DebugInfo.Timing
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Timing.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Timing;
    })();

    return DebugInfo;
})();

$root.DebugSettingsResponse = (function() {

    /**
     * Properties of a DebugSettingsResponse.
     * @exports IDebugSettingsResponse
     * @interface IDebugSettingsResponse
     * @property {string|null} [playCountryOverride] DebugSettingsResponse playCountryOverride
     * @property {string|null} [playCountryDebugInfo] DebugSettingsResponse playCountryDebugInfo
     */

    /**
     * Constructs a new DebugSettingsResponse.
     * @exports DebugSettingsResponse
     * @classdesc Represents a DebugSettingsResponse.
     * @implements IDebugSettingsResponse
     * @constructor
     * @param {IDebugSettingsResponse=} [properties] Properties to set
     */
    function DebugSettingsResponse(properties) {
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * DebugSettingsResponse playCountryOverride.
     * @member {string} playCountryOverride
     * @memberof DebugSettingsResponse
     * @instance
     */
    DebugSettingsResponse.prototype.playCountryOverride = "";

    /**
     * DebugSettingsResponse playCountryDebugInfo.
     * @member {string} playCountryDebugInfo
     * @memberof DebugSettingsResponse
     * @instance
     */
    DebugSettingsResponse.prototype.playCountryDebugInfo = "";

    /**
     * Creates a new DebugSettingsResponse instance using the specified properties.
     * @function create
     * @memberof DebugSettingsResponse
     * @static
     * @param {IDebugSettingsResponse=} [properties] Properties to set
     * @returns {DebugSettingsResponse} DebugSettingsResponse instance
     */
    DebugSettingsResponse.create = function create(properties) {
        return new DebugSettingsResponse(properties);
    };

    /**
     * Encodes the specified DebugSettingsResponse message. Does not implicitly {@link DebugSettingsResponse.verify|verify} messages.
     * @function encode
     * @memberof DebugSettingsResponse
     * @static
     * @param {IDebugSettingsResponse} message DebugSettingsResponse message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    DebugSettingsResponse.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.playCountryOverride != null && Object.hasOwnProperty.call(message, "playCountryOverride"))
            writer.uint32(/* id 1, wireType 2 =*/10).string(message.playCountryOverride);
        if (message.playCountryDebugInfo != null && Object.hasOwnProperty.call(message, "playCountryDebugInfo"))
            writer.uint32(/* id 2, wireType 2 =*/18).string(message.playCountryDebugInfo);
        return writer;
    };

    /**
     * Encodes the specified DebugSettingsResponse message, length delimited. Does not implicitly {@link DebugSettingsResponse.verify|verify} messages.
     * @function encodeDelimited
     * @memberof DebugSettingsResponse
     * @static
     * @param {IDebugSettingsResponse} message DebugSettingsResponse message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    DebugSettingsResponse.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a DebugSettingsResponse message from the specified reader or buffer.
     * @function decode
     * @memberof DebugSettingsResponse
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {DebugSettingsResponse} DebugSettingsResponse
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    DebugSettingsResponse.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.DebugSettingsResponse();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.playCountryOverride = reader.string();
                break;
            case 2:
                message.playCountryDebugInfo = reader.string();
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a DebugSettingsResponse message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof DebugSettingsResponse
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {DebugSettingsResponse} DebugSettingsResponse
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    DebugSettingsResponse.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a DebugSettingsResponse message.
     * @function verify
     * @memberof DebugSettingsResponse
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    DebugSettingsResponse.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.playCountryOverride != null && message.hasOwnProperty("playCountryOverride"))
            if (!$util.isString(message.playCountryOverride))
                return "playCountryOverride: string expected";
        if (message.playCountryDebugInfo != null && message.hasOwnProperty("playCountryDebugInfo"))
            if (!$util.isString(message.playCountryDebugInfo))
                return "playCountryDebugInfo: string expected";
        return null;
    };

    /**
     * Creates a DebugSettingsResponse message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof DebugSettingsResponse
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {DebugSettingsResponse} DebugSettingsResponse
     */
    DebugSettingsResponse.fromObject = function fromObject(object) {
        if (object instanceof $root.DebugSettingsResponse)
            return object;
        var message = new $root.DebugSettingsResponse();
        if (object.playCountryOverride != null)
            message.playCountryOverride = String(object.playCountryOverride);
        if (object.playCountryDebugInfo != null)
            message.playCountryDebugInfo = String(object.playCountryDebugInfo);
        return message;
    };

    /**
     * Creates a plain object from a DebugSettingsResponse message. Also converts values to other types if specified.
     * @function toObject
     * @memberof DebugSettingsResponse
     * @static
     * @param {DebugSettingsResponse} message DebugSettingsResponse
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    DebugSettingsResponse.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        var object = {};
        if (options.defaults) {
            object.playCountryOverride = "";
            object.playCountryDebugInfo = "";
        }
        if (message.playCountryOverride != null && message.hasOwnProperty("playCountryOverride"))
            object.playCountryOverride = message.playCountryOverride;
        if (message.playCountryDebugInfo != null && message.hasOwnProperty("playCountryDebugInfo"))
            object.playCountryDebugInfo = message.playCountryDebugInfo;
        return object;
    };

    /**
     * Converts this DebugSettingsResponse to JSON.
     * @function toJSON
     * @memberof DebugSettingsResponse
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    DebugSettingsResponse.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return DebugSettingsResponse;
})();

$root.DeliveryResponse = (function() {

    /**
     * Properties of a DeliveryResponse.
     * @exports IDeliveryResponse
     * @interface IDeliveryResponse
     * @property {number|null} [status] DeliveryResponse status
     * @property {IAndroidAppDeliveryData|null} [appDeliveryData] DeliveryResponse appDeliveryData
     */

    /**
     * Constructs a new DeliveryResponse.
     * @exports DeliveryResponse
     * @classdesc Represents a DeliveryResponse.
     * @implements IDeliveryResponse
     * @constructor
     * @param {IDeliveryResponse=} [properties] Properties to set
     */
    function DeliveryResponse(properties) {
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * DeliveryResponse status.
     * @member {number} status
     * @memberof DeliveryResponse
     * @instance
     */
    DeliveryResponse.prototype.status = 1;

    /**
     * DeliveryResponse appDeliveryData.
     * @member {IAndroidAppDeliveryData|null|undefined} appDeliveryData
     * @memberof DeliveryResponse
     * @instance
     */
    DeliveryResponse.prototype.appDeliveryData = null;

    /**
     * Creates a new DeliveryResponse instance using the specified properties.
     * @function create
     * @memberof DeliveryResponse
     * @static
     * @param {IDeliveryResponse=} [properties] Properties to set
     * @returns {DeliveryResponse} DeliveryResponse instance
     */
    DeliveryResponse.create = function create(properties) {
        return new DeliveryResponse(properties);
    };

    /**
     * Encodes the specified DeliveryResponse message. Does not implicitly {@link DeliveryResponse.verify|verify} messages.
     * @function encode
     * @memberof DeliveryResponse
     * @static
     * @param {IDeliveryResponse} message DeliveryResponse message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    DeliveryResponse.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.status != null && Object.hasOwnProperty.call(message, "status"))
            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.status);
        if (message.appDeliveryData != null && Object.hasOwnProperty.call(message, "appDeliveryData"))
            $root.AndroidAppDeliveryData.encode(message.appDeliveryData, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
        return writer;
    };

    /**
     * Encodes the specified DeliveryResponse message, length delimited. Does not implicitly {@link DeliveryResponse.verify|verify} messages.
     * @function encodeDelimited
     * @memberof DeliveryResponse
     * @static
     * @param {IDeliveryResponse} message DeliveryResponse message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    DeliveryResponse.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a DeliveryResponse message from the specified reader or buffer.
     * @function decode
     * @memberof DeliveryResponse
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {DeliveryResponse} DeliveryResponse
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    DeliveryResponse.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.DeliveryResponse();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.status = reader.int32();
                break;
            case 2:
                message.appDeliveryData = $root.AndroidAppDeliveryData.decode(reader, reader.uint32());
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a DeliveryResponse message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof DeliveryResponse
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {DeliveryResponse} DeliveryResponse
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    DeliveryResponse.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a DeliveryResponse message.
     * @function verify
     * @memberof DeliveryResponse
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    DeliveryResponse.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.status != null && message.hasOwnProperty("status"))
            if (!$util.isInteger(message.status))
                return "status: integer expected";
        if (message.appDeliveryData != null && message.hasOwnProperty("appDeliveryData")) {
            var error = $root.AndroidAppDeliveryData.verify(message.appDeliveryData);
            if (error)
                return "appDeliveryData." + error;
        }
        return null;
    };

    /**
     * Creates a DeliveryResponse message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof DeliveryResponse
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {DeliveryResponse} DeliveryResponse
     */
    DeliveryResponse.fromObject = function fromObject(object) {
        if (object instanceof $root.DeliveryResponse)
            return object;
        var message = new $root.DeliveryResponse();
        if (object.status != null)
            message.status = object.status | 0;
        if (object.appDeliveryData != null) {
            if (typeof object.appDeliveryData !== "object")
                throw TypeError(".DeliveryResponse.appDeliveryData: object expected");
            message.appDeliveryData = $root.AndroidAppDeliveryData.fromObject(object.appDeliveryData);
        }
        return message;
    };

    /**
     * Creates a plain object from a DeliveryResponse message. Also converts values to other types if specified.
     * @function toObject
     * @memberof DeliveryResponse
     * @static
     * @param {DeliveryResponse} message DeliveryResponse
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    DeliveryResponse.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        var object = {};
        if (options.defaults) {
            object.status = 1;
            object.appDeliveryData = null;
        }
        if (message.status != null && message.hasOwnProperty("status"))
            object.status = message.status;
        if (message.appDeliveryData != null && message.hasOwnProperty("appDeliveryData"))
            object.appDeliveryData = $root.AndroidAppDeliveryData.toObject(message.appDeliveryData, options);
        return object;
    };

    /**
     * Converts this DeliveryResponse to JSON.
     * @function toJSON
     * @memberof DeliveryResponse
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    DeliveryResponse.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return DeliveryResponse;
})();

$root.BulkDetailsEntry = (function() {

    /**
     * Properties of a BulkDetailsEntry.
     * @exports IBulkDetailsEntry
     * @interface IBulkDetailsEntry
     * @property {IItem|null} [item] BulkDetailsEntry item
     */

    /**
     * Constructs a new BulkDetailsEntry.
     * @exports BulkDetailsEntry
     * @classdesc Represents a BulkDetailsEntry.
     * @implements IBulkDetailsEntry
     * @constructor
     * @param {IBulkDetailsEntry=} [properties] Properties to set
     */
    function BulkDetailsEntry(properties) {
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * BulkDetailsEntry item.
     * @member {IItem|null|undefined} item
     * @memberof BulkDetailsEntry
     * @instance
     */
    BulkDetailsEntry.prototype.item = null;

    /**
     * Creates a new BulkDetailsEntry instance using the specified properties.
     * @function create
     * @memberof BulkDetailsEntry
     * @static
     * @param {IBulkDetailsEntry=} [properties] Properties to set
     * @returns {BulkDetailsEntry} BulkDetailsEntry instance
     */
    BulkDetailsEntry.create = function create(properties) {
        return new BulkDetailsEntry(properties);
    };

    /**
     * Encodes the specified BulkDetailsEntry message. Does not implicitly {@link BulkDetailsEntry.verify|verify} messages.
     * @function encode
     * @memberof BulkDetailsEntry
     * @static
     * @param {IBulkDetailsEntry} message BulkDetailsEntry message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    BulkDetailsEntry.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.item != null && Object.hasOwnProperty.call(message, "item"))
            $root.Item.encode(message.item, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
        return writer;
    };

    /**
     * Encodes the specified BulkDetailsEntry message, length delimited. Does not implicitly {@link BulkDetailsEntry.verify|verify} messages.
     * @function encodeDelimited
     * @memberof BulkDetailsEntry
     * @static
     * @param {IBulkDetailsEntry} message BulkDetailsEntry message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    BulkDetailsEntry.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a BulkDetailsEntry message from the specified reader or buffer.
     * @function decode
     * @memberof BulkDetailsEntry
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {BulkDetailsEntry} BulkDetailsEntry
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    BulkDetailsEntry.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.BulkDetailsEntry();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.item = $root.Item.decode(reader, reader.uint32());
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a BulkDetailsEntry message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof BulkDetailsEntry
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {BulkDetailsEntry} BulkDetailsEntry
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    BulkDetailsEntry.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a BulkDetailsEntry message.
     * @function verify
     * @memberof BulkDetailsEntry
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    BulkDetailsEntry.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.item != null && message.hasOwnProperty("item")) {
            var error = $root.Item.verify(message.item);
            if (error)
                return "item." + error;
        }
        return null;
    };

    /**
     * Creates a BulkDetailsEntry message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof BulkDetailsEntry
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {BulkDetailsEntry} BulkDetailsEntry
     */
    BulkDetailsEntry.fromObject = function fromObject(object) {
        if (object instanceof $root.BulkDetailsEntry)
            return object;
        var message = new $root.BulkDetailsEntry();
        if (object.item != null) {
            if (typeof object.item !== "object")
                throw TypeError(".BulkDetailsEntry.item: object expected");
            message.item = $root.Item.fromObject(object.item);
        }
        return message;
    };

    /**
     * Creates a plain object from a BulkDetailsEntry message. Also converts values to other types if specified.
     * @function toObject
     * @memberof BulkDetailsEntry
     * @static
     * @param {BulkDetailsEntry} message BulkDetailsEntry
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    BulkDetailsEntry.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        var object = {};
        if (options.defaults)
            object.item = null;
        if (message.item != null && message.hasOwnProperty("item"))
            object.item = $root.Item.toObject(message.item, options);
        return object;
    };

    /**
     * Converts this BulkDetailsEntry to JSON.
     * @function toJSON
     * @memberof BulkDetailsEntry
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    BulkDetailsEntry.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return BulkDetailsEntry;
})();

$root.BulkDetailsRequest = (function() {

    /**
     * Properties of a BulkDetailsRequest.
     * @exports IBulkDetailsRequest
     * @interface IBulkDetailsRequest
     * @property {Array.<string>|null} [DocId] BulkDetailsRequest DocId
     * @property {boolean|null} [includeChildDocs] BulkDetailsRequest includeChildDocs
     * @property {boolean|null} [includeDetails] BulkDetailsRequest includeDetails
     * @property {string|null} [sourcePackageName] BulkDetailsRequest sourcePackageName
     * @property {Array.<number>|null} [installedVersionCode] BulkDetailsRequest installedVersionCode
     */

    /**
     * Constructs a new BulkDetailsRequest.
     * @exports BulkDetailsRequest
     * @classdesc Represents a BulkDetailsRequest.
     * @implements IBulkDetailsRequest
     * @constructor
     * @param {IBulkDetailsRequest=} [properties] Properties to set
     */
    function BulkDetailsRequest(properties) {
        this.DocId = [];
        this.installedVersionCode = [];
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * BulkDetailsRequest DocId.
     * @member {Array.<string>} DocId
     * @memberof BulkDetailsRequest
     * @instance
     */
    BulkDetailsRequest.prototype.DocId = $util.emptyArray;

    /**
     * BulkDetailsRequest includeChildDocs.
     * @member {boolean} includeChildDocs
     * @memberof BulkDetailsRequest
     * @instance
     */
    BulkDetailsRequest.prototype.includeChildDocs = true;

    /**
     * BulkDetailsRequest includeDetails.
     * @member {boolean} includeDetails
     * @memberof BulkDetailsRequest
     * @instance
     */
    BulkDetailsRequest.prototype.includeDetails = false;

    /**
     * BulkDetailsRequest sourcePackageName.
     * @member {string} sourcePackageName
     * @memberof BulkDetailsRequest
     * @instance
     */
    BulkDetailsRequest.prototype.sourcePackageName = "";

    /**
     * BulkDetailsRequest installedVersionCode.
     * @member {Array.<number>} installedVersionCode
     * @memberof BulkDetailsRequest
     * @instance
     */
    BulkDetailsRequest.prototype.installedVersionCode = $util.emptyArray;

    /**
     * Creates a new BulkDetailsRequest instance using the specified properties.
     * @function create
     * @memberof BulkDetailsRequest
     * @static
     * @param {IBulkDetailsRequest=} [properties] Properties to set
     * @returns {BulkDetailsRequest} BulkDetailsRequest instance
     */
    BulkDetailsRequest.create = function create(properties) {
        return new BulkDetailsRequest(properties);
    };

    /**
     * Encodes the specified BulkDetailsRequest message. Does not implicitly {@link BulkDetailsRequest.verify|verify} messages.
     * @function encode
     * @memberof BulkDetailsRequest
     * @static
     * @param {IBulkDetailsRequest} message BulkDetailsRequest message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    BulkDetailsRequest.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.DocId != null && message.DocId.length)
            for (var i = 0; i < message.DocId.length; ++i)
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.DocId[i]);
        if (message.includeChildDocs != null && Object.hasOwnProperty.call(message, "includeChildDocs"))
            writer.uint32(/* id 2, wireType 0 =*/16).bool(message.includeChildDocs);
        if (message.includeDetails != null && Object.hasOwnProperty.call(message, "includeDetails"))
            writer.uint32(/* id 3, wireType 0 =*/24).bool(message.includeDetails);
        if (message.sourcePackageName != null && Object.hasOwnProperty.call(message, "sourcePackageName"))
            writer.uint32(/* id 4, wireType 2 =*/34).string(message.sourcePackageName);
        if (message.installedVersionCode != null && message.installedVersionCode.length)
            for (var i = 0; i < message.installedVersionCode.length; ++i)
                writer.uint32(/* id 7, wireType 0 =*/56).int32(message.installedVersionCode[i]);
        return writer;
    };

    /**
     * Encodes the specified BulkDetailsRequest message, length delimited. Does not implicitly {@link BulkDetailsRequest.verify|verify} messages.
     * @function encodeDelimited
     * @memberof BulkDetailsRequest
     * @static
     * @param {IBulkDetailsRequest} message BulkDetailsRequest message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    BulkDetailsRequest.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a BulkDetailsRequest message from the specified reader or buffer.
     * @function decode
     * @memberof BulkDetailsRequest
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {BulkDetailsRequest} BulkDetailsRequest
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    BulkDetailsRequest.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.BulkDetailsRequest();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                if (!(message.DocId && message.DocId.length))
                    message.DocId = [];
                message.DocId.push(reader.string());
                break;
            case 2:
                message.includeChildDocs = reader.bool();
                break;
            case 3:
                message.includeDetails = reader.bool();
                break;
            case 4:
                message.sourcePackageName = reader.string();
                break;
            case 7:
                if (!(message.installedVersionCode && message.installedVersionCode.length))
                    message.installedVersionCode = [];
                if ((tag & 7) === 2) {
                    var end2 = reader.uint32() + reader.pos;
                    while (reader.pos < end2)
                        message.installedVersionCode.push(reader.int32());
                } else
                    message.installedVersionCode.push(reader.int32());
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a BulkDetailsRequest message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof BulkDetailsRequest
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {BulkDetailsRequest} BulkDetailsRequest
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    BulkDetailsRequest.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a BulkDetailsRequest message.
     * @function verify
     * @memberof BulkDetailsRequest
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    BulkDetailsRequest.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.DocId != null && message.hasOwnProperty("DocId")) {
            if (!Array.isArray(message.DocId))
                return "DocId: array expected";
            for (var i = 0; i < message.DocId.length; ++i)
                if (!$util.isString(message.DocId[i]))
                    return "DocId: string[] expected";
        }
        if (message.includeChildDocs != null && message.hasOwnProperty("includeChildDocs"))
            if (typeof message.includeChildDocs !== "boolean")
                return "includeChildDocs: boolean expected";
        if (message.includeDetails != null && message.hasOwnProperty("includeDetails"))
            if (typeof message.includeDetails !== "boolean")
                return "includeDetails: boolean expected";
        if (message.sourcePackageName != null && message.hasOwnProperty("sourcePackageName"))
            if (!$util.isString(message.sourcePackageName))
                return "sourcePackageName: string expected";
        if (message.installedVersionCode != null && message.hasOwnProperty("installedVersionCode")) {
            if (!Array.isArray(message.installedVersionCode))
                return "installedVersionCode: array expected";
            for (var i = 0; i < message.installedVersionCode.length; ++i)
                if (!$util.isInteger(message.installedVersionCode[i]))
                    return "installedVersionCode: integer[] expected";
        }
        return null;
    };

    /**
     * Creates a BulkDetailsRequest message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof BulkDetailsRequest
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {BulkDetailsRequest} BulkDetailsRequest
     */
    BulkDetailsRequest.fromObject = function fromObject(object) {
        if (object instanceof $root.BulkDetailsRequest)
            return object;
        var message = new $root.BulkDetailsRequest();
        if (object.DocId) {
            if (!Array.isArray(object.DocId))
                throw TypeError(".BulkDetailsRequest.DocId: array expected");
            message.DocId = [];
            for (var i = 0; i < object.DocId.length; ++i)
                message.DocId[i] = String(object.DocId[i]);
        }
        if (object.includeChildDocs != null)
            message.includeChildDocs = Boolean(object.includeChildDocs);
        if (object.includeDetails != null)
            message.includeDetails = Boolean(object.includeDetails);
        if (object.sourcePackageName != null)
            message.sourcePackageName = String(object.sourcePackageName);
        if (object.installedVersionCode) {
            if (!Array.isArray(object.installedVersionCode))
                throw TypeError(".BulkDetailsRequest.installedVersionCode: array expected");
            message.installedVersionCode = [];
            for (var i = 0; i < object.installedVersionCode.length; ++i)
                message.installedVersionCode[i] = object.installedVersionCode[i] | 0;
        }
        return message;
    };

    /**
     * Creates a plain object from a BulkDetailsRequest message. Also converts values to other types if specified.
     * @function toObject
     * @memberof BulkDetailsRequest
     * @static
     * @param {BulkDetailsRequest} message BulkDetailsRequest
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    BulkDetailsRequest.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        var object = {};
        if (options.arrays || options.defaults) {
            object.DocId = [];
            object.installedVersionCode = [];
        }
        if (options.defaults) {
            object.includeChildDocs = true;
            object.includeDetails = false;
            object.sourcePackageName = "";
        }
        if (message.DocId && message.DocId.length) {
            object.DocId = [];
            for (var j = 0; j < message.DocId.length; ++j)
                object.DocId[j] = message.DocId[j];
        }
        if (message.includeChildDocs != null && message.hasOwnProperty("includeChildDocs"))
            object.includeChildDocs = message.includeChildDocs;
        if (message.includeDetails != null && message.hasOwnProperty("includeDetails"))
            object.includeDetails = message.includeDetails;
        if (message.sourcePackageName != null && message.hasOwnProperty("sourcePackageName"))
            object.sourcePackageName = message.sourcePackageName;
        if (message.installedVersionCode && message.installedVersionCode.length) {
            object.installedVersionCode = [];
            for (var j = 0; j < message.installedVersionCode.length; ++j)
                object.installedVersionCode[j] = message.installedVersionCode[j];
        }
        return object;
    };

    /**
     * Converts this BulkDetailsRequest to JSON.
     * @function toJSON
     * @memberof BulkDetailsRequest
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    BulkDetailsRequest.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return BulkDetailsRequest;
})();

$root.BulkDetailsResponse = (function() {

    /**
     * Properties of a BulkDetailsResponse.
     * @exports IBulkDetailsResponse
     * @interface IBulkDetailsResponse
     * @property {Array.<IBulkDetailsEntry>|null} [entry] BulkDetailsResponse entry
     */

    /**
     * Constructs a new BulkDetailsResponse.
     * @exports BulkDetailsResponse
     * @classdesc Represents a BulkDetailsResponse.
     * @implements IBulkDetailsResponse
     * @constructor
     * @param {IBulkDetailsResponse=} [properties] Properties to set
     */
    function BulkDetailsResponse(properties) {
        this.entry = [];
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * BulkDetailsResponse entry.
     * @member {Array.<IBulkDetailsEntry>} entry
     * @memberof BulkDetailsResponse
     * @instance
     */
    BulkDetailsResponse.prototype.entry = $util.emptyArray;

    /**
     * Creates a new BulkDetailsResponse instance using the specified properties.
     * @function create
     * @memberof BulkDetailsResponse
     * @static
     * @param {IBulkDetailsResponse=} [properties] Properties to set
     * @returns {BulkDetailsResponse} BulkDetailsResponse instance
     */
    BulkDetailsResponse.create = function create(properties) {
        return new BulkDetailsResponse(properties);
    };

    /**
     * Encodes the specified BulkDetailsResponse message. Does not implicitly {@link BulkDetailsResponse.verify|verify} messages.
     * @function encode
     * @memberof BulkDetailsResponse
     * @static
     * @param {IBulkDetailsResponse} message BulkDetailsResponse message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    BulkDetailsResponse.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.entry != null && message.entry.length)
            for (var i = 0; i < message.entry.length; ++i)
                $root.BulkDetailsEntry.encode(message.entry[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
        return writer;
    };

    /**
     * Encodes the specified BulkDetailsResponse message, length delimited. Does not implicitly {@link BulkDetailsResponse.verify|verify} messages.
     * @function encodeDelimited
     * @memberof BulkDetailsResponse
     * @static
     * @param {IBulkDetailsResponse} message BulkDetailsResponse message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    BulkDetailsResponse.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a BulkDetailsResponse message from the specified reader or buffer.
     * @function decode
     * @memberof BulkDetailsResponse
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {BulkDetailsResponse} BulkDetailsResponse
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    BulkDetailsResponse.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.BulkDetailsResponse();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                if (!(message.entry && message.entry.length))
                    message.entry = [];
                message.entry.push($root.BulkDetailsEntry.decode(reader, reader.uint32()));
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a BulkDetailsResponse message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof BulkDetailsResponse
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {BulkDetailsResponse} BulkDetailsResponse
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    BulkDetailsResponse.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a BulkDetailsResponse message.
     * @function verify
     * @memberof BulkDetailsResponse
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    BulkDetailsResponse.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.entry != null && message.hasOwnProperty("entry")) {
            if (!Array.isArray(message.entry))
                return "entry: array expected";
            for (var i = 0; i < message.entry.length; ++i) {
                var error = $root.BulkDetailsEntry.verify(message.entry[i]);
                if (error)
                    return "entry." + error;
            }
        }
        return null;
    };

    /**
     * Creates a BulkDetailsResponse message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof BulkDetailsResponse
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {BulkDetailsResponse} BulkDetailsResponse
     */
    BulkDetailsResponse.fromObject = function fromObject(object) {
        if (object instanceof $root.BulkDetailsResponse)
            return object;
        var message = new $root.BulkDetailsResponse();
        if (object.entry) {
            if (!Array.isArray(object.entry))
                throw TypeError(".BulkDetailsResponse.entry: array expected");
            message.entry = [];
            for (var i = 0; i < object.entry.length; ++i) {
                if (typeof object.entry[i] !== "object")
                    throw TypeError(".BulkDetailsResponse.entry: object expected");
                message.entry[i] = $root.BulkDetailsEntry.fromObject(object.entry[i]);
            }
        }
        return message;
    };

    /**
     * Creates a plain object from a BulkDetailsResponse message. Also converts values to other types if specified.
     * @function toObject
     * @memberof BulkDetailsResponse
     * @static
     * @param {BulkDetailsResponse} message BulkDetailsResponse
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    BulkDetailsResponse.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        var object = {};
        if (options.arrays || options.defaults)
            object.entry = [];
        if (message.entry && message.entry.length) {
            object.entry = [];
            for (var j = 0; j < message.entry.length; ++j)
                object.entry[j] = $root.BulkDetailsEntry.toObject(message.entry[j], options);
        }
        return object;
    };

    /**
     * Converts this BulkDetailsResponse to JSON.
     * @function toJSON
     * @memberof BulkDetailsResponse
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    BulkDetailsResponse.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return BulkDetailsResponse;
})();

$root.DetailsResponse = (function() {

    /**
     * Properties of a DetailsResponse.
     * @exports IDetailsResponse
     * @interface IDetailsResponse
     * @property {string|null} [analyticsCookie] DetailsResponse analyticsCookie
     * @property {IReview|null} [userReview] DetailsResponse userReview
     * @property {IItem|null} [item] DetailsResponse item
     * @property {string|null} [footerHtml] DetailsResponse footerHtml
     * @property {Uint8Array|null} [serverLogsCookie] DetailsResponse serverLogsCookie
     * @property {Array.<IDiscoveryBadge>|null} [discoveryBadge] DetailsResponse discoveryBadge
     * @property {boolean|null} [enableReviews] DetailsResponse enableReviews
     * @property {IFeatures|null} [features] DetailsResponse features
     * @property {string|null} [detailsStreamUrl] DetailsResponse detailsStreamUrl
     * @property {string|null} [userReviewUrl] DetailsResponse userReviewUrl
     * @property {string|null} [postAcquireDetailsStreamUrl] DetailsResponse postAcquireDetailsStreamUrl
     */

    /**
     * Constructs a new DetailsResponse.
     * @exports DetailsResponse
     * @classdesc Represents a DetailsResponse.
     * @implements IDetailsResponse
     * @constructor
     * @param {IDetailsResponse=} [properties] Properties to set
     */
    function DetailsResponse(properties) {
        this.discoveryBadge = [];
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * DetailsResponse analyticsCookie.
     * @member {string} analyticsCookie
     * @memberof DetailsResponse
     * @instance
     */
    DetailsResponse.prototype.analyticsCookie = "";

    /**
     * DetailsResponse userReview.
     * @member {IReview|null|undefined} userReview
     * @memberof DetailsResponse
     * @instance
     */
    DetailsResponse.prototype.userReview = null;

    /**
     * DetailsResponse item.
     * @member {IItem|null|undefined} item
     * @memberof DetailsResponse
     * @instance
     */
    DetailsResponse.prototype.item = null;

    /**
     * DetailsResponse footerHtml.
     * @member {string} footerHtml
     * @memberof DetailsResponse
     * @instance
     */
    DetailsResponse.prototype.footerHtml = "";

    /**
     * DetailsResponse serverLogsCookie.
     * @member {Uint8Array} serverLogsCookie
     * @memberof DetailsResponse
     * @instance
     */
    DetailsResponse.prototype.serverLogsCookie = $util.newBuffer([]);

    /**
     * DetailsResponse discoveryBadge.
     * @member {Array.<IDiscoveryBadge>} discoveryBadge
     * @memberof DetailsResponse
     * @instance
     */
    DetailsResponse.prototype.discoveryBadge = $util.emptyArray;

    /**
     * DetailsResponse enableReviews.
     * @member {boolean} enableReviews
     * @memberof DetailsResponse
     * @instance
     */
    DetailsResponse.prototype.enableReviews = true;

    /**
     * DetailsResponse features.
     * @member {IFeatures|null|undefined} features
     * @memberof DetailsResponse
     * @instance
     */
    DetailsResponse.prototype.features = null;

    /**
     * DetailsResponse detailsStreamUrl.
     * @member {string} detailsStreamUrl
     * @memberof DetailsResponse
     * @instance
     */
    DetailsResponse.prototype.detailsStreamUrl = "";

    /**
     * DetailsResponse userReviewUrl.
     * @member {string} userReviewUrl
     * @memberof DetailsResponse
     * @instance
     */
    DetailsResponse.prototype.userReviewUrl = "";

    /**
     * DetailsResponse postAcquireDetailsStreamUrl.
     * @member {string} postAcquireDetailsStreamUrl
     * @memberof DetailsResponse
     * @instance
     */
    DetailsResponse.prototype.postAcquireDetailsStreamUrl = "";

    /**
     * Creates a new DetailsResponse instance using the specified properties.
     * @function create
     * @memberof DetailsResponse
     * @static
     * @param {IDetailsResponse=} [properties] Properties to set
     * @returns {DetailsResponse} DetailsResponse instance
     */
    DetailsResponse.create = function create(properties) {
        return new DetailsResponse(properties);
    };

    /**
     * Encodes the specified DetailsResponse message. Does not implicitly {@link DetailsResponse.verify|verify} messages.
     * @function encode
     * @memberof DetailsResponse
     * @static
     * @param {IDetailsResponse} message DetailsResponse message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    DetailsResponse.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.analyticsCookie != null && Object.hasOwnProperty.call(message, "analyticsCookie"))
            writer.uint32(/* id 2, wireType 2 =*/18).string(message.analyticsCookie);
        if (message.userReview != null && Object.hasOwnProperty.call(message, "userReview"))
            $root.Review.encode(message.userReview, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
        if (message.item != null && Object.hasOwnProperty.call(message, "item"))
            $root.Item.encode(message.item, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
        if (message.footerHtml != null && Object.hasOwnProperty.call(message, "footerHtml"))
            writer.uint32(/* id 5, wireType 2 =*/42).string(message.footerHtml);
        if (message.serverLogsCookie != null && Object.hasOwnProperty.call(message, "serverLogsCookie"))
            writer.uint32(/* id 6, wireType 2 =*/50).bytes(message.serverLogsCookie);
        if (message.discoveryBadge != null && message.discoveryBadge.length)
            for (var i = 0; i < message.discoveryBadge.length; ++i)
                $root.DiscoveryBadge.encode(message.discoveryBadge[i], writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
        if (message.enableReviews != null && Object.hasOwnProperty.call(message, "enableReviews"))
            writer.uint32(/* id 8, wireType 0 =*/64).bool(message.enableReviews);
        if (message.features != null && Object.hasOwnProperty.call(message, "features"))
            $root.Features.encode(message.features, writer.uint32(/* id 12, wireType 2 =*/98).fork()).ldelim();
        if (message.detailsStreamUrl != null && Object.hasOwnProperty.call(message, "detailsStreamUrl"))
            writer.uint32(/* id 13, wireType 2 =*/106).string(message.detailsStreamUrl);
        if (message.userReviewUrl != null && Object.hasOwnProperty.call(message, "userReviewUrl"))
            writer.uint32(/* id 14, wireType 2 =*/114).string(message.userReviewUrl);
        if (message.postAcquireDetailsStreamUrl != null && Object.hasOwnProperty.call(message, "postAcquireDetailsStreamUrl"))
            writer.uint32(/* id 17, wireType 2 =*/138).string(message.postAcquireDetailsStreamUrl);
        return writer;
    };

    /**
     * Encodes the specified DetailsResponse message, length delimited. Does not implicitly {@link DetailsResponse.verify|verify} messages.
     * @function encodeDelimited
     * @memberof DetailsResponse
     * @static
     * @param {IDetailsResponse} message DetailsResponse message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    DetailsResponse.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a DetailsResponse message from the specified reader or buffer.
     * @function decode
     * @memberof DetailsResponse
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {DetailsResponse} DetailsResponse
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    DetailsResponse.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.DetailsResponse();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            case 2:
                message.analyticsCookie = reader.string();
                break;
            case 3:
                message.userReview = $root.Review.decode(reader, reader.uint32());
                break;
            case 4:
                message.item = $root.Item.decode(reader, reader.uint32());
                break;
            case 5:
                message.footerHtml = reader.string();
                break;
            case 6:
                message.serverLogsCookie = reader.bytes();
                break;
            case 7:
                if (!(message.discoveryBadge && message.discoveryBadge.length))
                    message.discoveryBadge = [];
                message.discoveryBadge.push($root.DiscoveryBadge.decode(reader, reader.uint32()));
                break;
            case 8:
                message.enableReviews = reader.bool();
                break;
            case 12:
                message.features = $root.Features.decode(reader, reader.uint32());
                break;
            case 13:
                message.detailsStreamUrl = reader.string();
                break;
            case 14:
                message.userReviewUrl = reader.string();
                break;
            case 17:
                message.postAcquireDetailsStreamUrl = reader.string();
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a DetailsResponse message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof DetailsResponse
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {DetailsResponse} DetailsResponse
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    DetailsResponse.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a DetailsResponse message.
     * @function verify
     * @memberof DetailsResponse
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    DetailsResponse.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.analyticsCookie != null && message.hasOwnProperty("analyticsCookie"))
            if (!$util.isString(message.analyticsCookie))
                return "analyticsCookie: string expected";
        if (message.userReview != null && message.hasOwnProperty("userReview")) {
            var error = $root.Review.verify(message.userReview);
            if (error)
                return "userReview." + error;
        }
        if (message.item != null && message.hasOwnProperty("item")) {
            var error = $root.Item.verify(message.item);
            if (error)
                return "item." + error;
        }
        if (message.footerHtml != null && message.hasOwnProperty("footerHtml"))
            if (!$util.isString(message.footerHtml))
                return "footerHtml: string expected";
        if (message.serverLogsCookie != null && message.hasOwnProperty("serverLogsCookie"))
            if (!(message.serverLogsCookie && typeof message.serverLogsCookie.length === "number" || $util.isString(message.serverLogsCookie)))
                return "serverLogsCookie: buffer expected";
        if (message.discoveryBadge != null && message.hasOwnProperty("discoveryBadge")) {
            if (!Array.isArray(message.discoveryBadge))
                return "discoveryBadge: array expected";
            for (var i = 0; i < message.discoveryBadge.length; ++i) {
                var error = $root.DiscoveryBadge.verify(message.discoveryBadge[i]);
                if (error)
                    return "discoveryBadge." + error;
            }
        }
        if (message.enableReviews != null && message.hasOwnProperty("enableReviews"))
            if (typeof message.enableReviews !== "boolean")
                return "enableReviews: boolean expected";
        if (message.features != null && message.hasOwnProperty("features")) {
            var error = $root.Features.verify(message.features);
            if (error)
                return "features." + error;
        }
        if (message.detailsStreamUrl != null && message.hasOwnProperty("detailsStreamUrl"))
            if (!$util.isString(message.detailsStreamUrl))
                return "detailsStreamUrl: string expected";
        if (message.userReviewUrl != null && message.hasOwnProperty("userReviewUrl"))
            if (!$util.isString(message.userReviewUrl))
                return "userReviewUrl: string expected";
        if (message.postAcquireDetailsStreamUrl != null && message.hasOwnProperty("postAcquireDetailsStreamUrl"))
            if (!$util.isString(message.postAcquireDetailsStreamUrl))
                return "postAcquireDetailsStreamUrl: string expected";
        return null;
    };

    /**
     * Creates a DetailsResponse message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof DetailsResponse
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {DetailsResponse} DetailsResponse
     */
    DetailsResponse.fromObject = function fromObject(object) {
        if (object instanceof $root.DetailsResponse)
            return object;
        var message = new $root.DetailsResponse();
        if (object.analyticsCookie != null)
            message.analyticsCookie = String(object.analyticsCookie);
        if (object.userReview != null) {
            if (typeof object.userReview !== "object")
                throw TypeError(".DetailsResponse.userReview: object expected");
            message.userReview = $root.Review.fromObject(object.userReview);
        }
        if (object.item != null) {
            if (typeof object.item !== "object")
                throw TypeError(".DetailsResponse.item: object expected");
            message.item = $root.Item.fromObject(object.item);
        }
        if (object.footerHtml != null)
            message.footerHtml = String(object.footerHtml);
        if (object.serverLogsCookie != null)
            if (typeof object.serverLogsCookie === "string")
                $util.base64.decode(object.serverLogsCookie, message.serverLogsCookie = $util.newBuffer($util.base64.length(object.serverLogsCookie)), 0);
            else if (object.serverLogsCookie.length)
                message.serverLogsCookie = object.serverLogsCookie;
        if (object.discoveryBadge) {
            if (!Array.isArray(object.discoveryBadge))
                throw TypeError(".DetailsResponse.discoveryBadge: array expected");
            message.discoveryBadge = [];
            for (var i = 0; i < object.discoveryBadge.length; ++i) {
                if (typeof object.discoveryBadge[i] !== "object")
                    throw TypeError(".DetailsResponse.discoveryBadge: object expected");
                message.discoveryBadge[i] = $root.DiscoveryBadge.fromObject(object.discoveryBadge[i]);
            }
        }
        if (object.enableReviews != null)
            message.enableReviews = Boolean(object.enableReviews);
        if (object.features != null) {
            if (typeof object.features !== "object")
                throw TypeError(".DetailsResponse.features: object expected");
            message.features = $root.Features.fromObject(object.features);
        }
        if (object.detailsStreamUrl != null)
            message.detailsStreamUrl = String(object.detailsStreamUrl);
        if (object.userReviewUrl != null)
            message.userReviewUrl = String(object.userReviewUrl);
        if (object.postAcquireDetailsStreamUrl != null)
            message.postAcquireDetailsStreamUrl = String(object.postAcquireDetailsStreamUrl);
        return message;
    };

    /**
     * Creates a plain object from a DetailsResponse message. Also converts values to other types if specified.
     * @function toObject
     * @memberof DetailsResponse
     * @static
     * @param {DetailsResponse} message DetailsResponse
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    DetailsResponse.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        var object = {};
        if (options.arrays || options.defaults)
            object.discoveryBadge = [];
        if (options.defaults) {
            object.analyticsCookie = "";
            object.userReview = null;
            object.item = null;
            object.footerHtml = "";
            if (options.bytes === String)
                object.serverLogsCookie = "";
            else {
                object.serverLogsCookie = [];
                if (options.bytes !== Array)
                    object.serverLogsCookie = $util.newBuffer(object.serverLogsCookie);
            }
            object.enableReviews = true;
            object.features = null;
            object.detailsStreamUrl = "";
            object.userReviewUrl = "";
            object.postAcquireDetailsStreamUrl = "";
        }
        if (message.analyticsCookie != null && message.hasOwnProperty("analyticsCookie"))
            object.analyticsCookie = message.analyticsCookie;
        if (message.userReview != null && message.hasOwnProperty("userReview"))
            object.userReview = $root.Review.toObject(message.userReview, options);
        if (message.item != null && message.hasOwnProperty("item"))
            object.item = $root.Item.toObject(message.item, options);
        if (message.footerHtml != null && message.hasOwnProperty("footerHtml"))
            object.footerHtml = message.footerHtml;
        if (message.serverLogsCookie != null && message.hasOwnProperty("serverLogsCookie"))
            object.serverLogsCookie = options.bytes === String ? $util.base64.encode(message.serverLogsCookie, 0, message.serverLogsCookie.length) : options.bytes === Array ? Array.prototype.slice.call(message.serverLogsCookie) : message.serverLogsCookie;
        if (message.discoveryBadge && message.discoveryBadge.length) {
            object.discoveryBadge = [];
            for (var j = 0; j < message.discoveryBadge.length; ++j)
                object.discoveryBadge[j] = $root.DiscoveryBadge.toObject(message.discoveryBadge[j], options);
        }
        if (message.enableReviews != null && message.hasOwnProperty("enableReviews"))
            object.enableReviews = message.enableReviews;
        if (message.features != null && message.hasOwnProperty("features"))
            object.features = $root.Features.toObject(message.features, options);
        if (message.detailsStreamUrl != null && message.hasOwnProperty("detailsStreamUrl"))
            object.detailsStreamUrl = message.detailsStreamUrl;
        if (message.userReviewUrl != null && message.hasOwnProperty("userReviewUrl"))
            object.userReviewUrl = message.userReviewUrl;
        if (message.postAcquireDetailsStreamUrl != null && message.hasOwnProperty("postAcquireDetailsStreamUrl"))
            object.postAcquireDetailsStreamUrl = message.postAcquireDetailsStreamUrl;
        return object;
    };

    /**
     * Converts this DetailsResponse to JSON.
     * @function toJSON
     * @memberof DetailsResponse
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    DetailsResponse.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return DetailsResponse;
})();

$root.DiscoveryBadge = (function() {

    /**
     * Properties of a DiscoveryBadge.
     * @exports IDiscoveryBadge
     * @interface IDiscoveryBadge
     * @property {string|null} [label] DiscoveryBadge label
     * @property {IImage|null} [image] DiscoveryBadge image
     * @property {number|null} [backgroundColor] DiscoveryBadge backgroundColor
     * @property {IDiscoveryBadgeLink|null} [badgeContainer1] DiscoveryBadge badgeContainer1
     * @property {Uint8Array|null} [serverLogsCookie] DiscoveryBadge serverLogsCookie
     * @property {boolean|null} [isPlusOne] DiscoveryBadge isPlusOne
     * @property {number|null} [aggregateRating] DiscoveryBadge aggregateRating
     * @property {number|null} [userStarRating] DiscoveryBadge userStarRating
     * @property {string|null} [downloadCount] DiscoveryBadge downloadCount
     * @property {string|null} [downloadUnits] DiscoveryBadge downloadUnits
     * @property {string|null} [contentDescription] DiscoveryBadge contentDescription
     * @property {IPlayerBadge|null} [playerBadge] DiscoveryBadge playerBadge
     * @property {Uint8Array|null} [familyAgeRangeBadge] DiscoveryBadge familyAgeRangeBadge
     * @property {Uint8Array|null} [familyCategoryBadge] DiscoveryBadge familyCategoryBadge
     */

    /**
     * Constructs a new DiscoveryBadge.
     * @exports DiscoveryBadge
     * @classdesc Represents a DiscoveryBadge.
     * @implements IDiscoveryBadge
     * @constructor
     * @param {IDiscoveryBadge=} [properties] Properties to set
     */
    function DiscoveryBadge(properties) {
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * DiscoveryBadge label.
     * @member {string} label
     * @memberof DiscoveryBadge
     * @instance
     */
    DiscoveryBadge.prototype.label = "";

    /**
     * DiscoveryBadge image.
     * @member {IImage|null|undefined} image
     * @memberof DiscoveryBadge
     * @instance
     */
    DiscoveryBadge.prototype.image = null;

    /**
     * DiscoveryBadge backgroundColor.
     * @member {number} backgroundColor
     * @memberof DiscoveryBadge
     * @instance
     */
    DiscoveryBadge.prototype.backgroundColor = 0;

    /**
     * DiscoveryBadge badgeContainer1.
     * @member {IDiscoveryBadgeLink|null|undefined} badgeContainer1
     * @memberof DiscoveryBadge
     * @instance
     */
    DiscoveryBadge.prototype.badgeContainer1 = null;

    /**
     * DiscoveryBadge serverLogsCookie.
     * @member {Uint8Array} serverLogsCookie
     * @memberof DiscoveryBadge
     * @instance
     */
    DiscoveryBadge.prototype.serverLogsCookie = $util.newBuffer([]);

    /**
     * DiscoveryBadge isPlusOne.
     * @member {boolean} isPlusOne
     * @memberof DiscoveryBadge
     * @instance
     */
    DiscoveryBadge.prototype.isPlusOne = false;

    /**
     * DiscoveryBadge aggregateRating.
     * @member {number} aggregateRating
     * @memberof DiscoveryBadge
     * @instance
     */
    DiscoveryBadge.prototype.aggregateRating = 0;

    /**
     * DiscoveryBadge userStarRating.
     * @member {number} userStarRating
     * @memberof DiscoveryBadge
     * @instance
     */
    DiscoveryBadge.prototype.userStarRating = 0;

    /**
     * DiscoveryBadge downloadCount.
     * @member {string} downloadCount
     * @memberof DiscoveryBadge
     * @instance
     */
    DiscoveryBadge.prototype.downloadCount = "";

    /**
     * DiscoveryBadge downloadUnits.
     * @member {string} downloadUnits
     * @memberof DiscoveryBadge
     * @instance
     */
    DiscoveryBadge.prototype.downloadUnits = "";

    /**
     * DiscoveryBadge contentDescription.
     * @member {string} contentDescription
     * @memberof DiscoveryBadge
     * @instance
     */
    DiscoveryBadge.prototype.contentDescription = "";

    /**
     * DiscoveryBadge playerBadge.
     * @member {IPlayerBadge|null|undefined} playerBadge
     * @memberof DiscoveryBadge
     * @instance
     */
    DiscoveryBadge.prototype.playerBadge = null;

    /**
     * DiscoveryBadge familyAgeRangeBadge.
     * @member {Uint8Array} familyAgeRangeBadge
     * @memberof DiscoveryBadge
     * @instance
     */
    DiscoveryBadge.prototype.familyAgeRangeBadge = $util.newBuffer([]);

    /**
     * DiscoveryBadge familyCategoryBadge.
     * @member {Uint8Array} familyCategoryBadge
     * @memberof DiscoveryBadge
     * @instance
     */
    DiscoveryBadge.prototype.familyCategoryBadge = $util.newBuffer([]);

    /**
     * Creates a new DiscoveryBadge instance using the specified properties.
     * @function create
     * @memberof DiscoveryBadge
     * @static
     * @param {IDiscoveryBadge=} [properties] Properties to set
     * @returns {DiscoveryBadge} DiscoveryBadge instance
     */
    DiscoveryBadge.create = function create(properties) {
        return new DiscoveryBadge(properties);
    };

    /**
     * Encodes the specified DiscoveryBadge message. Does not implicitly {@link DiscoveryBadge.verify|verify} messages.
     * @function encode
     * @memberof DiscoveryBadge
     * @static
     * @param {IDiscoveryBadge} message DiscoveryBadge message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    DiscoveryBadge.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.label != null && Object.hasOwnProperty.call(message, "label"))
            writer.uint32(/* id 1, wireType 2 =*/10).string(message.label);
        if (message.image != null && Object.hasOwnProperty.call(message, "image"))
            $root.Image.encode(message.image, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
        if (message.backgroundColor != null && Object.hasOwnProperty.call(message, "backgroundColor"))
            writer.uint32(/* id 3, wireType 0 =*/24).int32(message.backgroundColor);
        if (message.badgeContainer1 != null && Object.hasOwnProperty.call(message, "badgeContainer1"))
            $root.DiscoveryBadgeLink.encode(message.badgeContainer1, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
        if (message.serverLogsCookie != null && Object.hasOwnProperty.call(message, "serverLogsCookie"))
            writer.uint32(/* id 5, wireType 2 =*/42).bytes(message.serverLogsCookie);
        if (message.isPlusOne != null && Object.hasOwnProperty.call(message, "isPlusOne"))
            writer.uint32(/* id 6, wireType 0 =*/48).bool(message.isPlusOne);
        if (message.aggregateRating != null && Object.hasOwnProperty.call(message, "aggregateRating"))
            writer.uint32(/* id 7, wireType 5 =*/61).float(message.aggregateRating);
        if (message.userStarRating != null && Object.hasOwnProperty.call(message, "userStarRating"))
            writer.uint32(/* id 8, wireType 0 =*/64).int32(message.userStarRating);
        if (message.downloadCount != null && Object.hasOwnProperty.call(message, "downloadCount"))
            writer.uint32(/* id 9, wireType 2 =*/74).string(message.downloadCount);
        if (message.downloadUnits != null && Object.hasOwnProperty.call(message, "downloadUnits"))
            writer.uint32(/* id 10, wireType 2 =*/82).string(message.downloadUnits);
        if (message.contentDescription != null && Object.hasOwnProperty.call(message, "contentDescription"))
            writer.uint32(/* id 11, wireType 2 =*/90).string(message.contentDescription);
        if (message.playerBadge != null && Object.hasOwnProperty.call(message, "playerBadge"))
            $root.PlayerBadge.encode(message.playerBadge, writer.uint32(/* id 12, wireType 2 =*/98).fork()).ldelim();
        if (message.familyAgeRangeBadge != null && Object.hasOwnProperty.call(message, "familyAgeRangeBadge"))
            writer.uint32(/* id 13, wireType 2 =*/106).bytes(message.familyAgeRangeBadge);
        if (message.familyCategoryBadge != null && Object.hasOwnProperty.call(message, "familyCategoryBadge"))
            writer.uint32(/* id 14, wireType 2 =*/114).bytes(message.familyCategoryBadge);
        return writer;
    };

    /**
     * Encodes the specified DiscoveryBadge message, length delimited. Does not implicitly {@link DiscoveryBadge.verify|verify} messages.
     * @function encodeDelimited
     * @memberof DiscoveryBadge
     * @static
     * @param {IDiscoveryBadge} message DiscoveryBadge message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    DiscoveryBadge.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a DiscoveryBadge message from the specified reader or buffer.
     * @function decode
     * @memberof DiscoveryBadge
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {DiscoveryBadge} DiscoveryBadge
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    DiscoveryBadge.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.DiscoveryBadge();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.label = reader.string();
                break;
            case 2:
                message.image = $root.Image.decode(reader, reader.uint32());
                break;
            case 3:
                message.backgroundColor = reader.int32();
                break;
            case 4:
                message.badgeContainer1 = $root.DiscoveryBadgeLink.decode(reader, reader.uint32());
                break;
            case 5:
                message.serverLogsCookie = reader.bytes();
                break;
            case 6:
                message.isPlusOne = reader.bool();
                break;
            case 7:
                message.aggregateRating = reader.float();
                break;
            case 8:
                message.userStarRating = reader.int32();
                break;
            case 9:
                message.downloadCount = reader.string();
                break;
            case 10:
                message.downloadUnits = reader.string();
                break;
            case 11:
                message.contentDescription = reader.string();
                break;
            case 12:
                message.playerBadge = $root.PlayerBadge.decode(reader, reader.uint32());
                break;
            case 13:
                message.familyAgeRangeBadge = reader.bytes();
                break;
            case 14:
                message.familyCategoryBadge = reader.bytes();
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a DiscoveryBadge message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof DiscoveryBadge
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {DiscoveryBadge} DiscoveryBadge
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    DiscoveryBadge.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a DiscoveryBadge message.
     * @function verify
     * @memberof DiscoveryBadge
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    DiscoveryBadge.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.label != null && message.hasOwnProperty("label"))
            if (!$util.isString(message.label))
                return "label: string expected";
        if (message.image != null && message.hasOwnProperty("image")) {
            var error = $root.Image.verify(message.image);
            if (error)
                return "image." + error;
        }
        if (message.backgroundColor != null && message.hasOwnProperty("backgroundColor"))
            if (!$util.isInteger(message.backgroundColor))
                return "backgroundColor: integer expected";
        if (message.badgeContainer1 != null && message.hasOwnProperty("badgeContainer1")) {
            var error = $root.DiscoveryBadgeLink.verify(message.badgeContainer1);
            if (error)
                return "badgeContainer1." + error;
        }
        if (message.serverLogsCookie != null && message.hasOwnProperty("serverLogsCookie"))
            if (!(message.serverLogsCookie && typeof message.serverLogsCookie.length === "number" || $util.isString(message.serverLogsCookie)))
                return "serverLogsCookie: buffer expected";
        if (message.isPlusOne != null && message.hasOwnProperty("isPlusOne"))
            if (typeof message.isPlusOne !== "boolean")
                return "isPlusOne: boolean expected";
        if (message.aggregateRating != null && message.hasOwnProperty("aggregateRating"))
            if (typeof message.aggregateRating !== "number")
                return "aggregateRating: number expected";
        if (message.userStarRating != null && message.hasOwnProperty("userStarRating"))
            if (!$util.isInteger(message.userStarRating))
                return "userStarRating: integer expected";
        if (message.downloadCount != null && message.hasOwnProperty("downloadCount"))
            if (!$util.isString(message.downloadCount))
                return "downloadCount: string expected";
        if (message.downloadUnits != null && message.hasOwnProperty("downloadUnits"))
            if (!$util.isString(message.downloadUnits))
                return "downloadUnits: string expected";
        if (message.contentDescription != null && message.hasOwnProperty("contentDescription"))
            if (!$util.isString(message.contentDescription))
                return "contentDescription: string expected";
        if (message.playerBadge != null && message.hasOwnProperty("playerBadge")) {
            var error = $root.PlayerBadge.verify(message.playerBadge);
            if (error)
                return "playerBadge." + error;
        }
        if (message.familyAgeRangeBadge != null && message.hasOwnProperty("familyAgeRangeBadge"))
            if (!(message.familyAgeRangeBadge && typeof message.familyAgeRangeBadge.length === "number" || $util.isString(message.familyAgeRangeBadge)))
                return "familyAgeRangeBadge: buffer expected";
        if (message.familyCategoryBadge != null && message.hasOwnProperty("familyCategoryBadge"))
            if (!(message.familyCategoryBadge && typeof message.familyCategoryBadge.length === "number" || $util.isString(message.familyCategoryBadge)))
                return "familyCategoryBadge: buffer expected";
        return null;
    };

    /**
     * Creates a DiscoveryBadge message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof DiscoveryBadge
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {DiscoveryBadge} DiscoveryBadge
     */
    DiscoveryBadge.fromObject = function fromObject(object) {
        if (object instanceof $root.DiscoveryBadge)
            return object;
        var message = new $root.DiscoveryBadge();
        if (object.label != null)
            message.label = String(object.label);
        if (object.image != null) {
            if (typeof object.image !== "object")
                throw TypeError(".DiscoveryBadge.image: object expected");
            message.image = $root.Image.fromObject(object.image);
        }
        if (object.backgroundColor != null)
            message.backgroundColor = object.backgroundColor | 0;
        if (object.badgeContainer1 != null) {
            if (typeof object.badgeContainer1 !== "object")
                throw TypeError(".DiscoveryBadge.badgeContainer1: object expected");
            message.badgeContainer1 = $root.DiscoveryBadgeLink.fromObject(object.badgeContainer1);
        }
        if (object.serverLogsCookie != null)
            if (typeof object.serverLogsCookie === "string")
                $util.base64.decode(object.serverLogsCookie, message.serverLogsCookie = $util.newBuffer($util.base64.length(object.serverLogsCookie)), 0);
            else if (object.serverLogsCookie.length)
                message.serverLogsCookie = object.serverLogsCookie;
        if (object.isPlusOne != null)
            message.isPlusOne = Boolean(object.isPlusOne);
        if (object.aggregateRating != null)
            message.aggregateRating = Number(object.aggregateRating);
        if (object.userStarRating != null)
            message.userStarRating = object.userStarRating | 0;
        if (object.downloadCount != null)
            message.downloadCount = String(object.downloadCount);
        if (object.downloadUnits != null)
            message.downloadUnits = String(object.downloadUnits);
        if (object.contentDescription != null)
            message.contentDescription = String(object.contentDescription);
        if (object.playerBadge != null) {
            if (typeof object.playerBadge !== "object")
                throw TypeError(".DiscoveryBadge.playerBadge: object expected");
            message.playerBadge = $root.PlayerBadge.fromObject(object.playerBadge);
        }
        if (object.familyAgeRangeBadge != null)
            if (typeof object.familyAgeRangeBadge === "string")
                $util.base64.decode(object.familyAgeRangeBadge, message.familyAgeRangeBadge = $util.newBuffer($util.base64.length(object.familyAgeRangeBadge)), 0);
            else if (object.familyAgeRangeBadge.length)
                message.familyAgeRangeBadge = object.familyAgeRangeBadge;
        if (object.familyCategoryBadge != null)
            if (typeof object.familyCategoryBadge === "string")
                $util.base64.decode(object.familyCategoryBadge, message.familyCategoryBadge = $util.newBuffer($util.base64.length(object.familyCategoryBadge)), 0);
            else if (object.familyCategoryBadge.length)
                message.familyCategoryBadge = object.familyCategoryBadge;
        return message;
    };

    /**
     * Creates a plain object from a DiscoveryBadge message. Also converts values to other types if specified.
     * @function toObject
     * @memberof DiscoveryBadge
     * @static
     * @param {DiscoveryBadge} message DiscoveryBadge
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    DiscoveryBadge.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        var object = {};
        if (options.defaults) {
            object.label = "";
            object.image = null;
            object.backgroundColor = 0;
            object.badgeContainer1 = null;
            if (options.bytes === String)
                object.serverLogsCookie = "";
            else {
                object.serverLogsCookie = [];
                if (options.bytes !== Array)
                    object.serverLogsCookie = $util.newBuffer(object.serverLogsCookie);
            }
            object.isPlusOne = false;
            object.aggregateRating = 0;
            object.userStarRating = 0;
            object.downloadCount = "";
            object.downloadUnits = "";
            object.contentDescription = "";
            object.playerBadge = null;
            if (options.bytes === String)
                object.familyAgeRangeBadge = "";
            else {
                object.familyAgeRangeBadge = [];
                if (options.bytes !== Array)
                    object.familyAgeRangeBadge = $util.newBuffer(object.familyAgeRangeBadge);
            }
            if (options.bytes === String)
                object.familyCategoryBadge = "";
            else {
                object.familyCategoryBadge = [];
                if (options.bytes !== Array)
                    object.familyCategoryBadge = $util.newBuffer(object.familyCategoryBadge);
            }
        }
        if (message.label != null && message.hasOwnProperty("label"))
            object.label = message.label;
        if (message.image != null && message.hasOwnProperty("image"))
            object.image = $root.Image.toObject(message.image, options);
        if (message.backgroundColor != null && message.hasOwnProperty("backgroundColor"))
            object.backgroundColor = message.backgroundColor;
        if (message.badgeContainer1 != null && message.hasOwnProperty("badgeContainer1"))
            object.badgeContainer1 = $root.DiscoveryBadgeLink.toObject(message.badgeContainer1, options);
        if (message.serverLogsCookie != null && message.hasOwnProperty("serverLogsCookie"))
            object.serverLogsCookie = options.bytes === String ? $util.base64.encode(message.serverLogsCookie, 0, message.serverLogsCookie.length) : options.bytes === Array ? Array.prototype.slice.call(message.serverLogsCookie) : message.serverLogsCookie;
        if (message.isPlusOne != null && message.hasOwnProperty("isPlusOne"))
            object.isPlusOne = message.isPlusOne;
        if (message.aggregateRating != null && message.hasOwnProperty("aggregateRating"))
            object.aggregateRating = options.json && !isFinite(message.aggregateRating) ? String(message.aggregateRating) : message.aggregateRating;
        if (message.userStarRating != null && message.hasOwnProperty("userStarRating"))
            object.userStarRating = message.userStarRating;
        if (message.downloadCount != null && message.hasOwnProperty("downloadCount"))
            object.downloadCount = message.downloadCount;
        if (message.downloadUnits != null && message.hasOwnProperty("downloadUnits"))
            object.downloadUnits = message.downloadUnits;
        if (message.contentDescription != null && message.hasOwnProperty("contentDescription"))
            object.contentDescription = message.contentDescription;
        if (message.playerBadge != null && message.hasOwnProperty("playerBadge"))
            object.playerBadge = $root.PlayerBadge.toObject(message.playerBadge, options);
        if (message.familyAgeRangeBadge != null && message.hasOwnProperty("familyAgeRangeBadge"))
            object.familyAgeRangeBadge = options.bytes === String ? $util.base64.encode(message.familyAgeRangeBadge, 0, message.familyAgeRangeBadge.length) : options.bytes === Array ? Array.prototype.slice.call(message.familyAgeRangeBadge) : message.familyAgeRangeBadge;
        if (message.familyCategoryBadge != null && message.hasOwnProperty("familyCategoryBadge"))
            object.familyCategoryBadge = options.bytes === String ? $util.base64.encode(message.familyCategoryBadge, 0, message.familyCategoryBadge.length) : options.bytes === Array ? Array.prototype.slice.call(message.familyCategoryBadge) : message.familyCategoryBadge;
        return object;
    };

    /**
     * Converts this DiscoveryBadge to JSON.
     * @function toJSON
     * @memberof DiscoveryBadge
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    DiscoveryBadge.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return DiscoveryBadge;
})();

$root.PlayerBadge = (function() {

    /**
     * Properties of a PlayerBadge.
     * @exports IPlayerBadge
     * @interface IPlayerBadge
     * @property {IImage|null} [overlayIcon] PlayerBadge overlayIcon
     */

    /**
     * Constructs a new PlayerBadge.
     * @exports PlayerBadge
     * @classdesc Represents a PlayerBadge.
     * @implements IPlayerBadge
     * @constructor
     * @param {IPlayerBadge=} [properties] Properties to set
     */
    function PlayerBadge(properties) {
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * PlayerBadge overlayIcon.
     * @member {IImage|null|undefined} overlayIcon
     * @memberof PlayerBadge
     * @instance
     */
    PlayerBadge.prototype.overlayIcon = null;

    /**
     * Creates a new PlayerBadge instance using the specified properties.
     * @function create
     * @memberof PlayerBadge
     * @static
     * @param {IPlayerBadge=} [properties] Properties to set
     * @returns {PlayerBadge} PlayerBadge instance
     */
    PlayerBadge.create = function create(properties) {
        return new PlayerBadge(properties);
    };

    /**
     * Encodes the specified PlayerBadge message. Does not implicitly {@link PlayerBadge.verify|verify} messages.
     * @function encode
     * @memberof PlayerBadge
     * @static
     * @param {IPlayerBadge} message PlayerBadge message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    PlayerBadge.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.overlayIcon != null && Object.hasOwnProperty.call(message, "overlayIcon"))
            $root.Image.encode(message.overlayIcon, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
        return writer;
    };

    /**
     * Encodes the specified PlayerBadge message, length delimited. Does not implicitly {@link PlayerBadge.verify|verify} messages.
     * @function encodeDelimited
     * @memberof PlayerBadge
     * @static
     * @param {IPlayerBadge} message PlayerBadge message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    PlayerBadge.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a PlayerBadge message from the specified reader or buffer.
     * @function decode
     * @memberof PlayerBadge
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {PlayerBadge} PlayerBadge
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    PlayerBadge.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.PlayerBadge();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.overlayIcon = $root.Image.decode(reader, reader.uint32());
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a PlayerBadge message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof PlayerBadge
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {PlayerBadge} PlayerBadge
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    PlayerBadge.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a PlayerBadge message.
     * @function verify
     * @memberof PlayerBadge
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    PlayerBadge.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.overlayIcon != null && message.hasOwnProperty("overlayIcon")) {
            var error = $root.Image.verify(message.overlayIcon);
            if (error)
                return "overlayIcon." + error;
        }
        return null;
    };

    /**
     * Creates a PlayerBadge message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof PlayerBadge
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {PlayerBadge} PlayerBadge
     */
    PlayerBadge.fromObject = function fromObject(object) {
        if (object instanceof $root.PlayerBadge)
            return object;
        var message = new $root.PlayerBadge();
        if (object.overlayIcon != null) {
            if (typeof object.overlayIcon !== "object")
                throw TypeError(".PlayerBadge.overlayIcon: object expected");
            message.overlayIcon = $root.Image.fromObject(object.overlayIcon);
        }
        return message;
    };

    /**
     * Creates a plain object from a PlayerBadge message. Also converts values to other types if specified.
     * @function toObject
     * @memberof PlayerBadge
     * @static
     * @param {PlayerBadge} message PlayerBadge
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    PlayerBadge.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        var object = {};
        if (options.defaults)
            object.overlayIcon = null;
        if (message.overlayIcon != null && message.hasOwnProperty("overlayIcon"))
            object.overlayIcon = $root.Image.toObject(message.overlayIcon, options);
        return object;
    };

    /**
     * Converts this PlayerBadge to JSON.
     * @function toJSON
     * @memberof PlayerBadge
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    PlayerBadge.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return PlayerBadge;
})();

$root.DiscoveryBadgeLink = (function() {

    /**
     * Properties of a DiscoveryBadgeLink.
     * @exports IDiscoveryBadgeLink
     * @interface IDiscoveryBadgeLink
     * @property {ILink|null} [link] DiscoveryBadgeLink link
     * @property {string|null} [userReviewsUrl] DiscoveryBadgeLink userReviewsUrl
     * @property {string|null} [criticReviewsUrl] DiscoveryBadgeLink criticReviewsUrl
     */

    /**
     * Constructs a new DiscoveryBadgeLink.
     * @exports DiscoveryBadgeLink
     * @classdesc Represents a DiscoveryBadgeLink.
     * @implements IDiscoveryBadgeLink
     * @constructor
     * @param {IDiscoveryBadgeLink=} [properties] Properties to set
     */
    function DiscoveryBadgeLink(properties) {
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * DiscoveryBadgeLink link.
     * @member {ILink|null|undefined} link
     * @memberof DiscoveryBadgeLink
     * @instance
     */
    DiscoveryBadgeLink.prototype.link = null;

    /**
     * DiscoveryBadgeLink userReviewsUrl.
     * @member {string} userReviewsUrl
     * @memberof DiscoveryBadgeLink
     * @instance
     */
    DiscoveryBadgeLink.prototype.userReviewsUrl = "";

    /**
     * DiscoveryBadgeLink criticReviewsUrl.
     * @member {string} criticReviewsUrl
     * @memberof DiscoveryBadgeLink
     * @instance
     */
    DiscoveryBadgeLink.prototype.criticReviewsUrl = "";

    /**
     * Creates a new DiscoveryBadgeLink instance using the specified properties.
     * @function create
     * @memberof DiscoveryBadgeLink
     * @static
     * @param {IDiscoveryBadgeLink=} [properties] Properties to set
     * @returns {DiscoveryBadgeLink} DiscoveryBadgeLink instance
     */
    DiscoveryBadgeLink.create = function create(properties) {
        return new DiscoveryBadgeLink(properties);
    };

    /**
     * Encodes the specified DiscoveryBadgeLink message. Does not implicitly {@link DiscoveryBadgeLink.verify|verify} messages.
     * @function encode
     * @memberof DiscoveryBadgeLink
     * @static
     * @param {IDiscoveryBadgeLink} message DiscoveryBadgeLink message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    DiscoveryBadgeLink.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.link != null && Object.hasOwnProperty.call(message, "link"))
            $root.Link.encode(message.link, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
        if (message.userReviewsUrl != null && Object.hasOwnProperty.call(message, "userReviewsUrl"))
            writer.uint32(/* id 2, wireType 2 =*/18).string(message.userReviewsUrl);
        if (message.criticReviewsUrl != null && Object.hasOwnProperty.call(message, "criticReviewsUrl"))
            writer.uint32(/* id 3, wireType 2 =*/26).string(message.criticReviewsUrl);
        return writer;
    };

    /**
     * Encodes the specified DiscoveryBadgeLink message, length delimited. Does not implicitly {@link DiscoveryBadgeLink.verify|verify} messages.
     * @function encodeDelimited
     * @memberof DiscoveryBadgeLink
     * @static
     * @param {IDiscoveryBadgeLink} message DiscoveryBadgeLink message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    DiscoveryBadgeLink.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a DiscoveryBadgeLink message from the specified reader or buffer.
     * @function decode
     * @memberof DiscoveryBadgeLink
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {DiscoveryBadgeLink} DiscoveryBadgeLink
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    DiscoveryBadgeLink.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.DiscoveryBadgeLink();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.link = $root.Link.decode(reader, reader.uint32());
                break;
            case 2:
                message.userReviewsUrl = reader.string();
                break;
            case 3:
                message.criticReviewsUrl = reader.string();
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a DiscoveryBadgeLink message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof DiscoveryBadgeLink
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {DiscoveryBadgeLink} DiscoveryBadgeLink
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    DiscoveryBadgeLink.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a DiscoveryBadgeLink message.
     * @function verify
     * @memberof DiscoveryBadgeLink
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    DiscoveryBadgeLink.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.link != null && message.hasOwnProperty("link")) {
            var error = $root.Link.verify(message.link);
            if (error)
                return "link." + error;
        }
        if (message.userReviewsUrl != null && message.hasOwnProperty("userReviewsUrl"))
            if (!$util.isString(message.userReviewsUrl))
                return "userReviewsUrl: string expected";
        if (message.criticReviewsUrl != null && message.hasOwnProperty("criticReviewsUrl"))
            if (!$util.isString(message.criticReviewsUrl))
                return "criticReviewsUrl: string expected";
        return null;
    };

    /**
     * Creates a DiscoveryBadgeLink message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof DiscoveryBadgeLink
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {DiscoveryBadgeLink} DiscoveryBadgeLink
     */
    DiscoveryBadgeLink.fromObject = function fromObject(object) {
        if (object instanceof $root.DiscoveryBadgeLink)
            return object;
        var message = new $root.DiscoveryBadgeLink();
        if (object.link != null) {
            if (typeof object.link !== "object")
                throw TypeError(".DiscoveryBadgeLink.link: object expected");
            message.link = $root.Link.fromObject(object.link);
        }
        if (object.userReviewsUrl != null)
            message.userReviewsUrl = String(object.userReviewsUrl);
        if (object.criticReviewsUrl != null)
            message.criticReviewsUrl = String(object.criticReviewsUrl);
        return message;
    };

    /**
     * Creates a plain object from a DiscoveryBadgeLink message. Also converts values to other types if specified.
     * @function toObject
     * @memberof DiscoveryBadgeLink
     * @static
     * @param {DiscoveryBadgeLink} message DiscoveryBadgeLink
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    DiscoveryBadgeLink.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        var object = {};
        if (options.defaults) {
            object.link = null;
            object.userReviewsUrl = "";
            object.criticReviewsUrl = "";
        }
        if (message.link != null && message.hasOwnProperty("link"))
            object.link = $root.Link.toObject(message.link, options);
        if (message.userReviewsUrl != null && message.hasOwnProperty("userReviewsUrl"))
            object.userReviewsUrl = message.userReviewsUrl;
        if (message.criticReviewsUrl != null && message.hasOwnProperty("criticReviewsUrl"))
            object.criticReviewsUrl = message.criticReviewsUrl;
        return object;
    };

    /**
     * Converts this DiscoveryBadgeLink to JSON.
     * @function toJSON
     * @memberof DiscoveryBadgeLink
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    DiscoveryBadgeLink.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return DiscoveryBadgeLink;
})();

$root.Features = (function() {

    /**
     * Properties of a Features.
     * @exports IFeatures
     * @interface IFeatures
     * @property {Array.<IFeature>|null} [featurePresence] Features featurePresence
     * @property {Array.<IFeature>|null} [featureRating] Features featureRating
     */

    /**
     * Constructs a new Features.
     * @exports Features
     * @classdesc Represents a Features.
     * @implements IFeatures
     * @constructor
     * @param {IFeatures=} [properties] Properties to set
     */
    function Features(properties) {
        this.featurePresence = [];
        this.featureRating = [];
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * Features featurePresence.
     * @member {Array.<IFeature>} featurePresence
     * @memberof Features
     * @instance
     */
    Features.prototype.featurePresence = $util.emptyArray;

    /**
     * Features featureRating.
     * @member {Array.<IFeature>} featureRating
     * @memberof Features
     * @instance
     */
    Features.prototype.featureRating = $util.emptyArray;

    /**
     * Creates a new Features instance using the specified properties.
     * @function create
     * @memberof Features
     * @static
     * @param {IFeatures=} [properties] Properties to set
     * @returns {Features} Features instance
     */
    Features.create = function create(properties) {
        return new Features(properties);
    };

    /**
     * Encodes the specified Features message. Does not implicitly {@link Features.verify|verify} messages.
     * @function encode
     * @memberof Features
     * @static
     * @param {IFeatures} message Features message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    Features.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.featurePresence != null && message.featurePresence.length)
            for (var i = 0; i < message.featurePresence.length; ++i)
                $root.Feature.encode(message.featurePresence[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
        if (message.featureRating != null && message.featureRating.length)
            for (var i = 0; i < message.featureRating.length; ++i)
                $root.Feature.encode(message.featureRating[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
        return writer;
    };

    /**
     * Encodes the specified Features message, length delimited. Does not implicitly {@link Features.verify|verify} messages.
     * @function encodeDelimited
     * @memberof Features
     * @static
     * @param {IFeatures} message Features message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    Features.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a Features message from the specified reader or buffer.
     * @function decode
     * @memberof Features
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {Features} Features
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    Features.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Features();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                if (!(message.featurePresence && message.featurePresence.length))
                    message.featurePresence = [];
                message.featurePresence.push($root.Feature.decode(reader, reader.uint32()));
                break;
            case 2:
                if (!(message.featureRating && message.featureRating.length))
                    message.featureRating = [];
                message.featureRating.push($root.Feature.decode(reader, reader.uint32()));
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a Features message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof Features
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {Features} Features
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    Features.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a Features message.
     * @function verify
     * @memberof Features
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    Features.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.featurePresence != null && message.hasOwnProperty("featurePresence")) {
            if (!Array.isArray(message.featurePresence))
                return "featurePresence: array expected";
            for (var i = 0; i < message.featurePresence.length; ++i) {
                var error = $root.Feature.verify(message.featurePresence[i]);
                if (error)
                    return "featurePresence." + error;
            }
        }
        if (message.featureRating != null && message.hasOwnProperty("featureRating")) {
            if (!Array.isArray(message.featureRating))
                return "featureRating: array expected";
            for (var i = 0; i < message.featureRating.length; ++i) {
                var error = $root.Feature.verify(message.featureRating[i]);
                if (error)
                    return "featureRating." + error;
            }
        }
        return null;
    };

    /**
     * Creates a Features message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof Features
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {Features} Features
     */
    Features.fromObject = function fromObject(object) {
        if (object instanceof $root.Features)
            return object;
        var message = new $root.Features();
        if (object.featurePresence) {
            if (!Array.isArray(object.featurePresence))
                throw TypeError(".Features.featurePresence: array expected");
            message.featurePresence = [];
            for (var i = 0; i < object.featurePresence.length; ++i) {
                if (typeof object.featurePresence[i] !== "object")
                    throw TypeError(".Features.featurePresence: object expected");
                message.featurePresence[i] = $root.Feature.fromObject(object.featurePresence[i]);
            }
        }
        if (object.featureRating) {
            if (!Array.isArray(object.featureRating))
                throw TypeError(".Features.featureRating: array expected");
            message.featureRating = [];
            for (var i = 0; i < object.featureRating.length; ++i) {
                if (typeof object.featureRating[i] !== "object")
                    throw TypeError(".Features.featureRating: object expected");
                message.featureRating[i] = $root.Feature.fromObject(object.featureRating[i]);
            }
        }
        return message;
    };

    /**
     * Creates a plain object from a Features message. Also converts values to other types if specified.
     * @function toObject
     * @memberof Features
     * @static
     * @param {Features} message Features
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    Features.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        var object = {};
        if (options.arrays || options.defaults) {
            object.featurePresence = [];
            object.featureRating = [];
        }
        if (message.featurePresence && message.featurePresence.length) {
            object.featurePresence = [];
            for (var j = 0; j < message.featurePresence.length; ++j)
                object.featurePresence[j] = $root.Feature.toObject(message.featurePresence[j], options);
        }
        if (message.featureRating && message.featureRating.length) {
            object.featureRating = [];
            for (var j = 0; j < message.featureRating.length; ++j)
                object.featureRating[j] = $root.Feature.toObject(message.featureRating[j], options);
        }
        return object;
    };

    /**
     * Converts this Features to JSON.
     * @function toJSON
     * @memberof Features
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    Features.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return Features;
})();

$root.Feature = (function() {

    /**
     * Properties of a Feature.
     * @exports IFeature
     * @interface IFeature
     * @property {string|null} [label] Feature label
     * @property {string|null} [value] Feature value
     */

    /**
     * Constructs a new Feature.
     * @exports Feature
     * @classdesc Represents a Feature.
     * @implements IFeature
     * @constructor
     * @param {IFeature=} [properties] Properties to set
     */
    function Feature(properties) {
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * Feature label.
     * @member {string} label
     * @memberof Feature
     * @instance
     */
    Feature.prototype.label = "";

    /**
     * Feature value.
     * @member {string} value
     * @memberof Feature
     * @instance
     */
    Feature.prototype.value = "";

    /**
     * Creates a new Feature instance using the specified properties.
     * @function create
     * @memberof Feature
     * @static
     * @param {IFeature=} [properties] Properties to set
     * @returns {Feature} Feature instance
     */
    Feature.create = function create(properties) {
        return new Feature(properties);
    };

    /**
     * Encodes the specified Feature message. Does not implicitly {@link Feature.verify|verify} messages.
     * @function encode
     * @memberof Feature
     * @static
     * @param {IFeature} message Feature message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    Feature.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.label != null && Object.hasOwnProperty.call(message, "label"))
            writer.uint32(/* id 1, wireType 2 =*/10).string(message.label);
        if (message.value != null && Object.hasOwnProperty.call(message, "value"))
            writer.uint32(/* id 3, wireType 2 =*/26).string(message.value);
        return writer;
    };

    /**
     * Encodes the specified Feature message, length delimited. Does not implicitly {@link Feature.verify|verify} messages.
     * @function encodeDelimited
     * @memberof Feature
     * @static
     * @param {IFeature} message Feature message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    Feature.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a Feature message from the specified reader or buffer.
     * @function decode
     * @memberof Feature
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {Feature} Feature
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    Feature.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Feature();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.label = reader.string();
                break;
            case 3:
                message.value = reader.string();
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a Feature message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof Feature
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {Feature} Feature
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    Feature.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a Feature message.
     * @function verify
     * @memberof Feature
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    Feature.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.label != null && message.hasOwnProperty("label"))
            if (!$util.isString(message.label))
                return "label: string expected";
        if (message.value != null && message.hasOwnProperty("value"))
            if (!$util.isString(message.value))
                return "value: string expected";
        return null;
    };

    /**
     * Creates a Feature message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof Feature
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {Feature} Feature
     */
    Feature.fromObject = function fromObject(object) {
        if (object instanceof $root.Feature)
            return object;
        var message = new $root.Feature();
        if (object.label != null)
            message.label = String(object.label);
        if (object.value != null)
            message.value = String(object.value);
        return message;
    };

    /**
     * Creates a plain object from a Feature message. Also converts values to other types if specified.
     * @function toObject
     * @memberof Feature
     * @static
     * @param {Feature} message Feature
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    Feature.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        var object = {};
        if (options.defaults) {
            object.label = "";
            object.value = "";
        }
        if (message.label != null && message.hasOwnProperty("label"))
            object.label = message.label;
        if (message.value != null && message.hasOwnProperty("value"))
            object.value = message.value;
        return object;
    };

    /**
     * Converts this Feature to JSON.
     * @function toJSON
     * @memberof Feature
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    Feature.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return Feature;
})();

$root.DeviceConfigurationProto = (function() {

    /**
     * Properties of a DeviceConfigurationProto.
     * @exports IDeviceConfigurationProto
     * @interface IDeviceConfigurationProto
     * @property {number|null} [touchScreen] DeviceConfigurationProto touchScreen
     * @property {number|null} [keyboard] DeviceConfigurationProto keyboard
     * @property {number|null} [navigation] DeviceConfigurationProto navigation
     * @property {number|null} [screenLayout] DeviceConfigurationProto screenLayout
     * @property {boolean|null} [hasHardKeyboard] DeviceConfigurationProto hasHardKeyboard
     * @property {boolean|null} [hasFiveWayNavigation] DeviceConfigurationProto hasFiveWayNavigation
     * @property {number|null} [screenDensity] DeviceConfigurationProto screenDensity
     * @property {number|null} [glEsVersion] DeviceConfigurationProto glEsVersion
     * @property {Array.<string>|null} [systemSharedLibrary] DeviceConfigurationProto systemSharedLibrary
     * @property {Array.<string>|null} [systemAvailableFeature] DeviceConfigurationProto systemAvailableFeature
     * @property {Array.<string>|null} [nativePlatform] DeviceConfigurationProto nativePlatform
     * @property {number|null} [screenWidth] DeviceConfigurationProto screenWidth
     * @property {number|null} [screenHeight] DeviceConfigurationProto screenHeight
     * @property {Array.<string>|null} [systemSupportedLocale] DeviceConfigurationProto systemSupportedLocale
     * @property {Array.<string>|null} [glExtension] DeviceConfigurationProto glExtension
     * @property {number|null} [deviceClass] DeviceConfigurationProto deviceClass
     * @property {number|null} [maxApkDownloadSizeMb] DeviceConfigurationProto maxApkDownloadSizeMb
     * @property {number|null} [smallestScreenWidthDP] DeviceConfigurationProto smallestScreenWidthDP
     * @property {number|null} [lowRamDevice] DeviceConfigurationProto lowRamDevice
     * @property {number|Long|null} [totalMemoryBytes] DeviceConfigurationProto totalMemoryBytes
     * @property {number|null} [maxNumOf_CPUCores] DeviceConfigurationProto maxNumOf_CPUCores
     * @property {Array.<IDeviceFeature>|null} [deviceFeature] DeviceConfigurationProto deviceFeature
     * @property {number|null} [unknown28] DeviceConfigurationProto unknown28
     * @property {number|null} [unknown30] DeviceConfigurationProto unknown30
     */

    /**
     * Constructs a new DeviceConfigurationProto.
     * @exports DeviceConfigurationProto
     * @classdesc Represents a DeviceConfigurationProto.
     * @implements IDeviceConfigurationProto
     * @constructor
     * @param {IDeviceConfigurationProto=} [properties] Properties to set
     */
    function DeviceConfigurationProto(properties) {
        this.systemSharedLibrary = [];
        this.systemAvailableFeature = [];
        this.nativePlatform = [];
        this.systemSupportedLocale = [];
        this.glExtension = [];
        this.deviceFeature = [];
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * DeviceConfigurationProto touchScreen.
     * @member {number} touchScreen
     * @memberof DeviceConfigurationProto
     * @instance
     */
    DeviceConfigurationProto.prototype.touchScreen = 0;

    /**
     * DeviceConfigurationProto keyboard.
     * @member {number} keyboard
     * @memberof DeviceConfigurationProto
     * @instance
     */
    DeviceConfigurationProto.prototype.keyboard = 0;

    /**
     * DeviceConfigurationProto navigation.
     * @member {number} navigation
     * @memberof DeviceConfigurationProto
     * @instance
     */
    DeviceConfigurationProto.prototype.navigation = 0;

    /**
     * DeviceConfigurationProto screenLayout.
     * @member {number} screenLayout
     * @memberof DeviceConfigurationProto
     * @instance
     */
    DeviceConfigurationProto.prototype.screenLayout = 0;

    /**
     * DeviceConfigurationProto hasHardKeyboard.
     * @member {boolean} hasHardKeyboard
     * @memberof DeviceConfigurationProto
     * @instance
     */
    DeviceConfigurationProto.prototype.hasHardKeyboard = false;

    /**
     * DeviceConfigurationProto hasFiveWayNavigation.
     * @member {boolean} hasFiveWayNavigation
     * @memberof DeviceConfigurationProto
     * @instance
     */
    DeviceConfigurationProto.prototype.hasFiveWayNavigation = false;

    /**
     * DeviceConfigurationProto screenDensity.
     * @member {number} screenDensity
     * @memberof DeviceConfigurationProto
     * @instance
     */
    DeviceConfigurationProto.prototype.screenDensity = 0;

    /**
     * DeviceConfigurationProto glEsVersion.
     * @member {number} glEsVersion
     * @memberof DeviceConfigurationProto
     * @instance
     */
    DeviceConfigurationProto.prototype.glEsVersion = 0;

    /**
     * DeviceConfigurationProto systemSharedLibrary.
     * @member {Array.<string>} systemSharedLibrary
     * @memberof DeviceConfigurationProto
     * @instance
     */
    DeviceConfigurationProto.prototype.systemSharedLibrary = $util.emptyArray;

    /**
     * DeviceConfigurationProto systemAvailableFeature.
     * @member {Array.<string>} systemAvailableFeature
     * @memberof DeviceConfigurationProto
     * @instance
     */
    DeviceConfigurationProto.prototype.systemAvailableFeature = $util.emptyArray;

    /**
     * DeviceConfigurationProto nativePlatform.
     * @member {Array.<string>} nativePlatform
     * @memberof DeviceConfigurationProto
     * @instance
     */
    DeviceConfigurationProto.prototype.nativePlatform = $util.emptyArray;

    /**
     * DeviceConfigurationProto screenWidth.
     * @member {number} screenWidth
     * @memberof DeviceConfigurationProto
     * @instance
     */
    DeviceConfigurationProto.prototype.screenWidth = 0;

    /**
     * DeviceConfigurationProto screenHeight.
     * @member {number} screenHeight
     * @memberof DeviceConfigurationProto
     * @instance
     */
    DeviceConfigurationProto.prototype.screenHeight = 0;

    /**
     * DeviceConfigurationProto systemSupportedLocale.
     * @member {Array.<string>} systemSupportedLocale
     * @memberof DeviceConfigurationProto
     * @instance
     */
    DeviceConfigurationProto.prototype.systemSupportedLocale = $util.emptyArray;

    /**
     * DeviceConfigurationProto glExtension.
     * @member {Array.<string>} glExtension
     * @memberof DeviceConfigurationProto
     * @instance
     */
    DeviceConfigurationProto.prototype.glExtension = $util.emptyArray;

    /**
     * DeviceConfigurationProto deviceClass.
     * @member {number} deviceClass
     * @memberof DeviceConfigurationProto
     * @instance
     */
    DeviceConfigurationProto.prototype.deviceClass = 0;

    /**
     * DeviceConfigurationProto maxApkDownloadSizeMb.
     * @member {number} maxApkDownloadSizeMb
     * @memberof DeviceConfigurationProto
     * @instance
     */
    DeviceConfigurationProto.prototype.maxApkDownloadSizeMb = 50;

    /**
     * DeviceConfigurationProto smallestScreenWidthDP.
     * @member {number} smallestScreenWidthDP
     * @memberof DeviceConfigurationProto
     * @instance
     */
    DeviceConfigurationProto.prototype.smallestScreenWidthDP = 0;

    /**
     * DeviceConfigurationProto lowRamDevice.
     * @member {number} lowRamDevice
     * @memberof DeviceConfigurationProto
     * @instance
     */
    DeviceConfigurationProto.prototype.lowRamDevice = 0;

    /**
     * DeviceConfigurationProto totalMemoryBytes.
     * @member {number|Long} totalMemoryBytes
     * @memberof DeviceConfigurationProto
     * @instance
     */
    DeviceConfigurationProto.prototype.totalMemoryBytes = $util.Long ? $util.Long.fromBits(-234962944,1,false) : 8354971648;

    /**
     * DeviceConfigurationProto maxNumOf_CPUCores.
     * @member {number} maxNumOf_CPUCores
     * @memberof DeviceConfigurationProto
     * @instance
     */
    DeviceConfigurationProto.prototype.maxNumOf_CPUCores = 8;

    /**
     * DeviceConfigurationProto deviceFeature.
     * @member {Array.<IDeviceFeature>} deviceFeature
     * @memberof DeviceConfigurationProto
     * @instance
     */
    DeviceConfigurationProto.prototype.deviceFeature = $util.emptyArray;

    /**
     * DeviceConfigurationProto unknown28.
     * @member {number} unknown28
     * @memberof DeviceConfigurationProto
     * @instance
     */
    DeviceConfigurationProto.prototype.unknown28 = 0;

    /**
     * DeviceConfigurationProto unknown30.
     * @member {number} unknown30
     * @memberof DeviceConfigurationProto
     * @instance
     */
    DeviceConfigurationProto.prototype.unknown30 = 4;

    /**
     * Creates a new DeviceConfigurationProto instance using the specified properties.
     * @function create
     * @memberof DeviceConfigurationProto
     * @static
     * @param {IDeviceConfigurationProto=} [properties] Properties to set
     * @returns {DeviceConfigurationProto} DeviceConfigurationProto instance
     */
    DeviceConfigurationProto.create = function create(properties) {
        return new DeviceConfigurationProto(properties);
    };

    /**
     * Encodes the specified DeviceConfigurationProto message. Does not implicitly {@link DeviceConfigurationProto.verify|verify} messages.
     * @function encode
     * @memberof DeviceConfigurationProto
     * @static
     * @param {IDeviceConfigurationProto} message DeviceConfigurationProto message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    DeviceConfigurationProto.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.touchScreen != null && Object.hasOwnProperty.call(message, "touchScreen"))
            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.touchScreen);
        if (message.keyboard != null && Object.hasOwnProperty.call(message, "keyboard"))
            writer.uint32(/* id 2, wireType 0 =*/16).int32(message.keyboard);
        if (message.navigation != null && Object.hasOwnProperty.call(message, "navigation"))
            writer.uint32(/* id 3, wireType 0 =*/24).int32(message.navigation);
        if (message.screenLayout != null && Object.hasOwnProperty.call(message, "screenLayout"))
            writer.uint32(/* id 4, wireType 0 =*/32).int32(message.screenLayout);
        if (message.hasHardKeyboard != null && Object.hasOwnProperty.call(message, "hasHardKeyboard"))
            writer.uint32(/* id 5, wireType 0 =*/40).bool(message.hasHardKeyboard);
        if (message.hasFiveWayNavigation != null && Object.hasOwnProperty.call(message, "hasFiveWayNavigation"))
            writer.uint32(/* id 6, wireType 0 =*/48).bool(message.hasFiveWayNavigation);
        if (message.screenDensity != null && Object.hasOwnProperty.call(message, "screenDensity"))
            writer.uint32(/* id 7, wireType 0 =*/56).int32(message.screenDensity);
        if (message.glEsVersion != null && Object.hasOwnProperty.call(message, "glEsVersion"))
            writer.uint32(/* id 8, wireType 0 =*/64).int32(message.glEsVersion);
        if (message.systemSharedLibrary != null && message.systemSharedLibrary.length)
            for (var i = 0; i < message.systemSharedLibrary.length; ++i)
                writer.uint32(/* id 9, wireType 2 =*/74).string(message.systemSharedLibrary[i]);
        if (message.systemAvailableFeature != null && message.systemAvailableFeature.length)
            for (var i = 0; i < message.systemAvailableFeature.length; ++i)
                writer.uint32(/* id 10, wireType 2 =*/82).string(message.systemAvailableFeature[i]);
        if (message.nativePlatform != null && message.nativePlatform.length)
            for (var i = 0; i < message.nativePlatform.length; ++i)
                writer.uint32(/* id 11, wireType 2 =*/90).string(message.nativePlatform[i]);
        if (message.screenWidth != null && Object.hasOwnProperty.call(message, "screenWidth"))
            writer.uint32(/* id 12, wireType 0 =*/96).int32(message.screenWidth);
        if (message.screenHeight != null && Object.hasOwnProperty.call(message, "screenHeight"))
            writer.uint32(/* id 13, wireType 0 =*/104).int32(message.screenHeight);
        if (message.systemSupportedLocale != null && message.systemSupportedLocale.length)
            for (var i = 0; i < message.systemSupportedLocale.length; ++i)
                writer.uint32(/* id 14, wireType 2 =*/114).string(message.systemSupportedLocale[i]);
        if (message.glExtension != null && message.glExtension.length)
            for (var i = 0; i < message.glExtension.length; ++i)
                writer.uint32(/* id 15, wireType 2 =*/122).string(message.glExtension[i]);
        if (message.deviceClass != null && Object.hasOwnProperty.call(message, "deviceClass"))
            writer.uint32(/* id 16, wireType 0 =*/128).int32(message.deviceClass);
        if (message.maxApkDownloadSizeMb != null && Object.hasOwnProperty.call(message, "maxApkDownloadSizeMb"))
            writer.uint32(/* id 17, wireType 0 =*/136).int32(message.maxApkDownloadSizeMb);
        if (message.smallestScreenWidthDP != null && Object.hasOwnProperty.call(message, "smallestScreenWidthDP"))
            writer.uint32(/* id 18, wireType 0 =*/144).int32(message.smallestScreenWidthDP);
        if (message.lowRamDevice != null && Object.hasOwnProperty.call(message, "lowRamDevice"))
            writer.uint32(/* id 19, wireType 0 =*/152).int32(message.lowRamDevice);
        if (message.totalMemoryBytes != null && Object.hasOwnProperty.call(message, "totalMemoryBytes"))
            writer.uint32(/* id 20, wireType 0 =*/160).int64(message.totalMemoryBytes);
        if (message.maxNumOf_CPUCores != null && Object.hasOwnProperty.call(message, "maxNumOf_CPUCores"))
            writer.uint32(/* id 21, wireType 0 =*/168).int32(message.maxNumOf_CPUCores);
        if (message.deviceFeature != null && message.deviceFeature.length)
            for (var i = 0; i < message.deviceFeature.length; ++i)
                $root.DeviceFeature.encode(message.deviceFeature[i], writer.uint32(/* id 26, wireType 2 =*/210).fork()).ldelim();
        if (message.unknown28 != null && Object.hasOwnProperty.call(message, "unknown28"))
            writer.uint32(/* id 28, wireType 0 =*/224).int32(message.unknown28);
        if (message.unknown30 != null && Object.hasOwnProperty.call(message, "unknown30"))
            writer.uint32(/* id 30, wireType 0 =*/240).int32(message.unknown30);
        return writer;
    };

    /**
     * Encodes the specified DeviceConfigurationProto message, length delimited. Does not implicitly {@link DeviceConfigurationProto.verify|verify} messages.
     * @function encodeDelimited
     * @memberof DeviceConfigurationProto
     * @static
     * @param {IDeviceConfigurationProto} message DeviceConfigurationProto message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    DeviceConfigurationProto.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a DeviceConfigurationProto message from the specified reader or buffer.
     * @function decode
     * @memberof DeviceConfigurationProto
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {DeviceConfigurationProto} DeviceConfigurationProto
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    DeviceConfigurationProto.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.DeviceConfigurationProto();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.touchScreen = reader.int32();
                break;
            case 2:
                message.keyboard = reader.int32();
                break;
            case 3:
                message.navigation = reader.int32();
                break;
            case 4:
                message.screenLayout = reader.int32();
                break;
            case 5:
                message.hasHardKeyboard = reader.bool();
                break;
            case 6:
                message.hasFiveWayNavigation = reader.bool();
                break;
            case 7:
                message.screenDensity = reader.int32();
                break;
            case 8:
                message.glEsVersion = reader.int32();
                break;
            case 9:
                if (!(message.systemSharedLibrary && message.systemSharedLibrary.length))
                    message.systemSharedLibrary = [];
                message.systemSharedLibrary.push(reader.string());
                break;
            case 10:
                if (!(message.systemAvailableFeature && message.systemAvailableFeature.length))
                    message.systemAvailableFeature = [];
                message.systemAvailableFeature.push(reader.string());
                break;
            case 11:
                if (!(message.nativePlatform && message.nativePlatform.length))
                    message.nativePlatform = [];
                message.nativePlatform.push(reader.string());
                break;
            case 12:
                message.screenWidth = reader.int32();
                break;
            case 13:
                message.screenHeight = reader.int32();
                break;
            case 14:
                if (!(message.systemSupportedLocale && message.systemSupportedLocale.length))
                    message.systemSupportedLocale = [];
                message.systemSupportedLocale.push(reader.string());
                break;
            case 15:
                if (!(message.glExtension && message.glExtension.length))
                    message.glExtension = [];
                message.glExtension.push(reader.string());
                break;
            case 16:
                message.deviceClass = reader.int32();
                break;
            case 17:
                message.maxApkDownloadSizeMb = reader.int32();
                break;
            case 18:
                message.smallestScreenWidthDP = reader.int32();
                break;
            case 19:
                message.lowRamDevice = reader.int32();
                break;
            case 20:
                message.totalMemoryBytes = reader.int64();
                break;
            case 21:
                message.maxNumOf_CPUCores = reader.int32();
                break;
            case 26:
                if (!(message.deviceFeature && message.deviceFeature.length))
                    message.deviceFeature = [];
                message.deviceFeature.push($root.DeviceFeature.decode(reader, reader.uint32()));
                break;
            case 28:
                message.unknown28 = reader.int32();
                break;
            case 30:
                message.unknown30 = reader.int32();
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a DeviceConfigurationProto message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof DeviceConfigurationProto
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {DeviceConfigurationProto} DeviceConfigurationProto
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    DeviceConfigurationProto.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a DeviceConfigurationProto message.
     * @function verify
     * @memberof DeviceConfigurationProto
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    DeviceConfigurationProto.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.touchScreen != null && message.hasOwnProperty("touchScreen"))
            if (!$util.isInteger(message.touchScreen))
                return "touchScreen: integer expected";
        if (message.keyboard != null && message.hasOwnProperty("keyboard"))
            if (!$util.isInteger(message.keyboard))
                return "keyboard: integer expected";
        if (message.navigation != null && message.hasOwnProperty("navigation"))
            if (!$util.isInteger(message.navigation))
                return "navigation: integer expected";
        if (message.screenLayout != null && message.hasOwnProperty("screenLayout"))
            if (!$util.isInteger(message.screenLayout))
                return "screenLayout: integer expected";
        if (message.hasHardKeyboard != null && message.hasOwnProperty("hasHardKeyboard"))
            if (typeof message.hasHardKeyboard !== "boolean")
                return "hasHardKeyboard: boolean expected";
        if (message.hasFiveWayNavigation != null && message.hasOwnProperty("hasFiveWayNavigation"))
            if (typeof message.hasFiveWayNavigation !== "boolean")
                return "hasFiveWayNavigation: boolean expected";
        if (message.screenDensity != null && message.hasOwnProperty("screenDensity"))
            if (!$util.isInteger(message.screenDensity))
                return "screenDensity: integer expected";
        if (message.glEsVersion != null && message.hasOwnProperty("glEsVersion"))
            if (!$util.isInteger(message.glEsVersion))
                return "glEsVersion: integer expected";
        if (message.systemSharedLibrary != null && message.hasOwnProperty("systemSharedLibrary")) {
            if (!Array.isArray(message.systemSharedLibrary))
                return "systemSharedLibrary: array expected";
            for (var i = 0; i < message.systemSharedLibrary.length; ++i)
                if (!$util.isString(message.systemSharedLibrary[i]))
                    return "systemSharedLibrary: string[] expected";
        }
        if (message.systemAvailableFeature != null && message.hasOwnProperty("systemAvailableFeature")) {
            if (!Array.isArray(message.systemAvailableFeature))
                return "systemAvailableFeature: array expected";
            for (var i = 0; i < message.systemAvailableFeature.length; ++i)
                if (!$util.isString(message.systemAvailableFeature[i]))
                    return "systemAvailableFeature: string[] expected";
        }
        if (message.nativePlatform != null && message.hasOwnProperty("nativePlatform")) {
            if (!Array.isArray(message.nativePlatform))
                return "nativePlatform: array expected";
            for (var i = 0; i < message.nativePlatform.length; ++i)
                if (!$util.isString(message.nativePlatform[i]))
                    return "nativePlatform: string[] expected";
        }
        if (message.screenWidth != null && message.hasOwnProperty("screenWidth"))
            if (!$util.isInteger(message.screenWidth))
                return "screenWidth: integer expected";
        if (message.screenHeight != null && message.hasOwnProperty("screenHeight"))
            if (!$util.isInteger(message.screenHeight))
                return "screenHeight: integer expected";
        if (message.systemSupportedLocale != null && message.hasOwnProperty("systemSupportedLocale")) {
            if (!Array.isArray(message.systemSupportedLocale))
                return "systemSupportedLocale: array expected";
            for (var i = 0; i < message.systemSupportedLocale.length; ++i)
                if (!$util.isString(message.systemSupportedLocale[i]))
                    return "systemSupportedLocale: string[] expected";
        }
        if (message.glExtension != null && message.hasOwnProperty("glExtension")) {
            if (!Array.isArray(message.glExtension))
                return "glExtension: array expected";
            for (var i = 0; i < message.glExtension.length; ++i)
                if (!$util.isString(message.glExtension[i]))
                    return "glExtension: string[] expected";
        }
        if (message.deviceClass != null && message.hasOwnProperty("deviceClass"))
            if (!$util.isInteger(message.deviceClass))
                return "deviceClass: integer expected";
        if (message.maxApkDownloadSizeMb != null && message.hasOwnProperty("maxApkDownloadSizeMb"))
            if (!$util.isInteger(message.maxApkDownloadSizeMb))
                return "maxApkDownloadSizeMb: integer expected";
        if (message.smallestScreenWidthDP != null && message.hasOwnProperty("smallestScreenWidthDP"))
            if (!$util.isInteger(message.smallestScreenWidthDP))
                return "smallestScreenWidthDP: integer expected";
        if (message.lowRamDevice != null && message.hasOwnProperty("lowRamDevice"))
            if (!$util.isInteger(message.lowRamDevice))
                return "lowRamDevice: integer expected";
        if (message.totalMemoryBytes != null && message.hasOwnProperty("totalMemoryBytes"))
            if (!$util.isInteger(message.totalMemoryBytes) && !(message.totalMemoryBytes && $util.isInteger(message.totalMemoryBytes.low) && $util.isInteger(message.totalMemoryBytes.high)))
                return "totalMemoryBytes: integer|Long expected";
        if (message.maxNumOf_CPUCores != null && message.hasOwnProperty("maxNumOf_CPUCores"))
            if (!$util.isInteger(message.maxNumOf_CPUCores))
                return "maxNumOf_CPUCores: integer expected";
        if (message.deviceFeature != null && message.hasOwnProperty("deviceFeature")) {
            if (!Array.isArray(message.deviceFeature))
                return "deviceFeature: array expected";
            for (var i = 0; i < message.deviceFeature.length; ++i) {
                var error = $root.DeviceFeature.verify(message.deviceFeature[i]);
                if (error)
                    return "deviceFeature." + error;
            }
        }
        if (message.unknown28 != null && message.hasOwnProperty("unknown28"))
            if (!$util.isInteger(message.unknown28))
                return "unknown28: integer expected";
        if (message.unknown30 != null && message.hasOwnProperty("unknown30"))
            if (!$util.isInteger(message.unknown30))
                return "unknown30: integer expected";
        return null;
    };

    /**
     * Creates a DeviceConfigurationProto message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof DeviceConfigurationProto
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {DeviceConfigurationProto} DeviceConfigurationProto
     */
    DeviceConfigurationProto.fromObject = function fromObject(object) {
        if (object instanceof $root.DeviceConfigurationProto)
            return object;
        var message = new $root.DeviceConfigurationProto();
        if (object.touchScreen != null)
            message.touchScreen = object.touchScreen | 0;
        if (object.keyboard != null)
            message.keyboard = object.keyboard | 0;
        if (object.navigation != null)
            message.navigation = object.navigation | 0;
        if (object.screenLayout != null)
            message.screenLayout = object.screenLayout | 0;
        if (object.hasHardKeyboard != null)
            message.hasHardKeyboard = Boolean(object.hasHardKeyboard);
        if (object.hasFiveWayNavigation != null)
            message.hasFiveWayNavigation = Boolean(object.hasFiveWayNavigation);
        if (object.screenDensity != null)
            message.screenDensity = object.screenDensity | 0;
        if (object.glEsVersion != null)
            message.glEsVersion = object.glEsVersion | 0;
        if (object.systemSharedLibrary) {
            if (!Array.isArray(object.systemSharedLibrary))
                throw TypeError(".DeviceConfigurationProto.systemSharedLibrary: array expected");
            message.systemSharedLibrary = [];
            for (var i = 0; i < object.systemSharedLibrary.length; ++i)
                message.systemSharedLibrary[i] = String(object.systemSharedLibrary[i]);
        }
        if (object.systemAvailableFeature) {
            if (!Array.isArray(object.systemAvailableFeature))
                throw TypeError(".DeviceConfigurationProto.systemAvailableFeature: array expected");
            message.systemAvailableFeature = [];
            for (var i = 0; i < object.systemAvailableFeature.length; ++i)
                message.systemAvailableFeature[i] = String(object.systemAvailableFeature[i]);
        }
        if (object.nativePlatform) {
            if (!Array.isArray(object.nativePlatform))
                throw TypeError(".DeviceConfigurationProto.nativePlatform: array expected");
            message.nativePlatform = [];
            for (var i = 0; i < object.nativePlatform.length; ++i)
                message.nativePlatform[i] = String(object.nativePlatform[i]);
        }
        if (object.screenWidth != null)
            message.screenWidth = object.screenWidth | 0;
        if (object.screenHeight != null)
            message.screenHeight = object.screenHeight | 0;
        if (object.systemSupportedLocale) {
            if (!Array.isArray(object.systemSupportedLocale))
                throw TypeError(".DeviceConfigurationProto.systemSupportedLocale: array expected");
            message.systemSupportedLocale = [];
            for (var i = 0; i < object.systemSupportedLocale.length; ++i)
                message.systemSupportedLocale[i] = String(object.systemSupportedLocale[i]);
        }
        if (object.glExtension) {
            if (!Array.isArray(object.glExtension))
                throw TypeError(".DeviceConfigurationProto.glExtension: array expected");
            message.glExtension = [];
            for (var i = 0; i < object.glExtension.length; ++i)
                message.glExtension[i] = String(object.glExtension[i]);
        }
        if (object.deviceClass != null)
            message.deviceClass = object.deviceClass | 0;
        if (object.maxApkDownloadSizeMb != null)
            message.maxApkDownloadSizeMb = object.maxApkDownloadSizeMb | 0;
        if (object.smallestScreenWidthDP != null)
            message.smallestScreenWidthDP = object.smallestScreenWidthDP | 0;
        if (object.lowRamDevice != null)
            message.lowRamDevice = object.lowRamDevice | 0;
        if (object.totalMemoryBytes != null)
            if ($util.Long)
                (message.totalMemoryBytes = $util.Long.fromValue(object.totalMemoryBytes)).unsigned = false;
            else if (typeof object.totalMemoryBytes === "string")
                message.totalMemoryBytes = parseInt(object.totalMemoryBytes, 10);
            else if (typeof object.totalMemoryBytes === "number")
                message.totalMemoryBytes = object.totalMemoryBytes;
            else if (typeof object.totalMemoryBytes === "object")
                message.totalMemoryBytes = new $util.LongBits(object.totalMemoryBytes.low >>> 0, object.totalMemoryBytes.high >>> 0).toNumber();
        if (object.maxNumOf_CPUCores != null)
            message.maxNumOf_CPUCores = object.maxNumOf_CPUCores | 0;
        if (object.deviceFeature) {
            if (!Array.isArray(object.deviceFeature))
                throw TypeError(".DeviceConfigurationProto.deviceFeature: array expected");
            message.deviceFeature = [];
            for (var i = 0; i < object.deviceFeature.length; ++i) {
                if (typeof object.deviceFeature[i] !== "object")
                    throw TypeError(".DeviceConfigurationProto.deviceFeature: object expected");
                message.deviceFeature[i] = $root.DeviceFeature.fromObject(object.deviceFeature[i]);
            }
        }
        if (object.unknown28 != null)
            message.unknown28 = object.unknown28 | 0;
        if (object.unknown30 != null)
            message.unknown30 = object.unknown30 | 0;
        return message;
    };

    /**
     * Creates a plain object from a DeviceConfigurationProto message. Also converts values to other types if specified.
     * @function toObject
     * @memberof DeviceConfigurationProto
     * @static
     * @param {DeviceConfigurationProto} message DeviceConfigurationProto
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    DeviceConfigurationProto.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        var object = {};
        if (options.arrays || options.defaults) {
            object.systemSharedLibrary = [];
            object.systemAvailableFeature = [];
            object.nativePlatform = [];
            object.systemSupportedLocale = [];
            object.glExtension = [];
            object.deviceFeature = [];
        }
        if (options.defaults) {
            object.touchScreen = 0;
            object.keyboard = 0;
            object.navigation = 0;
            object.screenLayout = 0;
            object.hasHardKeyboard = false;
            object.hasFiveWayNavigation = false;
            object.screenDensity = 0;
            object.glEsVersion = 0;
            object.screenWidth = 0;
            object.screenHeight = 0;
            object.deviceClass = 0;
            object.maxApkDownloadSizeMb = 50;
            object.smallestScreenWidthDP = 0;
            object.lowRamDevice = 0;
            if ($util.Long) {
                var long = new $util.Long(-234962944, 1, false);
                object.totalMemoryBytes = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
            } else
                object.totalMemoryBytes = options.longs === String ? "8354971648" : 8354971648;
            object.maxNumOf_CPUCores = 8;
            object.unknown28 = 0;
            object.unknown30 = 4;
        }
        if (message.touchScreen != null && message.hasOwnProperty("touchScreen"))
            object.touchScreen = message.touchScreen;
        if (message.keyboard != null && message.hasOwnProperty("keyboard"))
            object.keyboard = message.keyboard;
        if (message.navigation != null && message.hasOwnProperty("navigation"))
            object.navigation = message.navigation;
        if (message.screenLayout != null && message.hasOwnProperty("screenLayout"))
            object.screenLayout = message.screenLayout;
        if (message.hasHardKeyboard != null && message.hasOwnProperty("hasHardKeyboard"))
            object.hasHardKeyboard = message.hasHardKeyboard;
        if (message.hasFiveWayNavigation != null && message.hasOwnProperty("hasFiveWayNavigation"))
            object.hasFiveWayNavigation = message.hasFiveWayNavigation;
        if (message.screenDensity != null && message.hasOwnProperty("screenDensity"))
            object.screenDensity = message.screenDensity;
        if (message.glEsVersion != null && message.hasOwnProperty("glEsVersion"))
            object.glEsVersion = message.glEsVersion;
        if (message.systemSharedLibrary && message.systemSharedLibrary.length) {
            object.systemSharedLibrary = [];
            for (var j = 0; j < message.systemSharedLibrary.length; ++j)
                object.systemSharedLibrary[j] = message.systemSharedLibrary[j];
        }
        if (message.systemAvailableFeature && message.systemAvailableFeature.length) {
            object.systemAvailableFeature = [];
            for (var j = 0; j < message.systemAvailableFeature.length; ++j)
                object.systemAvailableFeature[j] = message.systemAvailableFeature[j];
        }
        if (message.nativePlatform && message.nativePlatform.length) {
            object.nativePlatform = [];
            for (var j = 0; j < message.nativePlatform.length; ++j)
                object.nativePlatform[j] = message.nativePlatform[j];
        }
        if (message.screenWidth != null && message.hasOwnProperty("screenWidth"))
            object.screenWidth = message.screenWidth;
        if (message.screenHeight != null && message.hasOwnProperty("screenHeight"))
            object.screenHeight = message.screenHeight;
        if (message.systemSupportedLocale && message.systemSupportedLocale.length) {
            object.systemSupportedLocale = [];
            for (var j = 0; j < message.systemSupportedLocale.length; ++j)
                object.systemSupportedLocale[j] = message.systemSupportedLocale[j];
        }
        if (message.glExtension && message.glExtension.length) {
            object.glExtension = [];
            for (var j = 0; j < message.glExtension.length; ++j)
                object.glExtension[j] = message.glExtension[j];
        }
        if (message.deviceClass != null && message.hasOwnProperty("deviceClass"))
            object.deviceClass = message.deviceClass;
        if (message.maxApkDownloadSizeMb != null && message.hasOwnProperty("maxApkDownloadSizeMb"))
            object.maxApkDownloadSizeMb = message.maxApkDownloadSizeMb;
        if (message.smallestScreenWidthDP != null && message.hasOwnProperty("smallestScreenWidthDP"))
            object.smallestScreenWidthDP = message.smallestScreenWidthDP;
        if (message.lowRamDevice != null && message.hasOwnProperty("lowRamDevice"))
            object.lowRamDevice = message.lowRamDevice;
        if (message.totalMemoryBytes != null && message.hasOwnProperty("totalMemoryBytes"))
            if (typeof message.totalMemoryBytes === "number")
                object.totalMemoryBytes = options.longs === String ? String(message.totalMemoryBytes) : message.totalMemoryBytes;
            else
                object.totalMemoryBytes = options.longs === String ? $util.Long.prototype.toString.call(message.totalMemoryBytes) : options.longs === Number ? new $util.LongBits(message.totalMemoryBytes.low >>> 0, message.totalMemoryBytes.high >>> 0).toNumber() : message.totalMemoryBytes;
        if (message.maxNumOf_CPUCores != null && message.hasOwnProperty("maxNumOf_CPUCores"))
            object.maxNumOf_CPUCores = message.maxNumOf_CPUCores;
        if (message.deviceFeature && message.deviceFeature.length) {
            object.deviceFeature = [];
            for (var j = 0; j < message.deviceFeature.length; ++j)
                object.deviceFeature[j] = $root.DeviceFeature.toObject(message.deviceFeature[j], options);
        }
        if (message.unknown28 != null && message.hasOwnProperty("unknown28"))
            object.unknown28 = message.unknown28;
        if (message.unknown30 != null && message.hasOwnProperty("unknown30"))
            object.unknown30 = message.unknown30;
        return object;
    };

    /**
     * Converts this DeviceConfigurationProto to JSON.
     * @function toJSON
     * @memberof DeviceConfigurationProto
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    DeviceConfigurationProto.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return DeviceConfigurationProto;
})();

$root.DeviceFeature = (function() {

    /**
     * Properties of a DeviceFeature.
     * @exports IDeviceFeature
     * @interface IDeviceFeature
     * @property {string|null} [name] DeviceFeature name
     * @property {number|null} [value] DeviceFeature value
     */

    /**
     * Constructs a new DeviceFeature.
     * @exports DeviceFeature
     * @classdesc Represents a DeviceFeature.
     * @implements IDeviceFeature
     * @constructor
     * @param {IDeviceFeature=} [properties] Properties to set
     */
    function DeviceFeature(properties) {
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * DeviceFeature name.
     * @member {string} name
     * @memberof DeviceFeature
     * @instance
     */
    DeviceFeature.prototype.name = "";

    /**
     * DeviceFeature value.
     * @member {number} value
     * @memberof DeviceFeature
     * @instance
     */
    DeviceFeature.prototype.value = 0;

    /**
     * Creates a new DeviceFeature instance using the specified properties.
     * @function create
     * @memberof DeviceFeature
     * @static
     * @param {IDeviceFeature=} [properties] Properties to set
     * @returns {DeviceFeature} DeviceFeature instance
     */
    DeviceFeature.create = function create(properties) {
        return new DeviceFeature(properties);
    };

    /**
     * Encodes the specified DeviceFeature message. Does not implicitly {@link DeviceFeature.verify|verify} messages.
     * @function encode
     * @memberof DeviceFeature
     * @static
     * @param {IDeviceFeature} message DeviceFeature message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    DeviceFeature.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.name != null && Object.hasOwnProperty.call(message, "name"))
            writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
        if (message.value != null && Object.hasOwnProperty.call(message, "value"))
            writer.uint32(/* id 2, wireType 0 =*/16).int32(message.value);
        return writer;
    };

    /**
     * Encodes the specified DeviceFeature message, length delimited. Does not implicitly {@link DeviceFeature.verify|verify} messages.
     * @function encodeDelimited
     * @memberof DeviceFeature
     * @static
     * @param {IDeviceFeature} message DeviceFeature message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    DeviceFeature.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a DeviceFeature message from the specified reader or buffer.
     * @function decode
     * @memberof DeviceFeature
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {DeviceFeature} DeviceFeature
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    DeviceFeature.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.DeviceFeature();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.name = reader.string();
                break;
            case 2:
                message.value = reader.int32();
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a DeviceFeature message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof DeviceFeature
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {DeviceFeature} DeviceFeature
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    DeviceFeature.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a DeviceFeature message.
     * @function verify
     * @memberof DeviceFeature
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    DeviceFeature.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.name != null && message.hasOwnProperty("name"))
            if (!$util.isString(message.name))
                return "name: string expected";
        if (message.value != null && message.hasOwnProperty("value"))
            if (!$util.isInteger(message.value))
                return "value: integer expected";
        return null;
    };

    /**
     * Creates a DeviceFeature message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof DeviceFeature
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {DeviceFeature} DeviceFeature
     */
    DeviceFeature.fromObject = function fromObject(object) {
        if (object instanceof $root.DeviceFeature)
            return object;
        var message = new $root.DeviceFeature();
        if (object.name != null)
            message.name = String(object.name);
        if (object.value != null)
            message.value = object.value | 0;
        return message;
    };

    /**
     * Creates a plain object from a DeviceFeature message. Also converts values to other types if specified.
     * @function toObject
     * @memberof DeviceFeature
     * @static
     * @param {DeviceFeature} message DeviceFeature
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    DeviceFeature.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        var object = {};
        if (options.defaults) {
            object.name = "";
            object.value = 0;
        }
        if (message.name != null && message.hasOwnProperty("name"))
            object.name = message.name;
        if (message.value != null && message.hasOwnProperty("value"))
            object.value = message.value;
        return object;
    };

    /**
     * Converts this DeviceFeature to JSON.
     * @function toJSON
     * @memberof DeviceFeature
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    DeviceFeature.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return DeviceFeature;
})();

$root.Document = (function() {

    /**
     * Properties of a Document.
     * @exports IDocument
     * @interface IDocument
     * @property {IDocId|null} [DocId] Document DocId
     * @property {IDocId|null} [fetchDocId] Document fetchDocId
     * @property {IDocId|null} [sampleDocId] Document sampleDocId
     * @property {string|null} [title] Document title
     * @property {string|null} [url] Document url
     * @property {Array.<string>|null} [snippet] Document snippet
     * @property {IOffer|null} [priceDeprecated] Document priceDeprecated
     * @property {IAvailability|null} [availability] Document availability
     * @property {Array.<IImage>|null} [image] Document image
     * @property {Array.<IDocument>|null} [child] Document child
     * @property {IAggregateRating|null} [aggregateRating] Document aggregateRating
     * @property {Array.<IOffer>|null} [offer] Document offer
     * @property {Array.<ITranslatedText>|null} [translatedSnippet] Document translatedSnippet
     * @property {Array.<IDocumentVariant>|null} [documentVariant] Document documentVariant
     * @property {Array.<string>|null} [categoryId] Document categoryId
     * @property {Array.<IDocument>|null} [decoration] Document decoration
     * @property {Array.<IDocument>|null} [parent] Document parent
     * @property {string|null} [privacyPolicyUrl] Document privacyPolicyUrl
     * @property {string|null} [consumptionUrl] Document consumptionUrl
     * @property {number|null} [estimatedNumChildren] Document estimatedNumChildren
     * @property {string|null} [subtitle] Document subtitle
     */

    /**
     * Constructs a new Document.
     * @exports Document
     * @classdesc Represents a Document.
     * @implements IDocument
     * @constructor
     * @param {IDocument=} [properties] Properties to set
     */
    function Document(properties) {
        this.snippet = [];
        this.image = [];
        this.child = [];
        this.offer = [];
        this.translatedSnippet = [];
        this.documentVariant = [];
        this.categoryId = [];
        this.decoration = [];
        this.parent = [];
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * Document DocId.
     * @member {IDocId|null|undefined} DocId
     * @memberof Document
     * @instance
     */
    Document.prototype.DocId = null;

    /**
     * Document fetchDocId.
     * @member {IDocId|null|undefined} fetchDocId
     * @memberof Document
     * @instance
     */
    Document.prototype.fetchDocId = null;

    /**
     * Document sampleDocId.
     * @member {IDocId|null|undefined} sampleDocId
     * @memberof Document
     * @instance
     */
    Document.prototype.sampleDocId = null;

    /**
     * Document title.
     * @member {string} title
     * @memberof Document
     * @instance
     */
    Document.prototype.title = "";

    /**
     * Document url.
     * @member {string} url
     * @memberof Document
     * @instance
     */
    Document.prototype.url = "";

    /**
     * Document snippet.
     * @member {Array.<string>} snippet
     * @memberof Document
     * @instance
     */
    Document.prototype.snippet = $util.emptyArray;

    /**
     * Document priceDeprecated.
     * @member {IOffer|null|undefined} priceDeprecated
     * @memberof Document
     * @instance
     */
    Document.prototype.priceDeprecated = null;

    /**
     * Document availability.
     * @member {IAvailability|null|undefined} availability
     * @memberof Document
     * @instance
     */
    Document.prototype.availability = null;

    /**
     * Document image.
     * @member {Array.<IImage>} image
     * @memberof Document
     * @instance
     */
    Document.prototype.image = $util.emptyArray;

    /**
     * Document child.
     * @member {Array.<IDocument>} child
     * @memberof Document
     * @instance
     */
    Document.prototype.child = $util.emptyArray;

    /**
     * Document aggregateRating.
     * @member {IAggregateRating|null|undefined} aggregateRating
     * @memberof Document
     * @instance
     */
    Document.prototype.aggregateRating = null;

    /**
     * Document offer.
     * @member {Array.<IOffer>} offer
     * @memberof Document
     * @instance
     */
    Document.prototype.offer = $util.emptyArray;

    /**
     * Document translatedSnippet.
     * @member {Array.<ITranslatedText>} translatedSnippet
     * @memberof Document
     * @instance
     */
    Document.prototype.translatedSnippet = $util.emptyArray;

    /**
     * Document documentVariant.
     * @member {Array.<IDocumentVariant>} documentVariant
     * @memberof Document
     * @instance
     */
    Document.prototype.documentVariant = $util.emptyArray;

    /**
     * Document categoryId.
     * @member {Array.<string>} categoryId
     * @memberof Document
     * @instance
     */
    Document.prototype.categoryId = $util.emptyArray;

    /**
     * Document decoration.
     * @member {Array.<IDocument>} decoration
     * @memberof Document
     * @instance
     */
    Document.prototype.decoration = $util.emptyArray;

    /**
     * Document parent.
     * @member {Array.<IDocument>} parent
     * @memberof Document
     * @instance
     */
    Document.prototype.parent = $util.emptyArray;

    /**
     * Document privacyPolicyUrl.
     * @member {string} privacyPolicyUrl
     * @memberof Document
     * @instance
     */
    Document.prototype.privacyPolicyUrl = "";

    /**
     * Document consumptionUrl.
     * @member {string} consumptionUrl
     * @memberof Document
     * @instance
     */
    Document.prototype.consumptionUrl = "";

    /**
     * Document estimatedNumChildren.
     * @member {number} estimatedNumChildren
     * @memberof Document
     * @instance
     */
    Document.prototype.estimatedNumChildren = 0;

    /**
     * Document subtitle.
     * @member {string} subtitle
     * @memberof Document
     * @instance
     */
    Document.prototype.subtitle = "";

    /**
     * Creates a new Document instance using the specified properties.
     * @function create
     * @memberof Document
     * @static
     * @param {IDocument=} [properties] Properties to set
     * @returns {Document} Document instance
     */
    Document.create = function create(properties) {
        return new Document(properties);
    };

    /**
     * Encodes the specified Document message. Does not implicitly {@link Document.verify|verify} messages.
     * @function encode
     * @memberof Document
     * @static
     * @param {IDocument} message Document message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    Document.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.DocId != null && Object.hasOwnProperty.call(message, "DocId"))
            $root.DocId.encode(message.DocId, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
        if (message.fetchDocId != null && Object.hasOwnProperty.call(message, "fetchDocId"))
            $root.DocId.encode(message.fetchDocId, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
        if (message.sampleDocId != null && Object.hasOwnProperty.call(message, "sampleDocId"))
            $root.DocId.encode(message.sampleDocId, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
        if (message.title != null && Object.hasOwnProperty.call(message, "title"))
            writer.uint32(/* id 4, wireType 2 =*/34).string(message.title);
        if (message.url != null && Object.hasOwnProperty.call(message, "url"))
            writer.uint32(/* id 5, wireType 2 =*/42).string(message.url);
        if (message.snippet != null && message.snippet.length)
            for (var i = 0; i < message.snippet.length; ++i)
                writer.uint32(/* id 6, wireType 2 =*/50).string(message.snippet[i]);
        if (message.priceDeprecated != null && Object.hasOwnProperty.call(message, "priceDeprecated"))
            $root.Offer.encode(message.priceDeprecated, writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
        if (message.availability != null && Object.hasOwnProperty.call(message, "availability"))
            $root.Availability.encode(message.availability, writer.uint32(/* id 9, wireType 2 =*/74).fork()).ldelim();
        if (message.image != null && message.image.length)
            for (var i = 0; i < message.image.length; ++i)
                $root.Image.encode(message.image[i], writer.uint32(/* id 10, wireType 2 =*/82).fork()).ldelim();
        if (message.child != null && message.child.length)
            for (var i = 0; i < message.child.length; ++i)
                $root.Document.encode(message.child[i], writer.uint32(/* id 11, wireType 2 =*/90).fork()).ldelim();
        if (message.aggregateRating != null && Object.hasOwnProperty.call(message, "aggregateRating"))
            $root.AggregateRating.encode(message.aggregateRating, writer.uint32(/* id 13, wireType 2 =*/106).fork()).ldelim();
        if (message.offer != null && message.offer.length)
            for (var i = 0; i < message.offer.length; ++i)
                $root.Offer.encode(message.offer[i], writer.uint32(/* id 14, wireType 2 =*/114).fork()).ldelim();
        if (message.translatedSnippet != null && message.translatedSnippet.length)
            for (var i = 0; i < message.translatedSnippet.length; ++i)
                $root.TranslatedText.encode(message.translatedSnippet[i], writer.uint32(/* id 15, wireType 2 =*/122).fork()).ldelim();
        if (message.documentVariant != null && message.documentVariant.length)
            for (var i = 0; i < message.documentVariant.length; ++i)
                $root.DocumentVariant.encode(message.documentVariant[i], writer.uint32(/* id 16, wireType 2 =*/130).fork()).ldelim();
        if (message.categoryId != null && message.categoryId.length)
            for (var i = 0; i < message.categoryId.length; ++i)
                writer.uint32(/* id 17, wireType 2 =*/138).string(message.categoryId[i]);
        if (message.decoration != null && message.decoration.length)
            for (var i = 0; i < message.decoration.length; ++i)
                $root.Document.encode(message.decoration[i], writer.uint32(/* id 18, wireType 2 =*/146).fork()).ldelim();
        if (message.parent != null && message.parent.length)
            for (var i = 0; i < message.parent.length; ++i)
                $root.Document.encode(message.parent[i], writer.uint32(/* id 19, wireType 2 =*/154).fork()).ldelim();
        if (message.privacyPolicyUrl != null && Object.hasOwnProperty.call(message, "privacyPolicyUrl"))
            writer.uint32(/* id 20, wireType 2 =*/162).string(message.privacyPolicyUrl);
        if (message.consumptionUrl != null && Object.hasOwnProperty.call(message, "consumptionUrl"))
            writer.uint32(/* id 21, wireType 2 =*/170).string(message.consumptionUrl);
        if (message.estimatedNumChildren != null && Object.hasOwnProperty.call(message, "estimatedNumChildren"))
            writer.uint32(/* id 22, wireType 0 =*/176).int32(message.estimatedNumChildren);
        if (message.subtitle != null && Object.hasOwnProperty.call(message, "subtitle"))
            writer.uint32(/* id 23, wireType 2 =*/186).string(message.subtitle);
        return writer;
    };

    /**
     * Encodes the specified Document message, length delimited. Does not implicitly {@link Document.verify|verify} messages.
     * @function encodeDelimited
     * @memberof Document
     * @static
     * @param {IDocument} message Document message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    Document.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a Document message from the specified reader or buffer.
     * @function decode
     * @memberof Document
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {Document} Document
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    Document.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Document();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.DocId = $root.DocId.decode(reader, reader.uint32());
                break;
            case 2:
                message.fetchDocId = $root.DocId.decode(reader, reader.uint32());
                break;
            case 3:
                message.sampleDocId = $root.DocId.decode(reader, reader.uint32());
                break;
            case 4:
                message.title = reader.string();
                break;
            case 5:
                message.url = reader.string();
                break;
            case 6:
                if (!(message.snippet && message.snippet.length))
                    message.snippet = [];
                message.snippet.push(reader.string());
                break;
            case 7:
                message.priceDeprecated = $root.Offer.decode(reader, reader.uint32());
                break;
            case 9:
                message.availability = $root.Availability.decode(reader, reader.uint32());
                break;
            case 10:
                if (!(message.image && message.image.length))
                    message.image = [];
                message.image.push($root.Image.decode(reader, reader.uint32()));
                break;
            case 11:
                if (!(message.child && message.child.length))
                    message.child = [];
                message.child.push($root.Document.decode(reader, reader.uint32()));
                break;
            case 13:
                message.aggregateRating = $root.AggregateRating.decode(reader, reader.uint32());
                break;
            case 14:
                if (!(message.offer && message.offer.length))
                    message.offer = [];
                message.offer.push($root.Offer.decode(reader, reader.uint32()));
                break;
            case 15:
                if (!(message.translatedSnippet && message.translatedSnippet.length))
                    message.translatedSnippet = [];
                message.translatedSnippet.push($root.TranslatedText.decode(reader, reader.uint32()));
                break;
            case 16:
                if (!(message.documentVariant && message.documentVariant.length))
                    message.documentVariant = [];
                message.documentVariant.push($root.DocumentVariant.decode(reader, reader.uint32()));
                break;
            case 17:
                if (!(message.categoryId && message.categoryId.length))
                    message.categoryId = [];
                message.categoryId.push(reader.string());
                break;
            case 18:
                if (!(message.decoration && message.decoration.length))
                    message.decoration = [];
                message.decoration.push($root.Document.decode(reader, reader.uint32()));
                break;
            case 19:
                if (!(message.parent && message.parent.length))
                    message.parent = [];
                message.parent.push($root.Document.decode(reader, reader.uint32()));
                break;
            case 20:
                message.privacyPolicyUrl = reader.string();
                break;
            case 21:
                message.consumptionUrl = reader.string();
                break;
            case 22:
                message.estimatedNumChildren = reader.int32();
                break;
            case 23:
                message.subtitle = reader.string();
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a Document message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof Document
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {Document} Document
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    Document.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a Document message.
     * @function verify
     * @memberof Document
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    Document.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.DocId != null && message.hasOwnProperty("DocId")) {
            var error = $root.DocId.verify(message.DocId);
            if (error)
                return "DocId." + error;
        }
        if (message.fetchDocId != null && message.hasOwnProperty("fetchDocId")) {
            var error = $root.DocId.verify(message.fetchDocId);
            if (error)
                return "fetchDocId." + error;
        }
        if (message.sampleDocId != null && message.hasOwnProperty("sampleDocId")) {
            var error = $root.DocId.verify(message.sampleDocId);
            if (error)
                return "sampleDocId." + error;
        }
        if (message.title != null && message.hasOwnProperty("title"))
            if (!$util.isString(message.title))
                return "title: string expected";
        if (message.url != null && message.hasOwnProperty("url"))
            if (!$util.isString(message.url))
                return "url: string expected";
        if (message.snippet != null && message.hasOwnProperty("snippet")) {
            if (!Array.isArray(message.snippet))
                return "snippet: array expected";
            for (var i = 0; i < message.snippet.length; ++i)
                if (!$util.isString(message.snippet[i]))
                    return "snippet: string[] expected";
        }
        if (message.priceDeprecated != null && message.hasOwnProperty("priceDeprecated")) {
            var error = $root.Offer.verify(message.priceDeprecated);
            if (error)
                return "priceDeprecated." + error;
        }
        if (message.availability != null && message.hasOwnProperty("availability")) {
            var error = $root.Availability.verify(message.availability);
            if (error)
                return "availability." + error;
        }
        if (message.image != null && message.hasOwnProperty("image")) {
            if (!Array.isArray(message.image))
                return "image: array expected";
            for (var i = 0; i < message.image.length; ++i) {
                var error = $root.Image.verify(message.image[i]);
                if (error)
                    return "image." + error;
            }
        }
        if (message.child != null && message.hasOwnProperty("child")) {
            if (!Array.isArray(message.child))
                return "child: array expected";
            for (var i = 0; i < message.child.length; ++i) {
                var error = $root.Document.verify(message.child[i]);
                if (error)
                    return "child." + error;
            }
        }
        if (message.aggregateRating != null && message.hasOwnProperty("aggregateRating")) {
            var error = $root.AggregateRating.verify(message.aggregateRating);
            if (error)
                return "aggregateRating." + error;
        }
        if (message.offer != null && message.hasOwnProperty("offer")) {
            if (!Array.isArray(message.offer))
                return "offer: array expected";
            for (var i = 0; i < message.offer.length; ++i) {
                var error = $root.Offer.verify(message.offer[i]);
                if (error)
                    return "offer." + error;
            }
        }
        if (message.translatedSnippet != null && message.hasOwnProperty("translatedSnippet")) {
            if (!Array.isArray(message.translatedSnippet))
                return "translatedSnippet: array expected";
            for (var i = 0; i < message.translatedSnippet.length; ++i) {
                var error = $root.TranslatedText.verify(message.translatedSnippet[i]);
                if (error)
                    return "translatedSnippet." + error;
            }
        }
        if (message.documentVariant != null && message.hasOwnProperty("documentVariant")) {
            if (!Array.isArray(message.documentVariant))
                return "documentVariant: array expected";
            for (var i = 0; i < message.documentVariant.length; ++i) {
                var error = $root.DocumentVariant.verify(message.documentVariant[i]);
                if (error)
                    return "documentVariant." + error;
            }
        }
        if (message.categoryId != null && message.hasOwnProperty("categoryId")) {
            if (!Array.isArray(message.categoryId))
                return "categoryId: array expected";
            for (var i = 0; i < message.categoryId.length; ++i)
                if (!$util.isString(message.categoryId[i]))
                    return "categoryId: string[] expected";
        }
        if (message.decoration != null && message.hasOwnProperty("decoration")) {
            if (!Array.isArray(message.decoration))
                return "decoration: array expected";
            for (var i = 0; i < message.decoration.length; ++i) {
                var error = $root.Document.verify(message.decoration[i]);
                if (error)
                    return "decoration." + error;
            }
        }
        if (message.parent != null && message.hasOwnProperty("parent")) {
            if (!Array.isArray(message.parent))
                return "parent: array expected";
            for (var i = 0; i < message.parent.length; ++i) {
                var error = $root.Document.verify(message.parent[i]);
                if (error)
                    return "parent." + error;
            }
        }
        if (message.privacyPolicyUrl != null && message.hasOwnProperty("privacyPolicyUrl"))
            if (!$util.isString(message.privacyPolicyUrl))
                return "privacyPolicyUrl: string expected";
        if (message.consumptionUrl != null && message.hasOwnProperty("consumptionUrl"))
            if (!$util.isString(message.consumptionUrl))
                return "consumptionUrl: string expected";
        if (message.estimatedNumChildren != null && message.hasOwnProperty("estimatedNumChildren"))
            if (!$util.isInteger(message.estimatedNumChildren))
                return "estimatedNumChildren: integer expected";
        if (message.subtitle != null && message.hasOwnProperty("subtitle"))
            if (!$util.isString(message.subtitle))
                return "subtitle: string expected";
        return null;
    };

    /**
     * Creates a Document message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof Document
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {Document} Document
     */
    Document.fromObject = function fromObject(object) {
        if (object instanceof $root.Document)
            return object;
        var message = new $root.Document();
        if (object.DocId != null) {
            if (typeof object.DocId !== "object")
                throw TypeError(".Document.DocId: object expected");
            message.DocId = $root.DocId.fromObject(object.DocId);
        }
        if (object.fetchDocId != null) {
            if (typeof object.fetchDocId !== "object")
                throw TypeError(".Document.fetchDocId: object expected");
            message.fetchDocId = $root.DocId.fromObject(object.fetchDocId);
        }
        if (object.sampleDocId != null) {
            if (typeof object.sampleDocId !== "object")
                throw TypeError(".Document.sampleDocId: object expected");
            message.sampleDocId = $root.DocId.fromObject(object.sampleDocId);
        }
        if (object.title != null)
            message.title = String(object.title);
        if (object.url != null)
            message.url = String(object.url);
        if (object.snippet) {
            if (!Array.isArray(object.snippet))
                throw TypeError(".Document.snippet: array expected");
            message.snippet = [];
            for (var i = 0; i < object.snippet.length; ++i)
                message.snippet[i] = String(object.snippet[i]);
        }
        if (object.priceDeprecated != null) {
            if (typeof object.priceDeprecated !== "object")
                throw TypeError(".Document.priceDeprecated: object expected");
            message.priceDeprecated = $root.Offer.fromObject(object.priceDeprecated);
        }
        if (object.availability != null) {
            if (typeof object.availability !== "object")
                throw TypeError(".Document.availability: object expected");
            message.availability = $root.Availability.fromObject(object.availability);
        }
        if (object.image) {
            if (!Array.isArray(object.image))
                throw TypeError(".Document.image: array expected");
            message.image = [];
            for (var i = 0; i < object.image.length; ++i) {
                if (typeof object.image[i] !== "object")
                    throw TypeError(".Document.image: object expected");
                message.image[i] = $root.Image.fromObject(object.image[i]);
            }
        }
        if (object.child) {
            if (!Array.isArray(object.child))
                throw TypeError(".Document.child: array expected");
            message.child = [];
            for (var i = 0; i < object.child.length; ++i) {
                if (typeof object.child[i] !== "object")
                    throw TypeError(".Document.child: object expected");
                message.child[i] = $root.Document.fromObject(object.child[i]);
            }
        }
        if (object.aggregateRating != null) {
            if (typeof object.aggregateRating !== "object")
                throw TypeError(".Document.aggregateRating: object expected");
            message.aggregateRating = $root.AggregateRating.fromObject(object.aggregateRating);
        }
        if (object.offer) {
            if (!Array.isArray(object.offer))
                throw TypeError(".Document.offer: array expected");
            message.offer = [];
            for (var i = 0; i < object.offer.length; ++i) {
                if (typeof object.offer[i] !== "object")
                    throw TypeError(".Document.offer: object expected");
                message.offer[i] = $root.Offer.fromObject(object.offer[i]);
            }
        }
        if (object.translatedSnippet) {
            if (!Array.isArray(object.translatedSnippet))
                throw TypeError(".Document.translatedSnippet: array expected");
            message.translatedSnippet = [];
            for (var i = 0; i < object.translatedSnippet.length; ++i) {
                if (typeof object.translatedSnippet[i] !== "object")
                    throw TypeError(".Document.translatedSnippet: object expected");
                message.translatedSnippet[i] = $root.TranslatedText.fromObject(object.translatedSnippet[i]);
            }
        }
        if (object.documentVariant) {
            if (!Array.isArray(object.documentVariant))
                throw TypeError(".Document.documentVariant: array expected");
            message.documentVariant = [];
            for (var i = 0; i < object.documentVariant.length; ++i) {
                if (typeof object.documentVariant[i] !== "object")
                    throw TypeError(".Document.documentVariant: object expected");
                message.documentVariant[i] = $root.DocumentVariant.fromObject(object.documentVariant[i]);
            }
        }
        if (object.categoryId) {
            if (!Array.isArray(object.categoryId))
                throw TypeError(".Document.categoryId: array expected");
            message.categoryId = [];
            for (var i = 0; i < object.categoryId.length; ++i)
                message.categoryId[i] = String(object.categoryId[i]);
        }
        if (object.decoration) {
            if (!Array.isArray(object.decoration))
                throw TypeError(".Document.decoration: array expected");
            message.decoration = [];
            for (var i = 0; i < object.decoration.length; ++i) {
                if (typeof object.decoration[i] !== "object")
                    throw TypeError(".Document.decoration: object expected");
                message.decoration[i] = $root.Document.fromObject(object.decoration[i]);
            }
        }
        if (object.parent) {
            if (!Array.isArray(object.parent))
                throw TypeError(".Document.parent: array expected");
            message.parent = [];
            for (var i = 0; i < object.parent.length; ++i) {
                if (typeof object.parent[i] !== "object")
                    throw TypeError(".Document.parent: object expected");
                message.parent[i] = $root.Document.fromObject(object.parent[i]);
            }
        }
        if (object.privacyPolicyUrl != null)
            message.privacyPolicyUrl = String(object.privacyPolicyUrl);
        if (object.consumptionUrl != null)
            message.consumptionUrl = String(object.consumptionUrl);
        if (object.estimatedNumChildren != null)
            message.estimatedNumChildren = object.estimatedNumChildren | 0;
        if (object.subtitle != null)
            message.subtitle = String(object.subtitle);
        return message;
    };

    /**
     * Creates a plain object from a Document message. Also converts values to other types if specified.
     * @function toObject
     * @memberof Document
     * @static
     * @param {Document} message Document
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    Document.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        var object = {};
        if (options.arrays || options.defaults) {
            object.snippet = [];
            object.image = [];
            object.child = [];
            object.offer = [];
            object.translatedSnippet = [];
            object.documentVariant = [];
            object.categoryId = [];
            object.decoration = [];
            object.parent = [];
        }
        if (options.defaults) {
            object.DocId = null;
            object.fetchDocId = null;
            object.sampleDocId = null;
            object.title = "";
            object.url = "";
            object.priceDeprecated = null;
            object.availability = null;
            object.aggregateRating = null;
            object.privacyPolicyUrl = "";
            object.consumptionUrl = "";
            object.estimatedNumChildren = 0;
            object.subtitle = "";
        }
        if (message.DocId != null && message.hasOwnProperty("DocId"))
            object.DocId = $root.DocId.toObject(message.DocId, options);
        if (message.fetchDocId != null && message.hasOwnProperty("fetchDocId"))
            object.fetchDocId = $root.DocId.toObject(message.fetchDocId, options);
        if (message.sampleDocId != null && message.hasOwnProperty("sampleDocId"))
            object.sampleDocId = $root.DocId.toObject(message.sampleDocId, options);
        if (message.title != null && message.hasOwnProperty("title"))
            object.title = message.title;
        if (message.url != null && message.hasOwnProperty("url"))
            object.url = message.url;
        if (message.snippet && message.snippet.length) {
            object.snippet = [];
            for (var j = 0; j < message.snippet.length; ++j)
                object.snippet[j] = message.snippet[j];
        }
        if (message.priceDeprecated != null && message.hasOwnProperty("priceDeprecated"))
            object.priceDeprecated = $root.Offer.toObject(message.priceDeprecated, options);
        if (message.availability != null && message.hasOwnProperty("availability"))
            object.availability = $root.Availability.toObject(message.availability, options);
        if (message.image && message.image.length) {
            object.image = [];
            for (var j = 0; j < message.image.length; ++j)
                object.image[j] = $root.Image.toObject(message.image[j], options);
        }
        if (message.child && message.child.length) {
            object.child = [];
            for (var j = 0; j < message.child.length; ++j)
                object.child[j] = $root.Document.toObject(message.child[j], options);
        }
        if (message.aggregateRating != null && message.hasOwnProperty("aggregateRating"))
            object.aggregateRating = $root.AggregateRating.toObject(message.aggregateRating, options);
        if (message.offer && message.offer.length) {
            object.offer = [];
            for (var j = 0; j < message.offer.length; ++j)
                object.offer[j] = $root.Offer.toObject(message.offer[j], options);
        }
        if (message.translatedSnippet && message.translatedSnippet.length) {
            object.translatedSnippet = [];
            for (var j = 0; j < message.translatedSnippet.length; ++j)
                object.translatedSnippet[j] = $root.TranslatedText.toObject(message.translatedSnippet[j], options);
        }
        if (message.documentVariant && message.documentVariant.length) {
            object.documentVariant = [];
            for (var j = 0; j < message.documentVariant.length; ++j)
                object.documentVariant[j] = $root.DocumentVariant.toObject(message.documentVariant[j], options);
        }
        if (message.categoryId && message.categoryId.length) {
            object.categoryId = [];
            for (var j = 0; j < message.categoryId.length; ++j)
                object.categoryId[j] = message.categoryId[j];
        }
        if (message.decoration && message.decoration.length) {
            object.decoration = [];
            for (var j = 0; j < message.decoration.length; ++j)
                object.decoration[j] = $root.Document.toObject(message.decoration[j], options);
        }
        if (message.parent && message.parent.length) {
            object.parent = [];
            for (var j = 0; j < message.parent.length; ++j)
                object.parent[j] = $root.Document.toObject(message.parent[j], options);
        }
        if (message.privacyPolicyUrl != null && message.hasOwnProperty("privacyPolicyUrl"))
            object.privacyPolicyUrl = message.privacyPolicyUrl;
        if (message.consumptionUrl != null && message.hasOwnProperty("consumptionUrl"))
            object.consumptionUrl = message.consumptionUrl;
        if (message.estimatedNumChildren != null && message.hasOwnProperty("estimatedNumChildren"))
            object.estimatedNumChildren = message.estimatedNumChildren;
        if (message.subtitle != null && message.hasOwnProperty("subtitle"))
            object.subtitle = message.subtitle;
        return object;
    };

    /**
     * Converts this Document to JSON.
     * @function toJSON
     * @memberof Document
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    Document.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return Document;
})();

$root.DocumentVariant = (function() {

    /**
     * Properties of a DocumentVariant.
     * @exports IDocumentVariant
     * @interface IDocumentVariant
     * @property {number|null} [variationType] DocumentVariant variationType
     * @property {IRule|null} [rule] DocumentVariant rule
     * @property {string|null} [title] DocumentVariant title
     * @property {Array.<string>|null} [snippet] DocumentVariant snippet
     * @property {string|null} [recentChanges] DocumentVariant recentChanges
     * @property {Array.<ITranslatedText>|null} [autoTranslation] DocumentVariant autoTranslation
     * @property {Array.<IOffer>|null} [offer] DocumentVariant offer
     * @property {number|Long|null} [channelId] DocumentVariant channelId
     * @property {Array.<IDocument>|null} [child] DocumentVariant child
     * @property {Array.<IDocument>|null} [decoration] DocumentVariant decoration
     * @property {Array.<IImage>|null} [image] DocumentVariant image
     * @property {Array.<string>|null} [categoryId] DocumentVariant categoryId
     * @property {string|null} [subtitle] DocumentVariant subtitle
     */

    /**
     * Constructs a new DocumentVariant.
     * @exports DocumentVariant
     * @classdesc Represents a DocumentVariant.
     * @implements IDocumentVariant
     * @constructor
     * @param {IDocumentVariant=} [properties] Properties to set
     */
    function DocumentVariant(properties) {
        this.snippet = [];
        this.autoTranslation = [];
        this.offer = [];
        this.child = [];
        this.decoration = [];
        this.image = [];
        this.categoryId = [];
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * DocumentVariant variationType.
     * @member {number} variationType
     * @memberof DocumentVariant
     * @instance
     */
    DocumentVariant.prototype.variationType = 0;

    /**
     * DocumentVariant rule.
     * @member {IRule|null|undefined} rule
     * @memberof DocumentVariant
     * @instance
     */
    DocumentVariant.prototype.rule = null;

    /**
     * DocumentVariant title.
     * @member {string} title
     * @memberof DocumentVariant
     * @instance
     */
    DocumentVariant.prototype.title = "";

    /**
     * DocumentVariant snippet.
     * @member {Array.<string>} snippet
     * @memberof DocumentVariant
     * @instance
     */
    DocumentVariant.prototype.snippet = $util.emptyArray;

    /**
     * DocumentVariant recentChanges.
     * @member {string} recentChanges
     * @memberof DocumentVariant
     * @instance
     */
    DocumentVariant.prototype.recentChanges = "";

    /**
     * DocumentVariant autoTranslation.
     * @member {Array.<ITranslatedText>} autoTranslation
     * @memberof DocumentVariant
     * @instance
     */
    DocumentVariant.prototype.autoTranslation = $util.emptyArray;

    /**
     * DocumentVariant offer.
     * @member {Array.<IOffer>} offer
     * @memberof DocumentVariant
     * @instance
     */
    DocumentVariant.prototype.offer = $util.emptyArray;

    /**
     * DocumentVariant channelId.
     * @member {number|Long} channelId
     * @memberof DocumentVariant
     * @instance
     */
    DocumentVariant.prototype.channelId = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

    /**
     * DocumentVariant child.
     * @member {Array.<IDocument>} child
     * @memberof DocumentVariant
     * @instance
     */
    DocumentVariant.prototype.child = $util.emptyArray;

    /**
     * DocumentVariant decoration.
     * @member {Array.<IDocument>} decoration
     * @memberof DocumentVariant
     * @instance
     */
    DocumentVariant.prototype.decoration = $util.emptyArray;

    /**
     * DocumentVariant image.
     * @member {Array.<IImage>} image
     * @memberof DocumentVariant
     * @instance
     */
    DocumentVariant.prototype.image = $util.emptyArray;

    /**
     * DocumentVariant categoryId.
     * @member {Array.<string>} categoryId
     * @memberof DocumentVariant
     * @instance
     */
    DocumentVariant.prototype.categoryId = $util.emptyArray;

    /**
     * DocumentVariant subtitle.
     * @member {string} subtitle
     * @memberof DocumentVariant
     * @instance
     */
    DocumentVariant.prototype.subtitle = "";

    /**
     * Creates a new DocumentVariant instance using the specified properties.
     * @function create
     * @memberof DocumentVariant
     * @static
     * @param {IDocumentVariant=} [properties] Properties to set
     * @returns {DocumentVariant} DocumentVariant instance
     */
    DocumentVariant.create = function create(properties) {
        return new DocumentVariant(properties);
    };

    /**
     * Encodes the specified DocumentVariant message. Does not implicitly {@link DocumentVariant.verify|verify} messages.
     * @function encode
     * @memberof DocumentVariant
     * @static
     * @param {IDocumentVariant} message DocumentVariant message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    DocumentVariant.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.variationType != null && Object.hasOwnProperty.call(message, "variationType"))
            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.variationType);
        if (message.rule != null && Object.hasOwnProperty.call(message, "rule"))
            $root.Rule.encode(message.rule, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
        if (message.title != null && Object.hasOwnProperty.call(message, "title"))
            writer.uint32(/* id 3, wireType 2 =*/26).string(message.title);
        if (message.snippet != null && message.snippet.length)
            for (var i = 0; i < message.snippet.length; ++i)
                writer.uint32(/* id 4, wireType 2 =*/34).string(message.snippet[i]);
        if (message.recentChanges != null && Object.hasOwnProperty.call(message, "recentChanges"))
            writer.uint32(/* id 5, wireType 2 =*/42).string(message.recentChanges);
        if (message.autoTranslation != null && message.autoTranslation.length)
            for (var i = 0; i < message.autoTranslation.length; ++i)
                $root.TranslatedText.encode(message.autoTranslation[i], writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
        if (message.offer != null && message.offer.length)
            for (var i = 0; i < message.offer.length; ++i)
                $root.Offer.encode(message.offer[i], writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
        if (message.channelId != null && Object.hasOwnProperty.call(message, "channelId"))
            writer.uint32(/* id 9, wireType 0 =*/72).int64(message.channelId);
        if (message.child != null && message.child.length)
            for (var i = 0; i < message.child.length; ++i)
                $root.Document.encode(message.child[i], writer.uint32(/* id 10, wireType 2 =*/82).fork()).ldelim();
        if (message.decoration != null && message.decoration.length)
            for (var i = 0; i < message.decoration.length; ++i)
                $root.Document.encode(message.decoration[i], writer.uint32(/* id 11, wireType 2 =*/90).fork()).ldelim();
        if (message.image != null && message.image.length)
            for (var i = 0; i < message.image.length; ++i)
                $root.Image.encode(message.image[i], writer.uint32(/* id 12, wireType 2 =*/98).fork()).ldelim();
        if (message.categoryId != null && message.categoryId.length)
            for (var i = 0; i < message.categoryId.length; ++i)
                writer.uint32(/* id 13, wireType 2 =*/106).string(message.categoryId[i]);
        if (message.subtitle != null && Object.hasOwnProperty.call(message, "subtitle"))
            writer.uint32(/* id 14, wireType 2 =*/114).string(message.subtitle);
        return writer;
    };

    /**
     * Encodes the specified DocumentVariant message, length delimited. Does not implicitly {@link DocumentVariant.verify|verify} messages.
     * @function encodeDelimited
     * @memberof DocumentVariant
     * @static
     * @param {IDocumentVariant} message DocumentVariant message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    DocumentVariant.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a DocumentVariant message from the specified reader or buffer.
     * @function decode
     * @memberof DocumentVariant
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {DocumentVariant} DocumentVariant
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    DocumentVariant.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.DocumentVariant();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.variationType = reader.int32();
                break;
            case 2:
                message.rule = $root.Rule.decode(reader, reader.uint32());
                break;
            case 3:
                message.title = reader.string();
                break;
            case 4:
                if (!(message.snippet && message.snippet.length))
                    message.snippet = [];
                message.snippet.push(reader.string());
                break;
            case 5:
                message.recentChanges = reader.string();
                break;
            case 6:
                if (!(message.autoTranslation && message.autoTranslation.length))
                    message.autoTranslation = [];
                message.autoTranslation.push($root.TranslatedText.decode(reader, reader.uint32()));
                break;
            case 7:
                if (!(message.offer && message.offer.length))
                    message.offer = [];
                message.offer.push($root.Offer.decode(reader, reader.uint32()));
                break;
            case 9:
                message.channelId = reader.int64();
                break;
            case 10:
                if (!(message.child && message.child.length))
                    message.child = [];
                message.child.push($root.Document.decode(reader, reader.uint32()));
                break;
            case 11:
                if (!(message.decoration && message.decoration.length))
                    message.decoration = [];
                message.decoration.push($root.Document.decode(reader, reader.uint32()));
                break;
            case 12:
                if (!(message.image && message.image.length))
                    message.image = [];
                message.image.push($root.Image.decode(reader, reader.uint32()));
                break;
            case 13:
                if (!(message.categoryId && message.categoryId.length))
                    message.categoryId = [];
                message.categoryId.push(reader.string());
                break;
            case 14:
                message.subtitle = reader.string();
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a DocumentVariant message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof DocumentVariant
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {DocumentVariant} DocumentVariant
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    DocumentVariant.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a DocumentVariant message.
     * @function verify
     * @memberof DocumentVariant
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    DocumentVariant.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.variationType != null && message.hasOwnProperty("variationType"))
            if (!$util.isInteger(message.variationType))
                return "variationType: integer expected";
        if (message.rule != null && message.hasOwnProperty("rule")) {
            var error = $root.Rule.verify(message.rule);
            if (error)
                return "rule." + error;
        }
        if (message.title != null && message.hasOwnProperty("title"))
            if (!$util.isString(message.title))
                return "title: string expected";
        if (message.snippet != null && message.hasOwnProperty("snippet")) {
            if (!Array.isArray(message.snippet))
                return "snippet: array expected";
            for (var i = 0; i < message.snippet.length; ++i)
                if (!$util.isString(message.snippet[i]))
                    return "snippet: string[] expected";
        }
        if (message.recentChanges != null && message.hasOwnProperty("recentChanges"))
            if (!$util.isString(message.recentChanges))
                return "recentChanges: string expected";
        if (message.autoTranslation != null && message.hasOwnProperty("autoTranslation")) {
            if (!Array.isArray(message.autoTranslation))
                return "autoTranslation: array expected";
            for (var i = 0; i < message.autoTranslation.length; ++i) {
                var error = $root.TranslatedText.verify(message.autoTranslation[i]);
                if (error)
                    return "autoTranslation." + error;
            }
        }
        if (message.offer != null && message.hasOwnProperty("offer")) {
            if (!Array.isArray(message.offer))
                return "offer: array expected";
            for (var i = 0; i < message.offer.length; ++i) {
                var error = $root.Offer.verify(message.offer[i]);
                if (error)
                    return "offer." + error;
            }
        }
        if (message.channelId != null && message.hasOwnProperty("channelId"))
            if (!$util.isInteger(message.channelId) && !(message.channelId && $util.isInteger(message.channelId.low) && $util.isInteger(message.channelId.high)))
                return "channelId: integer|Long expected";
        if (message.child != null && message.hasOwnProperty("child")) {
            if (!Array.isArray(message.child))
                return "child: array expected";
            for (var i = 0; i < message.child.length; ++i) {
                var error = $root.Document.verify(message.child[i]);
                if (error)
                    return "child." + error;
            }
        }
        if (message.decoration != null && message.hasOwnProperty("decoration")) {
            if (!Array.isArray(message.decoration))
                return "decoration: array expected";
            for (var i = 0; i < message.decoration.length; ++i) {
                var error = $root.Document.verify(message.decoration[i]);
                if (error)
                    return "decoration." + error;
            }
        }
        if (message.image != null && message.hasOwnProperty("image")) {
            if (!Array.isArray(message.image))
                return "image: array expected";
            for (var i = 0; i < message.image.length; ++i) {
                var error = $root.Image.verify(message.image[i]);
                if (error)
                    return "image." + error;
            }
        }
        if (message.categoryId != null && message.hasOwnProperty("categoryId")) {
            if (!Array.isArray(message.categoryId))
                return "categoryId: array expected";
            for (var i = 0; i < message.categoryId.length; ++i)
                if (!$util.isString(message.categoryId[i]))
                    return "categoryId: string[] expected";
        }
        if (message.subtitle != null && message.hasOwnProperty("subtitle"))
            if (!$util.isString(message.subtitle))
                return "subtitle: string expected";
        return null;
    };

    /**
     * Creates a DocumentVariant message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof DocumentVariant
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {DocumentVariant} DocumentVariant
     */
    DocumentVariant.fromObject = function fromObject(object) {
        if (object instanceof $root.DocumentVariant)
            return object;
        var message = new $root.DocumentVariant();
        if (object.variationType != null)
            message.variationType = object.variationType | 0;
        if (object.rule != null) {
            if (typeof object.rule !== "object")
                throw TypeError(".DocumentVariant.rule: object expected");
            message.rule = $root.Rule.fromObject(object.rule);
        }
        if (object.title != null)
            message.title = String(object.title);
        if (object.snippet) {
            if (!Array.isArray(object.snippet))
                throw TypeError(".DocumentVariant.snippet: array expected");
            message.snippet = [];
            for (var i = 0; i < object.snippet.length; ++i)
                message.snippet[i] = String(object.snippet[i]);
        }
        if (object.recentChanges != null)
            message.recentChanges = String(object.recentChanges);
        if (object.autoTranslation) {
            if (!Array.isArray(object.autoTranslation))
                throw TypeError(".DocumentVariant.autoTranslation: array expected");
            message.autoTranslation = [];
            for (var i = 0; i < object.autoTranslation.length; ++i) {
                if (typeof object.autoTranslation[i] !== "object")
                    throw TypeError(".DocumentVariant.autoTranslation: object expected");
                message.autoTranslation[i] = $root.TranslatedText.fromObject(object.autoTranslation[i]);
            }
        }
        if (object.offer) {
            if (!Array.isArray(object.offer))
                throw TypeError(".DocumentVariant.offer: array expected");
            message.offer = [];
            for (var i = 0; i < object.offer.length; ++i) {
                if (typeof object.offer[i] !== "object")
                    throw TypeError(".DocumentVariant.offer: object expected");
                message.offer[i] = $root.Offer.fromObject(object.offer[i]);
            }
        }
        if (object.channelId != null)
            if ($util.Long)
                (message.channelId = $util.Long.fromValue(object.channelId)).unsigned = false;
            else if (typeof object.channelId === "string")
                message.channelId = parseInt(object.channelId, 10);
            else if (typeof object.channelId === "number")
                message.channelId = object.channelId;
            else if (typeof object.channelId === "object")
                message.channelId = new $util.LongBits(object.channelId.low >>> 0, object.channelId.high >>> 0).toNumber();
        if (object.child) {
            if (!Array.isArray(object.child))
                throw TypeError(".DocumentVariant.child: array expected");
            message.child = [];
            for (var i = 0; i < object.child.length; ++i) {
                if (typeof object.child[i] !== "object")
                    throw TypeError(".DocumentVariant.child: object expected");
                message.child[i] = $root.Document.fromObject(object.child[i]);
            }
        }
        if (object.decoration) {
            if (!Array.isArray(object.decoration))
                throw TypeError(".DocumentVariant.decoration: array expected");
            message.decoration = [];
            for (var i = 0; i < object.decoration.length; ++i) {
                if (typeof object.decoration[i] !== "object")
                    throw TypeError(".DocumentVariant.decoration: object expected");
                message.decoration[i] = $root.Document.fromObject(object.decoration[i]);
            }
        }
        if (object.image) {
            if (!Array.isArray(object.image))
                throw TypeError(".DocumentVariant.image: array expected");
            message.image = [];
            for (var i = 0; i < object.image.length; ++i) {
                if (typeof object.image[i] !== "object")
                    throw TypeError(".DocumentVariant.image: object expected");
                message.image[i] = $root.Image.fromObject(object.image[i]);
            }
        }
        if (object.categoryId) {
            if (!Array.isArray(object.categoryId))
                throw TypeError(".DocumentVariant.categoryId: array expected");
            message.categoryId = [];
            for (var i = 0; i < object.categoryId.length; ++i)
                message.categoryId[i] = String(object.categoryId[i]);
        }
        if (object.subtitle != null)
            message.subtitle = String(object.subtitle);
        return message;
    };

    /**
     * Creates a plain object from a DocumentVariant message. Also converts values to other types if specified.
     * @function toObject
     * @memberof DocumentVariant
     * @static
     * @param {DocumentVariant} message DocumentVariant
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    DocumentVariant.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        var object = {};
        if (options.arrays || options.defaults) {
            object.snippet = [];
            object.autoTranslation = [];
            object.offer = [];
            object.child = [];
            object.decoration = [];
            object.image = [];
            object.categoryId = [];
        }
        if (options.defaults) {
            object.variationType = 0;
            object.rule = null;
            object.title = "";
            object.recentChanges = "";
            if ($util.Long) {
                var long = new $util.Long(0, 0, false);
                object.channelId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
            } else
                object.channelId = options.longs === String ? "0" : 0;
            object.subtitle = "";
        }
        if (message.variationType != null && message.hasOwnProperty("variationType"))
            object.variationType = message.variationType;
        if (message.rule != null && message.hasOwnProperty("rule"))
            object.rule = $root.Rule.toObject(message.rule, options);
        if (message.title != null && message.hasOwnProperty("title"))
            object.title = message.title;
        if (message.snippet && message.snippet.length) {
            object.snippet = [];
            for (var j = 0; j < message.snippet.length; ++j)
                object.snippet[j] = message.snippet[j];
        }
        if (message.recentChanges != null && message.hasOwnProperty("recentChanges"))
            object.recentChanges = message.recentChanges;
        if (message.autoTranslation && message.autoTranslation.length) {
            object.autoTranslation = [];
            for (var j = 0; j < message.autoTranslation.length; ++j)
                object.autoTranslation[j] = $root.TranslatedText.toObject(message.autoTranslation[j], options);
        }
        if (message.offer && message.offer.length) {
            object.offer = [];
            for (var j = 0; j < message.offer.length; ++j)
                object.offer[j] = $root.Offer.toObject(message.offer[j], options);
        }
        if (message.channelId != null && message.hasOwnProperty("channelId"))
            if (typeof message.channelId === "number")
                object.channelId = options.longs === String ? String(message.channelId) : message.channelId;
            else
                object.channelId = options.longs === String ? $util.Long.prototype.toString.call(message.channelId) : options.longs === Number ? new $util.LongBits(message.channelId.low >>> 0, message.channelId.high >>> 0).toNumber() : message.channelId;
        if (message.child && message.child.length) {
            object.child = [];
            for (var j = 0; j < message.child.length; ++j)
                object.child[j] = $root.Document.toObject(message.child[j], options);
        }
        if (message.decoration && message.decoration.length) {
            object.decoration = [];
            for (var j = 0; j < message.decoration.length; ++j)
                object.decoration[j] = $root.Document.toObject(message.decoration[j], options);
        }
        if (message.image && message.image.length) {
            object.image = [];
            for (var j = 0; j < message.image.length; ++j)
                object.image[j] = $root.Image.toObject(message.image[j], options);
        }
        if (message.categoryId && message.categoryId.length) {
            object.categoryId = [];
            for (var j = 0; j < message.categoryId.length; ++j)
                object.categoryId[j] = message.categoryId[j];
        }
        if (message.subtitle != null && message.hasOwnProperty("subtitle"))
            object.subtitle = message.subtitle;
        return object;
    };

    /**
     * Converts this DocumentVariant to JSON.
     * @function toJSON
     * @memberof DocumentVariant
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    DocumentVariant.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return DocumentVariant;
})();

$root.SectionImage = (function() {

    /**
     * Properties of a SectionImage.
     * @exports ISectionImage
     * @interface ISectionImage
     * @property {Array.<IImageContainer>|null} [imageContainer] SectionImage imageContainer
     */

    /**
     * Constructs a new SectionImage.
     * @exports SectionImage
     * @classdesc Represents a SectionImage.
     * @implements ISectionImage
     * @constructor
     * @param {ISectionImage=} [properties] Properties to set
     */
    function SectionImage(properties) {
        this.imageContainer = [];
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * SectionImage imageContainer.
     * @member {Array.<IImageContainer>} imageContainer
     * @memberof SectionImage
     * @instance
     */
    SectionImage.prototype.imageContainer = $util.emptyArray;

    /**
     * Creates a new SectionImage instance using the specified properties.
     * @function create
     * @memberof SectionImage
     * @static
     * @param {ISectionImage=} [properties] Properties to set
     * @returns {SectionImage} SectionImage instance
     */
    SectionImage.create = function create(properties) {
        return new SectionImage(properties);
    };

    /**
     * Encodes the specified SectionImage message. Does not implicitly {@link SectionImage.verify|verify} messages.
     * @function encode
     * @memberof SectionImage
     * @static
     * @param {ISectionImage} message SectionImage message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    SectionImage.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.imageContainer != null && message.imageContainer.length)
            for (var i = 0; i < message.imageContainer.length; ++i)
                $root.ImageContainer.encode(message.imageContainer[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
        return writer;
    };

    /**
     * Encodes the specified SectionImage message, length delimited. Does not implicitly {@link SectionImage.verify|verify} messages.
     * @function encodeDelimited
     * @memberof SectionImage
     * @static
     * @param {ISectionImage} message SectionImage message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    SectionImage.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a SectionImage message from the specified reader or buffer.
     * @function decode
     * @memberof SectionImage
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {SectionImage} SectionImage
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    SectionImage.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.SectionImage();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                if (!(message.imageContainer && message.imageContainer.length))
                    message.imageContainer = [];
                message.imageContainer.push($root.ImageContainer.decode(reader, reader.uint32()));
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a SectionImage message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof SectionImage
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {SectionImage} SectionImage
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    SectionImage.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a SectionImage message.
     * @function verify
     * @memberof SectionImage
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    SectionImage.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.imageContainer != null && message.hasOwnProperty("imageContainer")) {
            if (!Array.isArray(message.imageContainer))
                return "imageContainer: array expected";
            for (var i = 0; i < message.imageContainer.length; ++i) {
                var error = $root.ImageContainer.verify(message.imageContainer[i]);
                if (error)
                    return "imageContainer." + error;
            }
        }
        return null;
    };

    /**
     * Creates a SectionImage message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof SectionImage
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {SectionImage} SectionImage
     */
    SectionImage.fromObject = function fromObject(object) {
        if (object instanceof $root.SectionImage)
            return object;
        var message = new $root.SectionImage();
        if (object.imageContainer) {
            if (!Array.isArray(object.imageContainer))
                throw TypeError(".SectionImage.imageContainer: array expected");
            message.imageContainer = [];
            for (var i = 0; i < object.imageContainer.length; ++i) {
                if (typeof object.imageContainer[i] !== "object")
                    throw TypeError(".SectionImage.imageContainer: object expected");
                message.imageContainer[i] = $root.ImageContainer.fromObject(object.imageContainer[i]);
            }
        }
        return message;
    };

    /**
     * Creates a plain object from a SectionImage message. Also converts values to other types if specified.
     * @function toObject
     * @memberof SectionImage
     * @static
     * @param {SectionImage} message SectionImage
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    SectionImage.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        var object = {};
        if (options.arrays || options.defaults)
            object.imageContainer = [];
        if (message.imageContainer && message.imageContainer.length) {
            object.imageContainer = [];
            for (var j = 0; j < message.imageContainer.length; ++j)
                object.imageContainer[j] = $root.ImageContainer.toObject(message.imageContainer[j], options);
        }
        return object;
    };

    /**
     * Converts this SectionImage to JSON.
     * @function toJSON
     * @memberof SectionImage
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    SectionImage.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return SectionImage;
})();

$root.ImageContainer = (function() {

    /**
     * Properties of an ImageContainer.
     * @exports IImageContainer
     * @interface IImageContainer
     * @property {IImage|null} [image] ImageContainer image
     */

    /**
     * Constructs a new ImageContainer.
     * @exports ImageContainer
     * @classdesc Represents an ImageContainer.
     * @implements IImageContainer
     * @constructor
     * @param {IImageContainer=} [properties] Properties to set
     */
    function ImageContainer(properties) {
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * ImageContainer image.
     * @member {IImage|null|undefined} image
     * @memberof ImageContainer
     * @instance
     */
    ImageContainer.prototype.image = null;

    /**
     * Creates a new ImageContainer instance using the specified properties.
     * @function create
     * @memberof ImageContainer
     * @static
     * @param {IImageContainer=} [properties] Properties to set
     * @returns {ImageContainer} ImageContainer instance
     */
    ImageContainer.create = function create(properties) {
        return new ImageContainer(properties);
    };

    /**
     * Encodes the specified ImageContainer message. Does not implicitly {@link ImageContainer.verify|verify} messages.
     * @function encode
     * @memberof ImageContainer
     * @static
     * @param {IImageContainer} message ImageContainer message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    ImageContainer.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.image != null && Object.hasOwnProperty.call(message, "image"))
            $root.Image.encode(message.image, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
        return writer;
    };

    /**
     * Encodes the specified ImageContainer message, length delimited. Does not implicitly {@link ImageContainer.verify|verify} messages.
     * @function encodeDelimited
     * @memberof ImageContainer
     * @static
     * @param {IImageContainer} message ImageContainer message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    ImageContainer.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes an ImageContainer message from the specified reader or buffer.
     * @function decode
     * @memberof ImageContainer
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {ImageContainer} ImageContainer
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    ImageContainer.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ImageContainer();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            case 4:
                message.image = $root.Image.decode(reader, reader.uint32());
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes an ImageContainer message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof ImageContainer
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {ImageContainer} ImageContainer
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    ImageContainer.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies an ImageContainer message.
     * @function verify
     * @memberof ImageContainer
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    ImageContainer.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.image != null && message.hasOwnProperty("image")) {
            var error = $root.Image.verify(message.image);
            if (error)
                return "image." + error;
        }
        return null;
    };

    /**
     * Creates an ImageContainer message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof ImageContainer
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {ImageContainer} ImageContainer
     */
    ImageContainer.fromObject = function fromObject(object) {
        if (object instanceof $root.ImageContainer)
            return object;
        var message = new $root.ImageContainer();
        if (object.image != null) {
            if (typeof object.image !== "object")
                throw TypeError(".ImageContainer.image: object expected");
            message.image = $root.Image.fromObject(object.image);
        }
        return message;
    };

    /**
     * Creates a plain object from an ImageContainer message. Also converts values to other types if specified.
     * @function toObject
     * @memberof ImageContainer
     * @static
     * @param {ImageContainer} message ImageContainer
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    ImageContainer.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        var object = {};
        if (options.defaults)
            object.image = null;
        if (message.image != null && message.hasOwnProperty("image"))
            object.image = $root.Image.toObject(message.image, options);
        return object;
    };

    /**
     * Converts this ImageContainer to JSON.
     * @function toJSON
     * @memberof ImageContainer
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    ImageContainer.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return ImageContainer;
})();

$root.Image = (function() {

    /**
     * Properties of an Image.
     * @exports IImage
     * @interface IImage
     * @property {number|null} [imageType] Image imageType
     * @property {Image.IDimension|null} [dimension] Image dimension
     * @property {string|null} [imageUrl] Image imageUrl
     * @property {string|null} [altTextLocalized] Image altTextLocalized
     * @property {string|null} [secureUrl] Image secureUrl
     * @property {number|null} [positionInSequence] Image positionInSequence
     * @property {boolean|null} [supportsFifeUrlOptions] Image supportsFifeUrlOptions
     * @property {Image.ICitation|null} [citation] Image citation
     * @property {number|null} [durationSeconds] Image durationSeconds
     * @property {string|null} [fillColorRGB] Image fillColorRGB
     * @property {boolean|null} [autogen] Image autogen
     * @property {IAttribution|null} [attribution] Image attribution
     * @property {string|null} [backgroundColorRgb] Image backgroundColorRgb
     * @property {IImagePalette|null} [palette] Image palette
     * @property {number|null} [deviceClass] Image deviceClass
     * @property {boolean|null} [supportsFifeMonogramOption] Image supportsFifeMonogramOption
     * @property {string|null} [imageUrlAlt] Image imageUrlAlt
     */

    /**
     * Constructs a new Image.
     * @exports Image
     * @classdesc Represents an Image.
     * @implements IImage
     * @constructor
     * @param {IImage=} [properties] Properties to set
     */
    function Image(properties) {
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * Image imageType.
     * @member {number} imageType
     * @memberof Image
     * @instance
     */
    Image.prototype.imageType = 0;

    /**
     * Image dimension.
     * @member {Image.IDimension|null|undefined} dimension
     * @memberof Image
     * @instance
     */
    Image.prototype.dimension = null;

    /**
     * Image imageUrl.
     * @member {string} imageUrl
     * @memberof Image
     * @instance
     */
    Image.prototype.imageUrl = "";

    /**
     * Image altTextLocalized.
     * @member {string} altTextLocalized
     * @memberof Image
     * @instance
     */
    Image.prototype.altTextLocalized = "";

    /**
     * Image secureUrl.
     * @member {string} secureUrl
     * @memberof Image
     * @instance
     */
    Image.prototype.secureUrl = "";

    /**
     * Image positionInSequence.
     * @member {number} positionInSequence
     * @memberof Image
     * @instance
     */
    Image.prototype.positionInSequence = 0;

    /**
     * Image supportsFifeUrlOptions.
     * @member {boolean} supportsFifeUrlOptions
     * @memberof Image
     * @instance
     */
    Image.prototype.supportsFifeUrlOptions = false;

    /**
     * Image citation.
     * @member {Image.ICitation|null|undefined} citation
     * @memberof Image
     * @instance
     */
    Image.prototype.citation = null;

    /**
     * Image durationSeconds.
     * @member {number} durationSeconds
     * @memberof Image
     * @instance
     */
    Image.prototype.durationSeconds = 0;

    /**
     * Image fillColorRGB.
     * @member {string} fillColorRGB
     * @memberof Image
     * @instance
     */
    Image.prototype.fillColorRGB = "";

    /**
     * Image autogen.
     * @member {boolean} autogen
     * @memberof Image
     * @instance
     */
    Image.prototype.autogen = false;

    /**
     * Image attribution.
     * @member {IAttribution|null|undefined} attribution
     * @memberof Image
     * @instance
     */
    Image.prototype.attribution = null;

    /**
     * Image backgroundColorRgb.
     * @member {string} backgroundColorRgb
     * @memberof Image
     * @instance
     */
    Image.prototype.backgroundColorRgb = "";

    /**
     * Image palette.
     * @member {IImagePalette|null|undefined} palette
     * @memberof Image
     * @instance
     */
    Image.prototype.palette = null;

    /**
     * Image deviceClass.
     * @member {number} deviceClass
     * @memberof Image
     * @instance
     */
    Image.prototype.deviceClass = 0;

    /**
     * Image supportsFifeMonogramOption.
     * @member {boolean} supportsFifeMonogramOption
     * @memberof Image
     * @instance
     */
    Image.prototype.supportsFifeMonogramOption = false;

    /**
     * Image imageUrlAlt.
     * @member {string} imageUrlAlt
     * @memberof Image
     * @instance
     */
    Image.prototype.imageUrlAlt = "";

    /**
     * Creates a new Image instance using the specified properties.
     * @function create
     * @memberof Image
     * @static
     * @param {IImage=} [properties] Properties to set
     * @returns {Image} Image instance
     */
    Image.create = function create(properties) {
        return new Image(properties);
    };

    /**
     * Encodes the specified Image message. Does not implicitly {@link Image.verify|verify} messages.
     * @function encode
     * @memberof Image
     * @static
     * @param {IImage} message Image message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    Image.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.imageType != null && Object.hasOwnProperty.call(message, "imageType"))
            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.imageType);
        if (message.dimension != null && Object.hasOwnProperty.call(message, "dimension"))
            $root.Image.Dimension.encode(message.dimension, writer.uint32(/* id 2, wireType 3 =*/19)).uint32(/* id 2, wireType 4 =*/20);
        if (message.imageUrl != null && Object.hasOwnProperty.call(message, "imageUrl"))
            writer.uint32(/* id 5, wireType 2 =*/42).string(message.imageUrl);
        if (message.altTextLocalized != null && Object.hasOwnProperty.call(message, "altTextLocalized"))
            writer.uint32(/* id 6, wireType 2 =*/50).string(message.altTextLocalized);
        if (message.secureUrl != null && Object.hasOwnProperty.call(message, "secureUrl"))
            writer.uint32(/* id 7, wireType 2 =*/58).string(message.secureUrl);
        if (message.positionInSequence != null && Object.hasOwnProperty.call(message, "positionInSequence"))
            writer.uint32(/* id 8, wireType 0 =*/64).int32(message.positionInSequence);
        if (message.supportsFifeUrlOptions != null && Object.hasOwnProperty.call(message, "supportsFifeUrlOptions"))
            writer.uint32(/* id 9, wireType 0 =*/72).bool(message.supportsFifeUrlOptions);
        if (message.citation != null && Object.hasOwnProperty.call(message, "citation"))
            $root.Image.Citation.encode(message.citation, writer.uint32(/* id 10, wireType 3 =*/83)).uint32(/* id 10, wireType 4 =*/84);
        if (message.durationSeconds != null && Object.hasOwnProperty.call(message, "durationSeconds"))
            writer.uint32(/* id 14, wireType 0 =*/112).int32(message.durationSeconds);
        if (message.fillColorRGB != null && Object.hasOwnProperty.call(message, "fillColorRGB"))
            writer.uint32(/* id 15, wireType 2 =*/122).string(message.fillColorRGB);
        if (message.autogen != null && Object.hasOwnProperty.call(message, "autogen"))
            writer.uint32(/* id 16, wireType 0 =*/128).bool(message.autogen);
        if (message.attribution != null && Object.hasOwnProperty.call(message, "attribution"))
            $root.Attribution.encode(message.attribution, writer.uint32(/* id 17, wireType 2 =*/138).fork()).ldelim();
        if (message.backgroundColorRgb != null && Object.hasOwnProperty.call(message, "backgroundColorRgb"))
            writer.uint32(/* id 19, wireType 2 =*/154).string(message.backgroundColorRgb);
        if (message.palette != null && Object.hasOwnProperty.call(message, "palette"))
            $root.ImagePalette.encode(message.palette, writer.uint32(/* id 20, wireType 2 =*/162).fork()).ldelim();
        if (message.deviceClass != null && Object.hasOwnProperty.call(message, "deviceClass"))
            writer.uint32(/* id 21, wireType 0 =*/168).int32(message.deviceClass);
        if (message.supportsFifeMonogramOption != null && Object.hasOwnProperty.call(message, "supportsFifeMonogramOption"))
            writer.uint32(/* id 22, wireType 0 =*/176).bool(message.supportsFifeMonogramOption);
        if (message.imageUrlAlt != null && Object.hasOwnProperty.call(message, "imageUrlAlt"))
            writer.uint32(/* id 28, wireType 2 =*/226).string(message.imageUrlAlt);
        return writer;
    };

    /**
     * Encodes the specified Image message, length delimited. Does not implicitly {@link Image.verify|verify} messages.
     * @function encodeDelimited
     * @memberof Image
     * @static
     * @param {IImage} message Image message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    Image.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes an Image message from the specified reader or buffer.
     * @function decode
     * @memberof Image
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {Image} Image
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    Image.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Image();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.imageType = reader.int32();
                break;
            case 2:
                message.dimension = $root.Image.Dimension.decode(reader);
                break;
            case 5:
                message.imageUrl = reader.string();
                break;
            case 6:
                message.altTextLocalized = reader.string();
                break;
            case 7:
                message.secureUrl = reader.string();
                break;
            case 8:
                message.positionInSequence = reader.int32();
                break;
            case 9:
                message.supportsFifeUrlOptions = reader.bool();
                break;
            case 10:
                message.citation = $root.Image.Citation.decode(reader);
                break;
            case 14:
                message.durationSeconds = reader.int32();
                break;
            case 15:
                message.fillColorRGB = reader.string();
                break;
            case 16:
                message.autogen = reader.bool();
                break;
            case 17:
                message.attribution = $root.Attribution.decode(reader, reader.uint32());
                break;
            case 19:
                message.backgroundColorRgb = reader.string();
                break;
            case 20:
                message.palette = $root.ImagePalette.decode(reader, reader.uint32());
                break;
            case 21:
                message.deviceClass = reader.int32();
                break;
            case 22:
                message.supportsFifeMonogramOption = reader.bool();
                break;
            case 28:
                message.imageUrlAlt = reader.string();
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes an Image message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof Image
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {Image} Image
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    Image.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies an Image message.
     * @function verify
     * @memberof Image
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    Image.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.imageType != null && message.hasOwnProperty("imageType"))
            if (!$util.isInteger(message.imageType))
                return "imageType: integer expected";
        if (message.dimension != null && message.hasOwnProperty("dimension")) {
            var error = $root.Image.Dimension.verify(message.dimension);
            if (error)
                return "dimension." + error;
        }
        if (message.imageUrl != null && message.hasOwnProperty("imageUrl"))
            if (!$util.isString(message.imageUrl))
                return "imageUrl: string expected";
        if (message.altTextLocalized != null && message.hasOwnProperty("altTextLocalized"))
            if (!$util.isString(message.altTextLocalized))
                return "altTextLocalized: string expected";
        if (message.secureUrl != null && message.hasOwnProperty("secureUrl"))
            if (!$util.isString(message.secureUrl))
                return "secureUrl: string expected";
        if (message.positionInSequence != null && message.hasOwnProperty("positionInSequence"))
            if (!$util.isInteger(message.positionInSequence))
                return "positionInSequence: integer expected";
        if (message.supportsFifeUrlOptions != null && message.hasOwnProperty("supportsFifeUrlOptions"))
            if (typeof message.supportsFifeUrlOptions !== "boolean")
                return "supportsFifeUrlOptions: boolean expected";
        if (message.citation != null && message.hasOwnProperty("citation")) {
            var error = $root.Image.Citation.verify(message.citation);
            if (error)
                return "citation." + error;
        }
        if (message.durationSeconds != null && message.hasOwnProperty("durationSeconds"))
            if (!$util.isInteger(message.durationSeconds))
                return "durationSeconds: integer expected";
        if (message.fillColorRGB != null && message.hasOwnProperty("fillColorRGB"))
            if (!$util.isString(message.fillColorRGB))
                return "fillColorRGB: string expected";
        if (message.autogen != null && message.hasOwnProperty("autogen"))
            if (typeof message.autogen !== "boolean")
                return "autogen: boolean expected";
        if (message.attribution != null && message.hasOwnProperty("attribution")) {
            var error = $root.Attribution.verify(message.attribution);
            if (error)
                return "attribution." + error;
        }
        if (message.backgroundColorRgb != null && message.hasOwnProperty("backgroundColorRgb"))
            if (!$util.isString(message.backgroundColorRgb))
                return "backgroundColorRgb: string expected";
        if (message.palette != null && message.hasOwnProperty("palette")) {
            var error = $root.ImagePalette.verify(message.palette);
            if (error)
                return "palette." + error;
        }
        if (message.deviceClass != null && message.hasOwnProperty("deviceClass"))
            if (!$util.isInteger(message.deviceClass))
                return "deviceClass: integer expected";
        if (message.supportsFifeMonogramOption != null && message.hasOwnProperty("supportsFifeMonogramOption"))
            if (typeof message.supportsFifeMonogramOption !== "boolean")
                return "supportsFifeMonogramOption: boolean expected";
        if (message.imageUrlAlt != null && message.hasOwnProperty("imageUrlAlt"))
            if (!$util.isString(message.imageUrlAlt))
                return "imageUrlAlt: string expected";
        return null;
    };

    /**
     * Creates an Image message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof Image
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {Image} Image
     */
    Image.fromObject = function fromObject(object) {
        if (object instanceof $root.Image)
            return object;
        var message = new $root.Image();
        if (object.imageType != null)
            message.imageType = object.imageType | 0;
        if (object.dimension != null) {
            if (typeof object.dimension !== "object")
                throw TypeError(".Image.dimension: object expected");
            message.dimension = $root.Image.Dimension.fromObject(object.dimension);
        }
        if (object.imageUrl != null)
            message.imageUrl = String(object.imageUrl);
        if (object.altTextLocalized != null)
            message.altTextLocalized = String(object.altTextLocalized);
        if (object.secureUrl != null)
            message.secureUrl = String(object.secureUrl);
        if (object.positionInSequence != null)
            message.positionInSequence = object.positionInSequence | 0;
        if (object.supportsFifeUrlOptions != null)
            message.supportsFifeUrlOptions = Boolean(object.supportsFifeUrlOptions);
        if (object.citation != null) {
            if (typeof object.citation !== "object")
                throw TypeError(".Image.citation: object expected");
            message.citation = $root.Image.Citation.fromObject(object.citation);
        }
        if (object.durationSeconds != null)
            message.durationSeconds = object.durationSeconds | 0;
        if (object.fillColorRGB != null)
            message.fillColorRGB = String(object.fillColorRGB);
        if (object.autogen != null)
            message.autogen = Boolean(object.autogen);
        if (object.attribution != null) {
            if (typeof object.attribution !== "object")
                throw TypeError(".Image.attribution: object expected");
            message.attribution = $root.Attribution.fromObject(object.attribution);
        }
        if (object.backgroundColorRgb != null)
            message.backgroundColorRgb = String(object.backgroundColorRgb);
        if (object.palette != null) {
            if (typeof object.palette !== "object")
                throw TypeError(".Image.palette: object expected");
            message.palette = $root.ImagePalette.fromObject(object.palette);
        }
        if (object.deviceClass != null)
            message.deviceClass = object.deviceClass | 0;
        if (object.supportsFifeMonogramOption != null)
            message.supportsFifeMonogramOption = Boolean(object.supportsFifeMonogramOption);
        if (object.imageUrlAlt != null)
            message.imageUrlAlt = String(object.imageUrlAlt);
        return message;
    };

    /**
     * Creates a plain object from an Image message. Also converts values to other types if specified.
     * @function toObject
     * @memberof Image
     * @static
     * @param {Image} message Image
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    Image.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        var object = {};
        if (options.defaults) {
            object.imageType = 0;
            object.dimension = null;
            object.imageUrl = "";
            object.altTextLocalized = "";
            object.secureUrl = "";
            object.positionInSequence = 0;
            object.supportsFifeUrlOptions = false;
            object.citation = null;
            object.durationSeconds = 0;
            object.fillColorRGB = "";
            object.autogen = false;
            object.attribution = null;
            object.backgroundColorRgb = "";
            object.palette = null;
            object.deviceClass = 0;
            object.supportsFifeMonogramOption = false;
            object.imageUrlAlt = "";
        }
        if (message.imageType != null && message.hasOwnProperty("imageType"))
            object.imageType = message.imageType;
        if (message.dimension != null && message.hasOwnProperty("dimension"))
            object.dimension = $root.Image.Dimension.toObject(message.dimension, options);
        if (message.imageUrl != null && message.hasOwnProperty("imageUrl"))
            object.imageUrl = message.imageUrl;
        if (message.altTextLocalized != null && message.hasOwnProperty("altTextLocalized"))
            object.altTextLocalized = message.altTextLocalized;
        if (message.secureUrl != null && message.hasOwnProperty("secureUrl"))
            object.secureUrl = message.secureUrl;
        if (message.positionInSequence != null && message.hasOwnProperty("positionInSequence"))
            object.positionInSequence = message.positionInSequence;
        if (message.supportsFifeUrlOptions != null && message.hasOwnProperty("supportsFifeUrlOptions"))
            object.supportsFifeUrlOptions = message.supportsFifeUrlOptions;
        if (message.citation != null && message.hasOwnProperty("citation"))
            object.citation = $root.Image.Citation.toObject(message.citation, options);
        if (message.durationSeconds != null && message.hasOwnProperty("durationSeconds"))
            object.durationSeconds = message.durationSeconds;
        if (message.fillColorRGB != null && message.hasOwnProperty("fillColorRGB"))
            object.fillColorRGB = message.fillColorRGB;
        if (message.autogen != null && message.hasOwnProperty("autogen"))
            object.autogen = message.autogen;
        if (message.attribution != null && message.hasOwnProperty("attribution"))
            object.attribution = $root.Attribution.toObject(message.attribution, options);
        if (message.backgroundColorRgb != null && message.hasOwnProperty("backgroundColorRgb"))
            object.backgroundColorRgb = message.backgroundColorRgb;
        if (message.palette != null && message.hasOwnProperty("palette"))
            object.palette = $root.ImagePalette.toObject(message.palette, options);
        if (message.deviceClass != null && message.hasOwnProperty("deviceClass"))
            object.deviceClass = message.deviceClass;
        if (message.supportsFifeMonogramOption != null && message.hasOwnProperty("supportsFifeMonogramOption"))
            object.supportsFifeMonogramOption = message.supportsFifeMonogramOption;
        if (message.imageUrlAlt != null && message.hasOwnProperty("imageUrlAlt"))
            object.imageUrlAlt = message.imageUrlAlt;
        return object;
    };

    /**
     * Converts this Image to JSON.
     * @function toJSON
     * @memberof Image
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    Image.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    Image.Dimension = (function() {

        /**
         * Properties of a Dimension.
         * @memberof Image
         * @interface IDimension
         * @property {number|null} [width] Dimension width
         * @property {number|null} [height] Dimension height
         * @property {number|null} [aspectRatio] Dimension aspectRatio
         */

        /**
         * Constructs a new Dimension.
         * @memberof Image
         * @classdesc Represents a Dimension.
         * @implements IDimension
         * @constructor
         * @param {Image.IDimension=} [properties] Properties to set
         */
        function Dimension(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Dimension width.
         * @member {number} width
         * @memberof Image.Dimension
         * @instance
         */
        Dimension.prototype.width = 0;

        /**
         * Dimension height.
         * @member {number} height
         * @memberof Image.Dimension
         * @instance
         */
        Dimension.prototype.height = 0;

        /**
         * Dimension aspectRatio.
         * @member {number} aspectRatio
         * @memberof Image.Dimension
         * @instance
         */
        Dimension.prototype.aspectRatio = 0;

        /**
         * Creates a new Dimension instance using the specified properties.
         * @function create
         * @memberof Image.Dimension
         * @static
         * @param {Image.IDimension=} [properties] Properties to set
         * @returns {Image.Dimension} Dimension instance
         */
        Dimension.create = function create(properties) {
            return new Dimension(properties);
        };

        /**
         * Encodes the specified Dimension message. Does not implicitly {@link Image.Dimension.verify|verify} messages.
         * @function encode
         * @memberof Image.Dimension
         * @static
         * @param {Image.IDimension} message Dimension message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Dimension.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.width != null && Object.hasOwnProperty.call(message, "width"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.width);
            if (message.height != null && Object.hasOwnProperty.call(message, "height"))
                writer.uint32(/* id 4, wireType 0 =*/32).int32(message.height);
            if (message.aspectRatio != null && Object.hasOwnProperty.call(message, "aspectRatio"))
                writer.uint32(/* id 18, wireType 0 =*/144).int32(message.aspectRatio);
            return writer;
        };

        /**
         * Encodes the specified Dimension message, length delimited. Does not implicitly {@link Image.Dimension.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Image.Dimension
         * @static
         * @param {Image.IDimension} message Dimension message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Dimension.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Dimension message from the specified reader or buffer.
         * @function decode
         * @memberof Image.Dimension
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Image.Dimension} Dimension
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Dimension.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Image.Dimension();
            while (reader.pos < end) {
                var tag = reader.uint32();
                if ((tag & 7) === 4)
                    break;
                switch (tag >>> 3) {
                case 3:
                    message.width = reader.int32();
                    break;
                case 4:
                    message.height = reader.int32();
                    break;
                case 18:
                    message.aspectRatio = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a Dimension message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Image.Dimension
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Image.Dimension} Dimension
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Dimension.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Dimension message.
         * @function verify
         * @memberof Image.Dimension
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Dimension.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.width != null && message.hasOwnProperty("width"))
                if (!$util.isInteger(message.width))
                    return "width: integer expected";
            if (message.height != null && message.hasOwnProperty("height"))
                if (!$util.isInteger(message.height))
                    return "height: integer expected";
            if (message.aspectRatio != null && message.hasOwnProperty("aspectRatio"))
                if (!$util.isInteger(message.aspectRatio))
                    return "aspectRatio: integer expected";
            return null;
        };

        /**
         * Creates a Dimension message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Image.Dimension
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Image.Dimension} Dimension
         */
        Dimension.fromObject = function fromObject(object) {
            if (object instanceof $root.Image.Dimension)
                return object;
            var message = new $root.Image.Dimension();
            if (object.width != null)
                message.width = object.width | 0;
            if (object.height != null)
                message.height = object.height | 0;
            if (object.aspectRatio != null)
                message.aspectRatio = object.aspectRatio | 0;
            return message;
        };

        /**
         * Creates a plain object from a Dimension message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Image.Dimension
         * @static
         * @param {Image.Dimension} message Dimension
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Dimension.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.width = 0;
                object.height = 0;
                object.aspectRatio = 0;
            }
            if (message.width != null && message.hasOwnProperty("width"))
                object.width = message.width;
            if (message.height != null && message.hasOwnProperty("height"))
                object.height = message.height;
            if (message.aspectRatio != null && message.hasOwnProperty("aspectRatio"))
                object.aspectRatio = message.aspectRatio;
            return object;
        };

        /**
         * Converts this Dimension to JSON.
         * @function toJSON
         * @memberof Image.Dimension
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Dimension.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Dimension;
    })();

    Image.Citation = (function() {

        /**
         * Properties of a Citation.
         * @memberof Image
         * @interface ICitation
         * @property {string|null} [titleLocalized] Citation titleLocalized
         * @property {string|null} [url] Citation url
         */

        /**
         * Constructs a new Citation.
         * @memberof Image
         * @classdesc Represents a Citation.
         * @implements ICitation
         * @constructor
         * @param {Image.ICitation=} [properties] Properties to set
         */
        function Citation(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Citation titleLocalized.
         * @member {string} titleLocalized
         * @memberof Image.Citation
         * @instance
         */
        Citation.prototype.titleLocalized = "";

        /**
         * Citation url.
         * @member {string} url
         * @memberof Image.Citation
         * @instance
         */
        Citation.prototype.url = "";

        /**
         * Creates a new Citation instance using the specified properties.
         * @function create
         * @memberof Image.Citation
         * @static
         * @param {Image.ICitation=} [properties] Properties to set
         * @returns {Image.Citation} Citation instance
         */
        Citation.create = function create(properties) {
            return new Citation(properties);
        };

        /**
         * Encodes the specified Citation message. Does not implicitly {@link Image.Citation.verify|verify} messages.
         * @function encode
         * @memberof Image.Citation
         * @static
         * @param {Image.ICitation} message Citation message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Citation.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.titleLocalized != null && Object.hasOwnProperty.call(message, "titleLocalized"))
                writer.uint32(/* id 11, wireType 2 =*/90).string(message.titleLocalized);
            if (message.url != null && Object.hasOwnProperty.call(message, "url"))
                writer.uint32(/* id 12, wireType 2 =*/98).string(message.url);
            return writer;
        };

        /**
         * Encodes the specified Citation message, length delimited. Does not implicitly {@link Image.Citation.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Image.Citation
         * @static
         * @param {Image.ICitation} message Citation message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Citation.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Citation message from the specified reader or buffer.
         * @function decode
         * @memberof Image.Citation
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Image.Citation} Citation
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Citation.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Image.Citation();
            while (reader.pos < end) {
                var tag = reader.uint32();
                if ((tag & 7) === 4)
                    break;
                switch (tag >>> 3) {
                case 11:
                    message.titleLocalized = reader.string();
                    break;
                case 12:
                    message.url = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a Citation message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Image.Citation
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Image.Citation} Citation
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Citation.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Citation message.
         * @function verify
         * @memberof Image.Citation
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Citation.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.titleLocalized != null && message.hasOwnProperty("titleLocalized"))
                if (!$util.isString(message.titleLocalized))
                    return "titleLocalized: string expected";
            if (message.url != null && message.hasOwnProperty("url"))
                if (!$util.isString(message.url))
                    return "url: string expected";
            return null;
        };

        /**
         * Creates a Citation message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Image.Citation
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Image.Citation} Citation
         */
        Citation.fromObject = function fromObject(object) {
            if (object instanceof $root.Image.Citation)
                return object;
            var message = new $root.Image.Citation();
            if (object.titleLocalized != null)
                message.titleLocalized = String(object.titleLocalized);
            if (object.url != null)
                message.url = String(object.url);
            return message;
        };

        /**
         * Creates a plain object from a Citation message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Image.Citation
         * @static
         * @param {Image.Citation} message Citation
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Citation.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.titleLocalized = "";
                object.url = "";
            }
            if (message.titleLocalized != null && message.hasOwnProperty("titleLocalized"))
                object.titleLocalized = message.titleLocalized;
            if (message.url != null && message.hasOwnProperty("url"))
                object.url = message.url;
            return object;
        };

        /**
         * Converts this Citation to JSON.
         * @function toJSON
         * @memberof Image.Citation
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Citation.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Citation;
    })();

    return Image;
})();

$root.Attribution = (function() {

    /**
     * Properties of an Attribution.
     * @exports IAttribution
     * @interface IAttribution
     * @property {string|null} [sourceTitle] Attribution sourceTitle
     * @property {string|null} [sourceUrl] Attribution sourceUrl
     * @property {string|null} [licenseTitle] Attribution licenseTitle
     * @property {string|null} [licenseUrl] Attribution licenseUrl
     */

    /**
     * Constructs a new Attribution.
     * @exports Attribution
     * @classdesc Represents an Attribution.
     * @implements IAttribution
     * @constructor
     * @param {IAttribution=} [properties] Properties to set
     */
    function Attribution(properties) {
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * Attribution sourceTitle.
     * @member {string} sourceTitle
     * @memberof Attribution
     * @instance
     */
    Attribution.prototype.sourceTitle = "";

    /**
     * Attribution sourceUrl.
     * @member {string} sourceUrl
     * @memberof Attribution
     * @instance
     */
    Attribution.prototype.sourceUrl = "";

    /**
     * Attribution licenseTitle.
     * @member {string} licenseTitle
     * @memberof Attribution
     * @instance
     */
    Attribution.prototype.licenseTitle = "";

    /**
     * Attribution licenseUrl.
     * @member {string} licenseUrl
     * @memberof Attribution
     * @instance
     */
    Attribution.prototype.licenseUrl = "";

    /**
     * Creates a new Attribution instance using the specified properties.
     * @function create
     * @memberof Attribution
     * @static
     * @param {IAttribution=} [properties] Properties to set
     * @returns {Attribution} Attribution instance
     */
    Attribution.create = function create(properties) {
        return new Attribution(properties);
    };

    /**
     * Encodes the specified Attribution message. Does not implicitly {@link Attribution.verify|verify} messages.
     * @function encode
     * @memberof Attribution
     * @static
     * @param {IAttribution} message Attribution message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    Attribution.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.sourceTitle != null && Object.hasOwnProperty.call(message, "sourceTitle"))
            writer.uint32(/* id 1, wireType 2 =*/10).string(message.sourceTitle);
        if (message.sourceUrl != null && Object.hasOwnProperty.call(message, "sourceUrl"))
            writer.uint32(/* id 2, wireType 2 =*/18).string(message.sourceUrl);
        if (message.licenseTitle != null && Object.hasOwnProperty.call(message, "licenseTitle"))
            writer.uint32(/* id 3, wireType 2 =*/26).string(message.licenseTitle);
        if (message.licenseUrl != null && Object.hasOwnProperty.call(message, "licenseUrl"))
            writer.uint32(/* id 4, wireType 2 =*/34).string(message.licenseUrl);
        return writer;
    };

    /**
     * Encodes the specified Attribution message, length delimited. Does not implicitly {@link Attribution.verify|verify} messages.
     * @function encodeDelimited
     * @memberof Attribution
     * @static
     * @param {IAttribution} message Attribution message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    Attribution.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes an Attribution message from the specified reader or buffer.
     * @function decode
     * @memberof Attribution
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {Attribution} Attribution
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    Attribution.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Attribution();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.sourceTitle = reader.string();
                break;
            case 2:
                message.sourceUrl = reader.string();
                break;
            case 3:
                message.licenseTitle = reader.string();
                break;
            case 4:
                message.licenseUrl = reader.string();
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes an Attribution message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof Attribution
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {Attribution} Attribution
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    Attribution.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies an Attribution message.
     * @function verify
     * @memberof Attribution
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    Attribution.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.sourceTitle != null && message.hasOwnProperty("sourceTitle"))
            if (!$util.isString(message.sourceTitle))
                return "sourceTitle: string expected";
        if (message.sourceUrl != null && message.hasOwnProperty("sourceUrl"))
            if (!$util.isString(message.sourceUrl))
                return "sourceUrl: string expected";
        if (message.licenseTitle != null && message.hasOwnProperty("licenseTitle"))
            if (!$util.isString(message.licenseTitle))
                return "licenseTitle: string expected";
        if (message.licenseUrl != null && message.hasOwnProperty("licenseUrl"))
            if (!$util.isString(message.licenseUrl))
                return "licenseUrl: string expected";
        return null;
    };

    /**
     * Creates an Attribution message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof Attribution
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {Attribution} Attribution
     */
    Attribution.fromObject = function fromObject(object) {
        if (object instanceof $root.Attribution)
            return object;
        var message = new $root.Attribution();
        if (object.sourceTitle != null)
            message.sourceTitle = String(object.sourceTitle);
        if (object.sourceUrl != null)
            message.sourceUrl = String(object.sourceUrl);
        if (object.licenseTitle != null)
            message.licenseTitle = String(object.licenseTitle);
        if (object.licenseUrl != null)
            message.licenseUrl = String(object.licenseUrl);
        return message;
    };

    /**
     * Creates a plain object from an Attribution message. Also converts values to other types if specified.
     * @function toObject
     * @memberof Attribution
     * @static
     * @param {Attribution} message Attribution
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    Attribution.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        var object = {};
        if (options.defaults) {
            object.sourceTitle = "";
            object.sourceUrl = "";
            object.licenseTitle = "";
            object.licenseUrl = "";
        }
        if (message.sourceTitle != null && message.hasOwnProperty("sourceTitle"))
            object.sourceTitle = message.sourceTitle;
        if (message.sourceUrl != null && message.hasOwnProperty("sourceUrl"))
            object.sourceUrl = message.sourceUrl;
        if (message.licenseTitle != null && message.hasOwnProperty("licenseTitle"))
            object.licenseTitle = message.licenseTitle;
        if (message.licenseUrl != null && message.hasOwnProperty("licenseUrl"))
            object.licenseUrl = message.licenseUrl;
        return object;
    };

    /**
     * Converts this Attribution to JSON.
     * @function toJSON
     * @memberof Attribution
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    Attribution.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return Attribution;
})();

$root.ImagePalette = (function() {

    /**
     * Properties of an ImagePalette.
     * @exports IImagePalette
     * @interface IImagePalette
     * @property {string|null} [lightVibrantRGB] ImagePalette lightVibrantRGB
     * @property {string|null} [vibrantRGB] ImagePalette vibrantRGB
     * @property {string|null} [darkVibrantRGB] ImagePalette darkVibrantRGB
     * @property {string|null} [lightMutedRGB] ImagePalette lightMutedRGB
     * @property {string|null} [mutedRGB] ImagePalette mutedRGB
     * @property {string|null} [darkMutedRGB] ImagePalette darkMutedRGB
     */

    /**
     * Constructs a new ImagePalette.
     * @exports ImagePalette
     * @classdesc Represents an ImagePalette.
     * @implements IImagePalette
     * @constructor
     * @param {IImagePalette=} [properties] Properties to set
     */
    function ImagePalette(properties) {
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * ImagePalette lightVibrantRGB.
     * @member {string} lightVibrantRGB
     * @memberof ImagePalette
     * @instance
     */
    ImagePalette.prototype.lightVibrantRGB = "";

    /**
     * ImagePalette vibrantRGB.
     * @member {string} vibrantRGB
     * @memberof ImagePalette
     * @instance
     */
    ImagePalette.prototype.vibrantRGB = "";

    /**
     * ImagePalette darkVibrantRGB.
     * @member {string} darkVibrantRGB
     * @memberof ImagePalette
     * @instance
     */
    ImagePalette.prototype.darkVibrantRGB = "";

    /**
     * ImagePalette lightMutedRGB.
     * @member {string} lightMutedRGB
     * @memberof ImagePalette
     * @instance
     */
    ImagePalette.prototype.lightMutedRGB = "";

    /**
     * ImagePalette mutedRGB.
     * @member {string} mutedRGB
     * @memberof ImagePalette
     * @instance
     */
    ImagePalette.prototype.mutedRGB = "";

    /**
     * ImagePalette darkMutedRGB.
     * @member {string} darkMutedRGB
     * @memberof ImagePalette
     * @instance
     */
    ImagePalette.prototype.darkMutedRGB = "";

    /**
     * Creates a new ImagePalette instance using the specified properties.
     * @function create
     * @memberof ImagePalette
     * @static
     * @param {IImagePalette=} [properties] Properties to set
     * @returns {ImagePalette} ImagePalette instance
     */
    ImagePalette.create = function create(properties) {
        return new ImagePalette(properties);
    };

    /**
     * Encodes the specified ImagePalette message. Does not implicitly {@link ImagePalette.verify|verify} messages.
     * @function encode
     * @memberof ImagePalette
     * @static
     * @param {IImagePalette} message ImagePalette message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    ImagePalette.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.lightVibrantRGB != null && Object.hasOwnProperty.call(message, "lightVibrantRGB"))
            writer.uint32(/* id 1, wireType 2 =*/10).string(message.lightVibrantRGB);
        if (message.vibrantRGB != null && Object.hasOwnProperty.call(message, "vibrantRGB"))
            writer.uint32(/* id 2, wireType 2 =*/18).string(message.vibrantRGB);
        if (message.darkVibrantRGB != null && Object.hasOwnProperty.call(message, "darkVibrantRGB"))
            writer.uint32(/* id 3, wireType 2 =*/26).string(message.darkVibrantRGB);
        if (message.lightMutedRGB != null && Object.hasOwnProperty.call(message, "lightMutedRGB"))
            writer.uint32(/* id 4, wireType 2 =*/34).string(message.lightMutedRGB);
        if (message.mutedRGB != null && Object.hasOwnProperty.call(message, "mutedRGB"))
            writer.uint32(/* id 5, wireType 2 =*/42).string(message.mutedRGB);
        if (message.darkMutedRGB != null && Object.hasOwnProperty.call(message, "darkMutedRGB"))
            writer.uint32(/* id 6, wireType 2 =*/50).string(message.darkMutedRGB);
        return writer;
    };

    /**
     * Encodes the specified ImagePalette message, length delimited. Does not implicitly {@link ImagePalette.verify|verify} messages.
     * @function encodeDelimited
     * @memberof ImagePalette
     * @static
     * @param {IImagePalette} message ImagePalette message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    ImagePalette.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes an ImagePalette message from the specified reader or buffer.
     * @function decode
     * @memberof ImagePalette
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {ImagePalette} ImagePalette
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    ImagePalette.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ImagePalette();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.lightVibrantRGB = reader.string();
                break;
            case 2:
                message.vibrantRGB = reader.string();
                break;
            case 3:
                message.darkVibrantRGB = reader.string();
                break;
            case 4:
                message.lightMutedRGB = reader.string();
                break;
            case 5:
                message.mutedRGB = reader.string();
                break;
            case 6:
                message.darkMutedRGB = reader.string();
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes an ImagePalette message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof ImagePalette
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {ImagePalette} ImagePalette
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    ImagePalette.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies an ImagePalette message.
     * @function verify
     * @memberof ImagePalette
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    ImagePalette.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.lightVibrantRGB != null && message.hasOwnProperty("lightVibrantRGB"))
            if (!$util.isString(message.lightVibrantRGB))
                return "lightVibrantRGB: string expected";
        if (message.vibrantRGB != null && message.hasOwnProperty("vibrantRGB"))
            if (!$util.isString(message.vibrantRGB))
                return "vibrantRGB: string expected";
        if (message.darkVibrantRGB != null && message.hasOwnProperty("darkVibrantRGB"))
            if (!$util.isString(message.darkVibrantRGB))
                return "darkVibrantRGB: string expected";
        if (message.lightMutedRGB != null && message.hasOwnProperty("lightMutedRGB"))
            if (!$util.isString(message.lightMutedRGB))
                return "lightMutedRGB: string expected";
        if (message.mutedRGB != null && message.hasOwnProperty("mutedRGB"))
            if (!$util.isString(message.mutedRGB))
                return "mutedRGB: string expected";
        if (message.darkMutedRGB != null && message.hasOwnProperty("darkMutedRGB"))
            if (!$util.isString(message.darkMutedRGB))
                return "darkMutedRGB: string expected";
        return null;
    };

    /**
     * Creates an ImagePalette message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof ImagePalette
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {ImagePalette} ImagePalette
     */
    ImagePalette.fromObject = function fromObject(object) {
        if (object instanceof $root.ImagePalette)
            return object;
        var message = new $root.ImagePalette();
        if (object.lightVibrantRGB != null)
            message.lightVibrantRGB = String(object.lightVibrantRGB);
        if (object.vibrantRGB != null)
            message.vibrantRGB = String(object.vibrantRGB);
        if (object.darkVibrantRGB != null)
            message.darkVibrantRGB = String(object.darkVibrantRGB);
        if (object.lightMutedRGB != null)
            message.lightMutedRGB = String(object.lightMutedRGB);
        if (object.mutedRGB != null)
            message.mutedRGB = String(object.mutedRGB);
        if (object.darkMutedRGB != null)
            message.darkMutedRGB = String(object.darkMutedRGB);
        return message;
    };

    /**
     * Creates a plain object from an ImagePalette message. Also converts values to other types if specified.
     * @function toObject
     * @memberof ImagePalette
     * @static
     * @param {ImagePalette} message ImagePalette
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    ImagePalette.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        var object = {};
        if (options.defaults) {
            object.lightVibrantRGB = "";
            object.vibrantRGB = "";
            object.darkVibrantRGB = "";
            object.lightMutedRGB = "";
            object.mutedRGB = "";
            object.darkMutedRGB = "";
        }
        if (message.lightVibrantRGB != null && message.hasOwnProperty("lightVibrantRGB"))
            object.lightVibrantRGB = message.lightVibrantRGB;
        if (message.vibrantRGB != null && message.hasOwnProperty("vibrantRGB"))
            object.vibrantRGB = message.vibrantRGB;
        if (message.darkVibrantRGB != null && message.hasOwnProperty("darkVibrantRGB"))
            object.darkVibrantRGB = message.darkVibrantRGB;
        if (message.lightMutedRGB != null && message.hasOwnProperty("lightMutedRGB"))
            object.lightMutedRGB = message.lightMutedRGB;
        if (message.mutedRGB != null && message.hasOwnProperty("mutedRGB"))
            object.mutedRGB = message.mutedRGB;
        if (message.darkMutedRGB != null && message.hasOwnProperty("darkMutedRGB"))
            object.darkMutedRGB = message.darkMutedRGB;
        return object;
    };

    /**
     * Converts this ImagePalette to JSON.
     * @function toJSON
     * @memberof ImagePalette
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    ImagePalette.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return ImagePalette;
})();

$root.TranslatedText = (function() {

    /**
     * Properties of a TranslatedText.
     * @exports ITranslatedText
     * @interface ITranslatedText
     * @property {string|null} [text] TranslatedText text
     * @property {string|null} [sourceLocale] TranslatedText sourceLocale
     * @property {string|null} [targetLocale] TranslatedText targetLocale
     */

    /**
     * Constructs a new TranslatedText.
     * @exports TranslatedText
     * @classdesc Represents a TranslatedText.
     * @implements ITranslatedText
     * @constructor
     * @param {ITranslatedText=} [properties] Properties to set
     */
    function TranslatedText(properties) {
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * TranslatedText text.
     * @member {string} text
     * @memberof TranslatedText
     * @instance
     */
    TranslatedText.prototype.text = "";

    /**
     * TranslatedText sourceLocale.
     * @member {string} sourceLocale
     * @memberof TranslatedText
     * @instance
     */
    TranslatedText.prototype.sourceLocale = "";

    /**
     * TranslatedText targetLocale.
     * @member {string} targetLocale
     * @memberof TranslatedText
     * @instance
     */
    TranslatedText.prototype.targetLocale = "";

    /**
     * Creates a new TranslatedText instance using the specified properties.
     * @function create
     * @memberof TranslatedText
     * @static
     * @param {ITranslatedText=} [properties] Properties to set
     * @returns {TranslatedText} TranslatedText instance
     */
    TranslatedText.create = function create(properties) {
        return new TranslatedText(properties);
    };

    /**
     * Encodes the specified TranslatedText message. Does not implicitly {@link TranslatedText.verify|verify} messages.
     * @function encode
     * @memberof TranslatedText
     * @static
     * @param {ITranslatedText} message TranslatedText message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    TranslatedText.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.text != null && Object.hasOwnProperty.call(message, "text"))
            writer.uint32(/* id 1, wireType 2 =*/10).string(message.text);
        if (message.sourceLocale != null && Object.hasOwnProperty.call(message, "sourceLocale"))
            writer.uint32(/* id 2, wireType 2 =*/18).string(message.sourceLocale);
        if (message.targetLocale != null && Object.hasOwnProperty.call(message, "targetLocale"))
            writer.uint32(/* id 3, wireType 2 =*/26).string(message.targetLocale);
        return writer;
    };

    /**
     * Encodes the specified TranslatedText message, length delimited. Does not implicitly {@link TranslatedText.verify|verify} messages.
     * @function encodeDelimited
     * @memberof TranslatedText
     * @static
     * @param {ITranslatedText} message TranslatedText message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    TranslatedText.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a TranslatedText message from the specified reader or buffer.
     * @function decode
     * @memberof TranslatedText
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {TranslatedText} TranslatedText
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    TranslatedText.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.TranslatedText();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.text = reader.string();
                break;
            case 2:
                message.sourceLocale = reader.string();
                break;
            case 3:
                message.targetLocale = reader.string();
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a TranslatedText message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof TranslatedText
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {TranslatedText} TranslatedText
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    TranslatedText.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a TranslatedText message.
     * @function verify
     * @memberof TranslatedText
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    TranslatedText.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.text != null && message.hasOwnProperty("text"))
            if (!$util.isString(message.text))
                return "text: string expected";
        if (message.sourceLocale != null && message.hasOwnProperty("sourceLocale"))
            if (!$util.isString(message.sourceLocale))
                return "sourceLocale: string expected";
        if (message.targetLocale != null && message.hasOwnProperty("targetLocale"))
            if (!$util.isString(message.targetLocale))
                return "targetLocale: string expected";
        return null;
    };

    /**
     * Creates a TranslatedText message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof TranslatedText
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {TranslatedText} TranslatedText
     */
    TranslatedText.fromObject = function fromObject(object) {
        if (object instanceof $root.TranslatedText)
            return object;
        var message = new $root.TranslatedText();
        if (object.text != null)
            message.text = String(object.text);
        if (object.sourceLocale != null)
            message.sourceLocale = String(object.sourceLocale);
        if (object.targetLocale != null)
            message.targetLocale = String(object.targetLocale);
        return message;
    };

    /**
     * Creates a plain object from a TranslatedText message. Also converts values to other types if specified.
     * @function toObject
     * @memberof TranslatedText
     * @static
     * @param {TranslatedText} message TranslatedText
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    TranslatedText.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        var object = {};
        if (options.defaults) {
            object.text = "";
            object.sourceLocale = "";
            object.targetLocale = "";
        }
        if (message.text != null && message.hasOwnProperty("text"))
            object.text = message.text;
        if (message.sourceLocale != null && message.hasOwnProperty("sourceLocale"))
            object.sourceLocale = message.sourceLocale;
        if (message.targetLocale != null && message.hasOwnProperty("targetLocale"))
            object.targetLocale = message.targetLocale;
        return object;
    };

    /**
     * Converts this TranslatedText to JSON.
     * @function toJSON
     * @memberof TranslatedText
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    TranslatedText.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return TranslatedText;
})();

$root.PlusOneData = (function() {

    /**
     * Properties of a PlusOneData.
     * @exports IPlusOneData
     * @interface IPlusOneData
     * @property {boolean|null} [setByUser] PlusOneData setByUser
     * @property {number|Long|null} [total] PlusOneData total
     * @property {number|Long|null} [circlesTotal] PlusOneData circlesTotal
     * @property {Array.<IPlusPerson>|null} [circlesPeople] PlusOneData circlesPeople
     */

    /**
     * Constructs a new PlusOneData.
     * @exports PlusOneData
     * @classdesc Represents a PlusOneData.
     * @implements IPlusOneData
     * @constructor
     * @param {IPlusOneData=} [properties] Properties to set
     */
    function PlusOneData(properties) {
        this.circlesPeople = [];
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * PlusOneData setByUser.
     * @member {boolean} setByUser
     * @memberof PlusOneData
     * @instance
     */
    PlusOneData.prototype.setByUser = false;

    /**
     * PlusOneData total.
     * @member {number|Long} total
     * @memberof PlusOneData
     * @instance
     */
    PlusOneData.prototype.total = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

    /**
     * PlusOneData circlesTotal.
     * @member {number|Long} circlesTotal
     * @memberof PlusOneData
     * @instance
     */
    PlusOneData.prototype.circlesTotal = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

    /**
     * PlusOneData circlesPeople.
     * @member {Array.<IPlusPerson>} circlesPeople
     * @memberof PlusOneData
     * @instance
     */
    PlusOneData.prototype.circlesPeople = $util.emptyArray;

    /**
     * Creates a new PlusOneData instance using the specified properties.
     * @function create
     * @memberof PlusOneData
     * @static
     * @param {IPlusOneData=} [properties] Properties to set
     * @returns {PlusOneData} PlusOneData instance
     */
    PlusOneData.create = function create(properties) {
        return new PlusOneData(properties);
    };

    /**
     * Encodes the specified PlusOneData message. Does not implicitly {@link PlusOneData.verify|verify} messages.
     * @function encode
     * @memberof PlusOneData
     * @static
     * @param {IPlusOneData} message PlusOneData message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    PlusOneData.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.setByUser != null && Object.hasOwnProperty.call(message, "setByUser"))
            writer.uint32(/* id 1, wireType 0 =*/8).bool(message.setByUser);
        if (message.total != null && Object.hasOwnProperty.call(message, "total"))
            writer.uint32(/* id 2, wireType 0 =*/16).int64(message.total);
        if (message.circlesTotal != null && Object.hasOwnProperty.call(message, "circlesTotal"))
            writer.uint32(/* id 3, wireType 0 =*/24).int64(message.circlesTotal);
        if (message.circlesPeople != null && message.circlesPeople.length)
            for (var i = 0; i < message.circlesPeople.length; ++i)
                $root.PlusPerson.encode(message.circlesPeople[i], writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
        return writer;
    };

    /**
     * Encodes the specified PlusOneData message, length delimited. Does not implicitly {@link PlusOneData.verify|verify} messages.
     * @function encodeDelimited
     * @memberof PlusOneData
     * @static
     * @param {IPlusOneData} message PlusOneData message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    PlusOneData.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a PlusOneData message from the specified reader or buffer.
     * @function decode
     * @memberof PlusOneData
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {PlusOneData} PlusOneData
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    PlusOneData.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.PlusOneData();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.setByUser = reader.bool();
                break;
            case 2:
                message.total = reader.int64();
                break;
            case 3:
                message.circlesTotal = reader.int64();
                break;
            case 4:
                if (!(message.circlesPeople && message.circlesPeople.length))
                    message.circlesPeople = [];
                message.circlesPeople.push($root.PlusPerson.decode(reader, reader.uint32()));
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a PlusOneData message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof PlusOneData
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {PlusOneData} PlusOneData
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    PlusOneData.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a PlusOneData message.
     * @function verify
     * @memberof PlusOneData
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    PlusOneData.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.setByUser != null && message.hasOwnProperty("setByUser"))
            if (typeof message.setByUser !== "boolean")
                return "setByUser: boolean expected";
        if (message.total != null && message.hasOwnProperty("total"))
            if (!$util.isInteger(message.total) && !(message.total && $util.isInteger(message.total.low) && $util.isInteger(message.total.high)))
                return "total: integer|Long expected";
        if (message.circlesTotal != null && message.hasOwnProperty("circlesTotal"))
            if (!$util.isInteger(message.circlesTotal) && !(message.circlesTotal && $util.isInteger(message.circlesTotal.low) && $util.isInteger(message.circlesTotal.high)))
                return "circlesTotal: integer|Long expected";
        if (message.circlesPeople != null && message.hasOwnProperty("circlesPeople")) {
            if (!Array.isArray(message.circlesPeople))
                return "circlesPeople: array expected";
            for (var i = 0; i < message.circlesPeople.length; ++i) {
                var error = $root.PlusPerson.verify(message.circlesPeople[i]);
                if (error)
                    return "circlesPeople." + error;
            }
        }
        return null;
    };

    /**
     * Creates a PlusOneData message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof PlusOneData
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {PlusOneData} PlusOneData
     */
    PlusOneData.fromObject = function fromObject(object) {
        if (object instanceof $root.PlusOneData)
            return object;
        var message = new $root.PlusOneData();
        if (object.setByUser != null)
            message.setByUser = Boolean(object.setByUser);
        if (object.total != null)
            if ($util.Long)
                (message.total = $util.Long.fromValue(object.total)).unsigned = false;
            else if (typeof object.total === "string")
                message.total = parseInt(object.total, 10);
            else if (typeof object.total === "number")
                message.total = object.total;
            else if (typeof object.total === "object")
                message.total = new $util.LongBits(object.total.low >>> 0, object.total.high >>> 0).toNumber();
        if (object.circlesTotal != null)
            if ($util.Long)
                (message.circlesTotal = $util.Long.fromValue(object.circlesTotal)).unsigned = false;
            else if (typeof object.circlesTotal === "string")
                message.circlesTotal = parseInt(object.circlesTotal, 10);
            else if (typeof object.circlesTotal === "number")
                message.circlesTotal = object.circlesTotal;
            else if (typeof object.circlesTotal === "object")
                message.circlesTotal = new $util.LongBits(object.circlesTotal.low >>> 0, object.circlesTotal.high >>> 0).toNumber();
        if (object.circlesPeople) {
            if (!Array.isArray(object.circlesPeople))
                throw TypeError(".PlusOneData.circlesPeople: array expected");
            message.circlesPeople = [];
            for (var i = 0; i < object.circlesPeople.length; ++i) {
                if (typeof object.circlesPeople[i] !== "object")
                    throw TypeError(".PlusOneData.circlesPeople: object expected");
                message.circlesPeople[i] = $root.PlusPerson.fromObject(object.circlesPeople[i]);
            }
        }
        return message;
    };

    /**
     * Creates a plain object from a PlusOneData message. Also converts values to other types if specified.
     * @function toObject
     * @memberof PlusOneData
     * @static
     * @param {PlusOneData} message PlusOneData
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    PlusOneData.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        var object = {};
        if (options.arrays || options.defaults)
            object.circlesPeople = [];
        if (options.defaults) {
            object.setByUser = false;
            if ($util.Long) {
                var long = new $util.Long(0, 0, false);
                object.total = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
            } else
                object.total = options.longs === String ? "0" : 0;
            if ($util.Long) {
                var long = new $util.Long(0, 0, false);
                object.circlesTotal = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
            } else
                object.circlesTotal = options.longs === String ? "0" : 0;
        }
        if (message.setByUser != null && message.hasOwnProperty("setByUser"))
            object.setByUser = message.setByUser;
        if (message.total != null && message.hasOwnProperty("total"))
            if (typeof message.total === "number")
                object.total = options.longs === String ? String(message.total) : message.total;
            else
                object.total = options.longs === String ? $util.Long.prototype.toString.call(message.total) : options.longs === Number ? new $util.LongBits(message.total.low >>> 0, message.total.high >>> 0).toNumber() : message.total;
        if (message.circlesTotal != null && message.hasOwnProperty("circlesTotal"))
            if (typeof message.circlesTotal === "number")
                object.circlesTotal = options.longs === String ? String(message.circlesTotal) : message.circlesTotal;
            else
                object.circlesTotal = options.longs === String ? $util.Long.prototype.toString.call(message.circlesTotal) : options.longs === Number ? new $util.LongBits(message.circlesTotal.low >>> 0, message.circlesTotal.high >>> 0).toNumber() : message.circlesTotal;
        if (message.circlesPeople && message.circlesPeople.length) {
            object.circlesPeople = [];
            for (var j = 0; j < message.circlesPeople.length; ++j)
                object.circlesPeople[j] = $root.PlusPerson.toObject(message.circlesPeople[j], options);
        }
        return object;
    };

    /**
     * Converts this PlusOneData to JSON.
     * @function toJSON
     * @memberof PlusOneData
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    PlusOneData.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return PlusOneData;
})();

$root.PlusPerson = (function() {

    /**
     * Properties of a PlusPerson.
     * @exports IPlusPerson
     * @interface IPlusPerson
     * @property {string|null} [displayName] PlusPerson displayName
     * @property {string|null} [profileImageUrl] PlusPerson profileImageUrl
     */

    /**
     * Constructs a new PlusPerson.
     * @exports PlusPerson
     * @classdesc Represents a PlusPerson.
     * @implements IPlusPerson
     * @constructor
     * @param {IPlusPerson=} [properties] Properties to set
     */
    function PlusPerson(properties) {
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * PlusPerson displayName.
     * @member {string} displayName
     * @memberof PlusPerson
     * @instance
     */
    PlusPerson.prototype.displayName = "";

    /**
     * PlusPerson profileImageUrl.
     * @member {string} profileImageUrl
     * @memberof PlusPerson
     * @instance
     */
    PlusPerson.prototype.profileImageUrl = "";

    /**
     * Creates a new PlusPerson instance using the specified properties.
     * @function create
     * @memberof PlusPerson
     * @static
     * @param {IPlusPerson=} [properties] Properties to set
     * @returns {PlusPerson} PlusPerson instance
     */
    PlusPerson.create = function create(properties) {
        return new PlusPerson(properties);
    };

    /**
     * Encodes the specified PlusPerson message. Does not implicitly {@link PlusPerson.verify|verify} messages.
     * @function encode
     * @memberof PlusPerson
     * @static
     * @param {IPlusPerson} message PlusPerson message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    PlusPerson.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.displayName != null && Object.hasOwnProperty.call(message, "displayName"))
            writer.uint32(/* id 2, wireType 2 =*/18).string(message.displayName);
        if (message.profileImageUrl != null && Object.hasOwnProperty.call(message, "profileImageUrl"))
            writer.uint32(/* id 4, wireType 2 =*/34).string(message.profileImageUrl);
        return writer;
    };

    /**
     * Encodes the specified PlusPerson message, length delimited. Does not implicitly {@link PlusPerson.verify|verify} messages.
     * @function encodeDelimited
     * @memberof PlusPerson
     * @static
     * @param {IPlusPerson} message PlusPerson message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    PlusPerson.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a PlusPerson message from the specified reader or buffer.
     * @function decode
     * @memberof PlusPerson
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {PlusPerson} PlusPerson
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    PlusPerson.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.PlusPerson();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            case 2:
                message.displayName = reader.string();
                break;
            case 4:
                message.profileImageUrl = reader.string();
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a PlusPerson message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof PlusPerson
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {PlusPerson} PlusPerson
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    PlusPerson.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a PlusPerson message.
     * @function verify
     * @memberof PlusPerson
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    PlusPerson.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.displayName != null && message.hasOwnProperty("displayName"))
            if (!$util.isString(message.displayName))
                return "displayName: string expected";
        if (message.profileImageUrl != null && message.hasOwnProperty("profileImageUrl"))
            if (!$util.isString(message.profileImageUrl))
                return "profileImageUrl: string expected";
        return null;
    };

    /**
     * Creates a PlusPerson message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof PlusPerson
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {PlusPerson} PlusPerson
     */
    PlusPerson.fromObject = function fromObject(object) {
        if (object instanceof $root.PlusPerson)
            return object;
        var message = new $root.PlusPerson();
        if (object.displayName != null)
            message.displayName = String(object.displayName);
        if (object.profileImageUrl != null)
            message.profileImageUrl = String(object.profileImageUrl);
        return message;
    };

    /**
     * Creates a plain object from a PlusPerson message. Also converts values to other types if specified.
     * @function toObject
     * @memberof PlusPerson
     * @static
     * @param {PlusPerson} message PlusPerson
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    PlusPerson.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        var object = {};
        if (options.defaults) {
            object.displayName = "";
            object.profileImageUrl = "";
        }
        if (message.displayName != null && message.hasOwnProperty("displayName"))
            object.displayName = message.displayName;
        if (message.profileImageUrl != null && message.hasOwnProperty("profileImageUrl"))
            object.profileImageUrl = message.profileImageUrl;
        return object;
    };

    /**
     * Converts this PlusPerson to JSON.
     * @function toJSON
     * @memberof PlusPerson
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    PlusPerson.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return PlusPerson;
})();

$root.AppDetails = (function() {

    /**
     * Properties of an AppDetails.
     * @exports IAppDetails
     * @interface IAppDetails
     * @property {string|null} [developerName] AppDetails developerName
     * @property {number|null} [majorVersionNumber] AppDetails majorVersionNumber
     * @property {number|null} [versionCode] AppDetails versionCode
     * @property {string|null} [versionString] AppDetails versionString
     * @property {string|null} [title] AppDetails title
     * @property {Array.<string>|null} [appCategory] AppDetails appCategory
     * @property {number|null} [contentRating] AppDetails contentRating
     * @property {number|Long|null} [infoDownloadSize] AppDetails infoDownloadSize
     * @property {Array.<string>|null} [permission] AppDetails permission
     * @property {string|null} [developerEmail] AppDetails developerEmail
     * @property {string|null} [developerWebsite] AppDetails developerWebsite
     * @property {string|null} [infoDownload] AppDetails infoDownload
     * @property {string|null} [packageName] AppDetails packageName
     * @property {string|null} [recentChangesHtml] AppDetails recentChangesHtml
     * @property {string|null} [infoUpdatedOn] AppDetails infoUpdatedOn
     * @property {Array.<IFileMetadata>|null} [file] AppDetails file
     * @property {string|null} [appType] AppDetails appType
     * @property {Array.<string>|null} [certificateHash] AppDetails certificateHash
     * @property {boolean|null} [variesWithDevice] AppDetails variesWithDevice
     * @property {Array.<ICertificateSet>|null} [certificateSet] AppDetails certificateSet
     * @property {Array.<string>|null} [autoAcquireFreeAppIfHigherVersionAvailableTag] AppDetails autoAcquireFreeAppIfHigherVersionAvailableTag
     * @property {boolean|null} [hasInstantLink2] AppDetails hasInstantLink2
     * @property {Array.<string>|null} [splitId] AppDetails splitId
     * @property {boolean|null} [gamepadRequired] AppDetails gamepadRequired
     * @property {boolean|null} [externallyHosted] AppDetails externallyHosted
     * @property {boolean|null} [everExternallyHosted] AppDetails everExternallyHosted
     * @property {string|null} [installNotes] AppDetails installNotes
     * @property {number|null} [installLocation] AppDetails installLocation
     * @property {number|null} [targetSdkVersion] AppDetails targetSdkVersion
     * @property {string|null} [hasPreregistrationPromoCode] AppDetails hasPreregistrationPromoCode
     * @property {IDependencies|null} [dependencies] AppDetails dependencies
     * @property {ITestingProgramInfo|null} [testingProgramInfo] AppDetails testingProgramInfo
     * @property {IEarlyAccessInfo|null} [earlyAccessInfo] AppDetails earlyAccessInfo
     * @property {IEditorChoice|null} [editorChoice] AppDetails editorChoice
     * @property {string|null} [instantLink] AppDetails instantLink
     * @property {string|null} [developerAddress] AppDetails developerAddress
     * @property {IPublisher|null} [publisher] AppDetails publisher
     * @property {string|null} [categoryName] AppDetails categoryName
     * @property {number|Long|null} [downloadCount] AppDetails downloadCount
     * @property {string|null} [downloadLabelDisplay] AppDetails downloadLabelDisplay
     * @property {string|null} [inAppProduct] AppDetails inAppProduct
     * @property {string|null} [downloadLabelAbbreviated] AppDetails downloadLabelAbbreviated
     * @property {string|null} [downloadLabel] AppDetails downloadLabel
     */

    /**
     * Constructs a new AppDetails.
     * @exports AppDetails
     * @classdesc Represents an AppDetails.
     * @implements IAppDetails
     * @constructor
     * @param {IAppDetails=} [properties] Properties to set
     */
    function AppDetails(properties) {
        this.appCategory = [];
        this.permission = [];
        this.file = [];
        this.certificateHash = [];
        this.certificateSet = [];
        this.autoAcquireFreeAppIfHigherVersionAvailableTag = [];
        this.splitId = [];
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * AppDetails developerName.
     * @member {string} developerName
     * @memberof AppDetails
     * @instance
     */
    AppDetails.prototype.developerName = "";

    /**
     * AppDetails majorVersionNumber.
     * @member {number} majorVersionNumber
     * @memberof AppDetails
     * @instance
     */
    AppDetails.prototype.majorVersionNumber = 0;

    /**
     * AppDetails versionCode.
     * @member {number} versionCode
     * @memberof AppDetails
     * @instance
     */
    AppDetails.prototype.versionCode = 0;

    /**
     * AppDetails versionString.
     * @member {string} versionString
     * @memberof AppDetails
     * @instance
     */
    AppDetails.prototype.versionString = "";

    /**
     * AppDetails title.
     * @member {string} title
     * @memberof AppDetails
     * @instance
     */
    AppDetails.prototype.title = "";

    /**
     * AppDetails appCategory.
     * @member {Array.<string>} appCategory
     * @memberof AppDetails
     * @instance
     */
    AppDetails.prototype.appCategory = $util.emptyArray;

    /**
     * AppDetails contentRating.
     * @member {number} contentRating
     * @memberof AppDetails
     * @instance
     */
    AppDetails.prototype.contentRating = 0;

    /**
     * AppDetails infoDownloadSize.
     * @member {number|Long} infoDownloadSize
     * @memberof AppDetails
     * @instance
     */
    AppDetails.prototype.infoDownloadSize = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

    /**
     * AppDetails permission.
     * @member {Array.<string>} permission
     * @memberof AppDetails
     * @instance
     */
    AppDetails.prototype.permission = $util.emptyArray;

    /**
     * AppDetails developerEmail.
     * @member {string} developerEmail
     * @memberof AppDetails
     * @instance
     */
    AppDetails.prototype.developerEmail = "";

    /**
     * AppDetails developerWebsite.
     * @member {string} developerWebsite
     * @memberof AppDetails
     * @instance
     */
    AppDetails.prototype.developerWebsite = "";

    /**
     * AppDetails infoDownload.
     * @member {string} infoDownload
     * @memberof AppDetails
     * @instance
     */
    AppDetails.prototype.infoDownload = "";

    /**
     * AppDetails packageName.
     * @member {string} packageName
     * @memberof AppDetails
     * @instance
     */
    AppDetails.prototype.packageName = "";

    /**
     * AppDetails recentChangesHtml.
     * @member {string} recentChangesHtml
     * @memberof AppDetails
     * @instance
     */
    AppDetails.prototype.recentChangesHtml = "";

    /**
     * AppDetails infoUpdatedOn.
     * @member {string} infoUpdatedOn
     * @memberof AppDetails
     * @instance
     */
    AppDetails.prototype.infoUpdatedOn = "";

    /**
     * AppDetails file.
     * @member {Array.<IFileMetadata>} file
     * @memberof AppDetails
     * @instance
     */
    AppDetails.prototype.file = $util.emptyArray;

    /**
     * AppDetails appType.
     * @member {string} appType
     * @memberof AppDetails
     * @instance
     */
    AppDetails.prototype.appType = "";

    /**
     * AppDetails certificateHash.
     * @member {Array.<string>} certificateHash
     * @memberof AppDetails
     * @instance
     */
    AppDetails.prototype.certificateHash = $util.emptyArray;

    /**
     * AppDetails variesWithDevice.
     * @member {boolean} variesWithDevice
     * @memberof AppDetails
     * @instance
     */
    AppDetails.prototype.variesWithDevice = true;

    /**
     * AppDetails certificateSet.
     * @member {Array.<ICertificateSet>} certificateSet
     * @memberof AppDetails
     * @instance
     */
    AppDetails.prototype.certificateSet = $util.emptyArray;

    /**
     * AppDetails autoAcquireFreeAppIfHigherVersionAvailableTag.
     * @member {Array.<string>} autoAcquireFreeAppIfHigherVersionAvailableTag
     * @memberof AppDetails
     * @instance
     */
    AppDetails.prototype.autoAcquireFreeAppIfHigherVersionAvailableTag = $util.emptyArray;

    /**
     * AppDetails hasInstantLink2.
     * @member {boolean} hasInstantLink2
     * @memberof AppDetails
     * @instance
     */
    AppDetails.prototype.hasInstantLink2 = false;

    /**
     * AppDetails splitId.
     * @member {Array.<string>} splitId
     * @memberof AppDetails
     * @instance
     */
    AppDetails.prototype.splitId = $util.emptyArray;

    /**
     * AppDetails gamepadRequired.
     * @member {boolean} gamepadRequired
     * @memberof AppDetails
     * @instance
     */
    AppDetails.prototype.gamepadRequired = false;

    /**
     * AppDetails externallyHosted.
     * @member {boolean} externallyHosted
     * @memberof AppDetails
     * @instance
     */
    AppDetails.prototype.externallyHosted = false;

    /**
     * AppDetails everExternallyHosted.
     * @member {boolean} everExternallyHosted
     * @memberof AppDetails
     * @instance
     */
    AppDetails.prototype.everExternallyHosted = false;

    /**
     * AppDetails installNotes.
     * @member {string} installNotes
     * @memberof AppDetails
     * @instance
     */
    AppDetails.prototype.installNotes = "";

    /**
     * AppDetails installLocation.
     * @member {number} installLocation
     * @memberof AppDetails
     * @instance
     */
    AppDetails.prototype.installLocation = 0;

    /**
     * AppDetails targetSdkVersion.
     * @member {number} targetSdkVersion
     * @memberof AppDetails
     * @instance
     */
    AppDetails.prototype.targetSdkVersion = 0;

    /**
     * AppDetails hasPreregistrationPromoCode.
     * @member {string} hasPreregistrationPromoCode
     * @memberof AppDetails
     * @instance
     */
    AppDetails.prototype.hasPreregistrationPromoCode = "";

    /**
     * AppDetails dependencies.
     * @member {IDependencies|null|undefined} dependencies
     * @memberof AppDetails
     * @instance
     */
    AppDetails.prototype.dependencies = null;

    /**
     * AppDetails testingProgramInfo.
     * @member {ITestingProgramInfo|null|undefined} testingProgramInfo
     * @memberof AppDetails
     * @instance
     */
    AppDetails.prototype.testingProgramInfo = null;

    /**
     * AppDetails earlyAccessInfo.
     * @member {IEarlyAccessInfo|null|undefined} earlyAccessInfo
     * @memberof AppDetails
     * @instance
     */
    AppDetails.prototype.earlyAccessInfo = null;

    /**
     * AppDetails editorChoice.
     * @member {IEditorChoice|null|undefined} editorChoice
     * @memberof AppDetails
     * @instance
     */
    AppDetails.prototype.editorChoice = null;

    /**
     * AppDetails instantLink.
     * @member {string} instantLink
     * @memberof AppDetails
     * @instance
     */
    AppDetails.prototype.instantLink = "";

    /**
     * AppDetails developerAddress.
     * @member {string} developerAddress
     * @memberof AppDetails
     * @instance
     */
    AppDetails.prototype.developerAddress = "";

    /**
     * AppDetails publisher.
     * @member {IPublisher|null|undefined} publisher
     * @memberof AppDetails
     * @instance
     */
    AppDetails.prototype.publisher = null;

    /**
     * AppDetails categoryName.
     * @member {string} categoryName
     * @memberof AppDetails
     * @instance
     */
    AppDetails.prototype.categoryName = "";

    /**
     * AppDetails downloadCount.
     * @member {number|Long} downloadCount
     * @memberof AppDetails
     * @instance
     */
    AppDetails.prototype.downloadCount = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

    /**
     * AppDetails downloadLabelDisplay.
     * @member {string} downloadLabelDisplay
     * @memberof AppDetails
     * @instance
     */
    AppDetails.prototype.downloadLabelDisplay = "";

    /**
     * AppDetails inAppProduct.
     * @member {string} inAppProduct
     * @memberof AppDetails
     * @instance
     */
    AppDetails.prototype.inAppProduct = "";

    /**
     * AppDetails downloadLabelAbbreviated.
     * @member {string} downloadLabelAbbreviated
     * @memberof AppDetails
     * @instance
     */
    AppDetails.prototype.downloadLabelAbbreviated = "";

    /**
     * AppDetails downloadLabel.
     * @member {string} downloadLabel
     * @memberof AppDetails
     * @instance
     */
    AppDetails.prototype.downloadLabel = "";

    /**
     * Creates a new AppDetails instance using the specified properties.
     * @function create
     * @memberof AppDetails
     * @static
     * @param {IAppDetails=} [properties] Properties to set
     * @returns {AppDetails} AppDetails instance
     */
    AppDetails.create = function create(properties) {
        return new AppDetails(properties);
    };

    /**
     * Encodes the specified AppDetails message. Does not implicitly {@link AppDetails.verify|verify} messages.
     * @function encode
     * @memberof AppDetails
     * @static
     * @param {IAppDetails} message AppDetails message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    AppDetails.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.developerName != null && Object.hasOwnProperty.call(message, "developerName"))
            writer.uint32(/* id 1, wireType 2 =*/10).string(message.developerName);
        if (message.majorVersionNumber != null && Object.hasOwnProperty.call(message, "majorVersionNumber"))
            writer.uint32(/* id 2, wireType 0 =*/16).int32(message.majorVersionNumber);
        if (message.versionCode != null && Object.hasOwnProperty.call(message, "versionCode"))
            writer.uint32(/* id 3, wireType 0 =*/24).int32(message.versionCode);
        if (message.versionString != null && Object.hasOwnProperty.call(message, "versionString"))
            writer.uint32(/* id 4, wireType 2 =*/34).string(message.versionString);
        if (message.title != null && Object.hasOwnProperty.call(message, "title"))
            writer.uint32(/* id 5, wireType 2 =*/42).string(message.title);
        if (message.appCategory != null && message.appCategory.length)
            for (var i = 0; i < message.appCategory.length; ++i)
                writer.uint32(/* id 7, wireType 2 =*/58).string(message.appCategory[i]);
        if (message.contentRating != null && Object.hasOwnProperty.call(message, "contentRating"))
            writer.uint32(/* id 8, wireType 0 =*/64).int32(message.contentRating);
        if (message.infoDownloadSize != null && Object.hasOwnProperty.call(message, "infoDownloadSize"))
            writer.uint32(/* id 9, wireType 0 =*/72).int64(message.infoDownloadSize);
        if (message.permission != null && message.permission.length)
            for (var i = 0; i < message.permission.length; ++i)
                writer.uint32(/* id 10, wireType 2 =*/82).string(message.permission[i]);
        if (message.developerEmail != null && Object.hasOwnProperty.call(message, "developerEmail"))
            writer.uint32(/* id 11, wireType 2 =*/90).string(message.developerEmail);
        if (message.developerWebsite != null && Object.hasOwnProperty.call(message, "developerWebsite"))
            writer.uint32(/* id 12, wireType 2 =*/98).string(message.developerWebsite);
        if (message.infoDownload != null && Object.hasOwnProperty.call(message, "infoDownload"))
            writer.uint32(/* id 13, wireType 2 =*/106).string(message.infoDownload);
        if (message.packageName != null && Object.hasOwnProperty.call(message, "packageName"))
            writer.uint32(/* id 14, wireType 2 =*/114).string(message.packageName);
        if (message.recentChangesHtml != null && Object.hasOwnProperty.call(message, "recentChangesHtml"))
            writer.uint32(/* id 15, wireType 2 =*/122).string(message.recentChangesHtml);
        if (message.infoUpdatedOn != null && Object.hasOwnProperty.call(message, "infoUpdatedOn"))
            writer.uint32(/* id 16, wireType 2 =*/130).string(message.infoUpdatedOn);
        if (message.file != null && message.file.length)
            for (var i = 0; i < message.file.length; ++i)
                $root.FileMetadata.encode(message.file[i], writer.uint32(/* id 17, wireType 2 =*/138).fork()).ldelim();
        if (message.appType != null && Object.hasOwnProperty.call(message, "appType"))
            writer.uint32(/* id 18, wireType 2 =*/146).string(message.appType);
        if (message.certificateHash != null && message.certificateHash.length)
            for (var i = 0; i < message.certificateHash.length; ++i)
                writer.uint32(/* id 19, wireType 2 =*/154).string(message.certificateHash[i]);
        if (message.variesWithDevice != null && Object.hasOwnProperty.call(message, "variesWithDevice"))
            writer.uint32(/* id 21, wireType 0 =*/168).bool(message.variesWithDevice);
        if (message.certificateSet != null && message.certificateSet.length)
            for (var i = 0; i < message.certificateSet.length; ++i)
                $root.CertificateSet.encode(message.certificateSet[i], writer.uint32(/* id 22, wireType 2 =*/178).fork()).ldelim();
        if (message.autoAcquireFreeAppIfHigherVersionAvailableTag != null && message.autoAcquireFreeAppIfHigherVersionAvailableTag.length)
            for (var i = 0; i < message.autoAcquireFreeAppIfHigherVersionAvailableTag.length; ++i)
                writer.uint32(/* id 23, wireType 2 =*/186).string(message.autoAcquireFreeAppIfHigherVersionAvailableTag[i]);
        if (message.hasInstantLink2 != null && Object.hasOwnProperty.call(message, "hasInstantLink2"))
            writer.uint32(/* id 24, wireType 0 =*/192).bool(message.hasInstantLink2);
        if (message.splitId != null && message.splitId.length)
            for (var i = 0; i < message.splitId.length; ++i)
                writer.uint32(/* id 25, wireType 2 =*/202).string(message.splitId[i]);
        if (message.gamepadRequired != null && Object.hasOwnProperty.call(message, "gamepadRequired"))
            writer.uint32(/* id 26, wireType 0 =*/208).bool(message.gamepadRequired);
        if (message.externallyHosted != null && Object.hasOwnProperty.call(message, "externallyHosted"))
            writer.uint32(/* id 27, wireType 0 =*/216).bool(message.externallyHosted);
        if (message.everExternallyHosted != null && Object.hasOwnProperty.call(message, "everExternallyHosted"))
            writer.uint32(/* id 28, wireType 0 =*/224).bool(message.everExternallyHosted);
        if (message.installNotes != null && Object.hasOwnProperty.call(message, "installNotes"))
            writer.uint32(/* id 30, wireType 2 =*/242).string(message.installNotes);
        if (message.installLocation != null && Object.hasOwnProperty.call(message, "installLocation"))
            writer.uint32(/* id 31, wireType 0 =*/248).int32(message.installLocation);
        if (message.targetSdkVersion != null && Object.hasOwnProperty.call(message, "targetSdkVersion"))
            writer.uint32(/* id 32, wireType 0 =*/256).int32(message.targetSdkVersion);
        if (message.hasPreregistrationPromoCode != null && Object.hasOwnProperty.call(message, "hasPreregistrationPromoCode"))
            writer.uint32(/* id 33, wireType 2 =*/266).string(message.hasPreregistrationPromoCode);
        if (message.dependencies != null && Object.hasOwnProperty.call(message, "dependencies"))
            $root.Dependencies.encode(message.dependencies, writer.uint32(/* id 34, wireType 2 =*/274).fork()).ldelim();
        if (message.testingProgramInfo != null && Object.hasOwnProperty.call(message, "testingProgramInfo"))
            $root.TestingProgramInfo.encode(message.testingProgramInfo, writer.uint32(/* id 35, wireType 2 =*/282).fork()).ldelim();
        if (message.earlyAccessInfo != null && Object.hasOwnProperty.call(message, "earlyAccessInfo"))
            $root.EarlyAccessInfo.encode(message.earlyAccessInfo, writer.uint32(/* id 36, wireType 2 =*/290).fork()).ldelim();
        if (message.editorChoice != null && Object.hasOwnProperty.call(message, "editorChoice"))
            $root.EditorChoice.encode(message.editorChoice, writer.uint32(/* id 41, wireType 2 =*/330).fork()).ldelim();
        if (message.instantLink != null && Object.hasOwnProperty.call(message, "instantLink"))
            writer.uint32(/* id 43, wireType 2 =*/346).string(message.instantLink);
        if (message.developerAddress != null && Object.hasOwnProperty.call(message, "developerAddress"))
            writer.uint32(/* id 45, wireType 2 =*/362).string(message.developerAddress);
        if (message.publisher != null && Object.hasOwnProperty.call(message, "publisher"))
            $root.Publisher.encode(message.publisher, writer.uint32(/* id 46, wireType 2 =*/370).fork()).ldelim();
        if (message.categoryName != null && Object.hasOwnProperty.call(message, "categoryName"))
            writer.uint32(/* id 48, wireType 2 =*/386).string(message.categoryName);
        if (message.downloadCount != null && Object.hasOwnProperty.call(message, "downloadCount"))
            writer.uint32(/* id 53, wireType 0 =*/424).int64(message.downloadCount);
        if (message.downloadLabelDisplay != null && Object.hasOwnProperty.call(message, "downloadLabelDisplay"))
            writer.uint32(/* id 61, wireType 2 =*/490).string(message.downloadLabelDisplay);
        if (message.inAppProduct != null && Object.hasOwnProperty.call(message, "inAppProduct"))
            writer.uint32(/* id 67, wireType 2 =*/538).string(message.inAppProduct);
        if (message.downloadLabelAbbreviated != null && Object.hasOwnProperty.call(message, "downloadLabelAbbreviated"))
            writer.uint32(/* id 77, wireType 2 =*/618).string(message.downloadLabelAbbreviated);
        if (message.downloadLabel != null && Object.hasOwnProperty.call(message, "downloadLabel"))
            writer.uint32(/* id 78, wireType 2 =*/626).string(message.downloadLabel);
        return writer;
    };

    /**
     * Encodes the specified AppDetails message, length delimited. Does not implicitly {@link AppDetails.verify|verify} messages.
     * @function encodeDelimited
     * @memberof AppDetails
     * @static
     * @param {IAppDetails} message AppDetails message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    AppDetails.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes an AppDetails message from the specified reader or buffer.
     * @function decode
     * @memberof AppDetails
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {AppDetails} AppDetails
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    AppDetails.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.AppDetails();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.developerName = reader.string();
                break;
            case 2:
                message.majorVersionNumber = reader.int32();
                break;
            case 3:
                message.versionCode = reader.int32();
                break;
            case 4:
                message.versionString = reader.string();
                break;
            case 5:
                message.title = reader.string();
                break;
            case 7:
                if (!(message.appCategory && message.appCategory.length))
                    message.appCategory = [];
                message.appCategory.push(reader.string());
                break;
            case 8:
                message.contentRating = reader.int32();
                break;
            case 9:
                message.infoDownloadSize = reader.int64();
                break;
            case 10:
                if (!(message.permission && message.permission.length))
                    message.permission = [];
                message.permission.push(reader.string());
                break;
            case 11:
                message.developerEmail = reader.string();
                break;
            case 12:
                message.developerWebsite = reader.string();
                break;
            case 13:
                message.infoDownload = reader.string();
                break;
            case 14:
                message.packageName = reader.string();
                break;
            case 15:
                message.recentChangesHtml = reader.string();
                break;
            case 16:
                message.infoUpdatedOn = reader.string();
                break;
            case 17:
                if (!(message.file && message.file.length))
                    message.file = [];
                message.file.push($root.FileMetadata.decode(reader, reader.uint32()));
                break;
            case 18:
                message.appType = reader.string();
                break;
            case 19:
                if (!(message.certificateHash && message.certificateHash.length))
                    message.certificateHash = [];
                message.certificateHash.push(reader.string());
                break;
            case 21:
                message.variesWithDevice = reader.bool();
                break;
            case 22:
                if (!(message.certificateSet && message.certificateSet.length))
                    message.certificateSet = [];
                message.certificateSet.push($root.CertificateSet.decode(reader, reader.uint32()));
                break;
            case 23:
                if (!(message.autoAcquireFreeAppIfHigherVersionAvailableTag && message.autoAcquireFreeAppIfHigherVersionAvailableTag.length))
                    message.autoAcquireFreeAppIfHigherVersionAvailableTag = [];
                message.autoAcquireFreeAppIfHigherVersionAvailableTag.push(reader.string());
                break;
            case 24:
                message.hasInstantLink2 = reader.bool();
                break;
            case 25:
                if (!(message.splitId && message.splitId.length))
                    message.splitId = [];
                message.splitId.push(reader.string());
                break;
            case 26:
                message.gamepadRequired = reader.bool();
                break;
            case 27:
                message.externallyHosted = reader.bool();
                break;
            case 28:
                message.everExternallyHosted = reader.bool();
                break;
            case 30:
                message.installNotes = reader.string();
                break;
            case 31:
                message.installLocation = reader.int32();
                break;
            case 32:
                message.targetSdkVersion = reader.int32();
                break;
            case 33:
                message.hasPreregistrationPromoCode = reader.string();
                break;
            case 34:
                message.dependencies = $root.Dependencies.decode(reader, reader.uint32());
                break;
            case 35:
                message.testingProgramInfo = $root.TestingProgramInfo.decode(reader, reader.uint32());
                break;
            case 36:
                message.earlyAccessInfo = $root.EarlyAccessInfo.decode(reader, reader.uint32());
                break;
            case 41:
                message.editorChoice = $root.EditorChoice.decode(reader, reader.uint32());
                break;
            case 43:
                message.instantLink = reader.string();
                break;
            case 45:
                message.developerAddress = reader.string();
                break;
            case 46:
                message.publisher = $root.Publisher.decode(reader, reader.uint32());
                break;
            case 48:
                message.categoryName = reader.string();
                break;
            case 53:
                message.downloadCount = reader.int64();
                break;
            case 61:
                message.downloadLabelDisplay = reader.string();
                break;
            case 67:
                message.inAppProduct = reader.string();
                break;
            case 77:
                message.downloadLabelAbbreviated = reader.string();
                break;
            case 78:
                message.downloadLabel = reader.string();
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes an AppDetails message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof AppDetails
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {AppDetails} AppDetails
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    AppDetails.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies an AppDetails message.
     * @function verify
     * @memberof AppDetails
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    AppDetails.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.developerName != null && message.hasOwnProperty("developerName"))
            if (!$util.isString(message.developerName))
                return "developerName: string expected";
        if (message.majorVersionNumber != null && message.hasOwnProperty("majorVersionNumber"))
            if (!$util.isInteger(message.majorVersionNumber))
                return "majorVersionNumber: integer expected";
        if (message.versionCode != null && message.hasOwnProperty("versionCode"))
            if (!$util.isInteger(message.versionCode))
                return "versionCode: integer expected";
        if (message.versionString != null && message.hasOwnProperty("versionString"))
            if (!$util.isString(message.versionString))
                return "versionString: string expected";
        if (message.title != null && message.hasOwnProperty("title"))
            if (!$util.isString(message.title))
                return "title: string expected";
        if (message.appCategory != null && message.hasOwnProperty("appCategory")) {
            if (!Array.isArray(message.appCategory))
                return "appCategory: array expected";
            for (var i = 0; i < message.appCategory.length; ++i)
                if (!$util.isString(message.appCategory[i]))
                    return "appCategory: string[] expected";
        }
        if (message.contentRating != null && message.hasOwnProperty("contentRating"))
            if (!$util.isInteger(message.contentRating))
                return "contentRating: integer expected";
        if (message.infoDownloadSize != null && message.hasOwnProperty("infoDownloadSize"))
            if (!$util.isInteger(message.infoDownloadSize) && !(message.infoDownloadSize && $util.isInteger(message.infoDownloadSize.low) && $util.isInteger(message.infoDownloadSize.high)))
                return "infoDownloadSize: integer|Long expected";
        if (message.permission != null && message.hasOwnProperty("permission")) {
            if (!Array.isArray(message.permission))
                return "permission: array expected";
            for (var i = 0; i < message.permission.length; ++i)
                if (!$util.isString(message.permission[i]))
                    return "permission: string[] expected";
        }
        if (message.developerEmail != null && message.hasOwnProperty("developerEmail"))
            if (!$util.isString(message.developerEmail))
                return "developerEmail: string expected";
        if (message.developerWebsite != null && message.hasOwnProperty("developerWebsite"))
            if (!$util.isString(message.developerWebsite))
                return "developerWebsite: string expected";
        if (message.infoDownload != null && message.hasOwnProperty("infoDownload"))
            if (!$util.isString(message.infoDownload))
                return "infoDownload: string expected";
        if (message.packageName != null && message.hasOwnProperty("packageName"))
            if (!$util.isString(message.packageName))
                return "packageName: string expected";
        if (message.recentChangesHtml != null && message.hasOwnProperty("recentChangesHtml"))
            if (!$util.isString(message.recentChangesHtml))
                return "recentChangesHtml: string expected";
        if (message.infoUpdatedOn != null && message.hasOwnProperty("infoUpdatedOn"))
            if (!$util.isString(message.infoUpdatedOn))
                return "infoUpdatedOn: string expected";
        if (message.file != null && message.hasOwnProperty("file")) {
            if (!Array.isArray(message.file))
                return "file: array expected";
            for (var i = 0; i < message.file.length; ++i) {
                var error = $root.FileMetadata.verify(message.file[i]);
                if (error)
                    return "file." + error;
            }
        }
        if (message.appType != null && message.hasOwnProperty("appType"))
            if (!$util.isString(message.appType))
                return "appType: string expected";
        if (message.certificateHash != null && message.hasOwnProperty("certificateHash")) {
            if (!Array.isArray(message.certificateHash))
                return "certificateHash: array expected";
            for (var i = 0; i < message.certificateHash.length; ++i)
                if (!$util.isString(message.certificateHash[i]))
                    return "certificateHash: string[] expected";
        }
        if (message.variesWithDevice != null && message.hasOwnProperty("variesWithDevice"))
            if (typeof message.variesWithDevice !== "boolean")
                return "variesWithDevice: boolean expected";
        if (message.certificateSet != null && message.hasOwnProperty("certificateSet")) {
            if (!Array.isArray(message.certificateSet))
                return "certificateSet: array expected";
            for (var i = 0; i < message.certificateSet.length; ++i) {
                var error = $root.CertificateSet.verify(message.certificateSet[i]);
                if (error)
                    return "certificateSet." + error;
            }
        }
        if (message.autoAcquireFreeAppIfHigherVersionAvailableTag != null && message.hasOwnProperty("autoAcquireFreeAppIfHigherVersionAvailableTag")) {
            if (!Array.isArray(message.autoAcquireFreeAppIfHigherVersionAvailableTag))
                return "autoAcquireFreeAppIfHigherVersionAvailableTag: array expected";
            for (var i = 0; i < message.autoAcquireFreeAppIfHigherVersionAvailableTag.length; ++i)
                if (!$util.isString(message.autoAcquireFreeAppIfHigherVersionAvailableTag[i]))
                    return "autoAcquireFreeAppIfHigherVersionAvailableTag: string[] expected";
        }
        if (message.hasInstantLink2 != null && message.hasOwnProperty("hasInstantLink2"))
            if (typeof message.hasInstantLink2 !== "boolean")
                return "hasInstantLink2: boolean expected";
        if (message.splitId != null && message.hasOwnProperty("splitId")) {
            if (!Array.isArray(message.splitId))
                return "splitId: array expected";
            for (var i = 0; i < message.splitId.length; ++i)
                if (!$util.isString(message.splitId[i]))
                    return "splitId: string[] expected";
        }
        if (message.gamepadRequired != null && message.hasOwnProperty("gamepadRequired"))
            if (typeof message.gamepadRequired !== "boolean")
                return "gamepadRequired: boolean expected";
        if (message.externallyHosted != null && message.hasOwnProperty("externallyHosted"))
            if (typeof message.externallyHosted !== "boolean")
                return "externallyHosted: boolean expected";
        if (message.everExternallyHosted != null && message.hasOwnProperty("everExternallyHosted"))
            if (typeof message.everExternallyHosted !== "boolean")
                return "everExternallyHosted: boolean expected";
        if (message.installNotes != null && message.hasOwnProperty("installNotes"))
            if (!$util.isString(message.installNotes))
                return "installNotes: string expected";
        if (message.installLocation != null && message.hasOwnProperty("installLocation"))
            if (!$util.isInteger(message.installLocation))
                return "installLocation: integer expected";
        if (message.targetSdkVersion != null && message.hasOwnProperty("targetSdkVersion"))
            if (!$util.isInteger(message.targetSdkVersion))
                return "targetSdkVersion: integer expected";
        if (message.hasPreregistrationPromoCode != null && message.hasOwnProperty("hasPreregistrationPromoCode"))
            if (!$util.isString(message.hasPreregistrationPromoCode))
                return "hasPreregistrationPromoCode: string expected";
        if (message.dependencies != null && message.hasOwnProperty("dependencies")) {
            var error = $root.Dependencies.verify(message.dependencies);
            if (error)
                return "dependencies." + error;
        }
        if (message.testingProgramInfo != null && message.hasOwnProperty("testingProgramInfo")) {
            var error = $root.TestingProgramInfo.verify(message.testingProgramInfo);
            if (error)
                return "testingProgramInfo." + error;
        }
        if (message.earlyAccessInfo != null && message.hasOwnProperty("earlyAccessInfo")) {
            var error = $root.EarlyAccessInfo.verify(message.earlyAccessInfo);
            if (error)
                return "earlyAccessInfo." + error;
        }
        if (message.editorChoice != null && message.hasOwnProperty("editorChoice")) {
            var error = $root.EditorChoice.verify(message.editorChoice);
            if (error)
                return "editorChoice." + error;
        }
        if (message.instantLink != null && message.hasOwnProperty("instantLink"))
            if (!$util.isString(message.instantLink))
                return "instantLink: string expected";
        if (message.developerAddress != null && message.hasOwnProperty("developerAddress"))
            if (!$util.isString(message.developerAddress))
                return "developerAddress: string expected";
        if (message.publisher != null && message.hasOwnProperty("publisher")) {
            var error = $root.Publisher.verify(message.publisher);
            if (error)
                return "publisher." + error;
        }
        if (message.categoryName != null && message.hasOwnProperty("categoryName"))
            if (!$util.isString(message.categoryName))
                return "categoryName: string expected";
        if (message.downloadCount != null && message.hasOwnProperty("downloadCount"))
            if (!$util.isInteger(message.downloadCount) && !(message.downloadCount && $util.isInteger(message.downloadCount.low) && $util.isInteger(message.downloadCount.high)))
                return "downloadCount: integer|Long expected";
        if (message.downloadLabelDisplay != null && message.hasOwnProperty("downloadLabelDisplay"))
            if (!$util.isString(message.downloadLabelDisplay))
                return "downloadLabelDisplay: string expected";
        if (message.inAppProduct != null && message.hasOwnProperty("inAppProduct"))
            if (!$util.isString(message.inAppProduct))
                return "inAppProduct: string expected";
        if (message.downloadLabelAbbreviated != null && message.hasOwnProperty("downloadLabelAbbreviated"))
            if (!$util.isString(message.downloadLabelAbbreviated))
                return "downloadLabelAbbreviated: string expected";
        if (message.downloadLabel != null && message.hasOwnProperty("downloadLabel"))
            if (!$util.isString(message.downloadLabel))
                return "downloadLabel: string expected";
        return null;
    };

    /**
     * Creates an AppDetails message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof AppDetails
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {AppDetails} AppDetails
     */
    AppDetails.fromObject = function fromObject(object) {
        if (object instanceof $root.AppDetails)
            return object;
        var message = new $root.AppDetails();
        if (object.developerName != null)
            message.developerName = String(object.developerName);
        if (object.majorVersionNumber != null)
            message.majorVersionNumber = object.majorVersionNumber | 0;
        if (object.versionCode != null)
            message.versionCode = object.versionCode | 0;
        if (object.versionString != null)
            message.versionString = String(object.versionString);
        if (object.title != null)
            message.title = String(object.title);
        if (object.appCategory) {
            if (!Array.isArray(object.appCategory))
                throw TypeError(".AppDetails.appCategory: array expected");
            message.appCategory = [];
            for (var i = 0; i < object.appCategory.length; ++i)
                message.appCategory[i] = String(object.appCategory[i]);
        }
        if (object.contentRating != null)
            message.contentRating = object.contentRating | 0;
        if (object.infoDownloadSize != null)
            if ($util.Long)
                (message.infoDownloadSize = $util.Long.fromValue(object.infoDownloadSize)).unsigned = false;
            else if (typeof object.infoDownloadSize === "string")
                message.infoDownloadSize = parseInt(object.infoDownloadSize, 10);
            else if (typeof object.infoDownloadSize === "number")
                message.infoDownloadSize = object.infoDownloadSize;
            else if (typeof object.infoDownloadSize === "object")
                message.infoDownloadSize = new $util.LongBits(object.infoDownloadSize.low >>> 0, object.infoDownloadSize.high >>> 0).toNumber();
        if (object.permission) {
            if (!Array.isArray(object.permission))
                throw TypeError(".AppDetails.permission: array expected");
            message.permission = [];
            for (var i = 0; i < object.permission.length; ++i)
                message.permission[i] = String(object.permission[i]);
        }
        if (object.developerEmail != null)
            message.developerEmail = String(object.developerEmail);
        if (object.developerWebsite != null)
            message.developerWebsite = String(object.developerWebsite);
        if (object.infoDownload != null)
            message.infoDownload = String(object.infoDownload);
        if (object.packageName != null)
            message.packageName = String(object.packageName);
        if (object.recentChangesHtml != null)
            message.recentChangesHtml = String(object.recentChangesHtml);
        if (object.infoUpdatedOn != null)
            message.infoUpdatedOn = String(object.infoUpdatedOn);
        if (object.file) {
            if (!Array.isArray(object.file))
                throw TypeError(".AppDetails.file: array expected");
            message.file = [];
            for (var i = 0; i < object.file.length; ++i) {
                if (typeof object.file[i] !== "object")
                    throw TypeError(".AppDetails.file: object expected");
                message.file[i] = $root.FileMetadata.fromObject(object.file[i]);
            }
        }
        if (object.appType != null)
            message.appType = String(object.appType);
        if (object.certificateHash) {
            if (!Array.isArray(object.certificateHash))
                throw TypeError(".AppDetails.certificateHash: array expected");
            message.certificateHash = [];
            for (var i = 0; i < object.certificateHash.length; ++i)
                message.certificateHash[i] = String(object.certificateHash[i]);
        }
        if (object.variesWithDevice != null)
            message.variesWithDevice = Boolean(object.variesWithDevice);
        if (object.certificateSet) {
            if (!Array.isArray(object.certificateSet))
                throw TypeError(".AppDetails.certificateSet: array expected");
            message.certificateSet = [];
            for (var i = 0; i < object.certificateSet.length; ++i) {
                if (typeof object.certificateSet[i] !== "object")
                    throw TypeError(".AppDetails.certificateSet: object expected");
                message.certificateSet[i] = $root.CertificateSet.fromObject(object.certificateSet[i]);
            }
        }
        if (object.autoAcquireFreeAppIfHigherVersionAvailableTag) {
            if (!Array.isArray(object.autoAcquireFreeAppIfHigherVersionAvailableTag))
                throw TypeError(".AppDetails.autoAcquireFreeAppIfHigherVersionAvailableTag: array expected");
            message.autoAcquireFreeAppIfHigherVersionAvailableTag = [];
            for (var i = 0; i < object.autoAcquireFreeAppIfHigherVersionAvailableTag.length; ++i)
                message.autoAcquireFreeAppIfHigherVersionAvailableTag[i] = String(object.autoAcquireFreeAppIfHigherVersionAvailableTag[i]);
        }
        if (object.hasInstantLink2 != null)
            message.hasInstantLink2 = Boolean(object.hasInstantLink2);
        if (object.splitId) {
            if (!Array.isArray(object.splitId))
                throw TypeError(".AppDetails.splitId: array expected");
            message.splitId = [];
            for (var i = 0; i < object.splitId.length; ++i)
                message.splitId[i] = String(object.splitId[i]);
        }
        if (object.gamepadRequired != null)
            message.gamepadRequired = Boolean(object.gamepadRequired);
        if (object.externallyHosted != null)
            message.externallyHosted = Boolean(object.externallyHosted);
        if (object.everExternallyHosted != null)
            message.everExternallyHosted = Boolean(object.everExternallyHosted);
        if (object.installNotes != null)
            message.installNotes = String(object.installNotes);
        if (object.installLocation != null)
            message.installLocation = object.installLocation | 0;
        if (object.targetSdkVersion != null)
            message.targetSdkVersion = object.targetSdkVersion | 0;
        if (object.hasPreregistrationPromoCode != null)
            message.hasPreregistrationPromoCode = String(object.hasPreregistrationPromoCode);
        if (object.dependencies != null) {
            if (typeof object.dependencies !== "object")
                throw TypeError(".AppDetails.dependencies: object expected");
            message.dependencies = $root.Dependencies.fromObject(object.dependencies);
        }
        if (object.testingProgramInfo != null) {
            if (typeof object.testingProgramInfo !== "object")
                throw TypeError(".AppDetails.testingProgramInfo: object expected");
            message.testingProgramInfo = $root.TestingProgramInfo.fromObject(object.testingProgramInfo);
        }
        if (object.earlyAccessInfo != null) {
            if (typeof object.earlyAccessInfo !== "object")
                throw TypeError(".AppDetails.earlyAccessInfo: object expected");
            message.earlyAccessInfo = $root.EarlyAccessInfo.fromObject(object.earlyAccessInfo);
        }
        if (object.editorChoice != null) {
            if (typeof object.editorChoice !== "object")
                throw TypeError(".AppDetails.editorChoice: object expected");
            message.editorChoice = $root.EditorChoice.fromObject(object.editorChoice);
        }
        if (object.instantLink != null)
            message.instantLink = String(object.instantLink);
        if (object.developerAddress != null)
            message.developerAddress = String(object.developerAddress);
        if (object.publisher != null) {
            if (typeof object.publisher !== "object")
                throw TypeError(".AppDetails.publisher: object expected");
            message.publisher = $root.Publisher.fromObject(object.publisher);
        }
        if (object.categoryName != null)
            message.categoryName = String(object.categoryName);
        if (object.downloadCount != null)
            if ($util.Long)
                (message.downloadCount = $util.Long.fromValue(object.downloadCount)).unsigned = false;
            else if (typeof object.downloadCount === "string")
                message.downloadCount = parseInt(object.downloadCount, 10);
            else if (typeof object.downloadCount === "number")
                message.downloadCount = object.downloadCount;
            else if (typeof object.downloadCount === "object")
                message.downloadCount = new $util.LongBits(object.downloadCount.low >>> 0, object.downloadCount.high >>> 0).toNumber();
        if (object.downloadLabelDisplay != null)
            message.downloadLabelDisplay = String(object.downloadLabelDisplay);
        if (object.inAppProduct != null)
            message.inAppProduct = String(object.inAppProduct);
        if (object.downloadLabelAbbreviated != null)
            message.downloadLabelAbbreviated = String(object.downloadLabelAbbreviated);
        if (object.downloadLabel != null)
            message.downloadLabel = String(object.downloadLabel);
        return message;
    };

    /**
     * Creates a plain object from an AppDetails message. Also converts values to other types if specified.
     * @function toObject
     * @memberof AppDetails
     * @static
     * @param {AppDetails} message AppDetails
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    AppDetails.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        var object = {};
        if (options.arrays || options.defaults) {
            object.appCategory = [];
            object.permission = [];
            object.file = [];
            object.certificateHash = [];
            object.certificateSet = [];
            object.autoAcquireFreeAppIfHigherVersionAvailableTag = [];
            object.splitId = [];
        }
        if (options.defaults) {
            object.developerName = "";
            object.majorVersionNumber = 0;
            object.versionCode = 0;
            object.versionString = "";
            object.title = "";
            object.contentRating = 0;
            if ($util.Long) {
                var long = new $util.Long(0, 0, false);
                object.infoDownloadSize = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
            } else
                object.infoDownloadSize = options.longs === String ? "0" : 0;
            object.developerEmail = "";
            object.developerWebsite = "";
            object.infoDownload = "";
            object.packageName = "";
            object.recentChangesHtml = "";
            object.infoUpdatedOn = "";
            object.appType = "";
            object.variesWithDevice = true;
            object.hasInstantLink2 = false;
            object.gamepadRequired = false;
            object.externallyHosted = false;
            object.everExternallyHosted = false;
            object.installNotes = "";
            object.installLocation = 0;
            object.targetSdkVersion = 0;
            object.hasPreregistrationPromoCode = "";
            object.dependencies = null;
            object.testingProgramInfo = null;
            object.earlyAccessInfo = null;
            object.editorChoice = null;
            object.instantLink = "";
            object.developerAddress = "";
            object.publisher = null;
            object.categoryName = "";
            if ($util.Long) {
                var long = new $util.Long(0, 0, false);
                object.downloadCount = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
            } else
                object.downloadCount = options.longs === String ? "0" : 0;
            object.downloadLabelDisplay = "";
            object.inAppProduct = "";
            object.downloadLabelAbbreviated = "";
            object.downloadLabel = "";
        }
        if (message.developerName != null && message.hasOwnProperty("developerName"))
            object.developerName = message.developerName;
        if (message.majorVersionNumber != null && message.hasOwnProperty("majorVersionNumber"))
            object.majorVersionNumber = message.majorVersionNumber;
        if (message.versionCode != null && message.hasOwnProperty("versionCode"))
            object.versionCode = message.versionCode;
        if (message.versionString != null && message.hasOwnProperty("versionString"))
            object.versionString = message.versionString;
        if (message.title != null && message.hasOwnProperty("title"))
            object.title = message.title;
        if (message.appCategory && message.appCategory.length) {
            object.appCategory = [];
            for (var j = 0; j < message.appCategory.length; ++j)
                object.appCategory[j] = message.appCategory[j];
        }
        if (message.contentRating != null && message.hasOwnProperty("contentRating"))
            object.contentRating = message.contentRating;
        if (message.infoDownloadSize != null && message.hasOwnProperty("infoDownloadSize"))
            if (typeof message.infoDownloadSize === "number")
                object.infoDownloadSize = options.longs === String ? String(message.infoDownloadSize) : message.infoDownloadSize;
            else
                object.infoDownloadSize = options.longs === String ? $util.Long.prototype.toString.call(message.infoDownloadSize) : options.longs === Number ? new $util.LongBits(message.infoDownloadSize.low >>> 0, message.infoDownloadSize.high >>> 0).toNumber() : message.infoDownloadSize;
        if (message.permission && message.permission.length) {
            object.permission = [];
            for (var j = 0; j < message.permission.length; ++j)
                object.permission[j] = message.permission[j];
        }
        if (message.developerEmail != null && message.hasOwnProperty("developerEmail"))
            object.developerEmail = message.developerEmail;
        if (message.developerWebsite != null && message.hasOwnProperty("developerWebsite"))
            object.developerWebsite = message.developerWebsite;
        if (message.infoDownload != null && message.hasOwnProperty("infoDownload"))
            object.infoDownload = message.infoDownload;
        if (message.packageName != null && message.hasOwnProperty("packageName"))
            object.packageName = message.packageName;
        if (message.recentChangesHtml != null && message.hasOwnProperty("recentChangesHtml"))
            object.recentChangesHtml = message.recentChangesHtml;
        if (message.infoUpdatedOn != null && message.hasOwnProperty("infoUpdatedOn"))
            object.infoUpdatedOn = message.infoUpdatedOn;
        if (message.file && message.file.length) {
            object.file = [];
            for (var j = 0; j < message.file.length; ++j)
                object.file[j] = $root.FileMetadata.toObject(message.file[j], options);
        }
        if (message.appType != null && message.hasOwnProperty("appType"))
            object.appType = message.appType;
        if (message.certificateHash && message.certificateHash.length) {
            object.certificateHash = [];
            for (var j = 0; j < message.certificateHash.length; ++j)
                object.certificateHash[j] = message.certificateHash[j];
        }
        if (message.variesWithDevice != null && message.hasOwnProperty("variesWithDevice"))
            object.variesWithDevice = message.variesWithDevice;
        if (message.certificateSet && message.certificateSet.length) {
            object.certificateSet = [];
            for (var j = 0; j < message.certificateSet.length; ++j)
                object.certificateSet[j] = $root.CertificateSet.toObject(message.certificateSet[j], options);
        }
        if (message.autoAcquireFreeAppIfHigherVersionAvailableTag && message.autoAcquireFreeAppIfHigherVersionAvailableTag.length) {
            object.autoAcquireFreeAppIfHigherVersionAvailableTag = [];
            for (var j = 0; j < message.autoAcquireFreeAppIfHigherVersionAvailableTag.length; ++j)
                object.autoAcquireFreeAppIfHigherVersionAvailableTag[j] = message.autoAcquireFreeAppIfHigherVersionAvailableTag[j];
        }
        if (message.hasInstantLink2 != null && message.hasOwnProperty("hasInstantLink2"))
            object.hasInstantLink2 = message.hasInstantLink2;
        if (message.splitId && message.splitId.length) {
            object.splitId = [];
            for (var j = 0; j < message.splitId.length; ++j)
                object.splitId[j] = message.splitId[j];
        }
        if (message.gamepadRequired != null && message.hasOwnProperty("gamepadRequired"))
            object.gamepadRequired = message.gamepadRequired;
        if (message.externallyHosted != null && message.hasOwnProperty("externallyHosted"))
            object.externallyHosted = message.externallyHosted;
        if (message.everExternallyHosted != null && message.hasOwnProperty("everExternallyHosted"))
            object.everExternallyHosted = message.everExternallyHosted;
        if (message.installNotes != null && message.hasOwnProperty("installNotes"))
            object.installNotes = message.installNotes;
        if (message.installLocation != null && message.hasOwnProperty("installLocation"))
            object.installLocation = message.installLocation;
        if (message.targetSdkVersion != null && message.hasOwnProperty("targetSdkVersion"))
            object.targetSdkVersion = message.targetSdkVersion;
        if (message.hasPreregistrationPromoCode != null && message.hasOwnProperty("hasPreregistrationPromoCode"))
            object.hasPreregistrationPromoCode = message.hasPreregistrationPromoCode;
        if (message.dependencies != null && message.hasOwnProperty("dependencies"))
            object.dependencies = $root.Dependencies.toObject(message.dependencies, options);
        if (message.testingProgramInfo != null && message.hasOwnProperty("testingProgramInfo"))
            object.testingProgramInfo = $root.TestingProgramInfo.toObject(message.testingProgramInfo, options);
        if (message.earlyAccessInfo != null && message.hasOwnProperty("earlyAccessInfo"))
            object.earlyAccessInfo = $root.EarlyAccessInfo.toObject(message.earlyAccessInfo, options);
        if (message.editorChoice != null && message.hasOwnProperty("editorChoice"))
            object.editorChoice = $root.EditorChoice.toObject(message.editorChoice, options);
        if (message.instantLink != null && message.hasOwnProperty("instantLink"))
            object.instantLink = message.instantLink;
        if (message.developerAddress != null && message.hasOwnProperty("developerAddress"))
            object.developerAddress = message.developerAddress;
        if (message.publisher != null && message.hasOwnProperty("publisher"))
            object.publisher = $root.Publisher.toObject(message.publisher, options);
        if (message.categoryName != null && message.hasOwnProperty("categoryName"))
            object.categoryName = message.categoryName;
        if (message.downloadCount != null && message.hasOwnProperty("downloadCount"))
            if (typeof message.downloadCount === "number")
                object.downloadCount = options.longs === String ? String(message.downloadCount) : message.downloadCount;
            else
                object.downloadCount = options.longs === String ? $util.Long.prototype.toString.call(message.downloadCount) : options.longs === Number ? new $util.LongBits(message.downloadCount.low >>> 0, message.downloadCount.high >>> 0).toNumber() : message.downloadCount;
        if (message.downloadLabelDisplay != null && message.hasOwnProperty("downloadLabelDisplay"))
            object.downloadLabelDisplay = message.downloadLabelDisplay;
        if (message.inAppProduct != null && message.hasOwnProperty("inAppProduct"))
            object.inAppProduct = message.inAppProduct;
        if (message.downloadLabelAbbreviated != null && message.hasOwnProperty("downloadLabelAbbreviated"))
            object.downloadLabelAbbreviated = message.downloadLabelAbbreviated;
        if (message.downloadLabel != null && message.hasOwnProperty("downloadLabel"))
            object.downloadLabel = message.downloadLabel;
        return object;
    };

    /**
     * Converts this AppDetails to JSON.
     * @function toJSON
     * @memberof AppDetails
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    AppDetails.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return AppDetails;
})();

$root.ModifyLibrary = (function() {

    /**
     * Properties of a ModifyLibrary.
     * @exports IModifyLibrary
     * @interface IModifyLibrary
     * @property {string|null} [id] ModifyLibrary id
     * @property {string|null} [packageToAdd] ModifyLibrary packageToAdd
     * @property {string|null} [packageToRemove] ModifyLibrary packageToRemove
     */

    /**
     * Constructs a new ModifyLibrary.
     * @exports ModifyLibrary
     * @classdesc Represents a ModifyLibrary.
     * @implements IModifyLibrary
     * @constructor
     * @param {IModifyLibrary=} [properties] Properties to set
     */
    function ModifyLibrary(properties) {
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * ModifyLibrary id.
     * @member {string} id
     * @memberof ModifyLibrary
     * @instance
     */
    ModifyLibrary.prototype.id = "";

    /**
     * ModifyLibrary packageToAdd.
     * @member {string} packageToAdd
     * @memberof ModifyLibrary
     * @instance
     */
    ModifyLibrary.prototype.packageToAdd = "";

    /**
     * ModifyLibrary packageToRemove.
     * @member {string} packageToRemove
     * @memberof ModifyLibrary
     * @instance
     */
    ModifyLibrary.prototype.packageToRemove = "";

    /**
     * Creates a new ModifyLibrary instance using the specified properties.
     * @function create
     * @memberof ModifyLibrary
     * @static
     * @param {IModifyLibrary=} [properties] Properties to set
     * @returns {ModifyLibrary} ModifyLibrary instance
     */
    ModifyLibrary.create = function create(properties) {
        return new ModifyLibrary(properties);
    };

    /**
     * Encodes the specified ModifyLibrary message. Does not implicitly {@link ModifyLibrary.verify|verify} messages.
     * @function encode
     * @memberof ModifyLibrary
     * @static
     * @param {IModifyLibrary} message ModifyLibrary message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    ModifyLibrary.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.id != null && Object.hasOwnProperty.call(message, "id"))
            writer.uint32(/* id 1, wireType 2 =*/10).string(message.id);
        if (message.packageToAdd != null && Object.hasOwnProperty.call(message, "packageToAdd"))
            writer.uint32(/* id 2, wireType 2 =*/18).string(message.packageToAdd);
        if (message.packageToRemove != null && Object.hasOwnProperty.call(message, "packageToRemove"))
            writer.uint32(/* id 3, wireType 2 =*/26).string(message.packageToRemove);
        return writer;
    };

    /**
     * Encodes the specified ModifyLibrary message, length delimited. Does not implicitly {@link ModifyLibrary.verify|verify} messages.
     * @function encodeDelimited
     * @memberof ModifyLibrary
     * @static
     * @param {IModifyLibrary} message ModifyLibrary message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    ModifyLibrary.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a ModifyLibrary message from the specified reader or buffer.
     * @function decode
     * @memberof ModifyLibrary
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {ModifyLibrary} ModifyLibrary
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    ModifyLibrary.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ModifyLibrary();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.id = reader.string();
                break;
            case 2:
                message.packageToAdd = reader.string();
                break;
            case 3:
                message.packageToRemove = reader.string();
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a ModifyLibrary message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof ModifyLibrary
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {ModifyLibrary} ModifyLibrary
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    ModifyLibrary.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a ModifyLibrary message.
     * @function verify
     * @memberof ModifyLibrary
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    ModifyLibrary.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.id != null && message.hasOwnProperty("id"))
            if (!$util.isString(message.id))
                return "id: string expected";
        if (message.packageToAdd != null && message.hasOwnProperty("packageToAdd"))
            if (!$util.isString(message.packageToAdd))
                return "packageToAdd: string expected";
        if (message.packageToRemove != null && message.hasOwnProperty("packageToRemove"))
            if (!$util.isString(message.packageToRemove))
                return "packageToRemove: string expected";
        return null;
    };

    /**
     * Creates a ModifyLibrary message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof ModifyLibrary
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {ModifyLibrary} ModifyLibrary
     */
    ModifyLibrary.fromObject = function fromObject(object) {
        if (object instanceof $root.ModifyLibrary)
            return object;
        var message = new $root.ModifyLibrary();
        if (object.id != null)
            message.id = String(object.id);
        if (object.packageToAdd != null)
            message.packageToAdd = String(object.packageToAdd);
        if (object.packageToRemove != null)
            message.packageToRemove = String(object.packageToRemove);
        return message;
    };

    /**
     * Creates a plain object from a ModifyLibrary message. Also converts values to other types if specified.
     * @function toObject
     * @memberof ModifyLibrary
     * @static
     * @param {ModifyLibrary} message ModifyLibrary
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    ModifyLibrary.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        var object = {};
        if (options.defaults) {
            object.id = "";
            object.packageToAdd = "";
            object.packageToRemove = "";
        }
        if (message.id != null && message.hasOwnProperty("id"))
            object.id = message.id;
        if (message.packageToAdd != null && message.hasOwnProperty("packageToAdd"))
            object.packageToAdd = message.packageToAdd;
        if (message.packageToRemove != null && message.hasOwnProperty("packageToRemove"))
            object.packageToRemove = message.packageToRemove;
        return object;
    };

    /**
     * Converts this ModifyLibrary to JSON.
     * @function toJSON
     * @memberof ModifyLibrary
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    ModifyLibrary.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return ModifyLibrary;
})();

$root.Publisher = (function() {

    /**
     * Properties of a Publisher.
     * @exports IPublisher
     * @interface IPublisher
     * @property {IPublisherStream|null} [publisherStream] Publisher publisherStream
     */

    /**
     * Constructs a new Publisher.
     * @exports Publisher
     * @classdesc Represents a Publisher.
     * @implements IPublisher
     * @constructor
     * @param {IPublisher=} [properties] Properties to set
     */
    function Publisher(properties) {
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * Publisher publisherStream.
     * @member {IPublisherStream|null|undefined} publisherStream
     * @memberof Publisher
     * @instance
     */
    Publisher.prototype.publisherStream = null;

    /**
     * Creates a new Publisher instance using the specified properties.
     * @function create
     * @memberof Publisher
     * @static
     * @param {IPublisher=} [properties] Properties to set
     * @returns {Publisher} Publisher instance
     */
    Publisher.create = function create(properties) {
        return new Publisher(properties);
    };

    /**
     * Encodes the specified Publisher message. Does not implicitly {@link Publisher.verify|verify} messages.
     * @function encode
     * @memberof Publisher
     * @static
     * @param {IPublisher} message Publisher message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    Publisher.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.publisherStream != null && Object.hasOwnProperty.call(message, "publisherStream"))
            $root.PublisherStream.encode(message.publisherStream, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
        return writer;
    };

    /**
     * Encodes the specified Publisher message, length delimited. Does not implicitly {@link Publisher.verify|verify} messages.
     * @function encodeDelimited
     * @memberof Publisher
     * @static
     * @param {IPublisher} message Publisher message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    Publisher.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a Publisher message from the specified reader or buffer.
     * @function decode
     * @memberof Publisher
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {Publisher} Publisher
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    Publisher.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Publisher();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            case 2:
                message.publisherStream = $root.PublisherStream.decode(reader, reader.uint32());
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a Publisher message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof Publisher
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {Publisher} Publisher
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    Publisher.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a Publisher message.
     * @function verify
     * @memberof Publisher
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    Publisher.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.publisherStream != null && message.hasOwnProperty("publisherStream")) {
            var error = $root.PublisherStream.verify(message.publisherStream);
            if (error)
                return "publisherStream." + error;
        }
        return null;
    };

    /**
     * Creates a Publisher message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof Publisher
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {Publisher} Publisher
     */
    Publisher.fromObject = function fromObject(object) {
        if (object instanceof $root.Publisher)
            return object;
        var message = new $root.Publisher();
        if (object.publisherStream != null) {
            if (typeof object.publisherStream !== "object")
                throw TypeError(".Publisher.publisherStream: object expected");
            message.publisherStream = $root.PublisherStream.fromObject(object.publisherStream);
        }
        return message;
    };

    /**
     * Creates a plain object from a Publisher message. Also converts values to other types if specified.
     * @function toObject
     * @memberof Publisher
     * @static
     * @param {Publisher} message Publisher
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    Publisher.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        var object = {};
        if (options.defaults)
            object.publisherStream = null;
        if (message.publisherStream != null && message.hasOwnProperty("publisherStream"))
            object.publisherStream = $root.PublisherStream.toObject(message.publisherStream, options);
        return object;
    };

    /**
     * Converts this Publisher to JSON.
     * @function toJSON
     * @memberof Publisher
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    Publisher.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return Publisher;
})();

$root.PublisherStream = (function() {

    /**
     * Properties of a PublisherStream.
     * @exports IPublisherStream
     * @interface IPublisherStream
     * @property {string|null} [moreUrl] PublisherStream moreUrl
     * @property {string|null} [query] PublisherStream query
     */

    /**
     * Constructs a new PublisherStream.
     * @exports PublisherStream
     * @classdesc Represents a PublisherStream.
     * @implements IPublisherStream
     * @constructor
     * @param {IPublisherStream=} [properties] Properties to set
     */
    function PublisherStream(properties) {
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * PublisherStream moreUrl.
     * @member {string} moreUrl
     * @memberof PublisherStream
     * @instance
     */
    PublisherStream.prototype.moreUrl = "";

    /**
     * PublisherStream query.
     * @member {string} query
     * @memberof PublisherStream
     * @instance
     */
    PublisherStream.prototype.query = "";

    /**
     * Creates a new PublisherStream instance using the specified properties.
     * @function create
     * @memberof PublisherStream
     * @static
     * @param {IPublisherStream=} [properties] Properties to set
     * @returns {PublisherStream} PublisherStream instance
     */
    PublisherStream.create = function create(properties) {
        return new PublisherStream(properties);
    };

    /**
     * Encodes the specified PublisherStream message. Does not implicitly {@link PublisherStream.verify|verify} messages.
     * @function encode
     * @memberof PublisherStream
     * @static
     * @param {IPublisherStream} message PublisherStream message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    PublisherStream.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.moreUrl != null && Object.hasOwnProperty.call(message, "moreUrl"))
            writer.uint32(/* id 3, wireType 2 =*/26).string(message.moreUrl);
        if (message.query != null && Object.hasOwnProperty.call(message, "query"))
            writer.uint32(/* id 11, wireType 2 =*/90).string(message.query);
        return writer;
    };

    /**
     * Encodes the specified PublisherStream message, length delimited. Does not implicitly {@link PublisherStream.verify|verify} messages.
     * @function encodeDelimited
     * @memberof PublisherStream
     * @static
     * @param {IPublisherStream} message PublisherStream message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    PublisherStream.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a PublisherStream message from the specified reader or buffer.
     * @function decode
     * @memberof PublisherStream
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {PublisherStream} PublisherStream
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    PublisherStream.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.PublisherStream();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            case 3:
                message.moreUrl = reader.string();
                break;
            case 11:
                message.query = reader.string();
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a PublisherStream message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof PublisherStream
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {PublisherStream} PublisherStream
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    PublisherStream.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a PublisherStream message.
     * @function verify
     * @memberof PublisherStream
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    PublisherStream.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.moreUrl != null && message.hasOwnProperty("moreUrl"))
            if (!$util.isString(message.moreUrl))
                return "moreUrl: string expected";
        if (message.query != null && message.hasOwnProperty("query"))
            if (!$util.isString(message.query))
                return "query: string expected";
        return null;
    };

    /**
     * Creates a PublisherStream message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof PublisherStream
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {PublisherStream} PublisherStream
     */
    PublisherStream.fromObject = function fromObject(object) {
        if (object instanceof $root.PublisherStream)
            return object;
        var message = new $root.PublisherStream();
        if (object.moreUrl != null)
            message.moreUrl = String(object.moreUrl);
        if (object.query != null)
            message.query = String(object.query);
        return message;
    };

    /**
     * Creates a plain object from a PublisherStream message. Also converts values to other types if specified.
     * @function toObject
     * @memberof PublisherStream
     * @static
     * @param {PublisherStream} message PublisherStream
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    PublisherStream.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        var object = {};
        if (options.defaults) {
            object.moreUrl = "";
            object.query = "";
        }
        if (message.moreUrl != null && message.hasOwnProperty("moreUrl"))
            object.moreUrl = message.moreUrl;
        if (message.query != null && message.hasOwnProperty("query"))
            object.query = message.query;
        return object;
    };

    /**
     * Converts this PublisherStream to JSON.
     * @function toJSON
     * @memberof PublisherStream
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    PublisherStream.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return PublisherStream;
})();

$root.EditorChoice = (function() {

    /**
     * Properties of an EditorChoice.
     * @exports IEditorChoice
     * @interface IEditorChoice
     * @property {Array.<string>|null} [bulletins] EditorChoice bulletins
     * @property {string|null} [description] EditorChoice description
     * @property {ISubStream|null} [stream] EditorChoice stream
     * @property {string|null} [title] EditorChoice title
     * @property {string|null} [subtitle] EditorChoice subtitle
     */

    /**
     * Constructs a new EditorChoice.
     * @exports EditorChoice
     * @classdesc Represents an EditorChoice.
     * @implements IEditorChoice
     * @constructor
     * @param {IEditorChoice=} [properties] Properties to set
     */
    function EditorChoice(properties) {
        this.bulletins = [];
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * EditorChoice bulletins.
     * @member {Array.<string>} bulletins
     * @memberof EditorChoice
     * @instance
     */
    EditorChoice.prototype.bulletins = $util.emptyArray;

    /**
     * EditorChoice description.
     * @member {string} description
     * @memberof EditorChoice
     * @instance
     */
    EditorChoice.prototype.description = "";

    /**
     * EditorChoice stream.
     * @member {ISubStream|null|undefined} stream
     * @memberof EditorChoice
     * @instance
     */
    EditorChoice.prototype.stream = null;

    /**
     * EditorChoice title.
     * @member {string} title
     * @memberof EditorChoice
     * @instance
     */
    EditorChoice.prototype.title = "";

    /**
     * EditorChoice subtitle.
     * @member {string} subtitle
     * @memberof EditorChoice
     * @instance
     */
    EditorChoice.prototype.subtitle = "";

    /**
     * Creates a new EditorChoice instance using the specified properties.
     * @function create
     * @memberof EditorChoice
     * @static
     * @param {IEditorChoice=} [properties] Properties to set
     * @returns {EditorChoice} EditorChoice instance
     */
    EditorChoice.create = function create(properties) {
        return new EditorChoice(properties);
    };

    /**
     * Encodes the specified EditorChoice message. Does not implicitly {@link EditorChoice.verify|verify} messages.
     * @function encode
     * @memberof EditorChoice
     * @static
     * @param {IEditorChoice} message EditorChoice message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    EditorChoice.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.bulletins != null && message.bulletins.length)
            for (var i = 0; i < message.bulletins.length; ++i)
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.bulletins[i]);
        if (message.description != null && Object.hasOwnProperty.call(message, "description"))
            writer.uint32(/* id 2, wireType 2 =*/18).string(message.description);
        if (message.stream != null && Object.hasOwnProperty.call(message, "stream"))
            $root.SubStream.encode(message.stream, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
        if (message.title != null && Object.hasOwnProperty.call(message, "title"))
            writer.uint32(/* id 4, wireType 2 =*/34).string(message.title);
        if (message.subtitle != null && Object.hasOwnProperty.call(message, "subtitle"))
            writer.uint32(/* id 5, wireType 2 =*/42).string(message.subtitle);
        return writer;
    };

    /**
     * Encodes the specified EditorChoice message, length delimited. Does not implicitly {@link EditorChoice.verify|verify} messages.
     * @function encodeDelimited
     * @memberof EditorChoice
     * @static
     * @param {IEditorChoice} message EditorChoice message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    EditorChoice.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes an EditorChoice message from the specified reader or buffer.
     * @function decode
     * @memberof EditorChoice
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {EditorChoice} EditorChoice
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    EditorChoice.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.EditorChoice();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                if (!(message.bulletins && message.bulletins.length))
                    message.bulletins = [];
                message.bulletins.push(reader.string());
                break;
            case 2:
                message.description = reader.string();
                break;
            case 3:
                message.stream = $root.SubStream.decode(reader, reader.uint32());
                break;
            case 4:
                message.title = reader.string();
                break;
            case 5:
                message.subtitle = reader.string();
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes an EditorChoice message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof EditorChoice
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {EditorChoice} EditorChoice
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    EditorChoice.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies an EditorChoice message.
     * @function verify
     * @memberof EditorChoice
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    EditorChoice.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.bulletins != null && message.hasOwnProperty("bulletins")) {
            if (!Array.isArray(message.bulletins))
                return "bulletins: array expected";
            for (var i = 0; i < message.bulletins.length; ++i)
                if (!$util.isString(message.bulletins[i]))
                    return "bulletins: string[] expected";
        }
        if (message.description != null && message.hasOwnProperty("description"))
            if (!$util.isString(message.description))
                return "description: string expected";
        if (message.stream != null && message.hasOwnProperty("stream")) {
            var error = $root.SubStream.verify(message.stream);
            if (error)
                return "stream." + error;
        }
        if (message.title != null && message.hasOwnProperty("title"))
            if (!$util.isString(message.title))
                return "title: string expected";
        if (message.subtitle != null && message.hasOwnProperty("subtitle"))
            if (!$util.isString(message.subtitle))
                return "subtitle: string expected";
        return null;
    };

    /**
     * Creates an EditorChoice message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof EditorChoice
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {EditorChoice} EditorChoice
     */
    EditorChoice.fromObject = function fromObject(object) {
        if (object instanceof $root.EditorChoice)
            return object;
        var message = new $root.EditorChoice();
        if (object.bulletins) {
            if (!Array.isArray(object.bulletins))
                throw TypeError(".EditorChoice.bulletins: array expected");
            message.bulletins = [];
            for (var i = 0; i < object.bulletins.length; ++i)
                message.bulletins[i] = String(object.bulletins[i]);
        }
        if (object.description != null)
            message.description = String(object.description);
        if (object.stream != null) {
            if (typeof object.stream !== "object")
                throw TypeError(".EditorChoice.stream: object expected");
            message.stream = $root.SubStream.fromObject(object.stream);
        }
        if (object.title != null)
            message.title = String(object.title);
        if (object.subtitle != null)
            message.subtitle = String(object.subtitle);
        return message;
    };

    /**
     * Creates a plain object from an EditorChoice message. Also converts values to other types if specified.
     * @function toObject
     * @memberof EditorChoice
     * @static
     * @param {EditorChoice} message EditorChoice
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    EditorChoice.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        var object = {};
        if (options.arrays || options.defaults)
            object.bulletins = [];
        if (options.defaults) {
            object.description = "";
            object.stream = null;
            object.title = "";
            object.subtitle = "";
        }
        if (message.bulletins && message.bulletins.length) {
            object.bulletins = [];
            for (var j = 0; j < message.bulletins.length; ++j)
                object.bulletins[j] = message.bulletins[j];
        }
        if (message.description != null && message.hasOwnProperty("description"))
            object.description = message.description;
        if (message.stream != null && message.hasOwnProperty("stream"))
            object.stream = $root.SubStream.toObject(message.stream, options);
        if (message.title != null && message.hasOwnProperty("title"))
            object.title = message.title;
        if (message.subtitle != null && message.hasOwnProperty("subtitle"))
            object.subtitle = message.subtitle;
        return object;
    };

    /**
     * Converts this EditorChoice to JSON.
     * @function toJSON
     * @memberof EditorChoice
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    EditorChoice.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return EditorChoice;
})();

$root.CertificateSet = (function() {

    /**
     * Properties of a CertificateSet.
     * @exports ICertificateSet
     * @interface ICertificateSet
     * @property {Array.<string>|null} [certificateHash] CertificateSet certificateHash
     * @property {Array.<string>|null} [sha256] CertificateSet sha256
     */

    /**
     * Constructs a new CertificateSet.
     * @exports CertificateSet
     * @classdesc Represents a CertificateSet.
     * @implements ICertificateSet
     * @constructor
     * @param {ICertificateSet=} [properties] Properties to set
     */
    function CertificateSet(properties) {
        this.certificateHash = [];
        this.sha256 = [];
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * CertificateSet certificateHash.
     * @member {Array.<string>} certificateHash
     * @memberof CertificateSet
     * @instance
     */
    CertificateSet.prototype.certificateHash = $util.emptyArray;

    /**
     * CertificateSet sha256.
     * @member {Array.<string>} sha256
     * @memberof CertificateSet
     * @instance
     */
    CertificateSet.prototype.sha256 = $util.emptyArray;

    /**
     * Creates a new CertificateSet instance using the specified properties.
     * @function create
     * @memberof CertificateSet
     * @static
     * @param {ICertificateSet=} [properties] Properties to set
     * @returns {CertificateSet} CertificateSet instance
     */
    CertificateSet.create = function create(properties) {
        return new CertificateSet(properties);
    };

    /**
     * Encodes the specified CertificateSet message. Does not implicitly {@link CertificateSet.verify|verify} messages.
     * @function encode
     * @memberof CertificateSet
     * @static
     * @param {ICertificateSet} message CertificateSet message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    CertificateSet.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.certificateHash != null && message.certificateHash.length)
            for (var i = 0; i < message.certificateHash.length; ++i)
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.certificateHash[i]);
        if (message.sha256 != null && message.sha256.length)
            for (var i = 0; i < message.sha256.length; ++i)
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.sha256[i]);
        return writer;
    };

    /**
     * Encodes the specified CertificateSet message, length delimited. Does not implicitly {@link CertificateSet.verify|verify} messages.
     * @function encodeDelimited
     * @memberof CertificateSet
     * @static
     * @param {ICertificateSet} message CertificateSet message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    CertificateSet.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a CertificateSet message from the specified reader or buffer.
     * @function decode
     * @memberof CertificateSet
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CertificateSet} CertificateSet
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CertificateSet.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CertificateSet();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                if (!(message.certificateHash && message.certificateHash.length))
                    message.certificateHash = [];
                message.certificateHash.push(reader.string());
                break;
            case 2:
                if (!(message.sha256 && message.sha256.length))
                    message.sha256 = [];
                message.sha256.push(reader.string());
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a CertificateSet message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof CertificateSet
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {CertificateSet} CertificateSet
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CertificateSet.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a CertificateSet message.
     * @function verify
     * @memberof CertificateSet
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    CertificateSet.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.certificateHash != null && message.hasOwnProperty("certificateHash")) {
            if (!Array.isArray(message.certificateHash))
                return "certificateHash: array expected";
            for (var i = 0; i < message.certificateHash.length; ++i)
                if (!$util.isString(message.certificateHash[i]))
                    return "certificateHash: string[] expected";
        }
        if (message.sha256 != null && message.hasOwnProperty("sha256")) {
            if (!Array.isArray(message.sha256))
                return "sha256: array expected";
            for (var i = 0; i < message.sha256.length; ++i)
                if (!$util.isString(message.sha256[i]))
                    return "sha256: string[] expected";
        }
        return null;
    };

    /**
     * Creates a CertificateSet message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof CertificateSet
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {CertificateSet} CertificateSet
     */
    CertificateSet.fromObject = function fromObject(object) {
        if (object instanceof $root.CertificateSet)
            return object;
        var message = new $root.CertificateSet();
        if (object.certificateHash) {
            if (!Array.isArray(object.certificateHash))
                throw TypeError(".CertificateSet.certificateHash: array expected");
            message.certificateHash = [];
            for (var i = 0; i < object.certificateHash.length; ++i)
                message.certificateHash[i] = String(object.certificateHash[i]);
        }
        if (object.sha256) {
            if (!Array.isArray(object.sha256))
                throw TypeError(".CertificateSet.sha256: array expected");
            message.sha256 = [];
            for (var i = 0; i < object.sha256.length; ++i)
                message.sha256[i] = String(object.sha256[i]);
        }
        return message;
    };

    /**
     * Creates a plain object from a CertificateSet message. Also converts values to other types if specified.
     * @function toObject
     * @memberof CertificateSet
     * @static
     * @param {CertificateSet} message CertificateSet
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    CertificateSet.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        var object = {};
        if (options.arrays || options.defaults) {
            object.certificateHash = [];
            object.sha256 = [];
        }
        if (message.certificateHash && message.certificateHash.length) {
            object.certificateHash = [];
            for (var j = 0; j < message.certificateHash.length; ++j)
                object.certificateHash[j] = message.certificateHash[j];
        }
        if (message.sha256 && message.sha256.length) {
            object.sha256 = [];
            for (var j = 0; j < message.sha256.length; ++j)
                object.sha256[j] = message.sha256[j];
        }
        return object;
    };

    /**
     * Converts this CertificateSet to JSON.
     * @function toJSON
     * @memberof CertificateSet
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    CertificateSet.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return CertificateSet;
})();

$root.Dependencies = (function() {

    /**
     * Properties of a Dependencies.
     * @exports IDependencies
     * @interface IDependencies
     * @property {number|null} [unknown] Dependencies unknown
     * @property {number|Long|null} [size] Dependencies size
     * @property {Array.<IDependency>|null} [dependency] Dependencies dependency
     * @property {number|null} [targetSdk] Dependencies targetSdk
     * @property {number|null} [unknown2] Dependencies unknown2
     * @property {Array.<string>|null} [splitApks] Dependencies splitApks
     */

    /**
     * Constructs a new Dependencies.
     * @exports Dependencies
     * @classdesc Represents a Dependencies.
     * @implements IDependencies
     * @constructor
     * @param {IDependencies=} [properties] Properties to set
     */
    function Dependencies(properties) {
        this.dependency = [];
        this.splitApks = [];
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * Dependencies unknown.
     * @member {number} unknown
     * @memberof Dependencies
     * @instance
     */
    Dependencies.prototype.unknown = 0;

    /**
     * Dependencies size.
     * @member {number|Long} size
     * @memberof Dependencies
     * @instance
     */
    Dependencies.prototype.size = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

    /**
     * Dependencies dependency.
     * @member {Array.<IDependency>} dependency
     * @memberof Dependencies
     * @instance
     */
    Dependencies.prototype.dependency = $util.emptyArray;

    /**
     * Dependencies targetSdk.
     * @member {number} targetSdk
     * @memberof Dependencies
     * @instance
     */
    Dependencies.prototype.targetSdk = 0;

    /**
     * Dependencies unknown2.
     * @member {number} unknown2
     * @memberof Dependencies
     * @instance
     */
    Dependencies.prototype.unknown2 = 0;

    /**
     * Dependencies splitApks.
     * @member {Array.<string>} splitApks
     * @memberof Dependencies
     * @instance
     */
    Dependencies.prototype.splitApks = $util.emptyArray;

    /**
     * Creates a new Dependencies instance using the specified properties.
     * @function create
     * @memberof Dependencies
     * @static
     * @param {IDependencies=} [properties] Properties to set
     * @returns {Dependencies} Dependencies instance
     */
    Dependencies.create = function create(properties) {
        return new Dependencies(properties);
    };

    /**
     * Encodes the specified Dependencies message. Does not implicitly {@link Dependencies.verify|verify} messages.
     * @function encode
     * @memberof Dependencies
     * @static
     * @param {IDependencies} message Dependencies message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    Dependencies.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.unknown != null && Object.hasOwnProperty.call(message, "unknown"))
            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.unknown);
        if (message.size != null && Object.hasOwnProperty.call(message, "size"))
            writer.uint32(/* id 2, wireType 0 =*/16).int64(message.size);
        if (message.dependency != null && message.dependency.length)
            for (var i = 0; i < message.dependency.length; ++i)
                $root.Dependency.encode(message.dependency[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
        if (message.targetSdk != null && Object.hasOwnProperty.call(message, "targetSdk"))
            writer.uint32(/* id 4, wireType 0 =*/32).int32(message.targetSdk);
        if (message.unknown2 != null && Object.hasOwnProperty.call(message, "unknown2"))
            writer.uint32(/* id 5, wireType 0 =*/40).int32(message.unknown2);
        if (message.splitApks != null && message.splitApks.length)
            for (var i = 0; i < message.splitApks.length; ++i)
                writer.uint32(/* id 11, wireType 2 =*/90).string(message.splitApks[i]);
        return writer;
    };

    /**
     * Encodes the specified Dependencies message, length delimited. Does not implicitly {@link Dependencies.verify|verify} messages.
     * @function encodeDelimited
     * @memberof Dependencies
     * @static
     * @param {IDependencies} message Dependencies message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    Dependencies.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a Dependencies message from the specified reader or buffer.
     * @function decode
     * @memberof Dependencies
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {Dependencies} Dependencies
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    Dependencies.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Dependencies();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.unknown = reader.int32();
                break;
            case 2:
                message.size = reader.int64();
                break;
            case 3:
                if (!(message.dependency && message.dependency.length))
                    message.dependency = [];
                message.dependency.push($root.Dependency.decode(reader, reader.uint32()));
                break;
            case 4:
                message.targetSdk = reader.int32();
                break;
            case 5:
                message.unknown2 = reader.int32();
                break;
            case 11:
                if (!(message.splitApks && message.splitApks.length))
                    message.splitApks = [];
                message.splitApks.push(reader.string());
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a Dependencies message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof Dependencies
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {Dependencies} Dependencies
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    Dependencies.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a Dependencies message.
     * @function verify
     * @memberof Dependencies
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    Dependencies.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.unknown != null && message.hasOwnProperty("unknown"))
            if (!$util.isInteger(message.unknown))
                return "unknown: integer expected";
        if (message.size != null && message.hasOwnProperty("size"))
            if (!$util.isInteger(message.size) && !(message.size && $util.isInteger(message.size.low) && $util.isInteger(message.size.high)))
                return "size: integer|Long expected";
        if (message.dependency != null && message.hasOwnProperty("dependency")) {
            if (!Array.isArray(message.dependency))
                return "dependency: array expected";
            for (var i = 0; i < message.dependency.length; ++i) {
                var error = $root.Dependency.verify(message.dependency[i]);
                if (error)
                    return "dependency." + error;
            }
        }
        if (message.targetSdk != null && message.hasOwnProperty("targetSdk"))
            if (!$util.isInteger(message.targetSdk))
                return "targetSdk: integer expected";
        if (message.unknown2 != null && message.hasOwnProperty("unknown2"))
            if (!$util.isInteger(message.unknown2))
                return "unknown2: integer expected";
        if (message.splitApks != null && message.hasOwnProperty("splitApks")) {
            if (!Array.isArray(message.splitApks))
                return "splitApks: array expected";
            for (var i = 0; i < message.splitApks.length; ++i)
                if (!$util.isString(message.splitApks[i]))
                    return "splitApks: string[] expected";
        }
        return null;
    };

    /**
     * Creates a Dependencies message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof Dependencies
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {Dependencies} Dependencies
     */
    Dependencies.fromObject = function fromObject(object) {
        if (object instanceof $root.Dependencies)
            return object;
        var message = new $root.Dependencies();
        if (object.unknown != null)
            message.unknown = object.unknown | 0;
        if (object.size != null)
            if ($util.Long)
                (message.size = $util.Long.fromValue(object.size)).unsigned = false;
            else if (typeof object.size === "string")
                message.size = parseInt(object.size, 10);
            else if (typeof object.size === "number")
                message.size = object.size;
            else if (typeof object.size === "object")
                message.size = new $util.LongBits(object.size.low >>> 0, object.size.high >>> 0).toNumber();
        if (object.dependency) {
            if (!Array.isArray(object.dependency))
                throw TypeError(".Dependencies.dependency: array expected");
            message.dependency = [];
            for (var i = 0; i < object.dependency.length; ++i) {
                if (typeof object.dependency[i] !== "object")
                    throw TypeError(".Dependencies.dependency: object expected");
                message.dependency[i] = $root.Dependency.fromObject(object.dependency[i]);
            }
        }
        if (object.targetSdk != null)
            message.targetSdk = object.targetSdk | 0;
        if (object.unknown2 != null)
            message.unknown2 = object.unknown2 | 0;
        if (object.splitApks) {
            if (!Array.isArray(object.splitApks))
                throw TypeError(".Dependencies.splitApks: array expected");
            message.splitApks = [];
            for (var i = 0; i < object.splitApks.length; ++i)
                message.splitApks[i] = String(object.splitApks[i]);
        }
        return message;
    };

    /**
     * Creates a plain object from a Dependencies message. Also converts values to other types if specified.
     * @function toObject
     * @memberof Dependencies
     * @static
     * @param {Dependencies} message Dependencies
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    Dependencies.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        var object = {};
        if (options.arrays || options.defaults) {
            object.dependency = [];
            object.splitApks = [];
        }
        if (options.defaults) {
            object.unknown = 0;
            if ($util.Long) {
                var long = new $util.Long(0, 0, false);
                object.size = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
            } else
                object.size = options.longs === String ? "0" : 0;
            object.targetSdk = 0;
            object.unknown2 = 0;
        }
        if (message.unknown != null && message.hasOwnProperty("unknown"))
            object.unknown = message.unknown;
        if (message.size != null && message.hasOwnProperty("size"))
            if (typeof message.size === "number")
                object.size = options.longs === String ? String(message.size) : message.size;
            else
                object.size = options.longs === String ? $util.Long.prototype.toString.call(message.size) : options.longs === Number ? new $util.LongBits(message.size.low >>> 0, message.size.high >>> 0).toNumber() : message.size;
        if (message.dependency && message.dependency.length) {
            object.dependency = [];
            for (var j = 0; j < message.dependency.length; ++j)
                object.dependency[j] = $root.Dependency.toObject(message.dependency[j], options);
        }
        if (message.targetSdk != null && message.hasOwnProperty("targetSdk"))
            object.targetSdk = message.targetSdk;
        if (message.unknown2 != null && message.hasOwnProperty("unknown2"))
            object.unknown2 = message.unknown2;
        if (message.splitApks && message.splitApks.length) {
            object.splitApks = [];
            for (var j = 0; j < message.splitApks.length; ++j)
                object.splitApks[j] = message.splitApks[j];
        }
        return object;
    };

    /**
     * Converts this Dependencies to JSON.
     * @function toJSON
     * @memberof Dependencies
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    Dependencies.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return Dependencies;
})();

$root.Dependency = (function() {

    /**
     * Properties of a Dependency.
     * @exports IDependency
     * @interface IDependency
     * @property {string|null} [packageName] Dependency packageName
     * @property {number|null} [version] Dependency version
     * @property {number|null} [unknown4] Dependency unknown4
     */

    /**
     * Constructs a new Dependency.
     * @exports Dependency
     * @classdesc Represents a Dependency.
     * @implements IDependency
     * @constructor
     * @param {IDependency=} [properties] Properties to set
     */
    function Dependency(properties) {
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * Dependency packageName.
     * @member {string} packageName
     * @memberof Dependency
     * @instance
     */
    Dependency.prototype.packageName = "";

    /**
     * Dependency version.
     * @member {number} version
     * @memberof Dependency
     * @instance
     */
    Dependency.prototype.version = 0;

    /**
     * Dependency unknown4.
     * @member {number} unknown4
     * @memberof Dependency
     * @instance
     */
    Dependency.prototype.unknown4 = 0;

    /**
     * Creates a new Dependency instance using the specified properties.
     * @function create
     * @memberof Dependency
     * @static
     * @param {IDependency=} [properties] Properties to set
     * @returns {Dependency} Dependency instance
     */
    Dependency.create = function create(properties) {
        return new Dependency(properties);
    };

    /**
     * Encodes the specified Dependency message. Does not implicitly {@link Dependency.verify|verify} messages.
     * @function encode
     * @memberof Dependency
     * @static
     * @param {IDependency} message Dependency message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    Dependency.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.packageName != null && Object.hasOwnProperty.call(message, "packageName"))
            writer.uint32(/* id 1, wireType 2 =*/10).string(message.packageName);
        if (message.version != null && Object.hasOwnProperty.call(message, "version"))
            writer.uint32(/* id 2, wireType 0 =*/16).int32(message.version);
        if (message.unknown4 != null && Object.hasOwnProperty.call(message, "unknown4"))
            writer.uint32(/* id 4, wireType 0 =*/32).int32(message.unknown4);
        return writer;
    };

    /**
     * Encodes the specified Dependency message, length delimited. Does not implicitly {@link Dependency.verify|verify} messages.
     * @function encodeDelimited
     * @memberof Dependency
     * @static
     * @param {IDependency} message Dependency message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    Dependency.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a Dependency message from the specified reader or buffer.
     * @function decode
     * @memberof Dependency
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {Dependency} Dependency
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    Dependency.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Dependency();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.packageName = reader.string();
                break;
            case 2:
                message.version = reader.int32();
                break;
            case 4:
                message.unknown4 = reader.int32();
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a Dependency message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof Dependency
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {Dependency} Dependency
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    Dependency.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a Dependency message.
     * @function verify
     * @memberof Dependency
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    Dependency.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.packageName != null && message.hasOwnProperty("packageName"))
            if (!$util.isString(message.packageName))
                return "packageName: string expected";
        if (message.version != null && message.hasOwnProperty("version"))
            if (!$util.isInteger(message.version))
                return "version: integer expected";
        if (message.unknown4 != null && message.hasOwnProperty("unknown4"))
            if (!$util.isInteger(message.unknown4))
                return "unknown4: integer expected";
        return null;
    };

    /**
     * Creates a Dependency message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof Dependency
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {Dependency} Dependency
     */
    Dependency.fromObject = function fromObject(object) {
        if (object instanceof $root.Dependency)
            return object;
        var message = new $root.Dependency();
        if (object.packageName != null)
            message.packageName = String(object.packageName);
        if (object.version != null)
            message.version = object.version | 0;
        if (object.unknown4 != null)
            message.unknown4 = object.unknown4 | 0;
        return message;
    };

    /**
     * Creates a plain object from a Dependency message. Also converts values to other types if specified.
     * @function toObject
     * @memberof Dependency
     * @static
     * @param {Dependency} message Dependency
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    Dependency.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        var object = {};
        if (options.defaults) {
            object.packageName = "";
            object.version = 0;
            object.unknown4 = 0;
        }
        if (message.packageName != null && message.hasOwnProperty("packageName"))
            object.packageName = message.packageName;
        if (message.version != null && message.hasOwnProperty("version"))
            object.version = message.version;
        if (message.unknown4 != null && message.hasOwnProperty("unknown4"))
            object.unknown4 = message.unknown4;
        return object;
    };

    /**
     * Converts this Dependency to JSON.
     * @function toJSON
     * @memberof Dependency
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    Dependency.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return Dependency;
})();

$root.TestingProgramInfo = (function() {

    /**
     * Properties of a TestingProgramInfo.
     * @exports ITestingProgramInfo
     * @interface ITestingProgramInfo
     * @property {boolean|null} [subscribed] TestingProgramInfo subscribed
     * @property {boolean|null} [subscribedAndInstalled] TestingProgramInfo subscribedAndInstalled
     * @property {string|null} [email] TestingProgramInfo email
     * @property {string|null} [displayName] TestingProgramInfo displayName
     * @property {IImage|null} [image] TestingProgramInfo image
     */

    /**
     * Constructs a new TestingProgramInfo.
     * @exports TestingProgramInfo
     * @classdesc Represents a TestingProgramInfo.
     * @implements ITestingProgramInfo
     * @constructor
     * @param {ITestingProgramInfo=} [properties] Properties to set
     */
    function TestingProgramInfo(properties) {
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * TestingProgramInfo subscribed.
     * @member {boolean} subscribed
     * @memberof TestingProgramInfo
     * @instance
     */
    TestingProgramInfo.prototype.subscribed = false;

    /**
     * TestingProgramInfo subscribedAndInstalled.
     * @member {boolean} subscribedAndInstalled
     * @memberof TestingProgramInfo
     * @instance
     */
    TestingProgramInfo.prototype.subscribedAndInstalled = false;

    /**
     * TestingProgramInfo email.
     * @member {string} email
     * @memberof TestingProgramInfo
     * @instance
     */
    TestingProgramInfo.prototype.email = "";

    /**
     * TestingProgramInfo displayName.
     * @member {string} displayName
     * @memberof TestingProgramInfo
     * @instance
     */
    TestingProgramInfo.prototype.displayName = "";

    /**
     * TestingProgramInfo image.
     * @member {IImage|null|undefined} image
     * @memberof TestingProgramInfo
     * @instance
     */
    TestingProgramInfo.prototype.image = null;

    /**
     * Creates a new TestingProgramInfo instance using the specified properties.
     * @function create
     * @memberof TestingProgramInfo
     * @static
     * @param {ITestingProgramInfo=} [properties] Properties to set
     * @returns {TestingProgramInfo} TestingProgramInfo instance
     */
    TestingProgramInfo.create = function create(properties) {
        return new TestingProgramInfo(properties);
    };

    /**
     * Encodes the specified TestingProgramInfo message. Does not implicitly {@link TestingProgramInfo.verify|verify} messages.
     * @function encode
     * @memberof TestingProgramInfo
     * @static
     * @param {ITestingProgramInfo} message TestingProgramInfo message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    TestingProgramInfo.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.subscribed != null && Object.hasOwnProperty.call(message, "subscribed"))
            writer.uint32(/* id 2, wireType 0 =*/16).bool(message.subscribed);
        if (message.subscribedAndInstalled != null && Object.hasOwnProperty.call(message, "subscribedAndInstalled"))
            writer.uint32(/* id 3, wireType 0 =*/24).bool(message.subscribedAndInstalled);
        if (message.email != null && Object.hasOwnProperty.call(message, "email"))
            writer.uint32(/* id 5, wireType 2 =*/42).string(message.email);
        if (message.image != null && Object.hasOwnProperty.call(message, "image"))
            $root.Image.encode(message.image, writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
        if (message.displayName != null && Object.hasOwnProperty.call(message, "displayName"))
            writer.uint32(/* id 7, wireType 2 =*/58).string(message.displayName);
        return writer;
    };

    /**
     * Encodes the specified TestingProgramInfo message, length delimited. Does not implicitly {@link TestingProgramInfo.verify|verify} messages.
     * @function encodeDelimited
     * @memberof TestingProgramInfo
     * @static
     * @param {ITestingProgramInfo} message TestingProgramInfo message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    TestingProgramInfo.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a TestingProgramInfo message from the specified reader or buffer.
     * @function decode
     * @memberof TestingProgramInfo
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {TestingProgramInfo} TestingProgramInfo
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    TestingProgramInfo.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.TestingProgramInfo();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            case 2:
                message.subscribed = reader.bool();
                break;
            case 3:
                message.subscribedAndInstalled = reader.bool();
                break;
            case 5:
                message.email = reader.string();
                break;
            case 7:
                message.displayName = reader.string();
                break;
            case 6:
                message.image = $root.Image.decode(reader, reader.uint32());
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a TestingProgramInfo message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof TestingProgramInfo
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {TestingProgramInfo} TestingProgramInfo
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    TestingProgramInfo.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a TestingProgramInfo message.
     * @function verify
     * @memberof TestingProgramInfo
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    TestingProgramInfo.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.subscribed != null && message.hasOwnProperty("subscribed"))
            if (typeof message.subscribed !== "boolean")
                return "subscribed: boolean expected";
        if (message.subscribedAndInstalled != null && message.hasOwnProperty("subscribedAndInstalled"))
            if (typeof message.subscribedAndInstalled !== "boolean")
                return "subscribedAndInstalled: boolean expected";
        if (message.email != null && message.hasOwnProperty("email"))
            if (!$util.isString(message.email))
                return "email: string expected";
        if (message.displayName != null && message.hasOwnProperty("displayName"))
            if (!$util.isString(message.displayName))
                return "displayName: string expected";
        if (message.image != null && message.hasOwnProperty("image")) {
            var error = $root.Image.verify(message.image);
            if (error)
                return "image." + error;
        }
        return null;
    };

    /**
     * Creates a TestingProgramInfo message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof TestingProgramInfo
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {TestingProgramInfo} TestingProgramInfo
     */
    TestingProgramInfo.fromObject = function fromObject(object) {
        if (object instanceof $root.TestingProgramInfo)
            return object;
        var message = new $root.TestingProgramInfo();
        if (object.subscribed != null)
            message.subscribed = Boolean(object.subscribed);
        if (object.subscribedAndInstalled != null)
            message.subscribedAndInstalled = Boolean(object.subscribedAndInstalled);
        if (object.email != null)
            message.email = String(object.email);
        if (object.displayName != null)
            message.displayName = String(object.displayName);
        if (object.image != null) {
            if (typeof object.image !== "object")
                throw TypeError(".TestingProgramInfo.image: object expected");
            message.image = $root.Image.fromObject(object.image);
        }
        return message;
    };

    /**
     * Creates a plain object from a TestingProgramInfo message. Also converts values to other types if specified.
     * @function toObject
     * @memberof TestingProgramInfo
     * @static
     * @param {TestingProgramInfo} message TestingProgramInfo
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    TestingProgramInfo.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        var object = {};
        if (options.defaults) {
            object.subscribed = false;
            object.subscribedAndInstalled = false;
            object.email = "";
            object.image = null;
            object.displayName = "";
        }
        if (message.subscribed != null && message.hasOwnProperty("subscribed"))
            object.subscribed = message.subscribed;
        if (message.subscribedAndInstalled != null && message.hasOwnProperty("subscribedAndInstalled"))
            object.subscribedAndInstalled = message.subscribedAndInstalled;
        if (message.email != null && message.hasOwnProperty("email"))
            object.email = message.email;
        if (message.image != null && message.hasOwnProperty("image"))
            object.image = $root.Image.toObject(message.image, options);
        if (message.displayName != null && message.hasOwnProperty("displayName"))
            object.displayName = message.displayName;
        return object;
    };

    /**
     * Converts this TestingProgramInfo to JSON.
     * @function toJSON
     * @memberof TestingProgramInfo
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    TestingProgramInfo.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return TestingProgramInfo;
})();

$root.EarlyAccessInfo = (function() {

    /**
     * Properties of an EarlyAccessInfo.
     * @exports IEarlyAccessInfo
     * @interface IEarlyAccessInfo
     * @property {string|null} [email] EarlyAccessInfo email
     */

    /**
     * Constructs a new EarlyAccessInfo.
     * @exports EarlyAccessInfo
     * @classdesc Represents an EarlyAccessInfo.
     * @implements IEarlyAccessInfo
     * @constructor
     * @param {IEarlyAccessInfo=} [properties] Properties to set
     */
    function EarlyAccessInfo(properties) {
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * EarlyAccessInfo email.
     * @member {string} email
     * @memberof EarlyAccessInfo
     * @instance
     */
    EarlyAccessInfo.prototype.email = "";

    /**
     * Creates a new EarlyAccessInfo instance using the specified properties.
     * @function create
     * @memberof EarlyAccessInfo
     * @static
     * @param {IEarlyAccessInfo=} [properties] Properties to set
     * @returns {EarlyAccessInfo} EarlyAccessInfo instance
     */
    EarlyAccessInfo.create = function create(properties) {
        return new EarlyAccessInfo(properties);
    };

    /**
     * Encodes the specified EarlyAccessInfo message. Does not implicitly {@link EarlyAccessInfo.verify|verify} messages.
     * @function encode
     * @memberof EarlyAccessInfo
     * @static
     * @param {IEarlyAccessInfo} message EarlyAccessInfo message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    EarlyAccessInfo.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.email != null && Object.hasOwnProperty.call(message, "email"))
            writer.uint32(/* id 3, wireType 2 =*/26).string(message.email);
        return writer;
    };

    /**
     * Encodes the specified EarlyAccessInfo message, length delimited. Does not implicitly {@link EarlyAccessInfo.verify|verify} messages.
     * @function encodeDelimited
     * @memberof EarlyAccessInfo
     * @static
     * @param {IEarlyAccessInfo} message EarlyAccessInfo message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    EarlyAccessInfo.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes an EarlyAccessInfo message from the specified reader or buffer.
     * @function decode
     * @memberof EarlyAccessInfo
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {EarlyAccessInfo} EarlyAccessInfo
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    EarlyAccessInfo.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.EarlyAccessInfo();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            case 3:
                message.email = reader.string();
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes an EarlyAccessInfo message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof EarlyAccessInfo
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {EarlyAccessInfo} EarlyAccessInfo
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    EarlyAccessInfo.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies an EarlyAccessInfo message.
     * @function verify
     * @memberof EarlyAccessInfo
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    EarlyAccessInfo.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.email != null && message.hasOwnProperty("email"))
            if (!$util.isString(message.email))
                return "email: string expected";
        return null;
    };

    /**
     * Creates an EarlyAccessInfo message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof EarlyAccessInfo
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {EarlyAccessInfo} EarlyAccessInfo
     */
    EarlyAccessInfo.fromObject = function fromObject(object) {
        if (object instanceof $root.EarlyAccessInfo)
            return object;
        var message = new $root.EarlyAccessInfo();
        if (object.email != null)
            message.email = String(object.email);
        return message;
    };

    /**
     * Creates a plain object from an EarlyAccessInfo message. Also converts values to other types if specified.
     * @function toObject
     * @memberof EarlyAccessInfo
     * @static
     * @param {EarlyAccessInfo} message EarlyAccessInfo
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    EarlyAccessInfo.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        var object = {};
        if (options.defaults)
            object.email = "";
        if (message.email != null && message.hasOwnProperty("email"))
            object.email = message.email;
        return object;
    };

    /**
     * Converts this EarlyAccessInfo to JSON.
     * @function toJSON
     * @memberof EarlyAccessInfo
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    EarlyAccessInfo.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return EarlyAccessInfo;
})();

$root.DocumentDetails = (function() {

    /**
     * Properties of a DocumentDetails.
     * @exports IDocumentDetails
     * @interface IDocumentDetails
     * @property {IAppDetails|null} [appDetails] DocumentDetails appDetails
     * @property {ISubscriptionDetails|null} [subscriptionDetails] DocumentDetails subscriptionDetails
     */

    /**
     * Constructs a new DocumentDetails.
     * @exports DocumentDetails
     * @classdesc Represents a DocumentDetails.
     * @implements IDocumentDetails
     * @constructor
     * @param {IDocumentDetails=} [properties] Properties to set
     */
    function DocumentDetails(properties) {
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * DocumentDetails appDetails.
     * @member {IAppDetails|null|undefined} appDetails
     * @memberof DocumentDetails
     * @instance
     */
    DocumentDetails.prototype.appDetails = null;

    /**
     * DocumentDetails subscriptionDetails.
     * @member {ISubscriptionDetails|null|undefined} subscriptionDetails
     * @memberof DocumentDetails
     * @instance
     */
    DocumentDetails.prototype.subscriptionDetails = null;

    /**
     * Creates a new DocumentDetails instance using the specified properties.
     * @function create
     * @memberof DocumentDetails
     * @static
     * @param {IDocumentDetails=} [properties] Properties to set
     * @returns {DocumentDetails} DocumentDetails instance
     */
    DocumentDetails.create = function create(properties) {
        return new DocumentDetails(properties);
    };

    /**
     * Encodes the specified DocumentDetails message. Does not implicitly {@link DocumentDetails.verify|verify} messages.
     * @function encode
     * @memberof DocumentDetails
     * @static
     * @param {IDocumentDetails} message DocumentDetails message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    DocumentDetails.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.appDetails != null && Object.hasOwnProperty.call(message, "appDetails"))
            $root.AppDetails.encode(message.appDetails, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
        if (message.subscriptionDetails != null && Object.hasOwnProperty.call(message, "subscriptionDetails"))
            $root.SubscriptionDetails.encode(message.subscriptionDetails, writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
        return writer;
    };

    /**
     * Encodes the specified DocumentDetails message, length delimited. Does not implicitly {@link DocumentDetails.verify|verify} messages.
     * @function encodeDelimited
     * @memberof DocumentDetails
     * @static
     * @param {IDocumentDetails} message DocumentDetails message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    DocumentDetails.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a DocumentDetails message from the specified reader or buffer.
     * @function decode
     * @memberof DocumentDetails
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {DocumentDetails} DocumentDetails
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    DocumentDetails.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.DocumentDetails();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.appDetails = $root.AppDetails.decode(reader, reader.uint32());
                break;
            case 7:
                message.subscriptionDetails = $root.SubscriptionDetails.decode(reader, reader.uint32());
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a DocumentDetails message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof DocumentDetails
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {DocumentDetails} DocumentDetails
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    DocumentDetails.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a DocumentDetails message.
     * @function verify
     * @memberof DocumentDetails
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    DocumentDetails.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.appDetails != null && message.hasOwnProperty("appDetails")) {
            var error = $root.AppDetails.verify(message.appDetails);
            if (error)
                return "appDetails." + error;
        }
        if (message.subscriptionDetails != null && message.hasOwnProperty("subscriptionDetails")) {
            var error = $root.SubscriptionDetails.verify(message.subscriptionDetails);
            if (error)
                return "subscriptionDetails." + error;
        }
        return null;
    };

    /**
     * Creates a DocumentDetails message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof DocumentDetails
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {DocumentDetails} DocumentDetails
     */
    DocumentDetails.fromObject = function fromObject(object) {
        if (object instanceof $root.DocumentDetails)
            return object;
        var message = new $root.DocumentDetails();
        if (object.appDetails != null) {
            if (typeof object.appDetails !== "object")
                throw TypeError(".DocumentDetails.appDetails: object expected");
            message.appDetails = $root.AppDetails.fromObject(object.appDetails);
        }
        if (object.subscriptionDetails != null) {
            if (typeof object.subscriptionDetails !== "object")
                throw TypeError(".DocumentDetails.subscriptionDetails: object expected");
            message.subscriptionDetails = $root.SubscriptionDetails.fromObject(object.subscriptionDetails);
        }
        return message;
    };

    /**
     * Creates a plain object from a DocumentDetails message. Also converts values to other types if specified.
     * @function toObject
     * @memberof DocumentDetails
     * @static
     * @param {DocumentDetails} message DocumentDetails
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    DocumentDetails.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        var object = {};
        if (options.defaults) {
            object.appDetails = null;
            object.subscriptionDetails = null;
        }
        if (message.appDetails != null && message.hasOwnProperty("appDetails"))
            object.appDetails = $root.AppDetails.toObject(message.appDetails, options);
        if (message.subscriptionDetails != null && message.hasOwnProperty("subscriptionDetails"))
            object.subscriptionDetails = $root.SubscriptionDetails.toObject(message.subscriptionDetails, options);
        return object;
    };

    /**
     * Converts this DocumentDetails to JSON.
     * @function toJSON
     * @memberof DocumentDetails
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    DocumentDetails.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return DocumentDetails;
})();

$root.PatchDetails = (function() {

    /**
     * Properties of a PatchDetails.
     * @exports IPatchDetails
     * @interface IPatchDetails
     * @property {number|null} [baseVersionCode] PatchDetails baseVersionCode
     * @property {number|Long|null} [size] PatchDetails size
     */

    /**
     * Constructs a new PatchDetails.
     * @exports PatchDetails
     * @classdesc Represents a PatchDetails.
     * @implements IPatchDetails
     * @constructor
     * @param {IPatchDetails=} [properties] Properties to set
     */
    function PatchDetails(properties) {
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * PatchDetails baseVersionCode.
     * @member {number} baseVersionCode
     * @memberof PatchDetails
     * @instance
     */
    PatchDetails.prototype.baseVersionCode = 0;

    /**
     * PatchDetails size.
     * @member {number|Long} size
     * @memberof PatchDetails
     * @instance
     */
    PatchDetails.prototype.size = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

    /**
     * Creates a new PatchDetails instance using the specified properties.
     * @function create
     * @memberof PatchDetails
     * @static
     * @param {IPatchDetails=} [properties] Properties to set
     * @returns {PatchDetails} PatchDetails instance
     */
    PatchDetails.create = function create(properties) {
        return new PatchDetails(properties);
    };

    /**
     * Encodes the specified PatchDetails message. Does not implicitly {@link PatchDetails.verify|verify} messages.
     * @function encode
     * @memberof PatchDetails
     * @static
     * @param {IPatchDetails} message PatchDetails message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    PatchDetails.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.baseVersionCode != null && Object.hasOwnProperty.call(message, "baseVersionCode"))
            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.baseVersionCode);
        if (message.size != null && Object.hasOwnProperty.call(message, "size"))
            writer.uint32(/* id 2, wireType 0 =*/16).int64(message.size);
        return writer;
    };

    /**
     * Encodes the specified PatchDetails message, length delimited. Does not implicitly {@link PatchDetails.verify|verify} messages.
     * @function encodeDelimited
     * @memberof PatchDetails
     * @static
     * @param {IPatchDetails} message PatchDetails message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    PatchDetails.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a PatchDetails message from the specified reader or buffer.
     * @function decode
     * @memberof PatchDetails
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {PatchDetails} PatchDetails
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    PatchDetails.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.PatchDetails();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.baseVersionCode = reader.int32();
                break;
            case 2:
                message.size = reader.int64();
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a PatchDetails message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof PatchDetails
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {PatchDetails} PatchDetails
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    PatchDetails.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a PatchDetails message.
     * @function verify
     * @memberof PatchDetails
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    PatchDetails.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.baseVersionCode != null && message.hasOwnProperty("baseVersionCode"))
            if (!$util.isInteger(message.baseVersionCode))
                return "baseVersionCode: integer expected";
        if (message.size != null && message.hasOwnProperty("size"))
            if (!$util.isInteger(message.size) && !(message.size && $util.isInteger(message.size.low) && $util.isInteger(message.size.high)))
                return "size: integer|Long expected";
        return null;
    };

    /**
     * Creates a PatchDetails message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof PatchDetails
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {PatchDetails} PatchDetails
     */
    PatchDetails.fromObject = function fromObject(object) {
        if (object instanceof $root.PatchDetails)
            return object;
        var message = new $root.PatchDetails();
        if (object.baseVersionCode != null)
            message.baseVersionCode = object.baseVersionCode | 0;
        if (object.size != null)
            if ($util.Long)
                (message.size = $util.Long.fromValue(object.size)).unsigned = false;
            else if (typeof object.size === "string")
                message.size = parseInt(object.size, 10);
            else if (typeof object.size === "number")
                message.size = object.size;
            else if (typeof object.size === "object")
                message.size = new $util.LongBits(object.size.low >>> 0, object.size.high >>> 0).toNumber();
        return message;
    };

    /**
     * Creates a plain object from a PatchDetails message. Also converts values to other types if specified.
     * @function toObject
     * @memberof PatchDetails
     * @static
     * @param {PatchDetails} message PatchDetails
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    PatchDetails.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        var object = {};
        if (options.defaults) {
            object.baseVersionCode = 0;
            if ($util.Long) {
                var long = new $util.Long(0, 0, false);
                object.size = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
            } else
                object.size = options.longs === String ? "0" : 0;
        }
        if (message.baseVersionCode != null && message.hasOwnProperty("baseVersionCode"))
            object.baseVersionCode = message.baseVersionCode;
        if (message.size != null && message.hasOwnProperty("size"))
            if (typeof message.size === "number")
                object.size = options.longs === String ? String(message.size) : message.size;
            else
                object.size = options.longs === String ? $util.Long.prototype.toString.call(message.size) : options.longs === Number ? new $util.LongBits(message.size.low >>> 0, message.size.high >>> 0).toNumber() : message.size;
        return object;
    };

    /**
     * Converts this PatchDetails to JSON.
     * @function toJSON
     * @memberof PatchDetails
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    PatchDetails.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return PatchDetails;
})();

$root.FileMetadata = (function() {

    /**
     * Properties of a FileMetadata.
     * @exports IFileMetadata
     * @interface IFileMetadata
     * @property {number|null} [fileType] FileMetadata fileType
     * @property {number|null} [versionCode] FileMetadata versionCode
     * @property {number|Long|null} [size] FileMetadata size
     * @property {string|null} [splitId] FileMetadata splitId
     * @property {number|Long|null} [compressedSize] FileMetadata compressedSize
     * @property {Array.<IPatchDetails>|null} [patchDetails] FileMetadata patchDetails
     */

    /**
     * Constructs a new FileMetadata.
     * @exports FileMetadata
     * @classdesc Represents a FileMetadata.
     * @implements IFileMetadata
     * @constructor
     * @param {IFileMetadata=} [properties] Properties to set
     */
    function FileMetadata(properties) {
        this.patchDetails = [];
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * FileMetadata fileType.
     * @member {number} fileType
     * @memberof FileMetadata
     * @instance
     */
    FileMetadata.prototype.fileType = 0;

    /**
     * FileMetadata versionCode.
     * @member {number} versionCode
     * @memberof FileMetadata
     * @instance
     */
    FileMetadata.prototype.versionCode = 0;

    /**
     * FileMetadata size.
     * @member {number|Long} size
     * @memberof FileMetadata
     * @instance
     */
    FileMetadata.prototype.size = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

    /**
     * FileMetadata splitId.
     * @member {string} splitId
     * @memberof FileMetadata
     * @instance
     */
    FileMetadata.prototype.splitId = "";

    /**
     * FileMetadata compressedSize.
     * @member {number|Long} compressedSize
     * @memberof FileMetadata
     * @instance
     */
    FileMetadata.prototype.compressedSize = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

    /**
     * FileMetadata patchDetails.
     * @member {Array.<IPatchDetails>} patchDetails
     * @memberof FileMetadata
     * @instance
     */
    FileMetadata.prototype.patchDetails = $util.emptyArray;

    /**
     * Creates a new FileMetadata instance using the specified properties.
     * @function create
     * @memberof FileMetadata
     * @static
     * @param {IFileMetadata=} [properties] Properties to set
     * @returns {FileMetadata} FileMetadata instance
     */
    FileMetadata.create = function create(properties) {
        return new FileMetadata(properties);
    };

    /**
     * Encodes the specified FileMetadata message. Does not implicitly {@link FileMetadata.verify|verify} messages.
     * @function encode
     * @memberof FileMetadata
     * @static
     * @param {IFileMetadata} message FileMetadata message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    FileMetadata.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.fileType != null && Object.hasOwnProperty.call(message, "fileType"))
            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.fileType);
        if (message.versionCode != null && Object.hasOwnProperty.call(message, "versionCode"))
            writer.uint32(/* id 2, wireType 0 =*/16).int32(message.versionCode);
        if (message.size != null && Object.hasOwnProperty.call(message, "size"))
            writer.uint32(/* id 3, wireType 0 =*/24).int64(message.size);
        if (message.splitId != null && Object.hasOwnProperty.call(message, "splitId"))
            writer.uint32(/* id 4, wireType 2 =*/34).string(message.splitId);
        if (message.compressedSize != null && Object.hasOwnProperty.call(message, "compressedSize"))
            writer.uint32(/* id 5, wireType 0 =*/40).int64(message.compressedSize);
        if (message.patchDetails != null && message.patchDetails.length)
            for (var i = 0; i < message.patchDetails.length; ++i)
                $root.PatchDetails.encode(message.patchDetails[i], writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
        return writer;
    };

    /**
     * Encodes the specified FileMetadata message, length delimited. Does not implicitly {@link FileMetadata.verify|verify} messages.
     * @function encodeDelimited
     * @memberof FileMetadata
     * @static
     * @param {IFileMetadata} message FileMetadata message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    FileMetadata.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a FileMetadata message from the specified reader or buffer.
     * @function decode
     * @memberof FileMetadata
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {FileMetadata} FileMetadata
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    FileMetadata.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.FileMetadata();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.fileType = reader.int32();
                break;
            case 2:
                message.versionCode = reader.int32();
                break;
            case 3:
                message.size = reader.int64();
                break;
            case 4:
                message.splitId = reader.string();
                break;
            case 5:
                message.compressedSize = reader.int64();
                break;
            case 6:
                if (!(message.patchDetails && message.patchDetails.length))
                    message.patchDetails = [];
                message.patchDetails.push($root.PatchDetails.decode(reader, reader.uint32()));
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a FileMetadata message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof FileMetadata
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {FileMetadata} FileMetadata
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    FileMetadata.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a FileMetadata message.
     * @function verify
     * @memberof FileMetadata
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    FileMetadata.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.fileType != null && message.hasOwnProperty("fileType"))
            if (!$util.isInteger(message.fileType))
                return "fileType: integer expected";
        if (message.versionCode != null && message.hasOwnProperty("versionCode"))
            if (!$util.isInteger(message.versionCode))
                return "versionCode: integer expected";
        if (message.size != null && message.hasOwnProperty("size"))
            if (!$util.isInteger(message.size) && !(message.size && $util.isInteger(message.size.low) && $util.isInteger(message.size.high)))
                return "size: integer|Long expected";
        if (message.splitId != null && message.hasOwnProperty("splitId"))
            if (!$util.isString(message.splitId))
                return "splitId: string expected";
        if (message.compressedSize != null && message.hasOwnProperty("compressedSize"))
            if (!$util.isInteger(message.compressedSize) && !(message.compressedSize && $util.isInteger(message.compressedSize.low) && $util.isInteger(message.compressedSize.high)))
                return "compressedSize: integer|Long expected";
        if (message.patchDetails != null && message.hasOwnProperty("patchDetails")) {
            if (!Array.isArray(message.patchDetails))
                return "patchDetails: array expected";
            for (var i = 0; i < message.patchDetails.length; ++i) {
                var error = $root.PatchDetails.verify(message.patchDetails[i]);
                if (error)
                    return "patchDetails." + error;
            }
        }
        return null;
    };

    /**
     * Creates a FileMetadata message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof FileMetadata
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {FileMetadata} FileMetadata
     */
    FileMetadata.fromObject = function fromObject(object) {
        if (object instanceof $root.FileMetadata)
            return object;
        var message = new $root.FileMetadata();
        if (object.fileType != null)
            message.fileType = object.fileType | 0;
        if (object.versionCode != null)
            message.versionCode = object.versionCode | 0;
        if (object.size != null)
            if ($util.Long)
                (message.size = $util.Long.fromValue(object.size)).unsigned = false;
            else if (typeof object.size === "string")
                message.size = parseInt(object.size, 10);
            else if (typeof object.size === "number")
                message.size = object.size;
            else if (typeof object.size === "object")
                message.size = new $util.LongBits(object.size.low >>> 0, object.size.high >>> 0).toNumber();
        if (object.splitId != null)
            message.splitId = String(object.splitId);
        if (object.compressedSize != null)
            if ($util.Long)
                (message.compressedSize = $util.Long.fromValue(object.compressedSize)).unsigned = false;
            else if (typeof object.compressedSize === "string")
                message.compressedSize = parseInt(object.compressedSize, 10);
            else if (typeof object.compressedSize === "number")
                message.compressedSize = object.compressedSize;
            else if (typeof object.compressedSize === "object")
                message.compressedSize = new $util.LongBits(object.compressedSize.low >>> 0, object.compressedSize.high >>> 0).toNumber();
        if (object.patchDetails) {
            if (!Array.isArray(object.patchDetails))
                throw TypeError(".FileMetadata.patchDetails: array expected");
            message.patchDetails = [];
            for (var i = 0; i < object.patchDetails.length; ++i) {
                if (typeof object.patchDetails[i] !== "object")
                    throw TypeError(".FileMetadata.patchDetails: object expected");
                message.patchDetails[i] = $root.PatchDetails.fromObject(object.patchDetails[i]);
            }
        }
        return message;
    };

    /**
     * Creates a plain object from a FileMetadata message. Also converts values to other types if specified.
     * @function toObject
     * @memberof FileMetadata
     * @static
     * @param {FileMetadata} message FileMetadata
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    FileMetadata.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        var object = {};
        if (options.arrays || options.defaults)
            object.patchDetails = [];
        if (options.defaults) {
            object.fileType = 0;
            object.versionCode = 0;
            if ($util.Long) {
                var long = new $util.Long(0, 0, false);
                object.size = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
            } else
                object.size = options.longs === String ? "0" : 0;
            object.splitId = "";
            if ($util.Long) {
                var long = new $util.Long(0, 0, false);
                object.compressedSize = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
            } else
                object.compressedSize = options.longs === String ? "0" : 0;
        }
        if (message.fileType != null && message.hasOwnProperty("fileType"))
            object.fileType = message.fileType;
        if (message.versionCode != null && message.hasOwnProperty("versionCode"))
            object.versionCode = message.versionCode;
        if (message.size != null && message.hasOwnProperty("size"))
            if (typeof message.size === "number")
                object.size = options.longs === String ? String(message.size) : message.size;
            else
                object.size = options.longs === String ? $util.Long.prototype.toString.call(message.size) : options.longs === Number ? new $util.LongBits(message.size.low >>> 0, message.size.high >>> 0).toNumber() : message.size;
        if (message.splitId != null && message.hasOwnProperty("splitId"))
            object.splitId = message.splitId;
        if (message.compressedSize != null && message.hasOwnProperty("compressedSize"))
            if (typeof message.compressedSize === "number")
                object.compressedSize = options.longs === String ? String(message.compressedSize) : message.compressedSize;
            else
                object.compressedSize = options.longs === String ? $util.Long.prototype.toString.call(message.compressedSize) : options.longs === Number ? new $util.LongBits(message.compressedSize.low >>> 0, message.compressedSize.high >>> 0).toNumber() : message.compressedSize;
        if (message.patchDetails && message.patchDetails.length) {
            object.patchDetails = [];
            for (var j = 0; j < message.patchDetails.length; ++j)
                object.patchDetails[j] = $root.PatchDetails.toObject(message.patchDetails[j], options);
        }
        return object;
    };

    /**
     * Converts this FileMetadata to JSON.
     * @function toJSON
     * @memberof FileMetadata
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    FileMetadata.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return FileMetadata;
})();

$root.SubscriptionDetails = (function() {

    /**
     * Properties of a SubscriptionDetails.
     * @exports ISubscriptionDetails
     * @interface ISubscriptionDetails
     * @property {number|null} [subscriptionPeriod] SubscriptionDetails subscriptionPeriod
     */

    /**
     * Constructs a new SubscriptionDetails.
     * @exports SubscriptionDetails
     * @classdesc Represents a SubscriptionDetails.
     * @implements ISubscriptionDetails
     * @constructor
     * @param {ISubscriptionDetails=} [properties] Properties to set
     */
    function SubscriptionDetails(properties) {
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * SubscriptionDetails subscriptionPeriod.
     * @member {number} subscriptionPeriod
     * @memberof SubscriptionDetails
     * @instance
     */
    SubscriptionDetails.prototype.subscriptionPeriod = 0;

    /**
     * Creates a new SubscriptionDetails instance using the specified properties.
     * @function create
     * @memberof SubscriptionDetails
     * @static
     * @param {ISubscriptionDetails=} [properties] Properties to set
     * @returns {SubscriptionDetails} SubscriptionDetails instance
     */
    SubscriptionDetails.create = function create(properties) {
        return new SubscriptionDetails(properties);
    };

    /**
     * Encodes the specified SubscriptionDetails message. Does not implicitly {@link SubscriptionDetails.verify|verify} messages.
     * @function encode
     * @memberof SubscriptionDetails
     * @static
     * @param {ISubscriptionDetails} message SubscriptionDetails message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    SubscriptionDetails.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.subscriptionPeriod != null && Object.hasOwnProperty.call(message, "subscriptionPeriod"))
            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.subscriptionPeriod);
        return writer;
    };

    /**
     * Encodes the specified SubscriptionDetails message, length delimited. Does not implicitly {@link SubscriptionDetails.verify|verify} messages.
     * @function encodeDelimited
     * @memberof SubscriptionDetails
     * @static
     * @param {ISubscriptionDetails} message SubscriptionDetails message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    SubscriptionDetails.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a SubscriptionDetails message from the specified reader or buffer.
     * @function decode
     * @memberof SubscriptionDetails
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {SubscriptionDetails} SubscriptionDetails
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    SubscriptionDetails.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.SubscriptionDetails();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.subscriptionPeriod = reader.int32();
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a SubscriptionDetails message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof SubscriptionDetails
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {SubscriptionDetails} SubscriptionDetails
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    SubscriptionDetails.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a SubscriptionDetails message.
     * @function verify
     * @memberof SubscriptionDetails
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    SubscriptionDetails.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.subscriptionPeriod != null && message.hasOwnProperty("subscriptionPeriod"))
            if (!$util.isInteger(message.subscriptionPeriod))
                return "subscriptionPeriod: integer expected";
        return null;
    };

    /**
     * Creates a SubscriptionDetails message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof SubscriptionDetails
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {SubscriptionDetails} SubscriptionDetails
     */
    SubscriptionDetails.fromObject = function fromObject(object) {
        if (object instanceof $root.SubscriptionDetails)
            return object;
        var message = new $root.SubscriptionDetails();
        if (object.subscriptionPeriod != null)
            message.subscriptionPeriod = object.subscriptionPeriod | 0;
        return message;
    };

    /**
     * Creates a plain object from a SubscriptionDetails message. Also converts values to other types if specified.
     * @function toObject
     * @memberof SubscriptionDetails
     * @static
     * @param {SubscriptionDetails} message SubscriptionDetails
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    SubscriptionDetails.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        var object = {};
        if (options.defaults)
            object.subscriptionPeriod = 0;
        if (message.subscriptionPeriod != null && message.hasOwnProperty("subscriptionPeriod"))
            object.subscriptionPeriod = message.subscriptionPeriod;
        return object;
    };

    /**
     * Converts this SubscriptionDetails to JSON.
     * @function toJSON
     * @memberof SubscriptionDetails
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    SubscriptionDetails.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return SubscriptionDetails;
})();

$root.Bucket = (function() {

    /**
     * Properties of a Bucket.
     * @exports IBucket
     * @interface IBucket
     * @property {boolean|null} [multiCorpus] Bucket multiCorpus
     * @property {string|null} [title] Bucket title
     * @property {string|null} [iconUrl] Bucket iconUrl
     * @property {string|null} [fullContentsUrl] Bucket fullContentsUrl
     * @property {number|null} [relevance] Bucket relevance
     * @property {number|Long|null} [estimatedResults] Bucket estimatedResults
     * @property {string|null} [analyticsCookie] Bucket analyticsCookie
     * @property {string|null} [fullContentsListUrl] Bucket fullContentsListUrl
     * @property {string|null} [nextPageUrl] Bucket nextPageUrl
     * @property {boolean|null} [ordered] Bucket ordered
     */

    /**
     * Constructs a new Bucket.
     * @exports Bucket
     * @classdesc Represents a Bucket.
     * @implements IBucket
     * @constructor
     * @param {IBucket=} [properties] Properties to set
     */
    function Bucket(properties) {
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * Bucket multiCorpus.
     * @member {boolean} multiCorpus
     * @memberof Bucket
     * @instance
     */
    Bucket.prototype.multiCorpus = false;

    /**
     * Bucket title.
     * @member {string} title
     * @memberof Bucket
     * @instance
     */
    Bucket.prototype.title = "";

    /**
     * Bucket iconUrl.
     * @member {string} iconUrl
     * @memberof Bucket
     * @instance
     */
    Bucket.prototype.iconUrl = "";

    /**
     * Bucket fullContentsUrl.
     * @member {string} fullContentsUrl
     * @memberof Bucket
     * @instance
     */
    Bucket.prototype.fullContentsUrl = "";

    /**
     * Bucket relevance.
     * @member {number} relevance
     * @memberof Bucket
     * @instance
     */
    Bucket.prototype.relevance = 0;

    /**
     * Bucket estimatedResults.
     * @member {number|Long} estimatedResults
     * @memberof Bucket
     * @instance
     */
    Bucket.prototype.estimatedResults = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

    /**
     * Bucket analyticsCookie.
     * @member {string} analyticsCookie
     * @memberof Bucket
     * @instance
     */
    Bucket.prototype.analyticsCookie = "";

    /**
     * Bucket fullContentsListUrl.
     * @member {string} fullContentsListUrl
     * @memberof Bucket
     * @instance
     */
    Bucket.prototype.fullContentsListUrl = "";

    /**
     * Bucket nextPageUrl.
     * @member {string} nextPageUrl
     * @memberof Bucket
     * @instance
     */
    Bucket.prototype.nextPageUrl = "";

    /**
     * Bucket ordered.
     * @member {boolean} ordered
     * @memberof Bucket
     * @instance
     */
    Bucket.prototype.ordered = false;

    /**
     * Creates a new Bucket instance using the specified properties.
     * @function create
     * @memberof Bucket
     * @static
     * @param {IBucket=} [properties] Properties to set
     * @returns {Bucket} Bucket instance
     */
    Bucket.create = function create(properties) {
        return new Bucket(properties);
    };

    /**
     * Encodes the specified Bucket message. Does not implicitly {@link Bucket.verify|verify} messages.
     * @function encode
     * @memberof Bucket
     * @static
     * @param {IBucket} message Bucket message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    Bucket.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.multiCorpus != null && Object.hasOwnProperty.call(message, "multiCorpus"))
            writer.uint32(/* id 2, wireType 0 =*/16).bool(message.multiCorpus);
        if (message.title != null && Object.hasOwnProperty.call(message, "title"))
            writer.uint32(/* id 3, wireType 2 =*/26).string(message.title);
        if (message.iconUrl != null && Object.hasOwnProperty.call(message, "iconUrl"))
            writer.uint32(/* id 4, wireType 2 =*/34).string(message.iconUrl);
        if (message.fullContentsUrl != null && Object.hasOwnProperty.call(message, "fullContentsUrl"))
            writer.uint32(/* id 5, wireType 2 =*/42).string(message.fullContentsUrl);
        if (message.relevance != null && Object.hasOwnProperty.call(message, "relevance"))
            writer.uint32(/* id 6, wireType 1 =*/49).double(message.relevance);
        if (message.estimatedResults != null && Object.hasOwnProperty.call(message, "estimatedResults"))
            writer.uint32(/* id 7, wireType 0 =*/56).int64(message.estimatedResults);
        if (message.analyticsCookie != null && Object.hasOwnProperty.call(message, "analyticsCookie"))
            writer.uint32(/* id 8, wireType 2 =*/66).string(message.analyticsCookie);
        if (message.fullContentsListUrl != null && Object.hasOwnProperty.call(message, "fullContentsListUrl"))
            writer.uint32(/* id 9, wireType 2 =*/74).string(message.fullContentsListUrl);
        if (message.nextPageUrl != null && Object.hasOwnProperty.call(message, "nextPageUrl"))
            writer.uint32(/* id 10, wireType 2 =*/82).string(message.nextPageUrl);
        if (message.ordered != null && Object.hasOwnProperty.call(message, "ordered"))
            writer.uint32(/* id 11, wireType 0 =*/88).bool(message.ordered);
        return writer;
    };

    /**
     * Encodes the specified Bucket message, length delimited. Does not implicitly {@link Bucket.verify|verify} messages.
     * @function encodeDelimited
     * @memberof Bucket
     * @static
     * @param {IBucket} message Bucket message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    Bucket.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a Bucket message from the specified reader or buffer.
     * @function decode
     * @memberof Bucket
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {Bucket} Bucket
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    Bucket.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Bucket();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            case 2:
                message.multiCorpus = reader.bool();
                break;
            case 3:
                message.title = reader.string();
                break;
            case 4:
                message.iconUrl = reader.string();
                break;
            case 5:
                message.fullContentsUrl = reader.string();
                break;
            case 6:
                message.relevance = reader.double();
                break;
            case 7:
                message.estimatedResults = reader.int64();
                break;
            case 8:
                message.analyticsCookie = reader.string();
                break;
            case 9:
                message.fullContentsListUrl = reader.string();
                break;
            case 10:
                message.nextPageUrl = reader.string();
                break;
            case 11:
                message.ordered = reader.bool();
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a Bucket message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof Bucket
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {Bucket} Bucket
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    Bucket.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a Bucket message.
     * @function verify
     * @memberof Bucket
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    Bucket.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.multiCorpus != null && message.hasOwnProperty("multiCorpus"))
            if (typeof message.multiCorpus !== "boolean")
                return "multiCorpus: boolean expected";
        if (message.title != null && message.hasOwnProperty("title"))
            if (!$util.isString(message.title))
                return "title: string expected";
        if (message.iconUrl != null && message.hasOwnProperty("iconUrl"))
            if (!$util.isString(message.iconUrl))
                return "iconUrl: string expected";
        if (message.fullContentsUrl != null && message.hasOwnProperty("fullContentsUrl"))
            if (!$util.isString(message.fullContentsUrl))
                return "fullContentsUrl: string expected";
        if (message.relevance != null && message.hasOwnProperty("relevance"))
            if (typeof message.relevance !== "number")
                return "relevance: number expected";
        if (message.estimatedResults != null && message.hasOwnProperty("estimatedResults"))
            if (!$util.isInteger(message.estimatedResults) && !(message.estimatedResults && $util.isInteger(message.estimatedResults.low) && $util.isInteger(message.estimatedResults.high)))
                return "estimatedResults: integer|Long expected";
        if (message.analyticsCookie != null && message.hasOwnProperty("analyticsCookie"))
            if (!$util.isString(message.analyticsCookie))
                return "analyticsCookie: string expected";
        if (message.fullContentsListUrl != null && message.hasOwnProperty("fullContentsListUrl"))
            if (!$util.isString(message.fullContentsListUrl))
                return "fullContentsListUrl: string expected";
        if (message.nextPageUrl != null && message.hasOwnProperty("nextPageUrl"))
            if (!$util.isString(message.nextPageUrl))
                return "nextPageUrl: string expected";
        if (message.ordered != null && message.hasOwnProperty("ordered"))
            if (typeof message.ordered !== "boolean")
                return "ordered: boolean expected";
        return null;
    };

    /**
     * Creates a Bucket message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof Bucket
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {Bucket} Bucket
     */
    Bucket.fromObject = function fromObject(object) {
        if (object instanceof $root.Bucket)
            return object;
        var message = new $root.Bucket();
        if (object.multiCorpus != null)
            message.multiCorpus = Boolean(object.multiCorpus);
        if (object.title != null)
            message.title = String(object.title);
        if (object.iconUrl != null)
            message.iconUrl = String(object.iconUrl);
        if (object.fullContentsUrl != null)
            message.fullContentsUrl = String(object.fullContentsUrl);
        if (object.relevance != null)
            message.relevance = Number(object.relevance);
        if (object.estimatedResults != null)
            if ($util.Long)
                (message.estimatedResults = $util.Long.fromValue(object.estimatedResults)).unsigned = false;
            else if (typeof object.estimatedResults === "string")
                message.estimatedResults = parseInt(object.estimatedResults, 10);
            else if (typeof object.estimatedResults === "number")
                message.estimatedResults = object.estimatedResults;
            else if (typeof object.estimatedResults === "object")
                message.estimatedResults = new $util.LongBits(object.estimatedResults.low >>> 0, object.estimatedResults.high >>> 0).toNumber();
        if (object.analyticsCookie != null)
            message.analyticsCookie = String(object.analyticsCookie);
        if (object.fullContentsListUrl != null)
            message.fullContentsListUrl = String(object.fullContentsListUrl);
        if (object.nextPageUrl != null)
            message.nextPageUrl = String(object.nextPageUrl);
        if (object.ordered != null)
            message.ordered = Boolean(object.ordered);
        return message;
    };

    /**
     * Creates a plain object from a Bucket message. Also converts values to other types if specified.
     * @function toObject
     * @memberof Bucket
     * @static
     * @param {Bucket} message Bucket
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    Bucket.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        var object = {};
        if (options.defaults) {
            object.multiCorpus = false;
            object.title = "";
            object.iconUrl = "";
            object.fullContentsUrl = "";
            object.relevance = 0;
            if ($util.Long) {
                var long = new $util.Long(0, 0, false);
                object.estimatedResults = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
            } else
                object.estimatedResults = options.longs === String ? "0" : 0;
            object.analyticsCookie = "";
            object.fullContentsListUrl = "";
            object.nextPageUrl = "";
            object.ordered = false;
        }
        if (message.multiCorpus != null && message.hasOwnProperty("multiCorpus"))
            object.multiCorpus = message.multiCorpus;
        if (message.title != null && message.hasOwnProperty("title"))
            object.title = message.title;
        if (message.iconUrl != null && message.hasOwnProperty("iconUrl"))
            object.iconUrl = message.iconUrl;
        if (message.fullContentsUrl != null && message.hasOwnProperty("fullContentsUrl"))
            object.fullContentsUrl = message.fullContentsUrl;
        if (message.relevance != null && message.hasOwnProperty("relevance"))
            object.relevance = options.json && !isFinite(message.relevance) ? String(message.relevance) : message.relevance;
        if (message.estimatedResults != null && message.hasOwnProperty("estimatedResults"))
            if (typeof message.estimatedResults === "number")
                object.estimatedResults = options.longs === String ? String(message.estimatedResults) : message.estimatedResults;
            else
                object.estimatedResults = options.longs === String ? $util.Long.prototype.toString.call(message.estimatedResults) : options.longs === Number ? new $util.LongBits(message.estimatedResults.low >>> 0, message.estimatedResults.high >>> 0).toNumber() : message.estimatedResults;
        if (message.analyticsCookie != null && message.hasOwnProperty("analyticsCookie"))
            object.analyticsCookie = message.analyticsCookie;
        if (message.fullContentsListUrl != null && message.hasOwnProperty("fullContentsListUrl"))
            object.fullContentsListUrl = message.fullContentsListUrl;
        if (message.nextPageUrl != null && message.hasOwnProperty("nextPageUrl"))
            object.nextPageUrl = message.nextPageUrl;
        if (message.ordered != null && message.hasOwnProperty("ordered"))
            object.ordered = message.ordered;
        return object;
    };

    /**
     * Converts this Bucket to JSON.
     * @function toJSON
     * @memberof Bucket
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    Bucket.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return Bucket;
})();

$root.ListResponse = (function() {

    /**
     * Properties of a ListResponse.
     * @exports IListResponse
     * @interface IListResponse
     * @property {Array.<IBucket>|null} [bucket] ListResponse bucket
     * @property {Array.<IItem>|null} [item] ListResponse item
     */

    /**
     * Constructs a new ListResponse.
     * @exports ListResponse
     * @classdesc Represents a ListResponse.
     * @implements IListResponse
     * @constructor
     * @param {IListResponse=} [properties] Properties to set
     */
    function ListResponse(properties) {
        this.bucket = [];
        this.item = [];
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * ListResponse bucket.
     * @member {Array.<IBucket>} bucket
     * @memberof ListResponse
     * @instance
     */
    ListResponse.prototype.bucket = $util.emptyArray;

    /**
     * ListResponse item.
     * @member {Array.<IItem>} item
     * @memberof ListResponse
     * @instance
     */
    ListResponse.prototype.item = $util.emptyArray;

    /**
     * Creates a new ListResponse instance using the specified properties.
     * @function create
     * @memberof ListResponse
     * @static
     * @param {IListResponse=} [properties] Properties to set
     * @returns {ListResponse} ListResponse instance
     */
    ListResponse.create = function create(properties) {
        return new ListResponse(properties);
    };

    /**
     * Encodes the specified ListResponse message. Does not implicitly {@link ListResponse.verify|verify} messages.
     * @function encode
     * @memberof ListResponse
     * @static
     * @param {IListResponse} message ListResponse message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    ListResponse.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.bucket != null && message.bucket.length)
            for (var i = 0; i < message.bucket.length; ++i)
                $root.Bucket.encode(message.bucket[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
        if (message.item != null && message.item.length)
            for (var i = 0; i < message.item.length; ++i)
                $root.Item.encode(message.item[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
        return writer;
    };

    /**
     * Encodes the specified ListResponse message, length delimited. Does not implicitly {@link ListResponse.verify|verify} messages.
     * @function encodeDelimited
     * @memberof ListResponse
     * @static
     * @param {IListResponse} message ListResponse message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    ListResponse.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a ListResponse message from the specified reader or buffer.
     * @function decode
     * @memberof ListResponse
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {ListResponse} ListResponse
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    ListResponse.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ListResponse();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                if (!(message.bucket && message.bucket.length))
                    message.bucket = [];
                message.bucket.push($root.Bucket.decode(reader, reader.uint32()));
                break;
            case 2:
                if (!(message.item && message.item.length))
                    message.item = [];
                message.item.push($root.Item.decode(reader, reader.uint32()));
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a ListResponse message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof ListResponse
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {ListResponse} ListResponse
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    ListResponse.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a ListResponse message.
     * @function verify
     * @memberof ListResponse
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    ListResponse.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.bucket != null && message.hasOwnProperty("bucket")) {
            if (!Array.isArray(message.bucket))
                return "bucket: array expected";
            for (var i = 0; i < message.bucket.length; ++i) {
                var error = $root.Bucket.verify(message.bucket[i]);
                if (error)
                    return "bucket." + error;
            }
        }
        if (message.item != null && message.hasOwnProperty("item")) {
            if (!Array.isArray(message.item))
                return "item: array expected";
            for (var i = 0; i < message.item.length; ++i) {
                var error = $root.Item.verify(message.item[i]);
                if (error)
                    return "item." + error;
            }
        }
        return null;
    };

    /**
     * Creates a ListResponse message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof ListResponse
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {ListResponse} ListResponse
     */
    ListResponse.fromObject = function fromObject(object) {
        if (object instanceof $root.ListResponse)
            return object;
        var message = new $root.ListResponse();
        if (object.bucket) {
            if (!Array.isArray(object.bucket))
                throw TypeError(".ListResponse.bucket: array expected");
            message.bucket = [];
            for (var i = 0; i < object.bucket.length; ++i) {
                if (typeof object.bucket[i] !== "object")
                    throw TypeError(".ListResponse.bucket: object expected");
                message.bucket[i] = $root.Bucket.fromObject(object.bucket[i]);
            }
        }
        if (object.item) {
            if (!Array.isArray(object.item))
                throw TypeError(".ListResponse.item: array expected");
            message.item = [];
            for (var i = 0; i < object.item.length; ++i) {
                if (typeof object.item[i] !== "object")
                    throw TypeError(".ListResponse.item: object expected");
                message.item[i] = $root.Item.fromObject(object.item[i]);
            }
        }
        return message;
    };

    /**
     * Creates a plain object from a ListResponse message. Also converts values to other types if specified.
     * @function toObject
     * @memberof ListResponse
     * @static
     * @param {ListResponse} message ListResponse
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    ListResponse.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        var object = {};
        if (options.arrays || options.defaults) {
            object.bucket = [];
            object.item = [];
        }
        if (message.bucket && message.bucket.length) {
            object.bucket = [];
            for (var j = 0; j < message.bucket.length; ++j)
                object.bucket[j] = $root.Bucket.toObject(message.bucket[j], options);
        }
        if (message.item && message.item.length) {
            object.item = [];
            for (var j = 0; j < message.item.length; ++j)
                object.item[j] = $root.Item.toObject(message.item[j], options);
        }
        return object;
    };

    /**
     * Converts this ListResponse to JSON.
     * @function toJSON
     * @memberof ListResponse
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    ListResponse.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return ListResponse;
})();

$root.Item = (function() {

    /**
     * Properties of an Item.
     * @exports IItem
     * @interface IItem
     * @property {string|null} [id] Item id
     * @property {string|null} [subId] Item subId
     * @property {number|null} [type] Item type
     * @property {number|null} [categoryId] Item categoryId
     * @property {string|null} [title] Item title
     * @property {string|null} [creator] Item creator
     * @property {string|null} [descriptionHtml] Item descriptionHtml
     * @property {Array.<IOffer>|null} [offer] Item offer
     * @property {IAvailability|null} [availability] Item availability
     * @property {Array.<IImage>|null} [image] Item image
     * @property {Array.<IItem>|null} [subItem] Item subItem
     * @property {IContainerMetadata|null} [containerMetadata] Item containerMetadata
     * @property {IDocumentDetails|null} [details] Item details
     * @property {IAggregateRating|null} [aggregateRating] Item aggregateRating
     * @property {IAnnotations|null} [annotations] Item annotations
     * @property {string|null} [detailsUrl] Item detailsUrl
     * @property {string|null} [shareUrl] Item shareUrl
     * @property {string|null} [reviewsUrl] Item reviewsUrl
     * @property {string|null} [backendUrl] Item backendUrl
     * @property {string|null} [purchaseDetailsUrl] Item purchaseDetailsUrl
     * @property {boolean|null} [detailsReusable] Item detailsReusable
     * @property {string|null} [subtitle] Item subtitle
     * @property {string|null} [translatedDescriptionHtml] Item translatedDescriptionHtml
     * @property {Uint8Array|null} [serverLogsCookie] Item serverLogsCookie
     * @property {IAppInfo|null} [appInfo] Item appInfo
     * @property {boolean|null} [mature] Item mature
     * @property {string|null} [promotionalDescription] Item promotionalDescription
     * @property {boolean|null} [availableForPreregistration] Item availableForPreregistration
     * @property {Array.<IReviewTip>|null} [tip] Item tip
     * @property {string|null} [reviewSnippetsUrl] Item reviewSnippetsUrl
     * @property {boolean|null} [forceShareability] Item forceShareability
     * @property {boolean|null} [useWishlistAsPrimaryAction] Item useWishlistAsPrimaryAction
     * @property {string|null} [reviewQuestionsUrl] Item reviewQuestionsUrl
     * @property {string|null} [reviewSummaryUrl] Item reviewSummaryUrl
     */

    /**
     * Constructs a new Item.
     * @exports Item
     * @classdesc Represents an Item.
     * @implements IItem
     * @constructor
     * @param {IItem=} [properties] Properties to set
     */
    function Item(properties) {
        this.offer = [];
        this.image = [];
        this.subItem = [];
        this.tip = [];
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * Item id.
     * @member {string} id
     * @memberof Item
     * @instance
     */
    Item.prototype.id = "";

    /**
     * Item subId.
     * @member {string} subId
     * @memberof Item
     * @instance
     */
    Item.prototype.subId = "";

    /**
     * Item type.
     * @member {number} type
     * @memberof Item
     * @instance
     */
    Item.prototype.type = 0;

    /**
     * Item categoryId.
     * @member {number} categoryId
     * @memberof Item
     * @instance
     */
    Item.prototype.categoryId = 0;

    /**
     * Item title.
     * @member {string} title
     * @memberof Item
     * @instance
     */
    Item.prototype.title = "";

    /**
     * Item creator.
     * @member {string} creator
     * @memberof Item
     * @instance
     */
    Item.prototype.creator = "";

    /**
     * Item descriptionHtml.
     * @member {string} descriptionHtml
     * @memberof Item
     * @instance
     */
    Item.prototype.descriptionHtml = "";

    /**
     * Item offer.
     * @member {Array.<IOffer>} offer
     * @memberof Item
     * @instance
     */
    Item.prototype.offer = $util.emptyArray;

    /**
     * Item availability.
     * @member {IAvailability|null|undefined} availability
     * @memberof Item
     * @instance
     */
    Item.prototype.availability = null;

    /**
     * Item image.
     * @member {Array.<IImage>} image
     * @memberof Item
     * @instance
     */
    Item.prototype.image = $util.emptyArray;

    /**
     * Item subItem.
     * @member {Array.<IItem>} subItem
     * @memberof Item
     * @instance
     */
    Item.prototype.subItem = $util.emptyArray;

    /**
     * Item containerMetadata.
     * @member {IContainerMetadata|null|undefined} containerMetadata
     * @memberof Item
     * @instance
     */
    Item.prototype.containerMetadata = null;

    /**
     * Item details.
     * @member {IDocumentDetails|null|undefined} details
     * @memberof Item
     * @instance
     */
    Item.prototype.details = null;

    /**
     * Item aggregateRating.
     * @member {IAggregateRating|null|undefined} aggregateRating
     * @memberof Item
     * @instance
     */
    Item.prototype.aggregateRating = null;

    /**
     * Item annotations.
     * @member {IAnnotations|null|undefined} annotations
     * @memberof Item
     * @instance
     */
    Item.prototype.annotations = null;

    /**
     * Item detailsUrl.
     * @member {string} detailsUrl
     * @memberof Item
     * @instance
     */
    Item.prototype.detailsUrl = "";

    /**
     * Item shareUrl.
     * @member {string} shareUrl
     * @memberof Item
     * @instance
     */
    Item.prototype.shareUrl = "";

    /**
     * Item reviewsUrl.
     * @member {string} reviewsUrl
     * @memberof Item
     * @instance
     */
    Item.prototype.reviewsUrl = "";

    /**
     * Item backendUrl.
     * @member {string} backendUrl
     * @memberof Item
     * @instance
     */
    Item.prototype.backendUrl = "";

    /**
     * Item purchaseDetailsUrl.
     * @member {string} purchaseDetailsUrl
     * @memberof Item
     * @instance
     */
    Item.prototype.purchaseDetailsUrl = "";

    /**
     * Item detailsReusable.
     * @member {boolean} detailsReusable
     * @memberof Item
     * @instance
     */
    Item.prototype.detailsReusable = false;

    /**
     * Item subtitle.
     * @member {string} subtitle
     * @memberof Item
     * @instance
     */
    Item.prototype.subtitle = "";

    /**
     * Item translatedDescriptionHtml.
     * @member {string} translatedDescriptionHtml
     * @memberof Item
     * @instance
     */
    Item.prototype.translatedDescriptionHtml = "";

    /**
     * Item serverLogsCookie.
     * @member {Uint8Array} serverLogsCookie
     * @memberof Item
     * @instance
     */
    Item.prototype.serverLogsCookie = $util.newBuffer([]);

    /**
     * Item appInfo.
     * @member {IAppInfo|null|undefined} appInfo
     * @memberof Item
     * @instance
     */
    Item.prototype.appInfo = null;

    /**
     * Item mature.
     * @member {boolean} mature
     * @memberof Item
     * @instance
     */
    Item.prototype.mature = false;

    /**
     * Item promotionalDescription.
     * @member {string} promotionalDescription
     * @memberof Item
     * @instance
     */
    Item.prototype.promotionalDescription = "";

    /**
     * Item availableForPreregistration.
     * @member {boolean} availableForPreregistration
     * @memberof Item
     * @instance
     */
    Item.prototype.availableForPreregistration = false;

    /**
     * Item tip.
     * @member {Array.<IReviewTip>} tip
     * @memberof Item
     * @instance
     */
    Item.prototype.tip = $util.emptyArray;

    /**
     * Item reviewSnippetsUrl.
     * @member {string} reviewSnippetsUrl
     * @memberof Item
     * @instance
     */
    Item.prototype.reviewSnippetsUrl = "";

    /**
     * Item forceShareability.
     * @member {boolean} forceShareability
     * @memberof Item
     * @instance
     */
    Item.prototype.forceShareability = false;

    /**
     * Item useWishlistAsPrimaryAction.
     * @member {boolean} useWishlistAsPrimaryAction
     * @memberof Item
     * @instance
     */
    Item.prototype.useWishlistAsPrimaryAction = false;

    /**
     * Item reviewQuestionsUrl.
     * @member {string} reviewQuestionsUrl
     * @memberof Item
     * @instance
     */
    Item.prototype.reviewQuestionsUrl = "";

    /**
     * Item reviewSummaryUrl.
     * @member {string} reviewSummaryUrl
     * @memberof Item
     * @instance
     */
    Item.prototype.reviewSummaryUrl = "";

    /**
     * Creates a new Item instance using the specified properties.
     * @function create
     * @memberof Item
     * @static
     * @param {IItem=} [properties] Properties to set
     * @returns {Item} Item instance
     */
    Item.create = function create(properties) {
        return new Item(properties);
    };

    /**
     * Encodes the specified Item message. Does not implicitly {@link Item.verify|verify} messages.
     * @function encode
     * @memberof Item
     * @static
     * @param {IItem} message Item message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    Item.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.id != null && Object.hasOwnProperty.call(message, "id"))
            writer.uint32(/* id 1, wireType 2 =*/10).string(message.id);
        if (message.subId != null && Object.hasOwnProperty.call(message, "subId"))
            writer.uint32(/* id 2, wireType 2 =*/18).string(message.subId);
        if (message.type != null && Object.hasOwnProperty.call(message, "type"))
            writer.uint32(/* id 3, wireType 0 =*/24).int32(message.type);
        if (message.categoryId != null && Object.hasOwnProperty.call(message, "categoryId"))
            writer.uint32(/* id 4, wireType 0 =*/32).int32(message.categoryId);
        if (message.title != null && Object.hasOwnProperty.call(message, "title"))
            writer.uint32(/* id 5, wireType 2 =*/42).string(message.title);
        if (message.creator != null && Object.hasOwnProperty.call(message, "creator"))
            writer.uint32(/* id 6, wireType 2 =*/50).string(message.creator);
        if (message.descriptionHtml != null && Object.hasOwnProperty.call(message, "descriptionHtml"))
            writer.uint32(/* id 7, wireType 2 =*/58).string(message.descriptionHtml);
        if (message.offer != null && message.offer.length)
            for (var i = 0; i < message.offer.length; ++i)
                $root.Offer.encode(message.offer[i], writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();
        if (message.availability != null && Object.hasOwnProperty.call(message, "availability"))
            $root.Availability.encode(message.availability, writer.uint32(/* id 9, wireType 2 =*/74).fork()).ldelim();
        if (message.image != null && message.image.length)
            for (var i = 0; i < message.image.length; ++i)
                $root.Image.encode(message.image[i], writer.uint32(/* id 10, wireType 2 =*/82).fork()).ldelim();
        if (message.subItem != null && message.subItem.length)
            for (var i = 0; i < message.subItem.length; ++i)
                $root.Item.encode(message.subItem[i], writer.uint32(/* id 11, wireType 2 =*/90).fork()).ldelim();
        if (message.containerMetadata != null && Object.hasOwnProperty.call(message, "containerMetadata"))
            $root.ContainerMetadata.encode(message.containerMetadata, writer.uint32(/* id 12, wireType 2 =*/98).fork()).ldelim();
        if (message.details != null && Object.hasOwnProperty.call(message, "details"))
            $root.DocumentDetails.encode(message.details, writer.uint32(/* id 13, wireType 2 =*/106).fork()).ldelim();
        if (message.aggregateRating != null && Object.hasOwnProperty.call(message, "aggregateRating"))
            $root.AggregateRating.encode(message.aggregateRating, writer.uint32(/* id 14, wireType 2 =*/114).fork()).ldelim();
        if (message.annotations != null && Object.hasOwnProperty.call(message, "annotations"))
            $root.Annotations.encode(message.annotations, writer.uint32(/* id 15, wireType 2 =*/122).fork()).ldelim();
        if (message.detailsUrl != null && Object.hasOwnProperty.call(message, "detailsUrl"))
            writer.uint32(/* id 16, wireType 2 =*/130).string(message.detailsUrl);
        if (message.shareUrl != null && Object.hasOwnProperty.call(message, "shareUrl"))
            writer.uint32(/* id 17, wireType 2 =*/138).string(message.shareUrl);
        if (message.reviewsUrl != null && Object.hasOwnProperty.call(message, "reviewsUrl"))
            writer.uint32(/* id 18, wireType 2 =*/146).string(message.reviewsUrl);
        if (message.backendUrl != null && Object.hasOwnProperty.call(message, "backendUrl"))
            writer.uint32(/* id 19, wireType 2 =*/154).string(message.backendUrl);
        if (message.purchaseDetailsUrl != null && Object.hasOwnProperty.call(message, "purchaseDetailsUrl"))
            writer.uint32(/* id 20, wireType 2 =*/162).string(message.purchaseDetailsUrl);
        if (message.detailsReusable != null && Object.hasOwnProperty.call(message, "detailsReusable"))
            writer.uint32(/* id 21, wireType 0 =*/168).bool(message.detailsReusable);
        if (message.subtitle != null && Object.hasOwnProperty.call(message, "subtitle"))
            writer.uint32(/* id 22, wireType 2 =*/178).string(message.subtitle);
        if (message.translatedDescriptionHtml != null && Object.hasOwnProperty.call(message, "translatedDescriptionHtml"))
            writer.uint32(/* id 23, wireType 2 =*/186).string(message.translatedDescriptionHtml);
        if (message.serverLogsCookie != null && Object.hasOwnProperty.call(message, "serverLogsCookie"))
            writer.uint32(/* id 24, wireType 2 =*/194).bytes(message.serverLogsCookie);
        if (message.appInfo != null && Object.hasOwnProperty.call(message, "appInfo"))
            $root.AppInfo.encode(message.appInfo, writer.uint32(/* id 25, wireType 2 =*/202).fork()).ldelim();
        if (message.mature != null && Object.hasOwnProperty.call(message, "mature"))
            writer.uint32(/* id 26, wireType 0 =*/208).bool(message.mature);
        if (message.promotionalDescription != null && Object.hasOwnProperty.call(message, "promotionalDescription"))
            writer.uint32(/* id 27, wireType 2 =*/218).string(message.promotionalDescription);
        if (message.availableForPreregistration != null && Object.hasOwnProperty.call(message, "availableForPreregistration"))
            writer.uint32(/* id 29, wireType 0 =*/232).bool(message.availableForPreregistration);
        if (message.tip != null && message.tip.length)
            for (var i = 0; i < message.tip.length; ++i)
                $root.ReviewTip.encode(message.tip[i], writer.uint32(/* id 30, wireType 2 =*/242).fork()).ldelim();
        if (message.reviewSnippetsUrl != null && Object.hasOwnProperty.call(message, "reviewSnippetsUrl"))
            writer.uint32(/* id 31, wireType 2 =*/250).string(message.reviewSnippetsUrl);
        if (message.forceShareability != null && Object.hasOwnProperty.call(message, "forceShareability"))
            writer.uint32(/* id 32, wireType 0 =*/256).bool(message.forceShareability);
        if (message.useWishlistAsPrimaryAction != null && Object.hasOwnProperty.call(message, "useWishlistAsPrimaryAction"))
            writer.uint32(/* id 33, wireType 0 =*/264).bool(message.useWishlistAsPrimaryAction);
        if (message.reviewQuestionsUrl != null && Object.hasOwnProperty.call(message, "reviewQuestionsUrl"))
            writer.uint32(/* id 34, wireType 2 =*/274).string(message.reviewQuestionsUrl);
        if (message.reviewSummaryUrl != null && Object.hasOwnProperty.call(message, "reviewSummaryUrl"))
            writer.uint32(/* id 39, wireType 2 =*/314).string(message.reviewSummaryUrl);
        return writer;
    };

    /**
     * Encodes the specified Item message, length delimited. Does not implicitly {@link Item.verify|verify} messages.
     * @function encodeDelimited
     * @memberof Item
     * @static
     * @param {IItem} message Item message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    Item.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes an Item message from the specified reader or buffer.
     * @function decode
     * @memberof Item
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {Item} Item
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    Item.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Item();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.id = reader.string();
                break;
            case 2:
                message.subId = reader.string();
                break;
            case 3:
                message.type = reader.int32();
                break;
            case 4:
                message.categoryId = reader.int32();
                break;
            case 5:
                message.title = reader.string();
                break;
            case 6:
                message.creator = reader.string();
                break;
            case 7:
                message.descriptionHtml = reader.string();
                break;
            case 8:
                if (!(message.offer && message.offer.length))
                    message.offer = [];
                message.offer.push($root.Offer.decode(reader, reader.uint32()));
                break;
            case 9:
                message.availability = $root.Availability.decode(reader, reader.uint32());
                break;
            case 10:
                if (!(message.image && message.image.length))
                    message.image = [];
                message.image.push($root.Image.decode(reader, reader.uint32()));
                break;
            case 11:
                if (!(message.subItem && message.subItem.length))
                    message.subItem = [];
                message.subItem.push($root.Item.decode(reader, reader.uint32()));
                break;
            case 12:
                message.containerMetadata = $root.ContainerMetadata.decode(reader, reader.uint32());
                break;
            case 13:
                message.details = $root.DocumentDetails.decode(reader, reader.uint32());
                break;
            case 14:
                message.aggregateRating = $root.AggregateRating.decode(reader, reader.uint32());
                break;
            case 15:
                message.annotations = $root.Annotations.decode(reader, reader.uint32());
                break;
            case 16:
                message.detailsUrl = reader.string();
                break;
            case 17:
                message.shareUrl = reader.string();
                break;
            case 18:
                message.reviewsUrl = reader.string();
                break;
            case 19:
                message.backendUrl = reader.string();
                break;
            case 20:
                message.purchaseDetailsUrl = reader.string();
                break;
            case 21:
                message.detailsReusable = reader.bool();
                break;
            case 22:
                message.subtitle = reader.string();
                break;
            case 23:
                message.translatedDescriptionHtml = reader.string();
                break;
            case 24:
                message.serverLogsCookie = reader.bytes();
                break;
            case 25:
                message.appInfo = $root.AppInfo.decode(reader, reader.uint32());
                break;
            case 26:
                message.mature = reader.bool();
                break;
            case 27:
                message.promotionalDescription = reader.string();
                break;
            case 29:
                message.availableForPreregistration = reader.bool();
                break;
            case 30:
                if (!(message.tip && message.tip.length))
                    message.tip = [];
                message.tip.push($root.ReviewTip.decode(reader, reader.uint32()));
                break;
            case 31:
                message.reviewSnippetsUrl = reader.string();
                break;
            case 32:
                message.forceShareability = reader.bool();
                break;
            case 33:
                message.useWishlistAsPrimaryAction = reader.bool();
                break;
            case 34:
                message.reviewQuestionsUrl = reader.string();
                break;
            case 39:
                message.reviewSummaryUrl = reader.string();
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes an Item message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof Item
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {Item} Item
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    Item.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies an Item message.
     * @function verify
     * @memberof Item
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    Item.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.id != null && message.hasOwnProperty("id"))
            if (!$util.isString(message.id))
                return "id: string expected";
        if (message.subId != null && message.hasOwnProperty("subId"))
            if (!$util.isString(message.subId))
                return "subId: string expected";
        if (message.type != null && message.hasOwnProperty("type"))
            if (!$util.isInteger(message.type))
                return "type: integer expected";
        if (message.categoryId != null && message.hasOwnProperty("categoryId"))
            if (!$util.isInteger(message.categoryId))
                return "categoryId: integer expected";
        if (message.title != null && message.hasOwnProperty("title"))
            if (!$util.isString(message.title))
                return "title: string expected";
        if (message.creator != null && message.hasOwnProperty("creator"))
            if (!$util.isString(message.creator))
                return "creator: string expected";
        if (message.descriptionHtml != null && message.hasOwnProperty("descriptionHtml"))
            if (!$util.isString(message.descriptionHtml))
                return "descriptionHtml: string expected";
        if (message.offer != null && message.hasOwnProperty("offer")) {
            if (!Array.isArray(message.offer))
                return "offer: array expected";
            for (var i = 0; i < message.offer.length; ++i) {
                var error = $root.Offer.verify(message.offer[i]);
                if (error)
                    return "offer." + error;
            }
        }
        if (message.availability != null && message.hasOwnProperty("availability")) {
            var error = $root.Availability.verify(message.availability);
            if (error)
                return "availability." + error;
        }
        if (message.image != null && message.hasOwnProperty("image")) {
            if (!Array.isArray(message.image))
                return "image: array expected";
            for (var i = 0; i < message.image.length; ++i) {
                var error = $root.Image.verify(message.image[i]);
                if (error)
                    return "image." + error;
            }
        }
        if (message.subItem != null && message.hasOwnProperty("subItem")) {
            if (!Array.isArray(message.subItem))
                return "subItem: array expected";
            for (var i = 0; i < message.subItem.length; ++i) {
                var error = $root.Item.verify(message.subItem[i]);
                if (error)
                    return "subItem." + error;
            }
        }
        if (message.containerMetadata != null && message.hasOwnProperty("containerMetadata")) {
            var error = $root.ContainerMetadata.verify(message.containerMetadata);
            if (error)
                return "containerMetadata." + error;
        }
        if (message.details != null && message.hasOwnProperty("details")) {
            var error = $root.DocumentDetails.verify(message.details);
            if (error)
                return "details." + error;
        }
        if (message.aggregateRating != null && message.hasOwnProperty("aggregateRating")) {
            var error = $root.AggregateRating.verify(message.aggregateRating);
            if (error)
                return "aggregateRating." + error;
        }
        if (message.annotations != null && message.hasOwnProperty("annotations")) {
            var error = $root.Annotations.verify(message.annotations);
            if (error)
                return "annotations." + error;
        }
        if (message.detailsUrl != null && message.hasOwnProperty("detailsUrl"))
            if (!$util.isString(message.detailsUrl))
                return "detailsUrl: string expected";
        if (message.shareUrl != null && message.hasOwnProperty("shareUrl"))
            if (!$util.isString(message.shareUrl))
                return "shareUrl: string expected";
        if (message.reviewsUrl != null && message.hasOwnProperty("reviewsUrl"))
            if (!$util.isString(message.reviewsUrl))
                return "reviewsUrl: string expected";
        if (message.backendUrl != null && message.hasOwnProperty("backendUrl"))
            if (!$util.isString(message.backendUrl))
                return "backendUrl: string expected";
        if (message.purchaseDetailsUrl != null && message.hasOwnProperty("purchaseDetailsUrl"))
            if (!$util.isString(message.purchaseDetailsUrl))
                return "purchaseDetailsUrl: string expected";
        if (message.detailsReusable != null && message.hasOwnProperty("detailsReusable"))
            if (typeof message.detailsReusable !== "boolean")
                return "detailsReusable: boolean expected";
        if (message.subtitle != null && message.hasOwnProperty("subtitle"))
            if (!$util.isString(message.subtitle))
                return "subtitle: string expected";
        if (message.translatedDescriptionHtml != null && message.hasOwnProperty("translatedDescriptionHtml"))
            if (!$util.isString(message.translatedDescriptionHtml))
                return "translatedDescriptionHtml: string expected";
        if (message.serverLogsCookie != null && message.hasOwnProperty("serverLogsCookie"))
            if (!(message.serverLogsCookie && typeof message.serverLogsCookie.length === "number" || $util.isString(message.serverLogsCookie)))
                return "serverLogsCookie: buffer expected";
        if (message.appInfo != null && message.hasOwnProperty("appInfo")) {
            var error = $root.AppInfo.verify(message.appInfo);
            if (error)
                return "appInfo." + error;
        }
        if (message.mature != null && message.hasOwnProperty("mature"))
            if (typeof message.mature !== "boolean")
                return "mature: boolean expected";
        if (message.promotionalDescription != null && message.hasOwnProperty("promotionalDescription"))
            if (!$util.isString(message.promotionalDescription))
                return "promotionalDescription: string expected";
        if (message.availableForPreregistration != null && message.hasOwnProperty("availableForPreregistration"))
            if (typeof message.availableForPreregistration !== "boolean")
                return "availableForPreregistration: boolean expected";
        if (message.tip != null && message.hasOwnProperty("tip")) {
            if (!Array.isArray(message.tip))
                return "tip: array expected";
            for (var i = 0; i < message.tip.length; ++i) {
                var error = $root.ReviewTip.verify(message.tip[i]);
                if (error)
                    return "tip." + error;
            }
        }
        if (message.reviewSnippetsUrl != null && message.hasOwnProperty("reviewSnippetsUrl"))
            if (!$util.isString(message.reviewSnippetsUrl))
                return "reviewSnippetsUrl: string expected";
        if (message.forceShareability != null && message.hasOwnProperty("forceShareability"))
            if (typeof message.forceShareability !== "boolean")
                return "forceShareability: boolean expected";
        if (message.useWishlistAsPrimaryAction != null && message.hasOwnProperty("useWishlistAsPrimaryAction"))
            if (typeof message.useWishlistAsPrimaryAction !== "boolean")
                return "useWishlistAsPrimaryAction: boolean expected";
        if (message.reviewQuestionsUrl != null && message.hasOwnProperty("reviewQuestionsUrl"))
            if (!$util.isString(message.reviewQuestionsUrl))
                return "reviewQuestionsUrl: string expected";
        if (message.reviewSummaryUrl != null && message.hasOwnProperty("reviewSummaryUrl"))
            if (!$util.isString(message.reviewSummaryUrl))
                return "reviewSummaryUrl: string expected";
        return null;
    };

    /**
     * Creates an Item message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof Item
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {Item} Item
     */
    Item.fromObject = function fromObject(object) {
        if (object instanceof $root.Item)
            return object;
        var message = new $root.Item();
        if (object.id != null)
            message.id = String(object.id);
        if (object.subId != null)
            message.subId = String(object.subId);
        if (object.type != null)
            message.type = object.type | 0;
        if (object.categoryId != null)
            message.categoryId = object.categoryId | 0;
        if (object.title != null)
            message.title = String(object.title);
        if (object.creator != null)
            message.creator = String(object.creator);
        if (object.descriptionHtml != null)
            message.descriptionHtml = String(object.descriptionHtml);
        if (object.offer) {
            if (!Array.isArray(object.offer))
                throw TypeError(".Item.offer: array expected");
            message.offer = [];
            for (var i = 0; i < object.offer.length; ++i) {
                if (typeof object.offer[i] !== "object")
                    throw TypeError(".Item.offer: object expected");
                message.offer[i] = $root.Offer.fromObject(object.offer[i]);
            }
        }
        if (object.availability != null) {
            if (typeof object.availability !== "object")
                throw TypeError(".Item.availability: object expected");
            message.availability = $root.Availability.fromObject(object.availability);
        }
        if (object.image) {
            if (!Array.isArray(object.image))
                throw TypeError(".Item.image: array expected");
            message.image = [];
            for (var i = 0; i < object.image.length; ++i) {
                if (typeof object.image[i] !== "object")
                    throw TypeError(".Item.image: object expected");
                message.image[i] = $root.Image.fromObject(object.image[i]);
            }
        }
        if (object.subItem) {
            if (!Array.isArray(object.subItem))
                throw TypeError(".Item.subItem: array expected");
            message.subItem = [];
            for (var i = 0; i < object.subItem.length; ++i) {
                if (typeof object.subItem[i] !== "object")
                    throw TypeError(".Item.subItem: object expected");
                message.subItem[i] = $root.Item.fromObject(object.subItem[i]);
            }
        }
        if (object.containerMetadata != null) {
            if (typeof object.containerMetadata !== "object")
                throw TypeError(".Item.containerMetadata: object expected");
            message.containerMetadata = $root.ContainerMetadata.fromObject(object.containerMetadata);
        }
        if (object.details != null) {
            if (typeof object.details !== "object")
                throw TypeError(".Item.details: object expected");
            message.details = $root.DocumentDetails.fromObject(object.details);
        }
        if (object.aggregateRating != null) {
            if (typeof object.aggregateRating !== "object")
                throw TypeError(".Item.aggregateRating: object expected");
            message.aggregateRating = $root.AggregateRating.fromObject(object.aggregateRating);
        }
        if (object.annotations != null) {
            if (typeof object.annotations !== "object")
                throw TypeError(".Item.annotations: object expected");
            message.annotations = $root.Annotations.fromObject(object.annotations);
        }
        if (object.detailsUrl != null)
            message.detailsUrl = String(object.detailsUrl);
        if (object.shareUrl != null)
            message.shareUrl = String(object.shareUrl);
        if (object.reviewsUrl != null)
            message.reviewsUrl = String(object.reviewsUrl);
        if (object.backendUrl != null)
            message.backendUrl = String(object.backendUrl);
        if (object.purchaseDetailsUrl != null)
            message.purchaseDetailsUrl = String(object.purchaseDetailsUrl);
        if (object.detailsReusable != null)
            message.detailsReusable = Boolean(object.detailsReusable);
        if (object.subtitle != null)
            message.subtitle = String(object.subtitle);
        if (object.translatedDescriptionHtml != null)
            message.translatedDescriptionHtml = String(object.translatedDescriptionHtml);
        if (object.serverLogsCookie != null)
            if (typeof object.serverLogsCookie === "string")
                $util.base64.decode(object.serverLogsCookie, message.serverLogsCookie = $util.newBuffer($util.base64.length(object.serverLogsCookie)), 0);
            else if (object.serverLogsCookie.length)
                message.serverLogsCookie = object.serverLogsCookie;
        if (object.appInfo != null) {
            if (typeof object.appInfo !== "object")
                throw TypeError(".Item.appInfo: object expected");
            message.appInfo = $root.AppInfo.fromObject(object.appInfo);
        }
        if (object.mature != null)
            message.mature = Boolean(object.mature);
        if (object.promotionalDescription != null)
            message.promotionalDescription = String(object.promotionalDescription);
        if (object.availableForPreregistration != null)
            message.availableForPreregistration = Boolean(object.availableForPreregistration);
        if (object.tip) {
            if (!Array.isArray(object.tip))
                throw TypeError(".Item.tip: array expected");
            message.tip = [];
            for (var i = 0; i < object.tip.length; ++i) {
                if (typeof object.tip[i] !== "object")
                    throw TypeError(".Item.tip: object expected");
                message.tip[i] = $root.ReviewTip.fromObject(object.tip[i]);
            }
        }
        if (object.reviewSnippetsUrl != null)
            message.reviewSnippetsUrl = String(object.reviewSnippetsUrl);
        if (object.forceShareability != null)
            message.forceShareability = Boolean(object.forceShareability);
        if (object.useWishlistAsPrimaryAction != null)
            message.useWishlistAsPrimaryAction = Boolean(object.useWishlistAsPrimaryAction);
        if (object.reviewQuestionsUrl != null)
            message.reviewQuestionsUrl = String(object.reviewQuestionsUrl);
        if (object.reviewSummaryUrl != null)
            message.reviewSummaryUrl = String(object.reviewSummaryUrl);
        return message;
    };

    /**
     * Creates a plain object from an Item message. Also converts values to other types if specified.
     * @function toObject
     * @memberof Item
     * @static
     * @param {Item} message Item
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    Item.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        var object = {};
        if (options.arrays || options.defaults) {
            object.offer = [];
            object.image = [];
            object.subItem = [];
            object.tip = [];
        }
        if (options.defaults) {
            object.id = "";
            object.subId = "";
            object.type = 0;
            object.categoryId = 0;
            object.title = "";
            object.creator = "";
            object.descriptionHtml = "";
            object.availability = null;
            object.containerMetadata = null;
            object.details = null;
            object.aggregateRating = null;
            object.annotations = null;
            object.detailsUrl = "";
            object.shareUrl = "";
            object.reviewsUrl = "";
            object.backendUrl = "";
            object.purchaseDetailsUrl = "";
            object.detailsReusable = false;
            object.subtitle = "";
            object.translatedDescriptionHtml = "";
            if (options.bytes === String)
                object.serverLogsCookie = "";
            else {
                object.serverLogsCookie = [];
                if (options.bytes !== Array)
                    object.serverLogsCookie = $util.newBuffer(object.serverLogsCookie);
            }
            object.appInfo = null;
            object.mature = false;
            object.promotionalDescription = "";
            object.availableForPreregistration = false;
            object.reviewSnippetsUrl = "";
            object.forceShareability = false;
            object.useWishlistAsPrimaryAction = false;
            object.reviewQuestionsUrl = "";
            object.reviewSummaryUrl = "";
        }
        if (message.id != null && message.hasOwnProperty("id"))
            object.id = message.id;
        if (message.subId != null && message.hasOwnProperty("subId"))
            object.subId = message.subId;
        if (message.type != null && message.hasOwnProperty("type"))
            object.type = message.type;
        if (message.categoryId != null && message.hasOwnProperty("categoryId"))
            object.categoryId = message.categoryId;
        if (message.title != null && message.hasOwnProperty("title"))
            object.title = message.title;
        if (message.creator != null && message.hasOwnProperty("creator"))
            object.creator = message.creator;
        if (message.descriptionHtml != null && message.hasOwnProperty("descriptionHtml"))
            object.descriptionHtml = message.descriptionHtml;
        if (message.offer && message.offer.length) {
            object.offer = [];
            for (var j = 0; j < message.offer.length; ++j)
                object.offer[j] = $root.Offer.toObject(message.offer[j], options);
        }
        if (message.availability != null && message.hasOwnProperty("availability"))
            object.availability = $root.Availability.toObject(message.availability, options);
        if (message.image && message.image.length) {
            object.image = [];
            for (var j = 0; j < message.image.length; ++j)
                object.image[j] = $root.Image.toObject(message.image[j], options);
        }
        if (message.subItem && message.subItem.length) {
            object.subItem = [];
            for (var j = 0; j < message.subItem.length; ++j)
                object.subItem[j] = $root.Item.toObject(message.subItem[j], options);
        }
        if (message.containerMetadata != null && message.hasOwnProperty("containerMetadata"))
            object.containerMetadata = $root.ContainerMetadata.toObject(message.containerMetadata, options);
        if (message.details != null && message.hasOwnProperty("details"))
            object.details = $root.DocumentDetails.toObject(message.details, options);
        if (message.aggregateRating != null && message.hasOwnProperty("aggregateRating"))
            object.aggregateRating = $root.AggregateRating.toObject(message.aggregateRating, options);
        if (message.annotations != null && message.hasOwnProperty("annotations"))
            object.annotations = $root.Annotations.toObject(message.annotations, options);
        if (message.detailsUrl != null && message.hasOwnProperty("detailsUrl"))
            object.detailsUrl = message.detailsUrl;
        if (message.shareUrl != null && message.hasOwnProperty("shareUrl"))
            object.shareUrl = message.shareUrl;
        if (message.reviewsUrl != null && message.hasOwnProperty("reviewsUrl"))
            object.reviewsUrl = message.reviewsUrl;
        if (message.backendUrl != null && message.hasOwnProperty("backendUrl"))
            object.backendUrl = message.backendUrl;
        if (message.purchaseDetailsUrl != null && message.hasOwnProperty("purchaseDetailsUrl"))
            object.purchaseDetailsUrl = message.purchaseDetailsUrl;
        if (message.detailsReusable != null && message.hasOwnProperty("detailsReusable"))
            object.detailsReusable = message.detailsReusable;
        if (message.subtitle != null && message.hasOwnProperty("subtitle"))
            object.subtitle = message.subtitle;
        if (message.translatedDescriptionHtml != null && message.hasOwnProperty("translatedDescriptionHtml"))
            object.translatedDescriptionHtml = message.translatedDescriptionHtml;
        if (message.serverLogsCookie != null && message.hasOwnProperty("serverLogsCookie"))
            object.serverLogsCookie = options.bytes === String ? $util.base64.encode(message.serverLogsCookie, 0, message.serverLogsCookie.length) : options.bytes === Array ? Array.prototype.slice.call(message.serverLogsCookie) : message.serverLogsCookie;
        if (message.appInfo != null && message.hasOwnProperty("appInfo"))
            object.appInfo = $root.AppInfo.toObject(message.appInfo, options);
        if (message.mature != null && message.hasOwnProperty("mature"))
            object.mature = message.mature;
        if (message.promotionalDescription != null && message.hasOwnProperty("promotionalDescription"))
            object.promotionalDescription = message.promotionalDescription;
        if (message.availableForPreregistration != null && message.hasOwnProperty("availableForPreregistration"))
            object.availableForPreregistration = message.availableForPreregistration;
        if (message.tip && message.tip.length) {
            object.tip = [];
            for (var j = 0; j < message.tip.length; ++j)
                object.tip[j] = $root.ReviewTip.toObject(message.tip[j], options);
        }
        if (message.reviewSnippetsUrl != null && message.hasOwnProperty("reviewSnippetsUrl"))
            object.reviewSnippetsUrl = message.reviewSnippetsUrl;
        if (message.forceShareability != null && message.hasOwnProperty("forceShareability"))
            object.forceShareability = message.forceShareability;
        if (message.useWishlistAsPrimaryAction != null && message.hasOwnProperty("useWishlistAsPrimaryAction"))
            object.useWishlistAsPrimaryAction = message.useWishlistAsPrimaryAction;
        if (message.reviewQuestionsUrl != null && message.hasOwnProperty("reviewQuestionsUrl"))
            object.reviewQuestionsUrl = message.reviewQuestionsUrl;
        if (message.reviewSummaryUrl != null && message.hasOwnProperty("reviewSummaryUrl"))
            object.reviewSummaryUrl = message.reviewSummaryUrl;
        return object;
    };

    /**
     * Converts this Item to JSON.
     * @function toJSON
     * @memberof Item
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    Item.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return Item;
})();

$root.AppInfo = (function() {

    /**
     * Properties of an AppInfo.
     * @exports IAppInfo
     * @interface IAppInfo
     * @property {string|null} [title] AppInfo title
     * @property {Array.<IAppInfoSection>|null} [section] AppInfo section
     */

    /**
     * Constructs a new AppInfo.
     * @exports AppInfo
     * @classdesc Represents an AppInfo.
     * @implements IAppInfo
     * @constructor
     * @param {IAppInfo=} [properties] Properties to set
     */
    function AppInfo(properties) {
        this.section = [];
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * AppInfo title.
     * @member {string} title
     * @memberof AppInfo
     * @instance
     */
    AppInfo.prototype.title = "";

    /**
     * AppInfo section.
     * @member {Array.<IAppInfoSection>} section
     * @memberof AppInfo
     * @instance
     */
    AppInfo.prototype.section = $util.emptyArray;

    /**
     * Creates a new AppInfo instance using the specified properties.
     * @function create
     * @memberof AppInfo
     * @static
     * @param {IAppInfo=} [properties] Properties to set
     * @returns {AppInfo} AppInfo instance
     */
    AppInfo.create = function create(properties) {
        return new AppInfo(properties);
    };

    /**
     * Encodes the specified AppInfo message. Does not implicitly {@link AppInfo.verify|verify} messages.
     * @function encode
     * @memberof AppInfo
     * @static
     * @param {IAppInfo} message AppInfo message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    AppInfo.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.title != null && Object.hasOwnProperty.call(message, "title"))
            writer.uint32(/* id 1, wireType 2 =*/10).string(message.title);
        if (message.section != null && message.section.length)
            for (var i = 0; i < message.section.length; ++i)
                $root.AppInfoSection.encode(message.section[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
        return writer;
    };

    /**
     * Encodes the specified AppInfo message, length delimited. Does not implicitly {@link AppInfo.verify|verify} messages.
     * @function encodeDelimited
     * @memberof AppInfo
     * @static
     * @param {IAppInfo} message AppInfo message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    AppInfo.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes an AppInfo message from the specified reader or buffer.
     * @function decode
     * @memberof AppInfo
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {AppInfo} AppInfo
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    AppInfo.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.AppInfo();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.title = reader.string();
                break;
            case 2:
                if (!(message.section && message.section.length))
                    message.section = [];
                message.section.push($root.AppInfoSection.decode(reader, reader.uint32()));
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes an AppInfo message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof AppInfo
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {AppInfo} AppInfo
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    AppInfo.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies an AppInfo message.
     * @function verify
     * @memberof AppInfo
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    AppInfo.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.title != null && message.hasOwnProperty("title"))
            if (!$util.isString(message.title))
                return "title: string expected";
        if (message.section != null && message.hasOwnProperty("section")) {
            if (!Array.isArray(message.section))
                return "section: array expected";
            for (var i = 0; i < message.section.length; ++i) {
                var error = $root.AppInfoSection.verify(message.section[i]);
                if (error)
                    return "section." + error;
            }
        }
        return null;
    };

    /**
     * Creates an AppInfo message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof AppInfo
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {AppInfo} AppInfo
     */
    AppInfo.fromObject = function fromObject(object) {
        if (object instanceof $root.AppInfo)
            return object;
        var message = new $root.AppInfo();
        if (object.title != null)
            message.title = String(object.title);
        if (object.section) {
            if (!Array.isArray(object.section))
                throw TypeError(".AppInfo.section: array expected");
            message.section = [];
            for (var i = 0; i < object.section.length; ++i) {
                if (typeof object.section[i] !== "object")
                    throw TypeError(".AppInfo.section: object expected");
                message.section[i] = $root.AppInfoSection.fromObject(object.section[i]);
            }
        }
        return message;
    };

    /**
     * Creates a plain object from an AppInfo message. Also converts values to other types if specified.
     * @function toObject
     * @memberof AppInfo
     * @static
     * @param {AppInfo} message AppInfo
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    AppInfo.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        var object = {};
        if (options.arrays || options.defaults)
            object.section = [];
        if (options.defaults)
            object.title = "";
        if (message.title != null && message.hasOwnProperty("title"))
            object.title = message.title;
        if (message.section && message.section.length) {
            object.section = [];
            for (var j = 0; j < message.section.length; ++j)
                object.section[j] = $root.AppInfoSection.toObject(message.section[j], options);
        }
        return object;
    };

    /**
     * Converts this AppInfo to JSON.
     * @function toJSON
     * @memberof AppInfo
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    AppInfo.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return AppInfo;
})();

$root.AppInfoSection = (function() {

    /**
     * Properties of an AppInfoSection.
     * @exports IAppInfoSection
     * @interface IAppInfoSection
     * @property {string|null} [label] AppInfoSection label
     * @property {IAppInfoContainer|null} [container] AppInfoSection container
     */

    /**
     * Constructs a new AppInfoSection.
     * @exports AppInfoSection
     * @classdesc Represents an AppInfoSection.
     * @implements IAppInfoSection
     * @constructor
     * @param {IAppInfoSection=} [properties] Properties to set
     */
    function AppInfoSection(properties) {
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * AppInfoSection label.
     * @member {string} label
     * @memberof AppInfoSection
     * @instance
     */
    AppInfoSection.prototype.label = "";

    /**
     * AppInfoSection container.
     * @member {IAppInfoContainer|null|undefined} container
     * @memberof AppInfoSection
     * @instance
     */
    AppInfoSection.prototype.container = null;

    /**
     * Creates a new AppInfoSection instance using the specified properties.
     * @function create
     * @memberof AppInfoSection
     * @static
     * @param {IAppInfoSection=} [properties] Properties to set
     * @returns {AppInfoSection} AppInfoSection instance
     */
    AppInfoSection.create = function create(properties) {
        return new AppInfoSection(properties);
    };

    /**
     * Encodes the specified AppInfoSection message. Does not implicitly {@link AppInfoSection.verify|verify} messages.
     * @function encode
     * @memberof AppInfoSection
     * @static
     * @param {IAppInfoSection} message AppInfoSection message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    AppInfoSection.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.label != null && Object.hasOwnProperty.call(message, "label"))
            writer.uint32(/* id 1, wireType 2 =*/10).string(message.label);
        if (message.container != null && Object.hasOwnProperty.call(message, "container"))
            $root.AppInfoContainer.encode(message.container, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
        return writer;
    };

    /**
     * Encodes the specified AppInfoSection message, length delimited. Does not implicitly {@link AppInfoSection.verify|verify} messages.
     * @function encodeDelimited
     * @memberof AppInfoSection
     * @static
     * @param {IAppInfoSection} message AppInfoSection message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    AppInfoSection.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes an AppInfoSection message from the specified reader or buffer.
     * @function decode
     * @memberof AppInfoSection
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {AppInfoSection} AppInfoSection
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    AppInfoSection.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.AppInfoSection();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.label = reader.string();
                break;
            case 3:
                message.container = $root.AppInfoContainer.decode(reader, reader.uint32());
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes an AppInfoSection message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof AppInfoSection
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {AppInfoSection} AppInfoSection
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    AppInfoSection.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies an AppInfoSection message.
     * @function verify
     * @memberof AppInfoSection
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    AppInfoSection.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.label != null && message.hasOwnProperty("label"))
            if (!$util.isString(message.label))
                return "label: string expected";
        if (message.container != null && message.hasOwnProperty("container")) {
            var error = $root.AppInfoContainer.verify(message.container);
            if (error)
                return "container." + error;
        }
        return null;
    };

    /**
     * Creates an AppInfoSection message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof AppInfoSection
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {AppInfoSection} AppInfoSection
     */
    AppInfoSection.fromObject = function fromObject(object) {
        if (object instanceof $root.AppInfoSection)
            return object;
        var message = new $root.AppInfoSection();
        if (object.label != null)
            message.label = String(object.label);
        if (object.container != null) {
            if (typeof object.container !== "object")
                throw TypeError(".AppInfoSection.container: object expected");
            message.container = $root.AppInfoContainer.fromObject(object.container);
        }
        return message;
    };

    /**
     * Creates a plain object from an AppInfoSection message. Also converts values to other types if specified.
     * @function toObject
     * @memberof AppInfoSection
     * @static
     * @param {AppInfoSection} message AppInfoSection
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    AppInfoSection.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        var object = {};
        if (options.defaults) {
            object.label = "";
            object.container = null;
        }
        if (message.label != null && message.hasOwnProperty("label"))
            object.label = message.label;
        if (message.container != null && message.hasOwnProperty("container"))
            object.container = $root.AppInfoContainer.toObject(message.container, options);
        return object;
    };

    /**
     * Converts this AppInfoSection to JSON.
     * @function toJSON
     * @memberof AppInfoSection
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    AppInfoSection.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return AppInfoSection;
})();

$root.AppInfoContainer = (function() {

    /**
     * Properties of an AppInfoContainer.
     * @exports IAppInfoContainer
     * @interface IAppInfoContainer
     * @property {IImage|null} [image] AppInfoContainer image
     * @property {string|null} [description] AppInfoContainer description
     */

    /**
     * Constructs a new AppInfoContainer.
     * @exports AppInfoContainer
     * @classdesc Represents an AppInfoContainer.
     * @implements IAppInfoContainer
     * @constructor
     * @param {IAppInfoContainer=} [properties] Properties to set
     */
    function AppInfoContainer(properties) {
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * AppInfoContainer image.
     * @member {IImage|null|undefined} image
     * @memberof AppInfoContainer
     * @instance
     */
    AppInfoContainer.prototype.image = null;

    /**
     * AppInfoContainer description.
     * @member {string} description
     * @memberof AppInfoContainer
     * @instance
     */
    AppInfoContainer.prototype.description = "";

    /**
     * Creates a new AppInfoContainer instance using the specified properties.
     * @function create
     * @memberof AppInfoContainer
     * @static
     * @param {IAppInfoContainer=} [properties] Properties to set
     * @returns {AppInfoContainer} AppInfoContainer instance
     */
    AppInfoContainer.create = function create(properties) {
        return new AppInfoContainer(properties);
    };

    /**
     * Encodes the specified AppInfoContainer message. Does not implicitly {@link AppInfoContainer.verify|verify} messages.
     * @function encode
     * @memberof AppInfoContainer
     * @static
     * @param {IAppInfoContainer} message AppInfoContainer message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    AppInfoContainer.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.image != null && Object.hasOwnProperty.call(message, "image"))
            $root.Image.encode(message.image, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
        if (message.description != null && Object.hasOwnProperty.call(message, "description"))
            writer.uint32(/* id 2, wireType 2 =*/18).string(message.description);
        return writer;
    };

    /**
     * Encodes the specified AppInfoContainer message, length delimited. Does not implicitly {@link AppInfoContainer.verify|verify} messages.
     * @function encodeDelimited
     * @memberof AppInfoContainer
     * @static
     * @param {IAppInfoContainer} message AppInfoContainer message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    AppInfoContainer.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes an AppInfoContainer message from the specified reader or buffer.
     * @function decode
     * @memberof AppInfoContainer
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {AppInfoContainer} AppInfoContainer
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    AppInfoContainer.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.AppInfoContainer();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.image = $root.Image.decode(reader, reader.uint32());
                break;
            case 2:
                message.description = reader.string();
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes an AppInfoContainer message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof AppInfoContainer
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {AppInfoContainer} AppInfoContainer
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    AppInfoContainer.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies an AppInfoContainer message.
     * @function verify
     * @memberof AppInfoContainer
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    AppInfoContainer.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.image != null && message.hasOwnProperty("image")) {
            var error = $root.Image.verify(message.image);
            if (error)
                return "image." + error;
        }
        if (message.description != null && message.hasOwnProperty("description"))
            if (!$util.isString(message.description))
                return "description: string expected";
        return null;
    };

    /**
     * Creates an AppInfoContainer message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof AppInfoContainer
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {AppInfoContainer} AppInfoContainer
     */
    AppInfoContainer.fromObject = function fromObject(object) {
        if (object instanceof $root.AppInfoContainer)
            return object;
        var message = new $root.AppInfoContainer();
        if (object.image != null) {
            if (typeof object.image !== "object")
                throw TypeError(".AppInfoContainer.image: object expected");
            message.image = $root.Image.fromObject(object.image);
        }
        if (object.description != null)
            message.description = String(object.description);
        return message;
    };

    /**
     * Creates a plain object from an AppInfoContainer message. Also converts values to other types if specified.
     * @function toObject
     * @memberof AppInfoContainer
     * @static
     * @param {AppInfoContainer} message AppInfoContainer
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    AppInfoContainer.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        var object = {};
        if (options.defaults) {
            object.image = null;
            object.description = "";
        }
        if (message.image != null && message.hasOwnProperty("image"))
            object.image = $root.Image.toObject(message.image, options);
        if (message.description != null && message.hasOwnProperty("description"))
            object.description = message.description;
        return object;
    };

    /**
     * Converts this AppInfoContainer to JSON.
     * @function toJSON
     * @memberof AppInfoContainer
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    AppInfoContainer.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return AppInfoContainer;
})();

$root.Annotations = (function() {

    /**
     * Properties of an Annotations.
     * @exports IAnnotations
     * @interface IAnnotations
     * @property {ISectionMetaData|null} [sectionRelated] Annotations sectionRelated
     * @property {ISectionMetaData|null} [sectionMoreBy] Annotations sectionMoreBy
     * @property {Array.<IWarning>|null} [warning] Annotations warning
     * @property {ISectionMetaData|null} [sectionBodyOfWork] Annotations sectionBodyOfWork
     * @property {ISectionMetaData|null} [sectionCoreContent] Annotations sectionCoreContent
     * @property {IOverlayMetaData|null} [overlayMetaData] Annotations overlayMetaData
     * @property {Array.<IBadge>|null} [badgeForCreator] Annotations badgeForCreator
     * @property {Array.<IBadge>|null} [infoBadge] Annotations infoBadge
     * @property {IAnnotationLink|null} [annotationLink] Annotations annotationLink
     * @property {ISectionMetaData|null} [sectionCrossSell] Annotations sectionCrossSell
     * @property {ISectionMetaData|null} [sectionRelatedItemType] Annotations sectionRelatedItemType
     * @property {Array.<IPromotedDoc>|null} [promotedDoc] Annotations promotedDoc
     * @property {string|null} [offerNote] Annotations offerNote
     * @property {string|null} [privacyPolicyUrl] Annotations privacyPolicyUrl
     * @property {ISuggestionReasons|null} [suggestionReasons] Annotations suggestionReasons
     * @property {IWarning|null} [optimalDeviceClassWarning] Annotations optimalDeviceClassWarning
     * @property {Array.<IBadgeContainer>|null} [badgeContainer] Annotations badgeContainer
     * @property {ISectionMetaData|null} [sectionSuggestForRating] Annotations sectionSuggestForRating
     * @property {ISectionMetaData|null} [sectionPurchaseCrossSell] Annotations sectionPurchaseCrossSell
     * @property {Array.<IOverflowLink>|null} [overflowLink] Annotations overflowLink
     * @property {string|null} [attributionHtml] Annotations attributionHtml
     * @property {IPurchaseHistoryDetails|null} [purchaseHistoryDetails] Annotations purchaseHistoryDetails
     * @property {IBadge|null} [badgeForLegacyRating] Annotations badgeForLegacyRating
     * @property {Array.<IVoucherInfo>|null} [voucherInfo] Annotations voucherInfo
     * @property {ISectionMetaData|null} [sectionFeaturedApps] Annotations sectionFeaturedApps
     * @property {Array.<ISectionMetaData>|null} [detailsPageCluster] Annotations detailsPageCluster
     * @property {IVideoAnnotations|null} [videoAnnotations] Annotations videoAnnotations
     * @property {ISectionMetaData|null} [sectionPurchaseRelatedTopics] Annotations sectionPurchaseRelatedTopics
     * @property {IMySubscriptionDetails|null} [mySubscriptionDetails] Annotations mySubscriptionDetails
     * @property {IMyRewardDetails|null} [myRewardDetails] Annotations myRewardDetails
     * @property {Array.<IBadge>|null} [featureBadge] Annotations featureBadge
     * @property {ISnippet|null} [snippet] Annotations snippet
     * @property {string|null} [downloadsLabel] Annotations downloadsLabel
     * @property {IBadge|null} [badgeForRating] Annotations badgeForRating
     * @property {ICategoryInfo|null} [categoryInfo] Annotations categoryInfo
     * @property {IEditorReason|null} [reasons] Annotations reasons
     * @property {IStream|null} [topChartStream] Annotations topChartStream
     * @property {string|null} [categoryName] Annotations categoryName
     * @property {Array.<IChip>|null} [chip] Annotations chip
     * @property {Array.<IBadge>|null} [displayBadge] Annotations displayBadge
     * @property {string|null} [liveStreamUrl] Annotations liveStreamUrl
     * @property {string|null} [promotionStreamUrl] Annotations promotionStreamUrl
     * @property {IOverlayMetaData|null} [overlayMetaDataExtra] Annotations overlayMetaDataExtra
     * @property {ISectionImage|null} [sectionImage] Annotations sectionImage
     * @property {ISubStream|null} [categoryStream] Annotations categoryStream
     */

    /**
     * Constructs a new Annotations.
     * @exports Annotations
     * @classdesc Represents an Annotations.
     * @implements IAnnotations
     * @constructor
     * @param {IAnnotations=} [properties] Properties to set
     */
    function Annotations(properties) {
        this.warning = [];
        this.badgeForCreator = [];
        this.infoBadge = [];
        this.promotedDoc = [];
        this.badgeContainer = [];
        this.overflowLink = [];
        this.voucherInfo = [];
        this.detailsPageCluster = [];
        this.featureBadge = [];
        this.chip = [];
        this.displayBadge = [];
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * Annotations sectionRelated.
     * @member {ISectionMetaData|null|undefined} sectionRelated
     * @memberof Annotations
     * @instance
     */
    Annotations.prototype.sectionRelated = null;

    /**
     * Annotations sectionMoreBy.
     * @member {ISectionMetaData|null|undefined} sectionMoreBy
     * @memberof Annotations
     * @instance
     */
    Annotations.prototype.sectionMoreBy = null;

    /**
     * Annotations warning.
     * @member {Array.<IWarning>} warning
     * @memberof Annotations
     * @instance
     */
    Annotations.prototype.warning = $util.emptyArray;

    /**
     * Annotations sectionBodyOfWork.
     * @member {ISectionMetaData|null|undefined} sectionBodyOfWork
     * @memberof Annotations
     * @instance
     */
    Annotations.prototype.sectionBodyOfWork = null;

    /**
     * Annotations sectionCoreContent.
     * @member {ISectionMetaData|null|undefined} sectionCoreContent
     * @memberof Annotations
     * @instance
     */
    Annotations.prototype.sectionCoreContent = null;

    /**
     * Annotations overlayMetaData.
     * @member {IOverlayMetaData|null|undefined} overlayMetaData
     * @memberof Annotations
     * @instance
     */
    Annotations.prototype.overlayMetaData = null;

    /**
     * Annotations badgeForCreator.
     * @member {Array.<IBadge>} badgeForCreator
     * @memberof Annotations
     * @instance
     */
    Annotations.prototype.badgeForCreator = $util.emptyArray;

    /**
     * Annotations infoBadge.
     * @member {Array.<IBadge>} infoBadge
     * @memberof Annotations
     * @instance
     */
    Annotations.prototype.infoBadge = $util.emptyArray;

    /**
     * Annotations annotationLink.
     * @member {IAnnotationLink|null|undefined} annotationLink
     * @memberof Annotations
     * @instance
     */
    Annotations.prototype.annotationLink = null;

    /**
     * Annotations sectionCrossSell.
     * @member {ISectionMetaData|null|undefined} sectionCrossSell
     * @memberof Annotations
     * @instance
     */
    Annotations.prototype.sectionCrossSell = null;

    /**
     * Annotations sectionRelatedItemType.
     * @member {ISectionMetaData|null|undefined} sectionRelatedItemType
     * @memberof Annotations
     * @instance
     */
    Annotations.prototype.sectionRelatedItemType = null;

    /**
     * Annotations promotedDoc.
     * @member {Array.<IPromotedDoc>} promotedDoc
     * @memberof Annotations
     * @instance
     */
    Annotations.prototype.promotedDoc = $util.emptyArray;

    /**
     * Annotations offerNote.
     * @member {string} offerNote
     * @memberof Annotations
     * @instance
     */
    Annotations.prototype.offerNote = "";

    /**
     * Annotations privacyPolicyUrl.
     * @member {string} privacyPolicyUrl
     * @memberof Annotations
     * @instance
     */
    Annotations.prototype.privacyPolicyUrl = "";

    /**
     * Annotations suggestionReasons.
     * @member {ISuggestionReasons|null|undefined} suggestionReasons
     * @memberof Annotations
     * @instance
     */
    Annotations.prototype.suggestionReasons = null;

    /**
     * Annotations optimalDeviceClassWarning.
     * @member {IWarning|null|undefined} optimalDeviceClassWarning
     * @memberof Annotations
     * @instance
     */
    Annotations.prototype.optimalDeviceClassWarning = null;

    /**
     * Annotations badgeContainer.
     * @member {Array.<IBadgeContainer>} badgeContainer
     * @memberof Annotations
     * @instance
     */
    Annotations.prototype.badgeContainer = $util.emptyArray;

    /**
     * Annotations sectionSuggestForRating.
     * @member {ISectionMetaData|null|undefined} sectionSuggestForRating
     * @memberof Annotations
     * @instance
     */
    Annotations.prototype.sectionSuggestForRating = null;

    /**
     * Annotations sectionPurchaseCrossSell.
     * @member {ISectionMetaData|null|undefined} sectionPurchaseCrossSell
     * @memberof Annotations
     * @instance
     */
    Annotations.prototype.sectionPurchaseCrossSell = null;

    /**
     * Annotations overflowLink.
     * @member {Array.<IOverflowLink>} overflowLink
     * @memberof Annotations
     * @instance
     */
    Annotations.prototype.overflowLink = $util.emptyArray;

    /**
     * Annotations attributionHtml.
     * @member {string} attributionHtml
     * @memberof Annotations
     * @instance
     */
    Annotations.prototype.attributionHtml = "";

    /**
     * Annotations purchaseHistoryDetails.
     * @member {IPurchaseHistoryDetails|null|undefined} purchaseHistoryDetails
     * @memberof Annotations
     * @instance
     */
    Annotations.prototype.purchaseHistoryDetails = null;

    /**
     * Annotations badgeForLegacyRating.
     * @member {IBadge|null|undefined} badgeForLegacyRating
     * @memberof Annotations
     * @instance
     */
    Annotations.prototype.badgeForLegacyRating = null;

    /**
     * Annotations voucherInfo.
     * @member {Array.<IVoucherInfo>} voucherInfo
     * @memberof Annotations
     * @instance
     */
    Annotations.prototype.voucherInfo = $util.emptyArray;

    /**
     * Annotations sectionFeaturedApps.
     * @member {ISectionMetaData|null|undefined} sectionFeaturedApps
     * @memberof Annotations
     * @instance
     */
    Annotations.prototype.sectionFeaturedApps = null;

    /**
     * Annotations detailsPageCluster.
     * @member {Array.<ISectionMetaData>} detailsPageCluster
     * @memberof Annotations
     * @instance
     */
    Annotations.prototype.detailsPageCluster = $util.emptyArray;

    /**
     * Annotations videoAnnotations.
     * @member {IVideoAnnotations|null|undefined} videoAnnotations
     * @memberof Annotations
     * @instance
     */
    Annotations.prototype.videoAnnotations = null;

    /**
     * Annotations sectionPurchaseRelatedTopics.
     * @member {ISectionMetaData|null|undefined} sectionPurchaseRelatedTopics
     * @memberof Annotations
     * @instance
     */
    Annotations.prototype.sectionPurchaseRelatedTopics = null;

    /**
     * Annotations mySubscriptionDetails.
     * @member {IMySubscriptionDetails|null|undefined} mySubscriptionDetails
     * @memberof Annotations
     * @instance
     */
    Annotations.prototype.mySubscriptionDetails = null;

    /**
     * Annotations myRewardDetails.
     * @member {IMyRewardDetails|null|undefined} myRewardDetails
     * @memberof Annotations
     * @instance
     */
    Annotations.prototype.myRewardDetails = null;

    /**
     * Annotations featureBadge.
     * @member {Array.<IBadge>} featureBadge
     * @memberof Annotations
     * @instance
     */
    Annotations.prototype.featureBadge = $util.emptyArray;

    /**
     * Annotations snippet.
     * @member {ISnippet|null|undefined} snippet
     * @memberof Annotations
     * @instance
     */
    Annotations.prototype.snippet = null;

    /**
     * Annotations downloadsLabel.
     * @member {string} downloadsLabel
     * @memberof Annotations
     * @instance
     */
    Annotations.prototype.downloadsLabel = "";

    /**
     * Annotations badgeForRating.
     * @member {IBadge|null|undefined} badgeForRating
     * @memberof Annotations
     * @instance
     */
    Annotations.prototype.badgeForRating = null;

    /**
     * Annotations categoryInfo.
     * @member {ICategoryInfo|null|undefined} categoryInfo
     * @memberof Annotations
     * @instance
     */
    Annotations.prototype.categoryInfo = null;

    /**
     * Annotations reasons.
     * @member {IEditorReason|null|undefined} reasons
     * @memberof Annotations
     * @instance
     */
    Annotations.prototype.reasons = null;

    /**
     * Annotations topChartStream.
     * @member {IStream|null|undefined} topChartStream
     * @memberof Annotations
     * @instance
     */
    Annotations.prototype.topChartStream = null;

    /**
     * Annotations categoryName.
     * @member {string} categoryName
     * @memberof Annotations
     * @instance
     */
    Annotations.prototype.categoryName = "";

    /**
     * Annotations chip.
     * @member {Array.<IChip>} chip
     * @memberof Annotations
     * @instance
     */
    Annotations.prototype.chip = $util.emptyArray;

    /**
     * Annotations displayBadge.
     * @member {Array.<IBadge>} displayBadge
     * @memberof Annotations
     * @instance
     */
    Annotations.prototype.displayBadge = $util.emptyArray;

    /**
     * Annotations liveStreamUrl.
     * @member {string} liveStreamUrl
     * @memberof Annotations
     * @instance
     */
    Annotations.prototype.liveStreamUrl = "";

    /**
     * Annotations promotionStreamUrl.
     * @member {string} promotionStreamUrl
     * @memberof Annotations
     * @instance
     */
    Annotations.prototype.promotionStreamUrl = "";

    /**
     * Annotations overlayMetaDataExtra.
     * @member {IOverlayMetaData|null|undefined} overlayMetaDataExtra
     * @memberof Annotations
     * @instance
     */
    Annotations.prototype.overlayMetaDataExtra = null;

    /**
     * Annotations sectionImage.
     * @member {ISectionImage|null|undefined} sectionImage
     * @memberof Annotations
     * @instance
     */
    Annotations.prototype.sectionImage = null;

    /**
     * Annotations categoryStream.
     * @member {ISubStream|null|undefined} categoryStream
     * @memberof Annotations
     * @instance
     */
    Annotations.prototype.categoryStream = null;

    /**
     * Creates a new Annotations instance using the specified properties.
     * @function create
     * @memberof Annotations
     * @static
     * @param {IAnnotations=} [properties] Properties to set
     * @returns {Annotations} Annotations instance
     */
    Annotations.create = function create(properties) {
        return new Annotations(properties);
    };

    /**
     * Encodes the specified Annotations message. Does not implicitly {@link Annotations.verify|verify} messages.
     * @function encode
     * @memberof Annotations
     * @static
     * @param {IAnnotations} message Annotations message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    Annotations.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.sectionRelated != null && Object.hasOwnProperty.call(message, "sectionRelated"))
            $root.SectionMetaData.encode(message.sectionRelated, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
        if (message.sectionMoreBy != null && Object.hasOwnProperty.call(message, "sectionMoreBy"))
            $root.SectionMetaData.encode(message.sectionMoreBy, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
        if (message.warning != null && message.warning.length)
            for (var i = 0; i < message.warning.length; ++i)
                $root.Warning.encode(message.warning[i], writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
        if (message.sectionBodyOfWork != null && Object.hasOwnProperty.call(message, "sectionBodyOfWork"))
            $root.SectionMetaData.encode(message.sectionBodyOfWork, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
        if (message.sectionCoreContent != null && Object.hasOwnProperty.call(message, "sectionCoreContent"))
            $root.SectionMetaData.encode(message.sectionCoreContent, writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
        if (message.overlayMetaData != null && Object.hasOwnProperty.call(message, "overlayMetaData"))
            $root.OverlayMetaData.encode(message.overlayMetaData, writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
        if (message.badgeForCreator != null && message.badgeForCreator.length)
            for (var i = 0; i < message.badgeForCreator.length; ++i)
                $root.Badge.encode(message.badgeForCreator[i], writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();
        if (message.infoBadge != null && message.infoBadge.length)
            for (var i = 0; i < message.infoBadge.length; ++i)
                $root.Badge.encode(message.infoBadge[i], writer.uint32(/* id 9, wireType 2 =*/74).fork()).ldelim();
        if (message.annotationLink != null && Object.hasOwnProperty.call(message, "annotationLink"))
            $root.AnnotationLink.encode(message.annotationLink, writer.uint32(/* id 10, wireType 2 =*/82).fork()).ldelim();
        if (message.sectionCrossSell != null && Object.hasOwnProperty.call(message, "sectionCrossSell"))
            $root.SectionMetaData.encode(message.sectionCrossSell, writer.uint32(/* id 11, wireType 2 =*/90).fork()).ldelim();
        if (message.sectionRelatedItemType != null && Object.hasOwnProperty.call(message, "sectionRelatedItemType"))
            $root.SectionMetaData.encode(message.sectionRelatedItemType, writer.uint32(/* id 12, wireType 2 =*/98).fork()).ldelim();
        if (message.promotedDoc != null && message.promotedDoc.length)
            for (var i = 0; i < message.promotedDoc.length; ++i)
                $root.PromotedDoc.encode(message.promotedDoc[i], writer.uint32(/* id 13, wireType 2 =*/106).fork()).ldelim();
        if (message.offerNote != null && Object.hasOwnProperty.call(message, "offerNote"))
            writer.uint32(/* id 14, wireType 2 =*/114).string(message.offerNote);
        if (message.privacyPolicyUrl != null && Object.hasOwnProperty.call(message, "privacyPolicyUrl"))
            writer.uint32(/* id 18, wireType 2 =*/146).string(message.privacyPolicyUrl);
        if (message.suggestionReasons != null && Object.hasOwnProperty.call(message, "suggestionReasons"))
            $root.SuggestionReasons.encode(message.suggestionReasons, writer.uint32(/* id 19, wireType 2 =*/154).fork()).ldelim();
        if (message.optimalDeviceClassWarning != null && Object.hasOwnProperty.call(message, "optimalDeviceClassWarning"))
            $root.Warning.encode(message.optimalDeviceClassWarning, writer.uint32(/* id 20, wireType 2 =*/162).fork()).ldelim();
        if (message.badgeContainer != null && message.badgeContainer.length)
            for (var i = 0; i < message.badgeContainer.length; ++i)
                $root.BadgeContainer.encode(message.badgeContainer[i], writer.uint32(/* id 21, wireType 2 =*/170).fork()).ldelim();
        if (message.sectionSuggestForRating != null && Object.hasOwnProperty.call(message, "sectionSuggestForRating"))
            $root.SectionMetaData.encode(message.sectionSuggestForRating, writer.uint32(/* id 22, wireType 2 =*/178).fork()).ldelim();
        if (message.sectionPurchaseCrossSell != null && Object.hasOwnProperty.call(message, "sectionPurchaseCrossSell"))
            $root.SectionMetaData.encode(message.sectionPurchaseCrossSell, writer.uint32(/* id 24, wireType 2 =*/194).fork()).ldelim();
        if (message.overflowLink != null && message.overflowLink.length)
            for (var i = 0; i < message.overflowLink.length; ++i)
                $root.OverflowLink.encode(message.overflowLink[i], writer.uint32(/* id 25, wireType 2 =*/202).fork()).ldelim();
        if (message.attributionHtml != null && Object.hasOwnProperty.call(message, "attributionHtml"))
            writer.uint32(/* id 27, wireType 2 =*/218).string(message.attributionHtml);
        if (message.purchaseHistoryDetails != null && Object.hasOwnProperty.call(message, "purchaseHistoryDetails"))
            $root.PurchaseHistoryDetails.encode(message.purchaseHistoryDetails, writer.uint32(/* id 28, wireType 2 =*/226).fork()).ldelim();
        if (message.badgeForLegacyRating != null && Object.hasOwnProperty.call(message, "badgeForLegacyRating"))
            $root.Badge.encode(message.badgeForLegacyRating, writer.uint32(/* id 29, wireType 2 =*/234).fork()).ldelim();
        if (message.voucherInfo != null && message.voucherInfo.length)
            for (var i = 0; i < message.voucherInfo.length; ++i)
                $root.VoucherInfo.encode(message.voucherInfo[i], writer.uint32(/* id 30, wireType 2 =*/242).fork()).ldelim();
        if (message.sectionFeaturedApps != null && Object.hasOwnProperty.call(message, "sectionFeaturedApps"))
            $root.SectionMetaData.encode(message.sectionFeaturedApps, writer.uint32(/* id 32, wireType 2 =*/258).fork()).ldelim();
        if (message.detailsPageCluster != null && message.detailsPageCluster.length)
            for (var i = 0; i < message.detailsPageCluster.length; ++i)
                $root.SectionMetaData.encode(message.detailsPageCluster[i], writer.uint32(/* id 34, wireType 2 =*/274).fork()).ldelim();
        if (message.videoAnnotations != null && Object.hasOwnProperty.call(message, "videoAnnotations"))
            $root.VideoAnnotations.encode(message.videoAnnotations, writer.uint32(/* id 35, wireType 2 =*/282).fork()).ldelim();
        if (message.sectionPurchaseRelatedTopics != null && Object.hasOwnProperty.call(message, "sectionPurchaseRelatedTopics"))
            $root.SectionMetaData.encode(message.sectionPurchaseRelatedTopics, writer.uint32(/* id 36, wireType 2 =*/290).fork()).ldelim();
        if (message.mySubscriptionDetails != null && Object.hasOwnProperty.call(message, "mySubscriptionDetails"))
            $root.MySubscriptionDetails.encode(message.mySubscriptionDetails, writer.uint32(/* id 37, wireType 2 =*/298).fork()).ldelim();
        if (message.myRewardDetails != null && Object.hasOwnProperty.call(message, "myRewardDetails"))
            $root.MyRewardDetails.encode(message.myRewardDetails, writer.uint32(/* id 38, wireType 2 =*/306).fork()).ldelim();
        if (message.featureBadge != null && message.featureBadge.length)
            for (var i = 0; i < message.featureBadge.length; ++i)
                $root.Badge.encode(message.featureBadge[i], writer.uint32(/* id 39, wireType 2 =*/314).fork()).ldelim();
        if (message.snippet != null && Object.hasOwnProperty.call(message, "snippet"))
            $root.Snippet.encode(message.snippet, writer.uint32(/* id 42, wireType 2 =*/338).fork()).ldelim();
        if (message.downloadsLabel != null && Object.hasOwnProperty.call(message, "downloadsLabel"))
            writer.uint32(/* id 48, wireType 2 =*/386).string(message.downloadsLabel);
        if (message.badgeForRating != null && Object.hasOwnProperty.call(message, "badgeForRating"))
            $root.Badge.encode(message.badgeForRating, writer.uint32(/* id 50, wireType 2 =*/402).fork()).ldelim();
        if (message.categoryInfo != null && Object.hasOwnProperty.call(message, "categoryInfo"))
            $root.CategoryInfo.encode(message.categoryInfo, writer.uint32(/* id 53, wireType 2 =*/426).fork()).ldelim();
        if (message.reasons != null && Object.hasOwnProperty.call(message, "reasons"))
            $root.EditorReason.encode(message.reasons, writer.uint32(/* id 60, wireType 2 =*/482).fork()).ldelim();
        if (message.topChartStream != null && Object.hasOwnProperty.call(message, "topChartStream"))
            $root.Stream.encode(message.topChartStream, writer.uint32(/* id 65, wireType 2 =*/522).fork()).ldelim();
        if (message.categoryName != null && Object.hasOwnProperty.call(message, "categoryName"))
            writer.uint32(/* id 66, wireType 2 =*/530).string(message.categoryName);
        if (message.chip != null && message.chip.length)
            for (var i = 0; i < message.chip.length; ++i)
                $root.Chip.encode(message.chip[i], writer.uint32(/* id 71, wireType 2 =*/570).fork()).ldelim();
        if (message.displayBadge != null && message.displayBadge.length)
            for (var i = 0; i < message.displayBadge.length; ++i)
                $root.Badge.encode(message.displayBadge[i], writer.uint32(/* id 72, wireType 2 =*/578).fork()).ldelim();
        if (message.liveStreamUrl != null && Object.hasOwnProperty.call(message, "liveStreamUrl"))
            writer.uint32(/* id 80, wireType 2 =*/642).string(message.liveStreamUrl);
        if (message.promotionStreamUrl != null && Object.hasOwnProperty.call(message, "promotionStreamUrl"))
            writer.uint32(/* id 85, wireType 2 =*/682).string(message.promotionStreamUrl);
        if (message.overlayMetaDataExtra != null && Object.hasOwnProperty.call(message, "overlayMetaDataExtra"))
            $root.OverlayMetaData.encode(message.overlayMetaDataExtra, writer.uint32(/* id 91, wireType 2 =*/730).fork()).ldelim();
        if (message.sectionImage != null && Object.hasOwnProperty.call(message, "sectionImage"))
            $root.SectionImage.encode(message.sectionImage, writer.uint32(/* id 94, wireType 2 =*/754).fork()).ldelim();
        if (message.categoryStream != null && Object.hasOwnProperty.call(message, "categoryStream"))
            $root.SubStream.encode(message.categoryStream, writer.uint32(/* id 97, wireType 2 =*/778).fork()).ldelim();
        return writer;
    };

    /**
     * Encodes the specified Annotations message, length delimited. Does not implicitly {@link Annotations.verify|verify} messages.
     * @function encodeDelimited
     * @memberof Annotations
     * @static
     * @param {IAnnotations} message Annotations message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    Annotations.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes an Annotations message from the specified reader or buffer.
     * @function decode
     * @memberof Annotations
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {Annotations} Annotations
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    Annotations.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Annotations();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.sectionRelated = $root.SectionMetaData.decode(reader, reader.uint32());
                break;
            case 2:
                message.sectionMoreBy = $root.SectionMetaData.decode(reader, reader.uint32());
                break;
            case 4:
                if (!(message.warning && message.warning.length))
                    message.warning = [];
                message.warning.push($root.Warning.decode(reader, reader.uint32()));
                break;
            case 5:
                message.sectionBodyOfWork = $root.SectionMetaData.decode(reader, reader.uint32());
                break;
            case 6:
                message.sectionCoreContent = $root.SectionMetaData.decode(reader, reader.uint32());
                break;
            case 7:
                message.overlayMetaData = $root.OverlayMetaData.decode(reader, reader.uint32());
                break;
            case 8:
                if (!(message.badgeForCreator && message.badgeForCreator.length))
                    message.badgeForCreator = [];
                message.badgeForCreator.push($root.Badge.decode(reader, reader.uint32()));
                break;
            case 9:
                if (!(message.infoBadge && message.infoBadge.length))
                    message.infoBadge = [];
                message.infoBadge.push($root.Badge.decode(reader, reader.uint32()));
                break;
            case 10:
                message.annotationLink = $root.AnnotationLink.decode(reader, reader.uint32());
                break;
            case 11:
                message.sectionCrossSell = $root.SectionMetaData.decode(reader, reader.uint32());
                break;
            case 12:
                message.sectionRelatedItemType = $root.SectionMetaData.decode(reader, reader.uint32());
                break;
            case 13:
                if (!(message.promotedDoc && message.promotedDoc.length))
                    message.promotedDoc = [];
                message.promotedDoc.push($root.PromotedDoc.decode(reader, reader.uint32()));
                break;
            case 14:
                message.offerNote = reader.string();
                break;
            case 18:
                message.privacyPolicyUrl = reader.string();
                break;
            case 19:
                message.suggestionReasons = $root.SuggestionReasons.decode(reader, reader.uint32());
                break;
            case 20:
                message.optimalDeviceClassWarning = $root.Warning.decode(reader, reader.uint32());
                break;
            case 21:
                if (!(message.badgeContainer && message.badgeContainer.length))
                    message.badgeContainer = [];
                message.badgeContainer.push($root.BadgeContainer.decode(reader, reader.uint32()));
                break;
            case 22:
                message.sectionSuggestForRating = $root.SectionMetaData.decode(reader, reader.uint32());
                break;
            case 24:
                message.sectionPurchaseCrossSell = $root.SectionMetaData.decode(reader, reader.uint32());
                break;
            case 25:
                if (!(message.overflowLink && message.overflowLink.length))
                    message.overflowLink = [];
                message.overflowLink.push($root.OverflowLink.decode(reader, reader.uint32()));
                break;
            case 27:
                message.attributionHtml = reader.string();
                break;
            case 28:
                message.purchaseHistoryDetails = $root.PurchaseHistoryDetails.decode(reader, reader.uint32());
                break;
            case 29:
                message.badgeForLegacyRating = $root.Badge.decode(reader, reader.uint32());
                break;
            case 30:
                if (!(message.voucherInfo && message.voucherInfo.length))
                    message.voucherInfo = [];
                message.voucherInfo.push($root.VoucherInfo.decode(reader, reader.uint32()));
                break;
            case 32:
                message.sectionFeaturedApps = $root.SectionMetaData.decode(reader, reader.uint32());
                break;
            case 34:
                if (!(message.detailsPageCluster && message.detailsPageCluster.length))
                    message.detailsPageCluster = [];
                message.detailsPageCluster.push($root.SectionMetaData.decode(reader, reader.uint32()));
                break;
            case 35:
                message.videoAnnotations = $root.VideoAnnotations.decode(reader, reader.uint32());
                break;
            case 36:
                message.sectionPurchaseRelatedTopics = $root.SectionMetaData.decode(reader, reader.uint32());
                break;
            case 37:
                message.mySubscriptionDetails = $root.MySubscriptionDetails.decode(reader, reader.uint32());
                break;
            case 38:
                message.myRewardDetails = $root.MyRewardDetails.decode(reader, reader.uint32());
                break;
            case 39:
                if (!(message.featureBadge && message.featureBadge.length))
                    message.featureBadge = [];
                message.featureBadge.push($root.Badge.decode(reader, reader.uint32()));
                break;
            case 42:
                message.snippet = $root.Snippet.decode(reader, reader.uint32());
                break;
            case 48:
                message.downloadsLabel = reader.string();
                break;
            case 50:
                message.badgeForRating = $root.Badge.decode(reader, reader.uint32());
                break;
            case 53:
                message.categoryInfo = $root.CategoryInfo.decode(reader, reader.uint32());
                break;
            case 60:
                message.reasons = $root.EditorReason.decode(reader, reader.uint32());
                break;
            case 65:
                message.topChartStream = $root.Stream.decode(reader, reader.uint32());
                break;
            case 66:
                message.categoryName = reader.string();
                break;
            case 71:
                if (!(message.chip && message.chip.length))
                    message.chip = [];
                message.chip.push($root.Chip.decode(reader, reader.uint32()));
                break;
            case 72:
                if (!(message.displayBadge && message.displayBadge.length))
                    message.displayBadge = [];
                message.displayBadge.push($root.Badge.decode(reader, reader.uint32()));
                break;
            case 80:
                message.liveStreamUrl = reader.string();
                break;
            case 85:
                message.promotionStreamUrl = reader.string();
                break;
            case 91:
                message.overlayMetaDataExtra = $root.OverlayMetaData.decode(reader, reader.uint32());
                break;
            case 94:
                message.sectionImage = $root.SectionImage.decode(reader, reader.uint32());
                break;
            case 97:
                message.categoryStream = $root.SubStream.decode(reader, reader.uint32());
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes an Annotations message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof Annotations
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {Annotations} Annotations
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    Annotations.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies an Annotations message.
     * @function verify
     * @memberof Annotations
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    Annotations.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.sectionRelated != null && message.hasOwnProperty("sectionRelated")) {
            var error = $root.SectionMetaData.verify(message.sectionRelated);
            if (error)
                return "sectionRelated." + error;
        }
        if (message.sectionMoreBy != null && message.hasOwnProperty("sectionMoreBy")) {
            var error = $root.SectionMetaData.verify(message.sectionMoreBy);
            if (error)
                return "sectionMoreBy." + error;
        }
        if (message.warning != null && message.hasOwnProperty("warning")) {
            if (!Array.isArray(message.warning))
                return "warning: array expected";
            for (var i = 0; i < message.warning.length; ++i) {
                var error = $root.Warning.verify(message.warning[i]);
                if (error)
                    return "warning." + error;
            }
        }
        if (message.sectionBodyOfWork != null && message.hasOwnProperty("sectionBodyOfWork")) {
            var error = $root.SectionMetaData.verify(message.sectionBodyOfWork);
            if (error)
                return "sectionBodyOfWork." + error;
        }
        if (message.sectionCoreContent != null && message.hasOwnProperty("sectionCoreContent")) {
            var error = $root.SectionMetaData.verify(message.sectionCoreContent);
            if (error)
                return "sectionCoreContent." + error;
        }
        if (message.overlayMetaData != null && message.hasOwnProperty("overlayMetaData")) {
            var error = $root.OverlayMetaData.verify(message.overlayMetaData);
            if (error)
                return "overlayMetaData." + error;
        }
        if (message.badgeForCreator != null && message.hasOwnProperty("badgeForCreator")) {
            if (!Array.isArray(message.badgeForCreator))
                return "badgeForCreator: array expected";
            for (var i = 0; i < message.badgeForCreator.length; ++i) {
                var error = $root.Badge.verify(message.badgeForCreator[i]);
                if (error)
                    return "badgeForCreator." + error;
            }
        }
        if (message.infoBadge != null && message.hasOwnProperty("infoBadge")) {
            if (!Array.isArray(message.infoBadge))
                return "infoBadge: array expected";
            for (var i = 0; i < message.infoBadge.length; ++i) {
                var error = $root.Badge.verify(message.infoBadge[i]);
                if (error)
                    return "infoBadge." + error;
            }
        }
        if (message.annotationLink != null && message.hasOwnProperty("annotationLink")) {
            var error = $root.AnnotationLink.verify(message.annotationLink);
            if (error)
                return "annotationLink." + error;
        }
        if (message.sectionCrossSell != null && message.hasOwnProperty("sectionCrossSell")) {
            var error = $root.SectionMetaData.verify(message.sectionCrossSell);
            if (error)
                return "sectionCrossSell." + error;
        }
        if (message.sectionRelatedItemType != null && message.hasOwnProperty("sectionRelatedItemType")) {
            var error = $root.SectionMetaData.verify(message.sectionRelatedItemType);
            if (error)
                return "sectionRelatedItemType." + error;
        }
        if (message.promotedDoc != null && message.hasOwnProperty("promotedDoc")) {
            if (!Array.isArray(message.promotedDoc))
                return "promotedDoc: array expected";
            for (var i = 0; i < message.promotedDoc.length; ++i) {
                var error = $root.PromotedDoc.verify(message.promotedDoc[i]);
                if (error)
                    return "promotedDoc." + error;
            }
        }
        if (message.offerNote != null && message.hasOwnProperty("offerNote"))
            if (!$util.isString(message.offerNote))
                return "offerNote: string expected";
        if (message.privacyPolicyUrl != null && message.hasOwnProperty("privacyPolicyUrl"))
            if (!$util.isString(message.privacyPolicyUrl))
                return "privacyPolicyUrl: string expected";
        if (message.suggestionReasons != null && message.hasOwnProperty("suggestionReasons")) {
            var error = $root.SuggestionReasons.verify(message.suggestionReasons);
            if (error)
                return "suggestionReasons." + error;
        }
        if (message.optimalDeviceClassWarning != null && message.hasOwnProperty("optimalDeviceClassWarning")) {
            var error = $root.Warning.verify(message.optimalDeviceClassWarning);
            if (error)
                return "optimalDeviceClassWarning." + error;
        }
        if (message.badgeContainer != null && message.hasOwnProperty("badgeContainer")) {
            if (!Array.isArray(message.badgeContainer))
                return "badgeContainer: array expected";
            for (var i = 0; i < message.badgeContainer.length; ++i) {
                var error = $root.BadgeContainer.verify(message.badgeContainer[i]);
                if (error)
                    return "badgeContainer." + error;
            }
        }
        if (message.sectionSuggestForRating != null && message.hasOwnProperty("sectionSuggestForRating")) {
            var error = $root.SectionMetaData.verify(message.sectionSuggestForRating);
            if (error)
                return "sectionSuggestForRating." + error;
        }
        if (message.sectionPurchaseCrossSell != null && message.hasOwnProperty("sectionPurchaseCrossSell")) {
            var error = $root.SectionMetaData.verify(message.sectionPurchaseCrossSell);
            if (error)
                return "sectionPurchaseCrossSell." + error;
        }
        if (message.overflowLink != null && message.hasOwnProperty("overflowLink")) {
            if (!Array.isArray(message.overflowLink))
                return "overflowLink: array expected";
            for (var i = 0; i < message.overflowLink.length; ++i) {
                var error = $root.OverflowLink.verify(message.overflowLink[i]);
                if (error)
                    return "overflowLink." + error;
            }
        }
        if (message.attributionHtml != null && message.hasOwnProperty("attributionHtml"))
            if (!$util.isString(message.attributionHtml))
                return "attributionHtml: string expected";
        if (message.purchaseHistoryDetails != null && message.hasOwnProperty("purchaseHistoryDetails")) {
            var error = $root.PurchaseHistoryDetails.verify(message.purchaseHistoryDetails);
            if (error)
                return "purchaseHistoryDetails." + error;
        }
        if (message.badgeForLegacyRating != null && message.hasOwnProperty("badgeForLegacyRating")) {
            var error = $root.Badge.verify(message.badgeForLegacyRating);
            if (error)
                return "badgeForLegacyRating." + error;
        }
        if (message.voucherInfo != null && message.hasOwnProperty("voucherInfo")) {
            if (!Array.isArray(message.voucherInfo))
                return "voucherInfo: array expected";
            for (var i = 0; i < message.voucherInfo.length; ++i) {
                var error = $root.VoucherInfo.verify(message.voucherInfo[i]);
                if (error)
                    return "voucherInfo." + error;
            }
        }
        if (message.sectionFeaturedApps != null && message.hasOwnProperty("sectionFeaturedApps")) {
            var error = $root.SectionMetaData.verify(message.sectionFeaturedApps);
            if (error)
                return "sectionFeaturedApps." + error;
        }
        if (message.detailsPageCluster != null && message.hasOwnProperty("detailsPageCluster")) {
            if (!Array.isArray(message.detailsPageCluster))
                return "detailsPageCluster: array expected";
            for (var i = 0; i < message.detailsPageCluster.length; ++i) {
                var error = $root.SectionMetaData.verify(message.detailsPageCluster[i]);
                if (error)
                    return "detailsPageCluster." + error;
            }
        }
        if (message.videoAnnotations != null && message.hasOwnProperty("videoAnnotations")) {
            var error = $root.VideoAnnotations.verify(message.videoAnnotations);
            if (error)
                return "videoAnnotations." + error;
        }
        if (message.sectionPurchaseRelatedTopics != null && message.hasOwnProperty("sectionPurchaseRelatedTopics")) {
            var error = $root.SectionMetaData.verify(message.sectionPurchaseRelatedTopics);
            if (error)
                return "sectionPurchaseRelatedTopics." + error;
        }
        if (message.mySubscriptionDetails != null && message.hasOwnProperty("mySubscriptionDetails")) {
            var error = $root.MySubscriptionDetails.verify(message.mySubscriptionDetails);
            if (error)
                return "mySubscriptionDetails." + error;
        }
        if (message.myRewardDetails != null && message.hasOwnProperty("myRewardDetails")) {
            var error = $root.MyRewardDetails.verify(message.myRewardDetails);
            if (error)
                return "myRewardDetails." + error;
        }
        if (message.featureBadge != null && message.hasOwnProperty("featureBadge")) {
            if (!Array.isArray(message.featureBadge))
                return "featureBadge: array expected";
            for (var i = 0; i < message.featureBadge.length; ++i) {
                var error = $root.Badge.verify(message.featureBadge[i]);
                if (error)
                    return "featureBadge." + error;
            }
        }
        if (message.snippet != null && message.hasOwnProperty("snippet")) {
            var error = $root.Snippet.verify(message.snippet);
            if (error)
                return "snippet." + error;
        }
        if (message.downloadsLabel != null && message.hasOwnProperty("downloadsLabel"))
            if (!$util.isString(message.downloadsLabel))
                return "downloadsLabel: string expected";
        if (message.badgeForRating != null && message.hasOwnProperty("badgeForRating")) {
            var error = $root.Badge.verify(message.badgeForRating);
            if (error)
                return "badgeForRating." + error;
        }
        if (message.categoryInfo != null && message.hasOwnProperty("categoryInfo")) {
            var error = $root.CategoryInfo.verify(message.categoryInfo);
            if (error)
                return "categoryInfo." + error;
        }
        if (message.reasons != null && message.hasOwnProperty("reasons")) {
            var error = $root.EditorReason.verify(message.reasons);
            if (error)
                return "reasons." + error;
        }
        if (message.topChartStream != null && message.hasOwnProperty("topChartStream")) {
            var error = $root.Stream.verify(message.topChartStream);
            if (error)
                return "topChartStream." + error;
        }
        if (message.categoryName != null && message.hasOwnProperty("categoryName"))
            if (!$util.isString(message.categoryName))
                return "categoryName: string expected";
        if (message.chip != null && message.hasOwnProperty("chip")) {
            if (!Array.isArray(message.chip))
                return "chip: array expected";
            for (var i = 0; i < message.chip.length; ++i) {
                var error = $root.Chip.verify(message.chip[i]);
                if (error)
                    return "chip." + error;
            }
        }
        if (message.displayBadge != null && message.hasOwnProperty("displayBadge")) {
            if (!Array.isArray(message.displayBadge))
                return "displayBadge: array expected";
            for (var i = 0; i < message.displayBadge.length; ++i) {
                var error = $root.Badge.verify(message.displayBadge[i]);
                if (error)
                    return "displayBadge." + error;
            }
        }
        if (message.liveStreamUrl != null && message.hasOwnProperty("liveStreamUrl"))
            if (!$util.isString(message.liveStreamUrl))
                return "liveStreamUrl: string expected";
        if (message.promotionStreamUrl != null && message.hasOwnProperty("promotionStreamUrl"))
            if (!$util.isString(message.promotionStreamUrl))
                return "promotionStreamUrl: string expected";
        if (message.overlayMetaDataExtra != null && message.hasOwnProperty("overlayMetaDataExtra")) {
            var error = $root.OverlayMetaData.verify(message.overlayMetaDataExtra);
            if (error)
                return "overlayMetaDataExtra." + error;
        }
        if (message.sectionImage != null && message.hasOwnProperty("sectionImage")) {
            var error = $root.SectionImage.verify(message.sectionImage);
            if (error)
                return "sectionImage." + error;
        }
        if (message.categoryStream != null && message.hasOwnProperty("categoryStream")) {
            var error = $root.SubStream.verify(message.categoryStream);
            if (error)
                return "categoryStream." + error;
        }
        return null;
    };

    /**
     * Creates an Annotations message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof Annotations
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {Annotations} Annotations
     */
    Annotations.fromObject = function fromObject(object) {
        if (object instanceof $root.Annotations)
            return object;
        var message = new $root.Annotations();
        if (object.sectionRelated != null) {
            if (typeof object.sectionRelated !== "object")
                throw TypeError(".Annotations.sectionRelated: object expected");
            message.sectionRelated = $root.SectionMetaData.fromObject(object.sectionRelated);
        }
        if (object.sectionMoreBy != null) {
            if (typeof object.sectionMoreBy !== "object")
                throw TypeError(".Annotations.sectionMoreBy: object expected");
            message.sectionMoreBy = $root.SectionMetaData.fromObject(object.sectionMoreBy);
        }
        if (object.warning) {
            if (!Array.isArray(object.warning))
                throw TypeError(".Annotations.warning: array expected");
            message.warning = [];
            for (var i = 0; i < object.warning.length; ++i) {
                if (typeof object.warning[i] !== "object")
                    throw TypeError(".Annotations.warning: object expected");
                message.warning[i] = $root.Warning.fromObject(object.warning[i]);
            }
        }
        if (object.sectionBodyOfWork != null) {
            if (typeof object.sectionBodyOfWork !== "object")
                throw TypeError(".Annotations.sectionBodyOfWork: object expected");
            message.sectionBodyOfWork = $root.SectionMetaData.fromObject(object.sectionBodyOfWork);
        }
        if (object.sectionCoreContent != null) {
            if (typeof object.sectionCoreContent !== "object")
                throw TypeError(".Annotations.sectionCoreContent: object expected");
            message.sectionCoreContent = $root.SectionMetaData.fromObject(object.sectionCoreContent);
        }
        if (object.overlayMetaData != null) {
            if (typeof object.overlayMetaData !== "object")
                throw TypeError(".Annotations.overlayMetaData: object expected");
            message.overlayMetaData = $root.OverlayMetaData.fromObject(object.overlayMetaData);
        }
        if (object.badgeForCreator) {
            if (!Array.isArray(object.badgeForCreator))
                throw TypeError(".Annotations.badgeForCreator: array expected");
            message.badgeForCreator = [];
            for (var i = 0; i < object.badgeForCreator.length; ++i) {
                if (typeof object.badgeForCreator[i] !== "object")
                    throw TypeError(".Annotations.badgeForCreator: object expected");
                message.badgeForCreator[i] = $root.Badge.fromObject(object.badgeForCreator[i]);
            }
        }
        if (object.infoBadge) {
            if (!Array.isArray(object.infoBadge))
                throw TypeError(".Annotations.infoBadge: array expected");
            message.infoBadge = [];
            for (var i = 0; i < object.infoBadge.length; ++i) {
                if (typeof object.infoBadge[i] !== "object")
                    throw TypeError(".Annotations.infoBadge: object expected");
                message.infoBadge[i] = $root.Badge.fromObject(object.infoBadge[i]);
            }
        }
        if (object.annotationLink != null) {
            if (typeof object.annotationLink !== "object")
                throw TypeError(".Annotations.annotationLink: object expected");
            message.annotationLink = $root.AnnotationLink.fromObject(object.annotationLink);
        }
        if (object.sectionCrossSell != null) {
            if (typeof object.sectionCrossSell !== "object")
                throw TypeError(".Annotations.sectionCrossSell: object expected");
            message.sectionCrossSell = $root.SectionMetaData.fromObject(object.sectionCrossSell);
        }
        if (object.sectionRelatedItemType != null) {
            if (typeof object.sectionRelatedItemType !== "object")
                throw TypeError(".Annotations.sectionRelatedItemType: object expected");
            message.sectionRelatedItemType = $root.SectionMetaData.fromObject(object.sectionRelatedItemType);
        }
        if (object.promotedDoc) {
            if (!Array.isArray(object.promotedDoc))
                throw TypeError(".Annotations.promotedDoc: array expected");
            message.promotedDoc = [];
            for (var i = 0; i < object.promotedDoc.length; ++i) {
                if (typeof object.promotedDoc[i] !== "object")
                    throw TypeError(".Annotations.promotedDoc: object expected");
                message.promotedDoc[i] = $root.PromotedDoc.fromObject(object.promotedDoc[i]);
            }
        }
        if (object.offerNote != null)
            message.offerNote = String(object.offerNote);
        if (object.privacyPolicyUrl != null)
            message.privacyPolicyUrl = String(object.privacyPolicyUrl);
        if (object.suggestionReasons != null) {
            if (typeof object.suggestionReasons !== "object")
                throw TypeError(".Annotations.suggestionReasons: object expected");
            message.suggestionReasons = $root.SuggestionReasons.fromObject(object.suggestionReasons);
        }
        if (object.optimalDeviceClassWarning != null) {
            if (typeof object.optimalDeviceClassWarning !== "object")
                throw TypeError(".Annotations.optimalDeviceClassWarning: object expected");
            message.optimalDeviceClassWarning = $root.Warning.fromObject(object.optimalDeviceClassWarning);
        }
        if (object.badgeContainer) {
            if (!Array.isArray(object.badgeContainer))
                throw TypeError(".Annotations.badgeContainer: array expected");
            message.badgeContainer = [];
            for (var i = 0; i < object.badgeContainer.length; ++i) {
                if (typeof object.badgeContainer[i] !== "object")
                    throw TypeError(".Annotations.badgeContainer: object expected");
                message.badgeContainer[i] = $root.BadgeContainer.fromObject(object.badgeContainer[i]);
            }
        }
        if (object.sectionSuggestForRating != null) {
            if (typeof object.sectionSuggestForRating !== "object")
                throw TypeError(".Annotations.sectionSuggestForRating: object expected");
            message.sectionSuggestForRating = $root.SectionMetaData.fromObject(object.sectionSuggestForRating);
        }
        if (object.sectionPurchaseCrossSell != null) {
            if (typeof object.sectionPurchaseCrossSell !== "object")
                throw TypeError(".Annotations.sectionPurchaseCrossSell: object expected");
            message.sectionPurchaseCrossSell = $root.SectionMetaData.fromObject(object.sectionPurchaseCrossSell);
        }
        if (object.overflowLink) {
            if (!Array.isArray(object.overflowLink))
                throw TypeError(".Annotations.overflowLink: array expected");
            message.overflowLink = [];
            for (var i = 0; i < object.overflowLink.length; ++i) {
                if (typeof object.overflowLink[i] !== "object")
                    throw TypeError(".Annotations.overflowLink: object expected");
                message.overflowLink[i] = $root.OverflowLink.fromObject(object.overflowLink[i]);
            }
        }
        if (object.attributionHtml != null)
            message.attributionHtml = String(object.attributionHtml);
        if (object.purchaseHistoryDetails != null) {
            if (typeof object.purchaseHistoryDetails !== "object")
                throw TypeError(".Annotations.purchaseHistoryDetails: object expected");
            message.purchaseHistoryDetails = $root.PurchaseHistoryDetails.fromObject(object.purchaseHistoryDetails);
        }
        if (object.badgeForLegacyRating != null) {
            if (typeof object.badgeForLegacyRating !== "object")
                throw TypeError(".Annotations.badgeForLegacyRating: object expected");
            message.badgeForLegacyRating = $root.Badge.fromObject(object.badgeForLegacyRating);
        }
        if (object.voucherInfo) {
            if (!Array.isArray(object.voucherInfo))
                throw TypeError(".Annotations.voucherInfo: array expected");
            message.voucherInfo = [];
            for (var i = 0; i < object.voucherInfo.length; ++i) {
                if (typeof object.voucherInfo[i] !== "object")
                    throw TypeError(".Annotations.voucherInfo: object expected");
                message.voucherInfo[i] = $root.VoucherInfo.fromObject(object.voucherInfo[i]);
            }
        }
        if (object.sectionFeaturedApps != null) {
            if (typeof object.sectionFeaturedApps !== "object")
                throw TypeError(".Annotations.sectionFeaturedApps: object expected");
            message.sectionFeaturedApps = $root.SectionMetaData.fromObject(object.sectionFeaturedApps);
        }
        if (object.detailsPageCluster) {
            if (!Array.isArray(object.detailsPageCluster))
                throw TypeError(".Annotations.detailsPageCluster: array expected");
            message.detailsPageCluster = [];
            for (var i = 0; i < object.detailsPageCluster.length; ++i) {
                if (typeof object.detailsPageCluster[i] !== "object")
                    throw TypeError(".Annotations.detailsPageCluster: object expected");
                message.detailsPageCluster[i] = $root.SectionMetaData.fromObject(object.detailsPageCluster[i]);
            }
        }
        if (object.videoAnnotations != null) {
            if (typeof object.videoAnnotations !== "object")
                throw TypeError(".Annotations.videoAnnotations: object expected");
            message.videoAnnotations = $root.VideoAnnotations.fromObject(object.videoAnnotations);
        }
        if (object.sectionPurchaseRelatedTopics != null) {
            if (typeof object.sectionPurchaseRelatedTopics !== "object")
                throw TypeError(".Annotations.sectionPurchaseRelatedTopics: object expected");
            message.sectionPurchaseRelatedTopics = $root.SectionMetaData.fromObject(object.sectionPurchaseRelatedTopics);
        }
        if (object.mySubscriptionDetails != null) {
            if (typeof object.mySubscriptionDetails !== "object")
                throw TypeError(".Annotations.mySubscriptionDetails: object expected");
            message.mySubscriptionDetails = $root.MySubscriptionDetails.fromObject(object.mySubscriptionDetails);
        }
        if (object.myRewardDetails != null) {
            if (typeof object.myRewardDetails !== "object")
                throw TypeError(".Annotations.myRewardDetails: object expected");
            message.myRewardDetails = $root.MyRewardDetails.fromObject(object.myRewardDetails);
        }
        if (object.featureBadge) {
            if (!Array.isArray(object.featureBadge))
                throw TypeError(".Annotations.featureBadge: array expected");
            message.featureBadge = [];
            for (var i = 0; i < object.featureBadge.length; ++i) {
                if (typeof object.featureBadge[i] !== "object")
                    throw TypeError(".Annotations.featureBadge: object expected");
                message.featureBadge[i] = $root.Badge.fromObject(object.featureBadge[i]);
            }
        }
        if (object.snippet != null) {
            if (typeof object.snippet !== "object")
                throw TypeError(".Annotations.snippet: object expected");
            message.snippet = $root.Snippet.fromObject(object.snippet);
        }
        if (object.downloadsLabel != null)
            message.downloadsLabel = String(object.downloadsLabel);
        if (object.badgeForRating != null) {
            if (typeof object.badgeForRating !== "object")
                throw TypeError(".Annotations.badgeForRating: object expected");
            message.badgeForRating = $root.Badge.fromObject(object.badgeForRating);
        }
        if (object.categoryInfo != null) {
            if (typeof object.categoryInfo !== "object")
                throw TypeError(".Annotations.categoryInfo: object expected");
            message.categoryInfo = $root.CategoryInfo.fromObject(object.categoryInfo);
        }
        if (object.reasons != null) {
            if (typeof object.reasons !== "object")
                throw TypeError(".Annotations.reasons: object expected");
            message.reasons = $root.EditorReason.fromObject(object.reasons);
        }
        if (object.topChartStream != null) {
            if (typeof object.topChartStream !== "object")
                throw TypeError(".Annotations.topChartStream: object expected");
            message.topChartStream = $root.Stream.fromObject(object.topChartStream);
        }
        if (object.categoryName != null)
            message.categoryName = String(object.categoryName);
        if (object.chip) {
            if (!Array.isArray(object.chip))
                throw TypeError(".Annotations.chip: array expected");
            message.chip = [];
            for (var i = 0; i < object.chip.length; ++i) {
                if (typeof object.chip[i] !== "object")
                    throw TypeError(".Annotations.chip: object expected");
                message.chip[i] = $root.Chip.fromObject(object.chip[i]);
            }
        }
        if (object.displayBadge) {
            if (!Array.isArray(object.displayBadge))
                throw TypeError(".Annotations.displayBadge: array expected");
            message.displayBadge = [];
            for (var i = 0; i < object.displayBadge.length; ++i) {
                if (typeof object.displayBadge[i] !== "object")
                    throw TypeError(".Annotations.displayBadge: object expected");
                message.displayBadge[i] = $root.Badge.fromObject(object.displayBadge[i]);
            }
        }
        if (object.liveStreamUrl != null)
            message.liveStreamUrl = String(object.liveStreamUrl);
        if (object.promotionStreamUrl != null)
            message.promotionStreamUrl = String(object.promotionStreamUrl);
        if (object.overlayMetaDataExtra != null) {
            if (typeof object.overlayMetaDataExtra !== "object")
                throw TypeError(".Annotations.overlayMetaDataExtra: object expected");
            message.overlayMetaDataExtra = $root.OverlayMetaData.fromObject(object.overlayMetaDataExtra);
        }
        if (object.sectionImage != null) {
            if (typeof object.sectionImage !== "object")
                throw TypeError(".Annotations.sectionImage: object expected");
            message.sectionImage = $root.SectionImage.fromObject(object.sectionImage);
        }
        if (object.categoryStream != null) {
            if (typeof object.categoryStream !== "object")
                throw TypeError(".Annotations.categoryStream: object expected");
            message.categoryStream = $root.SubStream.fromObject(object.categoryStream);
        }
        return message;
    };

    /**
     * Creates a plain object from an Annotations message. Also converts values to other types if specified.
     * @function toObject
     * @memberof Annotations
     * @static
     * @param {Annotations} message Annotations
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    Annotations.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        var object = {};
        if (options.arrays || options.defaults) {
            object.warning = [];
            object.badgeForCreator = [];
            object.infoBadge = [];
            object.promotedDoc = [];
            object.badgeContainer = [];
            object.overflowLink = [];
            object.voucherInfo = [];
            object.detailsPageCluster = [];
            object.featureBadge = [];
            object.chip = [];
            object.displayBadge = [];
        }
        if (options.defaults) {
            object.sectionRelated = null;
            object.sectionMoreBy = null;
            object.sectionBodyOfWork = null;
            object.sectionCoreContent = null;
            object.overlayMetaData = null;
            object.annotationLink = null;
            object.sectionCrossSell = null;
            object.sectionRelatedItemType = null;
            object.offerNote = "";
            object.privacyPolicyUrl = "";
            object.suggestionReasons = null;
            object.optimalDeviceClassWarning = null;
            object.sectionSuggestForRating = null;
            object.sectionPurchaseCrossSell = null;
            object.attributionHtml = "";
            object.purchaseHistoryDetails = null;
            object.badgeForLegacyRating = null;
            object.sectionFeaturedApps = null;
            object.videoAnnotations = null;
            object.sectionPurchaseRelatedTopics = null;
            object.mySubscriptionDetails = null;
            object.myRewardDetails = null;
            object.snippet = null;
            object.downloadsLabel = "";
            object.badgeForRating = null;
            object.categoryInfo = null;
            object.reasons = null;
            object.topChartStream = null;
            object.categoryName = "";
            object.liveStreamUrl = "";
            object.promotionStreamUrl = "";
            object.overlayMetaDataExtra = null;
            object.sectionImage = null;
            object.categoryStream = null;
        }
        if (message.sectionRelated != null && message.hasOwnProperty("sectionRelated"))
            object.sectionRelated = $root.SectionMetaData.toObject(message.sectionRelated, options);
        if (message.sectionMoreBy != null && message.hasOwnProperty("sectionMoreBy"))
            object.sectionMoreBy = $root.SectionMetaData.toObject(message.sectionMoreBy, options);
        if (message.warning && message.warning.length) {
            object.warning = [];
            for (var j = 0; j < message.warning.length; ++j)
                object.warning[j] = $root.Warning.toObject(message.warning[j], options);
        }
        if (message.sectionBodyOfWork != null && message.hasOwnProperty("sectionBodyOfWork"))
            object.sectionBodyOfWork = $root.SectionMetaData.toObject(message.sectionBodyOfWork, options);
        if (message.sectionCoreContent != null && message.hasOwnProperty("sectionCoreContent"))
            object.sectionCoreContent = $root.SectionMetaData.toObject(message.sectionCoreContent, options);
        if (message.overlayMetaData != null && message.hasOwnProperty("overlayMetaData"))
            object.overlayMetaData = $root.OverlayMetaData.toObject(message.overlayMetaData, options);
        if (message.badgeForCreator && message.badgeForCreator.length) {
            object.badgeForCreator = [];
            for (var j = 0; j < message.badgeForCreator.length; ++j)
                object.badgeForCreator[j] = $root.Badge.toObject(message.badgeForCreator[j], options);
        }
        if (message.infoBadge && message.infoBadge.length) {
            object.infoBadge = [];
            for (var j = 0; j < message.infoBadge.length; ++j)
                object.infoBadge[j] = $root.Badge.toObject(message.infoBadge[j], options);
        }
        if (message.annotationLink != null && message.hasOwnProperty("annotationLink"))
            object.annotationLink = $root.AnnotationLink.toObject(message.annotationLink, options);
        if (message.sectionCrossSell != null && message.hasOwnProperty("sectionCrossSell"))
            object.sectionCrossSell = $root.SectionMetaData.toObject(message.sectionCrossSell, options);
        if (message.sectionRelatedItemType != null && message.hasOwnProperty("sectionRelatedItemType"))
            object.sectionRelatedItemType = $root.SectionMetaData.toObject(message.sectionRelatedItemType, options);
        if (message.promotedDoc && message.promotedDoc.length) {
            object.promotedDoc = [];
            for (var j = 0; j < message.promotedDoc.length; ++j)
                object.promotedDoc[j] = $root.PromotedDoc.toObject(message.promotedDoc[j], options);
        }
        if (message.offerNote != null && message.hasOwnProperty("offerNote"))
            object.offerNote = message.offerNote;
        if (message.privacyPolicyUrl != null && message.hasOwnProperty("privacyPolicyUrl"))
            object.privacyPolicyUrl = message.privacyPolicyUrl;
        if (message.suggestionReasons != null && message.hasOwnProperty("suggestionReasons"))
            object.suggestionReasons = $root.SuggestionReasons.toObject(message.suggestionReasons, options);
        if (message.optimalDeviceClassWarning != null && message.hasOwnProperty("optimalDeviceClassWarning"))
            object.optimalDeviceClassWarning = $root.Warning.toObject(message.optimalDeviceClassWarning, options);
        if (message.badgeContainer && message.badgeContainer.length) {
            object.badgeContainer = [];
            for (var j = 0; j < message.badgeContainer.length; ++j)
                object.badgeContainer[j] = $root.BadgeContainer.toObject(message.badgeContainer[j], options);
        }
        if (message.sectionSuggestForRating != null && message.hasOwnProperty("sectionSuggestForRating"))
            object.sectionSuggestForRating = $root.SectionMetaData.toObject(message.sectionSuggestForRating, options);
        if (message.sectionPurchaseCrossSell != null && message.hasOwnProperty("sectionPurchaseCrossSell"))
            object.sectionPurchaseCrossSell = $root.SectionMetaData.toObject(message.sectionPurchaseCrossSell, options);
        if (message.overflowLink && message.overflowLink.length) {
            object.overflowLink = [];
            for (var j = 0; j < message.overflowLink.length; ++j)
                object.overflowLink[j] = $root.OverflowLink.toObject(message.overflowLink[j], options);
        }
        if (message.attributionHtml != null && message.hasOwnProperty("attributionHtml"))
            object.attributionHtml = message.attributionHtml;
        if (message.purchaseHistoryDetails != null && message.hasOwnProperty("purchaseHistoryDetails"))
            object.purchaseHistoryDetails = $root.PurchaseHistoryDetails.toObject(message.purchaseHistoryDetails, options);
        if (message.badgeForLegacyRating != null && message.hasOwnProperty("badgeForLegacyRating"))
            object.badgeForLegacyRating = $root.Badge.toObject(message.badgeForLegacyRating, options);
        if (message.voucherInfo && message.voucherInfo.length) {
            object.voucherInfo = [];
            for (var j = 0; j < message.voucherInfo.length; ++j)
                object.voucherInfo[j] = $root.VoucherInfo.toObject(message.voucherInfo[j], options);
        }
        if (message.sectionFeaturedApps != null && message.hasOwnProperty("sectionFeaturedApps"))
            object.sectionFeaturedApps = $root.SectionMetaData.toObject(message.sectionFeaturedApps, options);
        if (message.detailsPageCluster && message.detailsPageCluster.length) {
            object.detailsPageCluster = [];
            for (var j = 0; j < message.detailsPageCluster.length; ++j)
                object.detailsPageCluster[j] = $root.SectionMetaData.toObject(message.detailsPageCluster[j], options);
        }
        if (message.videoAnnotations != null && message.hasOwnProperty("videoAnnotations"))
            object.videoAnnotations = $root.VideoAnnotations.toObject(message.videoAnnotations, options);
        if (message.sectionPurchaseRelatedTopics != null && message.hasOwnProperty("sectionPurchaseRelatedTopics"))
            object.sectionPurchaseRelatedTopics = $root.SectionMetaData.toObject(message.sectionPurchaseRelatedTopics, options);
        if (message.mySubscriptionDetails != null && message.hasOwnProperty("mySubscriptionDetails"))
            object.mySubscriptionDetails = $root.MySubscriptionDetails.toObject(message.mySubscriptionDetails, options);
        if (message.myRewardDetails != null && message.hasOwnProperty("myRewardDetails"))
            object.myRewardDetails = $root.MyRewardDetails.toObject(message.myRewardDetails, options);
        if (message.featureBadge && message.featureBadge.length) {
            object.featureBadge = [];
            for (var j = 0; j < message.featureBadge.length; ++j)
                object.featureBadge[j] = $root.Badge.toObject(message.featureBadge[j], options);
        }
        if (message.snippet != null && message.hasOwnProperty("snippet"))
            object.snippet = $root.Snippet.toObject(message.snippet, options);
        if (message.downloadsLabel != null && message.hasOwnProperty("downloadsLabel"))
            object.downloadsLabel = message.downloadsLabel;
        if (message.badgeForRating != null && message.hasOwnProperty("badgeForRating"))
            object.badgeForRating = $root.Badge.toObject(message.badgeForRating, options);
        if (message.categoryInfo != null && message.hasOwnProperty("categoryInfo"))
            object.categoryInfo = $root.CategoryInfo.toObject(message.categoryInfo, options);
        if (message.reasons != null && message.hasOwnProperty("reasons"))
            object.reasons = $root.EditorReason.toObject(message.reasons, options);
        if (message.topChartStream != null && message.hasOwnProperty("topChartStream"))
            object.topChartStream = $root.Stream.toObject(message.topChartStream, options);
        if (message.categoryName != null && message.hasOwnProperty("categoryName"))
            object.categoryName = message.categoryName;
        if (message.chip && message.chip.length) {
            object.chip = [];
            for (var j = 0; j < message.chip.length; ++j)
                object.chip[j] = $root.Chip.toObject(message.chip[j], options);
        }
        if (message.displayBadge && message.displayBadge.length) {
            object.displayBadge = [];
            for (var j = 0; j < message.displayBadge.length; ++j)
                object.displayBadge[j] = $root.Badge.toObject(message.displayBadge[j], options);
        }
        if (message.liveStreamUrl != null && message.hasOwnProperty("liveStreamUrl"))
            object.liveStreamUrl = message.liveStreamUrl;
        if (message.promotionStreamUrl != null && message.hasOwnProperty("promotionStreamUrl"))
            object.promotionStreamUrl = message.promotionStreamUrl;
        if (message.overlayMetaDataExtra != null && message.hasOwnProperty("overlayMetaDataExtra"))
            object.overlayMetaDataExtra = $root.OverlayMetaData.toObject(message.overlayMetaDataExtra, options);
        if (message.sectionImage != null && message.hasOwnProperty("sectionImage"))
            object.sectionImage = $root.SectionImage.toObject(message.sectionImage, options);
        if (message.categoryStream != null && message.hasOwnProperty("categoryStream"))
            object.categoryStream = $root.SubStream.toObject(message.categoryStream, options);
        return object;
    };

    /**
     * Converts this Annotations to JSON.
     * @function toJSON
     * @memberof Annotations
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    Annotations.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return Annotations;
})();

$root.EditorReason = (function() {

    /**
     * Properties of an EditorReason.
     * @exports IEditorReason
     * @interface IEditorReason
     * @property {Array.<string>|null} [bulletin] EditorReason bulletin
     * @property {string|null} [description] EditorReason description
     */

    /**
     * Constructs a new EditorReason.
     * @exports EditorReason
     * @classdesc Represents an EditorReason.
     * @implements IEditorReason
     * @constructor
     * @param {IEditorReason=} [properties] Properties to set
     */
    function EditorReason(properties) {
        this.bulletin = [];
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * EditorReason bulletin.
     * @member {Array.<string>} bulletin
     * @memberof EditorReason
     * @instance
     */
    EditorReason.prototype.bulletin = $util.emptyArray;

    /**
     * EditorReason description.
     * @member {string} description
     * @memberof EditorReason
     * @instance
     */
    EditorReason.prototype.description = "";

    /**
     * Creates a new EditorReason instance using the specified properties.
     * @function create
     * @memberof EditorReason
     * @static
     * @param {IEditorReason=} [properties] Properties to set
     * @returns {EditorReason} EditorReason instance
     */
    EditorReason.create = function create(properties) {
        return new EditorReason(properties);
    };

    /**
     * Encodes the specified EditorReason message. Does not implicitly {@link EditorReason.verify|verify} messages.
     * @function encode
     * @memberof EditorReason
     * @static
     * @param {IEditorReason} message EditorReason message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    EditorReason.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.bulletin != null && message.bulletin.length)
            for (var i = 0; i < message.bulletin.length; ++i)
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.bulletin[i]);
        if (message.description != null && Object.hasOwnProperty.call(message, "description"))
            writer.uint32(/* id 2, wireType 2 =*/18).string(message.description);
        return writer;
    };

    /**
     * Encodes the specified EditorReason message, length delimited. Does not implicitly {@link EditorReason.verify|verify} messages.
     * @function encodeDelimited
     * @memberof EditorReason
     * @static
     * @param {IEditorReason} message EditorReason message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    EditorReason.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes an EditorReason message from the specified reader or buffer.
     * @function decode
     * @memberof EditorReason
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {EditorReason} EditorReason
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    EditorReason.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.EditorReason();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                if (!(message.bulletin && message.bulletin.length))
                    message.bulletin = [];
                message.bulletin.push(reader.string());
                break;
            case 2:
                message.description = reader.string();
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes an EditorReason message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof EditorReason
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {EditorReason} EditorReason
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    EditorReason.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies an EditorReason message.
     * @function verify
     * @memberof EditorReason
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    EditorReason.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.bulletin != null && message.hasOwnProperty("bulletin")) {
            if (!Array.isArray(message.bulletin))
                return "bulletin: array expected";
            for (var i = 0; i < message.bulletin.length; ++i)
                if (!$util.isString(message.bulletin[i]))
                    return "bulletin: string[] expected";
        }
        if (message.description != null && message.hasOwnProperty("description"))
            if (!$util.isString(message.description))
                return "description: string expected";
        return null;
    };

    /**
     * Creates an EditorReason message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof EditorReason
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {EditorReason} EditorReason
     */
    EditorReason.fromObject = function fromObject(object) {
        if (object instanceof $root.EditorReason)
            return object;
        var message = new $root.EditorReason();
        if (object.bulletin) {
            if (!Array.isArray(object.bulletin))
                throw TypeError(".EditorReason.bulletin: array expected");
            message.bulletin = [];
            for (var i = 0; i < object.bulletin.length; ++i)
                message.bulletin[i] = String(object.bulletin[i]);
        }
        if (object.description != null)
            message.description = String(object.description);
        return message;
    };

    /**
     * Creates a plain object from an EditorReason message. Also converts values to other types if specified.
     * @function toObject
     * @memberof EditorReason
     * @static
     * @param {EditorReason} message EditorReason
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    EditorReason.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        var object = {};
        if (options.arrays || options.defaults)
            object.bulletin = [];
        if (options.defaults)
            object.description = "";
        if (message.bulletin && message.bulletin.length) {
            object.bulletin = [];
            for (var j = 0; j < message.bulletin.length; ++j)
                object.bulletin[j] = message.bulletin[j];
        }
        if (message.description != null && message.hasOwnProperty("description"))
            object.description = message.description;
        return object;
    };

    /**
     * Converts this EditorReason to JSON.
     * @function toJSON
     * @memberof EditorReason
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    EditorReason.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return EditorReason;
})();

$root.SectionMetaData = (function() {

    /**
     * Properties of a SectionMetaData.
     * @exports ISectionMetaData
     * @interface ISectionMetaData
     * @property {string|null} [header] SectionMetaData header
     * @property {string|null} [listUrl] SectionMetaData listUrl
     * @property {string|null} [browseUrl] SectionMetaData browseUrl
     * @property {string|null} [description] SectionMetaData description
     */

    /**
     * Constructs a new SectionMetaData.
     * @exports SectionMetaData
     * @classdesc Represents a SectionMetaData.
     * @implements ISectionMetaData
     * @constructor
     * @param {ISectionMetaData=} [properties] Properties to set
     */
    function SectionMetaData(properties) {
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * SectionMetaData header.
     * @member {string} header
     * @memberof SectionMetaData
     * @instance
     */
    SectionMetaData.prototype.header = "";

    /**
     * SectionMetaData listUrl.
     * @member {string} listUrl
     * @memberof SectionMetaData
     * @instance
     */
    SectionMetaData.prototype.listUrl = "";

    /**
     * SectionMetaData browseUrl.
     * @member {string} browseUrl
     * @memberof SectionMetaData
     * @instance
     */
    SectionMetaData.prototype.browseUrl = "";

    /**
     * SectionMetaData description.
     * @member {string} description
     * @memberof SectionMetaData
     * @instance
     */
    SectionMetaData.prototype.description = "";

    /**
     * Creates a new SectionMetaData instance using the specified properties.
     * @function create
     * @memberof SectionMetaData
     * @static
     * @param {ISectionMetaData=} [properties] Properties to set
     * @returns {SectionMetaData} SectionMetaData instance
     */
    SectionMetaData.create = function create(properties) {
        return new SectionMetaData(properties);
    };

    /**
     * Encodes the specified SectionMetaData message. Does not implicitly {@link SectionMetaData.verify|verify} messages.
     * @function encode
     * @memberof SectionMetaData
     * @static
     * @param {ISectionMetaData} message SectionMetaData message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    SectionMetaData.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.header != null && Object.hasOwnProperty.call(message, "header"))
            writer.uint32(/* id 1, wireType 2 =*/10).string(message.header);
        if (message.listUrl != null && Object.hasOwnProperty.call(message, "listUrl"))
            writer.uint32(/* id 2, wireType 2 =*/18).string(message.listUrl);
        if (message.browseUrl != null && Object.hasOwnProperty.call(message, "browseUrl"))
            writer.uint32(/* id 3, wireType 2 =*/26).string(message.browseUrl);
        if (message.description != null && Object.hasOwnProperty.call(message, "description"))
            writer.uint32(/* id 4, wireType 2 =*/34).string(message.description);
        return writer;
    };

    /**
     * Encodes the specified SectionMetaData message, length delimited. Does not implicitly {@link SectionMetaData.verify|verify} messages.
     * @function encodeDelimited
     * @memberof SectionMetaData
     * @static
     * @param {ISectionMetaData} message SectionMetaData message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    SectionMetaData.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a SectionMetaData message from the specified reader or buffer.
     * @function decode
     * @memberof SectionMetaData
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {SectionMetaData} SectionMetaData
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    SectionMetaData.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.SectionMetaData();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.header = reader.string();
                break;
            case 2:
                message.listUrl = reader.string();
                break;
            case 3:
                message.browseUrl = reader.string();
                break;
            case 4:
                message.description = reader.string();
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a SectionMetaData message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof SectionMetaData
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {SectionMetaData} SectionMetaData
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    SectionMetaData.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a SectionMetaData message.
     * @function verify
     * @memberof SectionMetaData
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    SectionMetaData.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.header != null && message.hasOwnProperty("header"))
            if (!$util.isString(message.header))
                return "header: string expected";
        if (message.listUrl != null && message.hasOwnProperty("listUrl"))
            if (!$util.isString(message.listUrl))
                return "listUrl: string expected";
        if (message.browseUrl != null && message.hasOwnProperty("browseUrl"))
            if (!$util.isString(message.browseUrl))
                return "browseUrl: string expected";
        if (message.description != null && message.hasOwnProperty("description"))
            if (!$util.isString(message.description))
                return "description: string expected";
        return null;
    };

    /**
     * Creates a SectionMetaData message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof SectionMetaData
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {SectionMetaData} SectionMetaData
     */
    SectionMetaData.fromObject = function fromObject(object) {
        if (object instanceof $root.SectionMetaData)
            return object;
        var message = new $root.SectionMetaData();
        if (object.header != null)
            message.header = String(object.header);
        if (object.listUrl != null)
            message.listUrl = String(object.listUrl);
        if (object.browseUrl != null)
            message.browseUrl = String(object.browseUrl);
        if (object.description != null)
            message.description = String(object.description);
        return message;
    };

    /**
     * Creates a plain object from a SectionMetaData message. Also converts values to other types if specified.
     * @function toObject
     * @memberof SectionMetaData
     * @static
     * @param {SectionMetaData} message SectionMetaData
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    SectionMetaData.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        var object = {};
        if (options.defaults) {
            object.header = "";
            object.listUrl = "";
            object.browseUrl = "";
            object.description = "";
        }
        if (message.header != null && message.hasOwnProperty("header"))
            object.header = message.header;
        if (message.listUrl != null && message.hasOwnProperty("listUrl"))
            object.listUrl = message.listUrl;
        if (message.browseUrl != null && message.hasOwnProperty("browseUrl"))
            object.browseUrl = message.browseUrl;
        if (message.description != null && message.hasOwnProperty("description"))
            object.description = message.description;
        return object;
    };

    /**
     * Converts this SectionMetaData to JSON.
     * @function toJSON
     * @memberof SectionMetaData
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    SectionMetaData.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return SectionMetaData;
})();

$root.OverlayMetaData = (function() {

    /**
     * Properties of an OverlayMetaData.
     * @exports IOverlayMetaData
     * @interface IOverlayMetaData
     * @property {IOverlayHeader|null} [overlayHeader] OverlayMetaData overlayHeader
     * @property {IOverlayTitle|null} [overlayTitle] OverlayMetaData overlayTitle
     * @property {IOverlayDescription|null} [overlayDescription] OverlayMetaData overlayDescription
     */

    /**
     * Constructs a new OverlayMetaData.
     * @exports OverlayMetaData
     * @classdesc Represents an OverlayMetaData.
     * @implements IOverlayMetaData
     * @constructor
     * @param {IOverlayMetaData=} [properties] Properties to set
     */
    function OverlayMetaData(properties) {
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * OverlayMetaData overlayHeader.
     * @member {IOverlayHeader|null|undefined} overlayHeader
     * @memberof OverlayMetaData
     * @instance
     */
    OverlayMetaData.prototype.overlayHeader = null;

    /**
     * OverlayMetaData overlayTitle.
     * @member {IOverlayTitle|null|undefined} overlayTitle
     * @memberof OverlayMetaData
     * @instance
     */
    OverlayMetaData.prototype.overlayTitle = null;

    /**
     * OverlayMetaData overlayDescription.
     * @member {IOverlayDescription|null|undefined} overlayDescription
     * @memberof OverlayMetaData
     * @instance
     */
    OverlayMetaData.prototype.overlayDescription = null;

    /**
     * Creates a new OverlayMetaData instance using the specified properties.
     * @function create
     * @memberof OverlayMetaData
     * @static
     * @param {IOverlayMetaData=} [properties] Properties to set
     * @returns {OverlayMetaData} OverlayMetaData instance
     */
    OverlayMetaData.create = function create(properties) {
        return new OverlayMetaData(properties);
    };

    /**
     * Encodes the specified OverlayMetaData message. Does not implicitly {@link OverlayMetaData.verify|verify} messages.
     * @function encode
     * @memberof OverlayMetaData
     * @static
     * @param {IOverlayMetaData} message OverlayMetaData message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    OverlayMetaData.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.overlayHeader != null && Object.hasOwnProperty.call(message, "overlayHeader"))
            $root.OverlayHeader.encode(message.overlayHeader, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
        if (message.overlayTitle != null && Object.hasOwnProperty.call(message, "overlayTitle"))
            $root.OverlayTitle.encode(message.overlayTitle, writer.uint32(/* id 181, wireType 2 =*/1450).fork()).ldelim();
        if (message.overlayDescription != null && Object.hasOwnProperty.call(message, "overlayDescription"))
            $root.OverlayDescription.encode(message.overlayDescription, writer.uint32(/* id 182, wireType 2 =*/1458).fork()).ldelim();
        return writer;
    };

    /**
     * Encodes the specified OverlayMetaData message, length delimited. Does not implicitly {@link OverlayMetaData.verify|verify} messages.
     * @function encodeDelimited
     * @memberof OverlayMetaData
     * @static
     * @param {IOverlayMetaData} message OverlayMetaData message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    OverlayMetaData.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes an OverlayMetaData message from the specified reader or buffer.
     * @function decode
     * @memberof OverlayMetaData
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {OverlayMetaData} OverlayMetaData
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    OverlayMetaData.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.OverlayMetaData();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.overlayHeader = $root.OverlayHeader.decode(reader, reader.uint32());
                break;
            case 181:
                message.overlayTitle = $root.OverlayTitle.decode(reader, reader.uint32());
                break;
            case 182:
                message.overlayDescription = $root.OverlayDescription.decode(reader, reader.uint32());
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes an OverlayMetaData message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof OverlayMetaData
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {OverlayMetaData} OverlayMetaData
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    OverlayMetaData.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies an OverlayMetaData message.
     * @function verify
     * @memberof OverlayMetaData
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    OverlayMetaData.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.overlayHeader != null && message.hasOwnProperty("overlayHeader")) {
            var error = $root.OverlayHeader.verify(message.overlayHeader);
            if (error)
                return "overlayHeader." + error;
        }
        if (message.overlayTitle != null && message.hasOwnProperty("overlayTitle")) {
            var error = $root.OverlayTitle.verify(message.overlayTitle);
            if (error)
                return "overlayTitle." + error;
        }
        if (message.overlayDescription != null && message.hasOwnProperty("overlayDescription")) {
            var error = $root.OverlayDescription.verify(message.overlayDescription);
            if (error)
                return "overlayDescription." + error;
        }
        return null;
    };

    /**
     * Creates an OverlayMetaData message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof OverlayMetaData
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {OverlayMetaData} OverlayMetaData
     */
    OverlayMetaData.fromObject = function fromObject(object) {
        if (object instanceof $root.OverlayMetaData)
            return object;
        var message = new $root.OverlayMetaData();
        if (object.overlayHeader != null) {
            if (typeof object.overlayHeader !== "object")
                throw TypeError(".OverlayMetaData.overlayHeader: object expected");
            message.overlayHeader = $root.OverlayHeader.fromObject(object.overlayHeader);
        }
        if (object.overlayTitle != null) {
            if (typeof object.overlayTitle !== "object")
                throw TypeError(".OverlayMetaData.overlayTitle: object expected");
            message.overlayTitle = $root.OverlayTitle.fromObject(object.overlayTitle);
        }
        if (object.overlayDescription != null) {
            if (typeof object.overlayDescription !== "object")
                throw TypeError(".OverlayMetaData.overlayDescription: object expected");
            message.overlayDescription = $root.OverlayDescription.fromObject(object.overlayDescription);
        }
        return message;
    };

    /**
     * Creates a plain object from an OverlayMetaData message. Also converts values to other types if specified.
     * @function toObject
     * @memberof OverlayMetaData
     * @static
     * @param {OverlayMetaData} message OverlayMetaData
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    OverlayMetaData.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        var object = {};
        if (options.defaults) {
            object.overlayHeader = null;
            object.overlayTitle = null;
            object.overlayDescription = null;
        }
        if (message.overlayHeader != null && message.hasOwnProperty("overlayHeader"))
            object.overlayHeader = $root.OverlayHeader.toObject(message.overlayHeader, options);
        if (message.overlayTitle != null && message.hasOwnProperty("overlayTitle"))
            object.overlayTitle = $root.OverlayTitle.toObject(message.overlayTitle, options);
        if (message.overlayDescription != null && message.hasOwnProperty("overlayDescription"))
            object.overlayDescription = $root.OverlayDescription.toObject(message.overlayDescription, options);
        return object;
    };

    /**
     * Converts this OverlayMetaData to JSON.
     * @function toJSON
     * @memberof OverlayMetaData
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    OverlayMetaData.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return OverlayMetaData;
})();

$root.OverlayHeader = (function() {

    /**
     * Properties of an OverlayHeader.
     * @exports IOverlayHeader
     * @interface IOverlayHeader
     */

    /**
     * Constructs a new OverlayHeader.
     * @exports OverlayHeader
     * @classdesc Represents an OverlayHeader.
     * @implements IOverlayHeader
     * @constructor
     * @param {IOverlayHeader=} [properties] Properties to set
     */
    function OverlayHeader(properties) {
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * Creates a new OverlayHeader instance using the specified properties.
     * @function create
     * @memberof OverlayHeader
     * @static
     * @param {IOverlayHeader=} [properties] Properties to set
     * @returns {OverlayHeader} OverlayHeader instance
     */
    OverlayHeader.create = function create(properties) {
        return new OverlayHeader(properties);
    };

    /**
     * Encodes the specified OverlayHeader message. Does not implicitly {@link OverlayHeader.verify|verify} messages.
     * @function encode
     * @memberof OverlayHeader
     * @static
     * @param {IOverlayHeader} message OverlayHeader message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    OverlayHeader.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        return writer;
    };

    /**
     * Encodes the specified OverlayHeader message, length delimited. Does not implicitly {@link OverlayHeader.verify|verify} messages.
     * @function encodeDelimited
     * @memberof OverlayHeader
     * @static
     * @param {IOverlayHeader} message OverlayHeader message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    OverlayHeader.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes an OverlayHeader message from the specified reader or buffer.
     * @function decode
     * @memberof OverlayHeader
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {OverlayHeader} OverlayHeader
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    OverlayHeader.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.OverlayHeader();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes an OverlayHeader message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof OverlayHeader
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {OverlayHeader} OverlayHeader
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    OverlayHeader.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies an OverlayHeader message.
     * @function verify
     * @memberof OverlayHeader
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    OverlayHeader.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        return null;
    };

    /**
     * Creates an OverlayHeader message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof OverlayHeader
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {OverlayHeader} OverlayHeader
     */
    OverlayHeader.fromObject = function fromObject(object) {
        if (object instanceof $root.OverlayHeader)
            return object;
        return new $root.OverlayHeader();
    };

    /**
     * Creates a plain object from an OverlayHeader message. Also converts values to other types if specified.
     * @function toObject
     * @memberof OverlayHeader
     * @static
     * @param {OverlayHeader} message OverlayHeader
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    OverlayHeader.toObject = function toObject() {
        return {};
    };

    /**
     * Converts this OverlayHeader to JSON.
     * @function toJSON
     * @memberof OverlayHeader
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    OverlayHeader.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return OverlayHeader;
})();

$root.OverlayTitle = (function() {

    /**
     * Properties of an OverlayTitle.
     * @exports IOverlayTitle
     * @interface IOverlayTitle
     * @property {string|null} [title] OverlayTitle title
     * @property {ICompositeImage|null} [compositeImage] OverlayTitle compositeImage
     */

    /**
     * Constructs a new OverlayTitle.
     * @exports OverlayTitle
     * @classdesc Represents an OverlayTitle.
     * @implements IOverlayTitle
     * @constructor
     * @param {IOverlayTitle=} [properties] Properties to set
     */
    function OverlayTitle(properties) {
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * OverlayTitle title.
     * @member {string} title
     * @memberof OverlayTitle
     * @instance
     */
    OverlayTitle.prototype.title = "";

    /**
     * OverlayTitle compositeImage.
     * @member {ICompositeImage|null|undefined} compositeImage
     * @memberof OverlayTitle
     * @instance
     */
    OverlayTitle.prototype.compositeImage = null;

    /**
     * Creates a new OverlayTitle instance using the specified properties.
     * @function create
     * @memberof OverlayTitle
     * @static
     * @param {IOverlayTitle=} [properties] Properties to set
     * @returns {OverlayTitle} OverlayTitle instance
     */
    OverlayTitle.create = function create(properties) {
        return new OverlayTitle(properties);
    };

    /**
     * Encodes the specified OverlayTitle message. Does not implicitly {@link OverlayTitle.verify|verify} messages.
     * @function encode
     * @memberof OverlayTitle
     * @static
     * @param {IOverlayTitle} message OverlayTitle message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    OverlayTitle.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.title != null && Object.hasOwnProperty.call(message, "title"))
            writer.uint32(/* id 1, wireType 2 =*/10).string(message.title);
        if (message.compositeImage != null && Object.hasOwnProperty.call(message, "compositeImage"))
            $root.CompositeImage.encode(message.compositeImage, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
        return writer;
    };

    /**
     * Encodes the specified OverlayTitle message, length delimited. Does not implicitly {@link OverlayTitle.verify|verify} messages.
     * @function encodeDelimited
     * @memberof OverlayTitle
     * @static
     * @param {IOverlayTitle} message OverlayTitle message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    OverlayTitle.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes an OverlayTitle message from the specified reader or buffer.
     * @function decode
     * @memberof OverlayTitle
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {OverlayTitle} OverlayTitle
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    OverlayTitle.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.OverlayTitle();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.title = reader.string();
                break;
            case 3:
                message.compositeImage = $root.CompositeImage.decode(reader, reader.uint32());
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes an OverlayTitle message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof OverlayTitle
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {OverlayTitle} OverlayTitle
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    OverlayTitle.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies an OverlayTitle message.
     * @function verify
     * @memberof OverlayTitle
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    OverlayTitle.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.title != null && message.hasOwnProperty("title"))
            if (!$util.isString(message.title))
                return "title: string expected";
        if (message.compositeImage != null && message.hasOwnProperty("compositeImage")) {
            var error = $root.CompositeImage.verify(message.compositeImage);
            if (error)
                return "compositeImage." + error;
        }
        return null;
    };

    /**
     * Creates an OverlayTitle message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof OverlayTitle
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {OverlayTitle} OverlayTitle
     */
    OverlayTitle.fromObject = function fromObject(object) {
        if (object instanceof $root.OverlayTitle)
            return object;
        var message = new $root.OverlayTitle();
        if (object.title != null)
            message.title = String(object.title);
        if (object.compositeImage != null) {
            if (typeof object.compositeImage !== "object")
                throw TypeError(".OverlayTitle.compositeImage: object expected");
            message.compositeImage = $root.CompositeImage.fromObject(object.compositeImage);
        }
        return message;
    };

    /**
     * Creates a plain object from an OverlayTitle message. Also converts values to other types if specified.
     * @function toObject
     * @memberof OverlayTitle
     * @static
     * @param {OverlayTitle} message OverlayTitle
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    OverlayTitle.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        var object = {};
        if (options.defaults) {
            object.title = "";
            object.compositeImage = null;
        }
        if (message.title != null && message.hasOwnProperty("title"))
            object.title = message.title;
        if (message.compositeImage != null && message.hasOwnProperty("compositeImage"))
            object.compositeImage = $root.CompositeImage.toObject(message.compositeImage, options);
        return object;
    };

    /**
     * Converts this OverlayTitle to JSON.
     * @function toJSON
     * @memberof OverlayTitle
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    OverlayTitle.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return OverlayTitle;
})();

$root.CompositeImage = (function() {

    /**
     * Properties of a CompositeImage.
     * @exports ICompositeImage
     * @interface ICompositeImage
     * @property {number|null} [type] CompositeImage type
     * @property {string|null} [url] CompositeImage url
     * @property {number|null} [typeAlt] CompositeImage typeAlt
     * @property {string|null} [title] CompositeImage title
     * @property {string|null} [urlAlt] CompositeImage urlAlt
     */

    /**
     * Constructs a new CompositeImage.
     * @exports CompositeImage
     * @classdesc Represents a CompositeImage.
     * @implements ICompositeImage
     * @constructor
     * @param {ICompositeImage=} [properties] Properties to set
     */
    function CompositeImage(properties) {
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * CompositeImage type.
     * @member {number} type
     * @memberof CompositeImage
     * @instance
     */
    CompositeImage.prototype.type = 0;

    /**
     * CompositeImage url.
     * @member {string} url
     * @memberof CompositeImage
     * @instance
     */
    CompositeImage.prototype.url = "";

    /**
     * CompositeImage typeAlt.
     * @member {number} typeAlt
     * @memberof CompositeImage
     * @instance
     */
    CompositeImage.prototype.typeAlt = 0;

    /**
     * CompositeImage title.
     * @member {string} title
     * @memberof CompositeImage
     * @instance
     */
    CompositeImage.prototype.title = "";

    /**
     * CompositeImage urlAlt.
     * @member {string} urlAlt
     * @memberof CompositeImage
     * @instance
     */
    CompositeImage.prototype.urlAlt = "";

    /**
     * Creates a new CompositeImage instance using the specified properties.
     * @function create
     * @memberof CompositeImage
     * @static
     * @param {ICompositeImage=} [properties] Properties to set
     * @returns {CompositeImage} CompositeImage instance
     */
    CompositeImage.create = function create(properties) {
        return new CompositeImage(properties);
    };

    /**
     * Encodes the specified CompositeImage message. Does not implicitly {@link CompositeImage.verify|verify} messages.
     * @function encode
     * @memberof CompositeImage
     * @static
     * @param {ICompositeImage} message CompositeImage message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    CompositeImage.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.type != null && Object.hasOwnProperty.call(message, "type"))
            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.type);
        if (message.url != null && Object.hasOwnProperty.call(message, "url"))
            writer.uint32(/* id 5, wireType 2 =*/42).string(message.url);
        if (message.typeAlt != null && Object.hasOwnProperty.call(message, "typeAlt"))
            writer.uint32(/* id 9, wireType 0 =*/72).int32(message.typeAlt);
        if (message.title != null && Object.hasOwnProperty.call(message, "title"))
            writer.uint32(/* id 24, wireType 2 =*/194).string(message.title);
        if (message.urlAlt != null && Object.hasOwnProperty.call(message, "urlAlt"))
            writer.uint32(/* id 28, wireType 2 =*/226).string(message.urlAlt);
        return writer;
    };

    /**
     * Encodes the specified CompositeImage message, length delimited. Does not implicitly {@link CompositeImage.verify|verify} messages.
     * @function encodeDelimited
     * @memberof CompositeImage
     * @static
     * @param {ICompositeImage} message CompositeImage message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    CompositeImage.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a CompositeImage message from the specified reader or buffer.
     * @function decode
     * @memberof CompositeImage
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CompositeImage} CompositeImage
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CompositeImage.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CompositeImage();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.type = reader.int32();
                break;
            case 5:
                message.url = reader.string();
                break;
            case 9:
                message.typeAlt = reader.int32();
                break;
            case 24:
                message.title = reader.string();
                break;
            case 28:
                message.urlAlt = reader.string();
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a CompositeImage message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof CompositeImage
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {CompositeImage} CompositeImage
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CompositeImage.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a CompositeImage message.
     * @function verify
     * @memberof CompositeImage
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    CompositeImage.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.type != null && message.hasOwnProperty("type"))
            if (!$util.isInteger(message.type))
                return "type: integer expected";
        if (message.url != null && message.hasOwnProperty("url"))
            if (!$util.isString(message.url))
                return "url: string expected";
        if (message.typeAlt != null && message.hasOwnProperty("typeAlt"))
            if (!$util.isInteger(message.typeAlt))
                return "typeAlt: integer expected";
        if (message.title != null && message.hasOwnProperty("title"))
            if (!$util.isString(message.title))
                return "title: string expected";
        if (message.urlAlt != null && message.hasOwnProperty("urlAlt"))
            if (!$util.isString(message.urlAlt))
                return "urlAlt: string expected";
        return null;
    };

    /**
     * Creates a CompositeImage message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof CompositeImage
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {CompositeImage} CompositeImage
     */
    CompositeImage.fromObject = function fromObject(object) {
        if (object instanceof $root.CompositeImage)
            return object;
        var message = new $root.CompositeImage();
        if (object.type != null)
            message.type = object.type | 0;
        if (object.url != null)
            message.url = String(object.url);
        if (object.typeAlt != null)
            message.typeAlt = object.typeAlt | 0;
        if (object.title != null)
            message.title = String(object.title);
        if (object.urlAlt != null)
            message.urlAlt = String(object.urlAlt);
        return message;
    };

    /**
     * Creates a plain object from a CompositeImage message. Also converts values to other types if specified.
     * @function toObject
     * @memberof CompositeImage
     * @static
     * @param {CompositeImage} message CompositeImage
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    CompositeImage.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        var object = {};
        if (options.defaults) {
            object.type = 0;
            object.url = "";
            object.typeAlt = 0;
            object.title = "";
            object.urlAlt = "";
        }
        if (message.type != null && message.hasOwnProperty("type"))
            object.type = message.type;
        if (message.url != null && message.hasOwnProperty("url"))
            object.url = message.url;
        if (message.typeAlt != null && message.hasOwnProperty("typeAlt"))
            object.typeAlt = message.typeAlt;
        if (message.title != null && message.hasOwnProperty("title"))
            object.title = message.title;
        if (message.urlAlt != null && message.hasOwnProperty("urlAlt"))
            object.urlAlt = message.urlAlt;
        return object;
    };

    /**
     * Converts this CompositeImage to JSON.
     * @function toJSON
     * @memberof CompositeImage
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    CompositeImage.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return CompositeImage;
})();

$root.OverlayDescription = (function() {

    /**
     * Properties of an OverlayDescription.
     * @exports IOverlayDescription
     * @interface IOverlayDescription
     * @property {string|null} [description] OverlayDescription description
     */

    /**
     * Constructs a new OverlayDescription.
     * @exports OverlayDescription
     * @classdesc Represents an OverlayDescription.
     * @implements IOverlayDescription
     * @constructor
     * @param {IOverlayDescription=} [properties] Properties to set
     */
    function OverlayDescription(properties) {
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * OverlayDescription description.
     * @member {string} description
     * @memberof OverlayDescription
     * @instance
     */
    OverlayDescription.prototype.description = "";

    /**
     * Creates a new OverlayDescription instance using the specified properties.
     * @function create
     * @memberof OverlayDescription
     * @static
     * @param {IOverlayDescription=} [properties] Properties to set
     * @returns {OverlayDescription} OverlayDescription instance
     */
    OverlayDescription.create = function create(properties) {
        return new OverlayDescription(properties);
    };

    /**
     * Encodes the specified OverlayDescription message. Does not implicitly {@link OverlayDescription.verify|verify} messages.
     * @function encode
     * @memberof OverlayDescription
     * @static
     * @param {IOverlayDescription} message OverlayDescription message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    OverlayDescription.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.description != null && Object.hasOwnProperty.call(message, "description"))
            writer.uint32(/* id 2, wireType 2 =*/18).string(message.description);
        return writer;
    };

    /**
     * Encodes the specified OverlayDescription message, length delimited. Does not implicitly {@link OverlayDescription.verify|verify} messages.
     * @function encodeDelimited
     * @memberof OverlayDescription
     * @static
     * @param {IOverlayDescription} message OverlayDescription message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    OverlayDescription.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes an OverlayDescription message from the specified reader or buffer.
     * @function decode
     * @memberof OverlayDescription
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {OverlayDescription} OverlayDescription
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    OverlayDescription.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.OverlayDescription();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            case 2:
                message.description = reader.string();
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes an OverlayDescription message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof OverlayDescription
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {OverlayDescription} OverlayDescription
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    OverlayDescription.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies an OverlayDescription message.
     * @function verify
     * @memberof OverlayDescription
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    OverlayDescription.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.description != null && message.hasOwnProperty("description"))
            if (!$util.isString(message.description))
                return "description: string expected";
        return null;
    };

    /**
     * Creates an OverlayDescription message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof OverlayDescription
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {OverlayDescription} OverlayDescription
     */
    OverlayDescription.fromObject = function fromObject(object) {
        if (object instanceof $root.OverlayDescription)
            return object;
        var message = new $root.OverlayDescription();
        if (object.description != null)
            message.description = String(object.description);
        return message;
    };

    /**
     * Creates a plain object from an OverlayDescription message. Also converts values to other types if specified.
     * @function toObject
     * @memberof OverlayDescription
     * @static
     * @param {OverlayDescription} message OverlayDescription
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    OverlayDescription.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        var object = {};
        if (options.defaults)
            object.description = "";
        if (message.description != null && message.hasOwnProperty("description"))
            object.description = message.description;
        return object;
    };

    /**
     * Converts this OverlayDescription to JSON.
     * @function toJSON
     * @memberof OverlayDescription
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    OverlayDescription.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return OverlayDescription;
})();

$root.SuggestionReasons = (function() {

    /**
     * Properties of a SuggestionReasons.
     * @exports ISuggestionReasons
     * @interface ISuggestionReasons
     * @property {Array.<IReason>|null} [reason] SuggestionReasons reason
     * @property {IDismissal|null} [neutralDismissal] SuggestionReasons neutralDismissal
     * @property {IDismissal|null} [positiveDismissal] SuggestionReasons positiveDismissal
     */

    /**
     * Constructs a new SuggestionReasons.
     * @exports SuggestionReasons
     * @classdesc Represents a SuggestionReasons.
     * @implements ISuggestionReasons
     * @constructor
     * @param {ISuggestionReasons=} [properties] Properties to set
     */
    function SuggestionReasons(properties) {
        this.reason = [];
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * SuggestionReasons reason.
     * @member {Array.<IReason>} reason
     * @memberof SuggestionReasons
     * @instance
     */
    SuggestionReasons.prototype.reason = $util.emptyArray;

    /**
     * SuggestionReasons neutralDismissal.
     * @member {IDismissal|null|undefined} neutralDismissal
     * @memberof SuggestionReasons
     * @instance
     */
    SuggestionReasons.prototype.neutralDismissal = null;

    /**
     * SuggestionReasons positiveDismissal.
     * @member {IDismissal|null|undefined} positiveDismissal
     * @memberof SuggestionReasons
     * @instance
     */
    SuggestionReasons.prototype.positiveDismissal = null;

    /**
     * Creates a new SuggestionReasons instance using the specified properties.
     * @function create
     * @memberof SuggestionReasons
     * @static
     * @param {ISuggestionReasons=} [properties] Properties to set
     * @returns {SuggestionReasons} SuggestionReasons instance
     */
    SuggestionReasons.create = function create(properties) {
        return new SuggestionReasons(properties);
    };

    /**
     * Encodes the specified SuggestionReasons message. Does not implicitly {@link SuggestionReasons.verify|verify} messages.
     * @function encode
     * @memberof SuggestionReasons
     * @static
     * @param {ISuggestionReasons} message SuggestionReasons message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    SuggestionReasons.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.reason != null && message.reason.length)
            for (var i = 0; i < message.reason.length; ++i)
                $root.Reason.encode(message.reason[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
        if (message.neutralDismissal != null && Object.hasOwnProperty.call(message, "neutralDismissal"))
            $root.Dismissal.encode(message.neutralDismissal, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
        if (message.positiveDismissal != null && Object.hasOwnProperty.call(message, "positiveDismissal"))
            $root.Dismissal.encode(message.positiveDismissal, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
        return writer;
    };

    /**
     * Encodes the specified SuggestionReasons message, length delimited. Does not implicitly {@link SuggestionReasons.verify|verify} messages.
     * @function encodeDelimited
     * @memberof SuggestionReasons
     * @static
     * @param {ISuggestionReasons} message SuggestionReasons message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    SuggestionReasons.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a SuggestionReasons message from the specified reader or buffer.
     * @function decode
     * @memberof SuggestionReasons
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {SuggestionReasons} SuggestionReasons
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    SuggestionReasons.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.SuggestionReasons();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            case 2:
                if (!(message.reason && message.reason.length))
                    message.reason = [];
                message.reason.push($root.Reason.decode(reader, reader.uint32()));
                break;
            case 4:
                message.neutralDismissal = $root.Dismissal.decode(reader, reader.uint32());
                break;
            case 5:
                message.positiveDismissal = $root.Dismissal.decode(reader, reader.uint32());
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a SuggestionReasons message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof SuggestionReasons
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {SuggestionReasons} SuggestionReasons
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    SuggestionReasons.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a SuggestionReasons message.
     * @function verify
     * @memberof SuggestionReasons
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    SuggestionReasons.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.reason != null && message.hasOwnProperty("reason")) {
            if (!Array.isArray(message.reason))
                return "reason: array expected";
            for (var i = 0; i < message.reason.length; ++i) {
                var error = $root.Reason.verify(message.reason[i]);
                if (error)
                    return "reason." + error;
            }
        }
        if (message.neutralDismissal != null && message.hasOwnProperty("neutralDismissal")) {
            var error = $root.Dismissal.verify(message.neutralDismissal);
            if (error)
                return "neutralDismissal." + error;
        }
        if (message.positiveDismissal != null && message.hasOwnProperty("positiveDismissal")) {
            var error = $root.Dismissal.verify(message.positiveDismissal);
            if (error)
                return "positiveDismissal." + error;
        }
        return null;
    };

    /**
     * Creates a SuggestionReasons message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof SuggestionReasons
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {SuggestionReasons} SuggestionReasons
     */
    SuggestionReasons.fromObject = function fromObject(object) {
        if (object instanceof $root.SuggestionReasons)
            return object;
        var message = new $root.SuggestionReasons();
        if (object.reason) {
            if (!Array.isArray(object.reason))
                throw TypeError(".SuggestionReasons.reason: array expected");
            message.reason = [];
            for (var i = 0; i < object.reason.length; ++i) {
                if (typeof object.reason[i] !== "object")
                    throw TypeError(".SuggestionReasons.reason: object expected");
                message.reason[i] = $root.Reason.fromObject(object.reason[i]);
            }
        }
        if (object.neutralDismissal != null) {
            if (typeof object.neutralDismissal !== "object")
                throw TypeError(".SuggestionReasons.neutralDismissal: object expected");
            message.neutralDismissal = $root.Dismissal.fromObject(object.neutralDismissal);
        }
        if (object.positiveDismissal != null) {
            if (typeof object.positiveDismissal !== "object")
                throw TypeError(".SuggestionReasons.positiveDismissal: object expected");
            message.positiveDismissal = $root.Dismissal.fromObject(object.positiveDismissal);
        }
        return message;
    };

    /**
     * Creates a plain object from a SuggestionReasons message. Also converts values to other types if specified.
     * @function toObject
     * @memberof SuggestionReasons
     * @static
     * @param {SuggestionReasons} message SuggestionReasons
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    SuggestionReasons.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        var object = {};
        if (options.arrays || options.defaults)
            object.reason = [];
        if (options.defaults) {
            object.neutralDismissal = null;
            object.positiveDismissal = null;
        }
        if (message.reason && message.reason.length) {
            object.reason = [];
            for (var j = 0; j < message.reason.length; ++j)
                object.reason[j] = $root.Reason.toObject(message.reason[j], options);
        }
        if (message.neutralDismissal != null && message.hasOwnProperty("neutralDismissal"))
            object.neutralDismissal = $root.Dismissal.toObject(message.neutralDismissal, options);
        if (message.positiveDismissal != null && message.hasOwnProperty("positiveDismissal"))
            object.positiveDismissal = $root.Dismissal.toObject(message.positiveDismissal, options);
        return object;
    };

    /**
     * Converts this SuggestionReasons to JSON.
     * @function toJSON
     * @memberof SuggestionReasons
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    SuggestionReasons.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return SuggestionReasons;
})();

$root.Reason = (function() {

    /**
     * Properties of a Reason.
     * @exports IReason
     * @interface IReason
     * @property {string|null} [descriptionHtml] Reason descriptionHtml
     * @property {IReasonPlusOne|null} [reasonPlusOne] Reason reasonPlusOne
     * @property {IReasonReview|null} [reasonReview] Reason reasonReview
     * @property {IDismissal|null} [dismissal] Reason dismissal
     * @property {IReasonUserAction|null} [reasonUserAction] Reason reasonUserAction
     */

    /**
     * Constructs a new Reason.
     * @exports Reason
     * @classdesc Represents a Reason.
     * @implements IReason
     * @constructor
     * @param {IReason=} [properties] Properties to set
     */
    function Reason(properties) {
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * Reason descriptionHtml.
     * @member {string} descriptionHtml
     * @memberof Reason
     * @instance
     */
    Reason.prototype.descriptionHtml = "";

    /**
     * Reason reasonPlusOne.
     * @member {IReasonPlusOne|null|undefined} reasonPlusOne
     * @memberof Reason
     * @instance
     */
    Reason.prototype.reasonPlusOne = null;

    /**
     * Reason reasonReview.
     * @member {IReasonReview|null|undefined} reasonReview
     * @memberof Reason
     * @instance
     */
    Reason.prototype.reasonReview = null;

    /**
     * Reason dismissal.
     * @member {IDismissal|null|undefined} dismissal
     * @memberof Reason
     * @instance
     */
    Reason.prototype.dismissal = null;

    /**
     * Reason reasonUserAction.
     * @member {IReasonUserAction|null|undefined} reasonUserAction
     * @memberof Reason
     * @instance
     */
    Reason.prototype.reasonUserAction = null;

    /**
     * Creates a new Reason instance using the specified properties.
     * @function create
     * @memberof Reason
     * @static
     * @param {IReason=} [properties] Properties to set
     * @returns {Reason} Reason instance
     */
    Reason.create = function create(properties) {
        return new Reason(properties);
    };

    /**
     * Encodes the specified Reason message. Does not implicitly {@link Reason.verify|verify} messages.
     * @function encode
     * @memberof Reason
     * @static
     * @param {IReason} message Reason message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    Reason.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.descriptionHtml != null && Object.hasOwnProperty.call(message, "descriptionHtml"))
            writer.uint32(/* id 3, wireType 2 =*/26).string(message.descriptionHtml);
        if (message.reasonPlusOne != null && Object.hasOwnProperty.call(message, "reasonPlusOne"))
            $root.ReasonPlusOne.encode(message.reasonPlusOne, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
        if (message.reasonReview != null && Object.hasOwnProperty.call(message, "reasonReview"))
            $root.ReasonReview.encode(message.reasonReview, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
        if (message.dismissal != null && Object.hasOwnProperty.call(message, "dismissal"))
            $root.Dismissal.encode(message.dismissal, writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
        if (message.reasonUserAction != null && Object.hasOwnProperty.call(message, "reasonUserAction"))
            $root.ReasonUserAction.encode(message.reasonUserAction, writer.uint32(/* id 9, wireType 2 =*/74).fork()).ldelim();
        return writer;
    };

    /**
     * Encodes the specified Reason message, length delimited. Does not implicitly {@link Reason.verify|verify} messages.
     * @function encodeDelimited
     * @memberof Reason
     * @static
     * @param {IReason} message Reason message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    Reason.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a Reason message from the specified reader or buffer.
     * @function decode
     * @memberof Reason
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {Reason} Reason
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    Reason.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Reason();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            case 3:
                message.descriptionHtml = reader.string();
                break;
            case 4:
                message.reasonPlusOne = $root.ReasonPlusOne.decode(reader, reader.uint32());
                break;
            case 5:
                message.reasonReview = $root.ReasonReview.decode(reader, reader.uint32());
                break;
            case 7:
                message.dismissal = $root.Dismissal.decode(reader, reader.uint32());
                break;
            case 9:
                message.reasonUserAction = $root.ReasonUserAction.decode(reader, reader.uint32());
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a Reason message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof Reason
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {Reason} Reason
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    Reason.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a Reason message.
     * @function verify
     * @memberof Reason
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    Reason.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.descriptionHtml != null && message.hasOwnProperty("descriptionHtml"))
            if (!$util.isString(message.descriptionHtml))
                return "descriptionHtml: string expected";
        if (message.reasonPlusOne != null && message.hasOwnProperty("reasonPlusOne")) {
            var error = $root.ReasonPlusOne.verify(message.reasonPlusOne);
            if (error)
                return "reasonPlusOne." + error;
        }
        if (message.reasonReview != null && message.hasOwnProperty("reasonReview")) {
            var error = $root.ReasonReview.verify(message.reasonReview);
            if (error)
                return "reasonReview." + error;
        }
        if (message.dismissal != null && message.hasOwnProperty("dismissal")) {
            var error = $root.Dismissal.verify(message.dismissal);
            if (error)
                return "dismissal." + error;
        }
        if (message.reasonUserAction != null && message.hasOwnProperty("reasonUserAction")) {
            var error = $root.ReasonUserAction.verify(message.reasonUserAction);
            if (error)
                return "reasonUserAction." + error;
        }
        return null;
    };

    /**
     * Creates a Reason message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof Reason
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {Reason} Reason
     */
    Reason.fromObject = function fromObject(object) {
        if (object instanceof $root.Reason)
            return object;
        var message = new $root.Reason();
        if (object.descriptionHtml != null)
            message.descriptionHtml = String(object.descriptionHtml);
        if (object.reasonPlusOne != null) {
            if (typeof object.reasonPlusOne !== "object")
                throw TypeError(".Reason.reasonPlusOne: object expected");
            message.reasonPlusOne = $root.ReasonPlusOne.fromObject(object.reasonPlusOne);
        }
        if (object.reasonReview != null) {
            if (typeof object.reasonReview !== "object")
                throw TypeError(".Reason.reasonReview: object expected");
            message.reasonReview = $root.ReasonReview.fromObject(object.reasonReview);
        }
        if (object.dismissal != null) {
            if (typeof object.dismissal !== "object")
                throw TypeError(".Reason.dismissal: object expected");
            message.dismissal = $root.Dismissal.fromObject(object.dismissal);
        }
        if (object.reasonUserAction != null) {
            if (typeof object.reasonUserAction !== "object")
                throw TypeError(".Reason.reasonUserAction: object expected");
            message.reasonUserAction = $root.ReasonUserAction.fromObject(object.reasonUserAction);
        }
        return message;
    };

    /**
     * Creates a plain object from a Reason message. Also converts values to other types if specified.
     * @function toObject
     * @memberof Reason
     * @static
     * @param {Reason} message Reason
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    Reason.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        var object = {};
        if (options.defaults) {
            object.descriptionHtml = "";
            object.reasonPlusOne = null;
            object.reasonReview = null;
            object.dismissal = null;
            object.reasonUserAction = null;
        }
        if (message.descriptionHtml != null && message.hasOwnProperty("descriptionHtml"))
            object.descriptionHtml = message.descriptionHtml;
        if (message.reasonPlusOne != null && message.hasOwnProperty("reasonPlusOne"))
            object.reasonPlusOne = $root.ReasonPlusOne.toObject(message.reasonPlusOne, options);
        if (message.reasonReview != null && message.hasOwnProperty("reasonReview"))
            object.reasonReview = $root.ReasonReview.toObject(message.reasonReview, options);
        if (message.dismissal != null && message.hasOwnProperty("dismissal"))
            object.dismissal = $root.Dismissal.toObject(message.dismissal, options);
        if (message.reasonUserAction != null && message.hasOwnProperty("reasonUserAction"))
            object.reasonUserAction = $root.ReasonUserAction.toObject(message.reasonUserAction, options);
        return object;
    };

    /**
     * Converts this Reason to JSON.
     * @function toJSON
     * @memberof Reason
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    Reason.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return Reason;
})();

$root.ReasonPlusOne = (function() {

    /**
     * Properties of a ReasonPlusOne.
     * @exports IReasonPlusOne
     * @interface IReasonPlusOne
     * @property {string|null} [localizedDescriptionHtml] ReasonPlusOne localizedDescriptionHtml
     * @property {Array.<IUserProfile>|null} [userProfile] ReasonPlusOne userProfile
     */

    /**
     * Constructs a new ReasonPlusOne.
     * @exports ReasonPlusOne
     * @classdesc Represents a ReasonPlusOne.
     * @implements IReasonPlusOne
     * @constructor
     * @param {IReasonPlusOne=} [properties] Properties to set
     */
    function ReasonPlusOne(properties) {
        this.userProfile = [];
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * ReasonPlusOne localizedDescriptionHtml.
     * @member {string} localizedDescriptionHtml
     * @memberof ReasonPlusOne
     * @instance
     */
    ReasonPlusOne.prototype.localizedDescriptionHtml = "";

    /**
     * ReasonPlusOne userProfile.
     * @member {Array.<IUserProfile>} userProfile
     * @memberof ReasonPlusOne
     * @instance
     */
    ReasonPlusOne.prototype.userProfile = $util.emptyArray;

    /**
     * Creates a new ReasonPlusOne instance using the specified properties.
     * @function create
     * @memberof ReasonPlusOne
     * @static
     * @param {IReasonPlusOne=} [properties] Properties to set
     * @returns {ReasonPlusOne} ReasonPlusOne instance
     */
    ReasonPlusOne.create = function create(properties) {
        return new ReasonPlusOne(properties);
    };

    /**
     * Encodes the specified ReasonPlusOne message. Does not implicitly {@link ReasonPlusOne.verify|verify} messages.
     * @function encode
     * @memberof ReasonPlusOne
     * @static
     * @param {IReasonPlusOne} message ReasonPlusOne message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    ReasonPlusOne.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.localizedDescriptionHtml != null && Object.hasOwnProperty.call(message, "localizedDescriptionHtml"))
            writer.uint32(/* id 1, wireType 2 =*/10).string(message.localizedDescriptionHtml);
        if (message.userProfile != null && message.userProfile.length)
            for (var i = 0; i < message.userProfile.length; ++i)
                $root.UserProfile.encode(message.userProfile[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
        return writer;
    };

    /**
     * Encodes the specified ReasonPlusOne message, length delimited. Does not implicitly {@link ReasonPlusOne.verify|verify} messages.
     * @function encodeDelimited
     * @memberof ReasonPlusOne
     * @static
     * @param {IReasonPlusOne} message ReasonPlusOne message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    ReasonPlusOne.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a ReasonPlusOne message from the specified reader or buffer.
     * @function decode
     * @memberof ReasonPlusOne
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {ReasonPlusOne} ReasonPlusOne
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    ReasonPlusOne.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ReasonPlusOne();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.localizedDescriptionHtml = reader.string();
                break;
            case 3:
                if (!(message.userProfile && message.userProfile.length))
                    message.userProfile = [];
                message.userProfile.push($root.UserProfile.decode(reader, reader.uint32()));
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a ReasonPlusOne message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof ReasonPlusOne
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {ReasonPlusOne} ReasonPlusOne
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    ReasonPlusOne.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a ReasonPlusOne message.
     * @function verify
     * @memberof ReasonPlusOne
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    ReasonPlusOne.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.localizedDescriptionHtml != null && message.hasOwnProperty("localizedDescriptionHtml"))
            if (!$util.isString(message.localizedDescriptionHtml))
                return "localizedDescriptionHtml: string expected";
        if (message.userProfile != null && message.hasOwnProperty("userProfile")) {
            if (!Array.isArray(message.userProfile))
                return "userProfile: array expected";
            for (var i = 0; i < message.userProfile.length; ++i) {
                var error = $root.UserProfile.verify(message.userProfile[i]);
                if (error)
                    return "userProfile." + error;
            }
        }
        return null;
    };

    /**
     * Creates a ReasonPlusOne message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof ReasonPlusOne
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {ReasonPlusOne} ReasonPlusOne
     */
    ReasonPlusOne.fromObject = function fromObject(object) {
        if (object instanceof $root.ReasonPlusOne)
            return object;
        var message = new $root.ReasonPlusOne();
        if (object.localizedDescriptionHtml != null)
            message.localizedDescriptionHtml = String(object.localizedDescriptionHtml);
        if (object.userProfile) {
            if (!Array.isArray(object.userProfile))
                throw TypeError(".ReasonPlusOne.userProfile: array expected");
            message.userProfile = [];
            for (var i = 0; i < object.userProfile.length; ++i) {
                if (typeof object.userProfile[i] !== "object")
                    throw TypeError(".ReasonPlusOne.userProfile: object expected");
                message.userProfile[i] = $root.UserProfile.fromObject(object.userProfile[i]);
            }
        }
        return message;
    };

    /**
     * Creates a plain object from a ReasonPlusOne message. Also converts values to other types if specified.
     * @function toObject
     * @memberof ReasonPlusOne
     * @static
     * @param {ReasonPlusOne} message ReasonPlusOne
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    ReasonPlusOne.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        var object = {};
        if (options.arrays || options.defaults)
            object.userProfile = [];
        if (options.defaults)
            object.localizedDescriptionHtml = "";
        if (message.localizedDescriptionHtml != null && message.hasOwnProperty("localizedDescriptionHtml"))
            object.localizedDescriptionHtml = message.localizedDescriptionHtml;
        if (message.userProfile && message.userProfile.length) {
            object.userProfile = [];
            for (var j = 0; j < message.userProfile.length; ++j)
                object.userProfile[j] = $root.UserProfile.toObject(message.userProfile[j], options);
        }
        return object;
    };

    /**
     * Converts this ReasonPlusOne to JSON.
     * @function toJSON
     * @memberof ReasonPlusOne
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    ReasonPlusOne.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return ReasonPlusOne;
})();

$root.ReasonReview = (function() {

    /**
     * Properties of a ReasonReview.
     * @exports IReasonReview
     * @interface IReasonReview
     * @property {IReview|null} [review] ReasonReview review
     */

    /**
     * Constructs a new ReasonReview.
     * @exports ReasonReview
     * @classdesc Represents a ReasonReview.
     * @implements IReasonReview
     * @constructor
     * @param {IReasonReview=} [properties] Properties to set
     */
    function ReasonReview(properties) {
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * ReasonReview review.
     * @member {IReview|null|undefined} review
     * @memberof ReasonReview
     * @instance
     */
    ReasonReview.prototype.review = null;

    /**
     * Creates a new ReasonReview instance using the specified properties.
     * @function create
     * @memberof ReasonReview
     * @static
     * @param {IReasonReview=} [properties] Properties to set
     * @returns {ReasonReview} ReasonReview instance
     */
    ReasonReview.create = function create(properties) {
        return new ReasonReview(properties);
    };

    /**
     * Encodes the specified ReasonReview message. Does not implicitly {@link ReasonReview.verify|verify} messages.
     * @function encode
     * @memberof ReasonReview
     * @static
     * @param {IReasonReview} message ReasonReview message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    ReasonReview.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.review != null && Object.hasOwnProperty.call(message, "review"))
            $root.Review.encode(message.review, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
        return writer;
    };

    /**
     * Encodes the specified ReasonReview message, length delimited. Does not implicitly {@link ReasonReview.verify|verify} messages.
     * @function encodeDelimited
     * @memberof ReasonReview
     * @static
     * @param {IReasonReview} message ReasonReview message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    ReasonReview.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a ReasonReview message from the specified reader or buffer.
     * @function decode
     * @memberof ReasonReview
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {ReasonReview} ReasonReview
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    ReasonReview.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ReasonReview();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.review = $root.Review.decode(reader, reader.uint32());
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a ReasonReview message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof ReasonReview
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {ReasonReview} ReasonReview
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    ReasonReview.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a ReasonReview message.
     * @function verify
     * @memberof ReasonReview
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    ReasonReview.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.review != null && message.hasOwnProperty("review")) {
            var error = $root.Review.verify(message.review);
            if (error)
                return "review." + error;
        }
        return null;
    };

    /**
     * Creates a ReasonReview message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof ReasonReview
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {ReasonReview} ReasonReview
     */
    ReasonReview.fromObject = function fromObject(object) {
        if (object instanceof $root.ReasonReview)
            return object;
        var message = new $root.ReasonReview();
        if (object.review != null) {
            if (typeof object.review !== "object")
                throw TypeError(".ReasonReview.review: object expected");
            message.review = $root.Review.fromObject(object.review);
        }
        return message;
    };

    /**
     * Creates a plain object from a ReasonReview message. Also converts values to other types if specified.
     * @function toObject
     * @memberof ReasonReview
     * @static
     * @param {ReasonReview} message ReasonReview
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    ReasonReview.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        var object = {};
        if (options.defaults)
            object.review = null;
        if (message.review != null && message.hasOwnProperty("review"))
            object.review = $root.Review.toObject(message.review, options);
        return object;
    };

    /**
     * Converts this ReasonReview to JSON.
     * @function toJSON
     * @memberof ReasonReview
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    ReasonReview.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return ReasonReview;
})();

$root.ReasonUserAction = (function() {

    /**
     * Properties of a ReasonUserAction.
     * @exports IReasonUserAction
     * @interface IReasonUserAction
     * @property {IUserProfile|null} [userProfile] ReasonUserAction userProfile
     * @property {string|null} [localizedDescriptionHtml] ReasonUserAction localizedDescriptionHtml
     */

    /**
     * Constructs a new ReasonUserAction.
     * @exports ReasonUserAction
     * @classdesc Represents a ReasonUserAction.
     * @implements IReasonUserAction
     * @constructor
     * @param {IReasonUserAction=} [properties] Properties to set
     */
    function ReasonUserAction(properties) {
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * ReasonUserAction userProfile.
     * @member {IUserProfile|null|undefined} userProfile
     * @memberof ReasonUserAction
     * @instance
     */
    ReasonUserAction.prototype.userProfile = null;

    /**
     * ReasonUserAction localizedDescriptionHtml.
     * @member {string} localizedDescriptionHtml
     * @memberof ReasonUserAction
     * @instance
     */
    ReasonUserAction.prototype.localizedDescriptionHtml = "";

    /**
     * Creates a new ReasonUserAction instance using the specified properties.
     * @function create
     * @memberof ReasonUserAction
     * @static
     * @param {IReasonUserAction=} [properties] Properties to set
     * @returns {ReasonUserAction} ReasonUserAction instance
     */
    ReasonUserAction.create = function create(properties) {
        return new ReasonUserAction(properties);
    };

    /**
     * Encodes the specified ReasonUserAction message. Does not implicitly {@link ReasonUserAction.verify|verify} messages.
     * @function encode
     * @memberof ReasonUserAction
     * @static
     * @param {IReasonUserAction} message ReasonUserAction message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    ReasonUserAction.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.userProfile != null && Object.hasOwnProperty.call(message, "userProfile"))
            $root.UserProfile.encode(message.userProfile, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
        if (message.localizedDescriptionHtml != null && Object.hasOwnProperty.call(message, "localizedDescriptionHtml"))
            writer.uint32(/* id 2, wireType 2 =*/18).string(message.localizedDescriptionHtml);
        return writer;
    };

    /**
     * Encodes the specified ReasonUserAction message, length delimited. Does not implicitly {@link ReasonUserAction.verify|verify} messages.
     * @function encodeDelimited
     * @memberof ReasonUserAction
     * @static
     * @param {IReasonUserAction} message ReasonUserAction message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    ReasonUserAction.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a ReasonUserAction message from the specified reader or buffer.
     * @function decode
     * @memberof ReasonUserAction
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {ReasonUserAction} ReasonUserAction
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    ReasonUserAction.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ReasonUserAction();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.userProfile = $root.UserProfile.decode(reader, reader.uint32());
                break;
            case 2:
                message.localizedDescriptionHtml = reader.string();
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a ReasonUserAction message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof ReasonUserAction
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {ReasonUserAction} ReasonUserAction
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    ReasonUserAction.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a ReasonUserAction message.
     * @function verify
     * @memberof ReasonUserAction
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    ReasonUserAction.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.userProfile != null && message.hasOwnProperty("userProfile")) {
            var error = $root.UserProfile.verify(message.userProfile);
            if (error)
                return "userProfile." + error;
        }
        if (message.localizedDescriptionHtml != null && message.hasOwnProperty("localizedDescriptionHtml"))
            if (!$util.isString(message.localizedDescriptionHtml))
                return "localizedDescriptionHtml: string expected";
        return null;
    };

    /**
     * Creates a ReasonUserAction message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof ReasonUserAction
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {ReasonUserAction} ReasonUserAction
     */
    ReasonUserAction.fromObject = function fromObject(object) {
        if (object instanceof $root.ReasonUserAction)
            return object;
        var message = new $root.ReasonUserAction();
        if (object.userProfile != null) {
            if (typeof object.userProfile !== "object")
                throw TypeError(".ReasonUserAction.userProfile: object expected");
            message.userProfile = $root.UserProfile.fromObject(object.userProfile);
        }
        if (object.localizedDescriptionHtml != null)
            message.localizedDescriptionHtml = String(object.localizedDescriptionHtml);
        return message;
    };

    /**
     * Creates a plain object from a ReasonUserAction message. Also converts values to other types if specified.
     * @function toObject
     * @memberof ReasonUserAction
     * @static
     * @param {ReasonUserAction} message ReasonUserAction
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    ReasonUserAction.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        var object = {};
        if (options.defaults) {
            object.userProfile = null;
            object.localizedDescriptionHtml = "";
        }
        if (message.userProfile != null && message.hasOwnProperty("userProfile"))
            object.userProfile = $root.UserProfile.toObject(message.userProfile, options);
        if (message.localizedDescriptionHtml != null && message.hasOwnProperty("localizedDescriptionHtml"))
            object.localizedDescriptionHtml = message.localizedDescriptionHtml;
        return object;
    };

    /**
     * Converts this ReasonUserAction to JSON.
     * @function toJSON
     * @memberof ReasonUserAction
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    ReasonUserAction.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return ReasonUserAction;
})();

$root.Dismissal = (function() {

    /**
     * Properties of a Dismissal.
     * @exports IDismissal
     * @interface IDismissal
     * @property {string|null} [url] Dismissal url
     * @property {string|null} [descriptionHtml] Dismissal descriptionHtml
     */

    /**
     * Constructs a new Dismissal.
     * @exports Dismissal
     * @classdesc Represents a Dismissal.
     * @implements IDismissal
     * @constructor
     * @param {IDismissal=} [properties] Properties to set
     */
    function Dismissal(properties) {
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * Dismissal url.
     * @member {string} url
     * @memberof Dismissal
     * @instance
     */
    Dismissal.prototype.url = "";

    /**
     * Dismissal descriptionHtml.
     * @member {string} descriptionHtml
     * @memberof Dismissal
     * @instance
     */
    Dismissal.prototype.descriptionHtml = "";

    /**
     * Creates a new Dismissal instance using the specified properties.
     * @function create
     * @memberof Dismissal
     * @static
     * @param {IDismissal=} [properties] Properties to set
     * @returns {Dismissal} Dismissal instance
     */
    Dismissal.create = function create(properties) {
        return new Dismissal(properties);
    };

    /**
     * Encodes the specified Dismissal message. Does not implicitly {@link Dismissal.verify|verify} messages.
     * @function encode
     * @memberof Dismissal
     * @static
     * @param {IDismissal} message Dismissal message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    Dismissal.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.url != null && Object.hasOwnProperty.call(message, "url"))
            writer.uint32(/* id 1, wireType 2 =*/10).string(message.url);
        if (message.descriptionHtml != null && Object.hasOwnProperty.call(message, "descriptionHtml"))
            writer.uint32(/* id 2, wireType 2 =*/18).string(message.descriptionHtml);
        return writer;
    };

    /**
     * Encodes the specified Dismissal message, length delimited. Does not implicitly {@link Dismissal.verify|verify} messages.
     * @function encodeDelimited
     * @memberof Dismissal
     * @static
     * @param {IDismissal} message Dismissal message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    Dismissal.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a Dismissal message from the specified reader or buffer.
     * @function decode
     * @memberof Dismissal
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {Dismissal} Dismissal
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    Dismissal.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Dismissal();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.url = reader.string();
                break;
            case 2:
                message.descriptionHtml = reader.string();
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a Dismissal message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof Dismissal
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {Dismissal} Dismissal
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    Dismissal.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a Dismissal message.
     * @function verify
     * @memberof Dismissal
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    Dismissal.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.url != null && message.hasOwnProperty("url"))
            if (!$util.isString(message.url))
                return "url: string expected";
        if (message.descriptionHtml != null && message.hasOwnProperty("descriptionHtml"))
            if (!$util.isString(message.descriptionHtml))
                return "descriptionHtml: string expected";
        return null;
    };

    /**
     * Creates a Dismissal message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof Dismissal
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {Dismissal} Dismissal
     */
    Dismissal.fromObject = function fromObject(object) {
        if (object instanceof $root.Dismissal)
            return object;
        var message = new $root.Dismissal();
        if (object.url != null)
            message.url = String(object.url);
        if (object.descriptionHtml != null)
            message.descriptionHtml = String(object.descriptionHtml);
        return message;
    };

    /**
     * Creates a plain object from a Dismissal message. Also converts values to other types if specified.
     * @function toObject
     * @memberof Dismissal
     * @static
     * @param {Dismissal} message Dismissal
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    Dismissal.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        var object = {};
        if (options.defaults) {
            object.url = "";
            object.descriptionHtml = "";
        }
        if (message.url != null && message.hasOwnProperty("url"))
            object.url = message.url;
        if (message.descriptionHtml != null && message.hasOwnProperty("descriptionHtml"))
            object.descriptionHtml = message.descriptionHtml;
        return object;
    };

    /**
     * Converts this Dismissal to JSON.
     * @function toJSON
     * @memberof Dismissal
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    Dismissal.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return Dismissal;
})();

$root.Snippet = (function() {

    /**
     * Properties of a Snippet.
     * @exports ISnippet
     * @interface ISnippet
     * @property {string|null} [snippetHtml] Snippet snippetHtml
     */

    /**
     * Constructs a new Snippet.
     * @exports Snippet
     * @classdesc Represents a Snippet.
     * @implements ISnippet
     * @constructor
     * @param {ISnippet=} [properties] Properties to set
     */
    function Snippet(properties) {
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * Snippet snippetHtml.
     * @member {string} snippetHtml
     * @memberof Snippet
     * @instance
     */
    Snippet.prototype.snippetHtml = "";

    /**
     * Creates a new Snippet instance using the specified properties.
     * @function create
     * @memberof Snippet
     * @static
     * @param {ISnippet=} [properties] Properties to set
     * @returns {Snippet} Snippet instance
     */
    Snippet.create = function create(properties) {
        return new Snippet(properties);
    };

    /**
     * Encodes the specified Snippet message. Does not implicitly {@link Snippet.verify|verify} messages.
     * @function encode
     * @memberof Snippet
     * @static
     * @param {ISnippet} message Snippet message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    Snippet.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.snippetHtml != null && Object.hasOwnProperty.call(message, "snippetHtml"))
            writer.uint32(/* id 1, wireType 2 =*/10).string(message.snippetHtml);
        return writer;
    };

    /**
     * Encodes the specified Snippet message, length delimited. Does not implicitly {@link Snippet.verify|verify} messages.
     * @function encodeDelimited
     * @memberof Snippet
     * @static
     * @param {ISnippet} message Snippet message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    Snippet.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a Snippet message from the specified reader or buffer.
     * @function decode
     * @memberof Snippet
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {Snippet} Snippet
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    Snippet.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Snippet();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.snippetHtml = reader.string();
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a Snippet message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof Snippet
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {Snippet} Snippet
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    Snippet.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a Snippet message.
     * @function verify
     * @memberof Snippet
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    Snippet.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.snippetHtml != null && message.hasOwnProperty("snippetHtml"))
            if (!$util.isString(message.snippetHtml))
                return "snippetHtml: string expected";
        return null;
    };

    /**
     * Creates a Snippet message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof Snippet
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {Snippet} Snippet
     */
    Snippet.fromObject = function fromObject(object) {
        if (object instanceof $root.Snippet)
            return object;
        var message = new $root.Snippet();
        if (object.snippetHtml != null)
            message.snippetHtml = String(object.snippetHtml);
        return message;
    };

    /**
     * Creates a plain object from a Snippet message. Also converts values to other types if specified.
     * @function toObject
     * @memberof Snippet
     * @static
     * @param {Snippet} message Snippet
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    Snippet.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        var object = {};
        if (options.defaults)
            object.snippetHtml = "";
        if (message.snippetHtml != null && message.hasOwnProperty("snippetHtml"))
            object.snippetHtml = message.snippetHtml;
        return object;
    };

    /**
     * Converts this Snippet to JSON.
     * @function toJSON
     * @memberof Snippet
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    Snippet.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return Snippet;
})();

$root.MyRewardDetails = (function() {

    /**
     * Properties of a MyRewardDetails.
     * @exports IMyRewardDetails
     * @interface IMyRewardDetails
     * @property {number|Long|null} [expirationTimeMillis] MyRewardDetails expirationTimeMillis
     * @property {string|null} [expirationDescription] MyRewardDetails expirationDescription
     * @property {string|null} [buttonLabel] MyRewardDetails buttonLabel
     * @property {ILink|null} [linkAction] MyRewardDetails linkAction
     */

    /**
     * Constructs a new MyRewardDetails.
     * @exports MyRewardDetails
     * @classdesc Represents a MyRewardDetails.
     * @implements IMyRewardDetails
     * @constructor
     * @param {IMyRewardDetails=} [properties] Properties to set
     */
    function MyRewardDetails(properties) {
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * MyRewardDetails expirationTimeMillis.
     * @member {number|Long} expirationTimeMillis
     * @memberof MyRewardDetails
     * @instance
     */
    MyRewardDetails.prototype.expirationTimeMillis = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

    /**
     * MyRewardDetails expirationDescription.
     * @member {string} expirationDescription
     * @memberof MyRewardDetails
     * @instance
     */
    MyRewardDetails.prototype.expirationDescription = "";

    /**
     * MyRewardDetails buttonLabel.
     * @member {string} buttonLabel
     * @memberof MyRewardDetails
     * @instance
     */
    MyRewardDetails.prototype.buttonLabel = "";

    /**
     * MyRewardDetails linkAction.
     * @member {ILink|null|undefined} linkAction
     * @memberof MyRewardDetails
     * @instance
     */
    MyRewardDetails.prototype.linkAction = null;

    /**
     * Creates a new MyRewardDetails instance using the specified properties.
     * @function create
     * @memberof MyRewardDetails
     * @static
     * @param {IMyRewardDetails=} [properties] Properties to set
     * @returns {MyRewardDetails} MyRewardDetails instance
     */
    MyRewardDetails.create = function create(properties) {
        return new MyRewardDetails(properties);
    };

    /**
     * Encodes the specified MyRewardDetails message. Does not implicitly {@link MyRewardDetails.verify|verify} messages.
     * @function encode
     * @memberof MyRewardDetails
     * @static
     * @param {IMyRewardDetails} message MyRewardDetails message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    MyRewardDetails.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.expirationTimeMillis != null && Object.hasOwnProperty.call(message, "expirationTimeMillis"))
            writer.uint32(/* id 1, wireType 0 =*/8).int64(message.expirationTimeMillis);
        if (message.expirationDescription != null && Object.hasOwnProperty.call(message, "expirationDescription"))
            writer.uint32(/* id 2, wireType 2 =*/18).string(message.expirationDescription);
        if (message.buttonLabel != null && Object.hasOwnProperty.call(message, "buttonLabel"))
            writer.uint32(/* id 3, wireType 2 =*/26).string(message.buttonLabel);
        if (message.linkAction != null && Object.hasOwnProperty.call(message, "linkAction"))
            $root.Link.encode(message.linkAction, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
        return writer;
    };

    /**
     * Encodes the specified MyRewardDetails message, length delimited. Does not implicitly {@link MyRewardDetails.verify|verify} messages.
     * @function encodeDelimited
     * @memberof MyRewardDetails
     * @static
     * @param {IMyRewardDetails} message MyRewardDetails message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    MyRewardDetails.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a MyRewardDetails message from the specified reader or buffer.
     * @function decode
     * @memberof MyRewardDetails
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {MyRewardDetails} MyRewardDetails
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    MyRewardDetails.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.MyRewardDetails();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.expirationTimeMillis = reader.int64();
                break;
            case 2:
                message.expirationDescription = reader.string();
                break;
            case 3:
                message.buttonLabel = reader.string();
                break;
            case 4:
                message.linkAction = $root.Link.decode(reader, reader.uint32());
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a MyRewardDetails message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof MyRewardDetails
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {MyRewardDetails} MyRewardDetails
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    MyRewardDetails.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a MyRewardDetails message.
     * @function verify
     * @memberof MyRewardDetails
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    MyRewardDetails.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.expirationTimeMillis != null && message.hasOwnProperty("expirationTimeMillis"))
            if (!$util.isInteger(message.expirationTimeMillis) && !(message.expirationTimeMillis && $util.isInteger(message.expirationTimeMillis.low) && $util.isInteger(message.expirationTimeMillis.high)))
                return "expirationTimeMillis: integer|Long expected";
        if (message.expirationDescription != null && message.hasOwnProperty("expirationDescription"))
            if (!$util.isString(message.expirationDescription))
                return "expirationDescription: string expected";
        if (message.buttonLabel != null && message.hasOwnProperty("buttonLabel"))
            if (!$util.isString(message.buttonLabel))
                return "buttonLabel: string expected";
        if (message.linkAction != null && message.hasOwnProperty("linkAction")) {
            var error = $root.Link.verify(message.linkAction);
            if (error)
                return "linkAction." + error;
        }
        return null;
    };

    /**
     * Creates a MyRewardDetails message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof MyRewardDetails
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {MyRewardDetails} MyRewardDetails
     */
    MyRewardDetails.fromObject = function fromObject(object) {
        if (object instanceof $root.MyRewardDetails)
            return object;
        var message = new $root.MyRewardDetails();
        if (object.expirationTimeMillis != null)
            if ($util.Long)
                (message.expirationTimeMillis = $util.Long.fromValue(object.expirationTimeMillis)).unsigned = false;
            else if (typeof object.expirationTimeMillis === "string")
                message.expirationTimeMillis = parseInt(object.expirationTimeMillis, 10);
            else if (typeof object.expirationTimeMillis === "number")
                message.expirationTimeMillis = object.expirationTimeMillis;
            else if (typeof object.expirationTimeMillis === "object")
                message.expirationTimeMillis = new $util.LongBits(object.expirationTimeMillis.low >>> 0, object.expirationTimeMillis.high >>> 0).toNumber();
        if (object.expirationDescription != null)
            message.expirationDescription = String(object.expirationDescription);
        if (object.buttonLabel != null)
            message.buttonLabel = String(object.buttonLabel);
        if (object.linkAction != null) {
            if (typeof object.linkAction !== "object")
                throw TypeError(".MyRewardDetails.linkAction: object expected");
            message.linkAction = $root.Link.fromObject(object.linkAction);
        }
        return message;
    };

    /**
     * Creates a plain object from a MyRewardDetails message. Also converts values to other types if specified.
     * @function toObject
     * @memberof MyRewardDetails
     * @static
     * @param {MyRewardDetails} message MyRewardDetails
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    MyRewardDetails.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        var object = {};
        if (options.defaults) {
            if ($util.Long) {
                var long = new $util.Long(0, 0, false);
                object.expirationTimeMillis = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
            } else
                object.expirationTimeMillis = options.longs === String ? "0" : 0;
            object.expirationDescription = "";
            object.buttonLabel = "";
            object.linkAction = null;
        }
        if (message.expirationTimeMillis != null && message.hasOwnProperty("expirationTimeMillis"))
            if (typeof message.expirationTimeMillis === "number")
                object.expirationTimeMillis = options.longs === String ? String(message.expirationTimeMillis) : message.expirationTimeMillis;
            else
                object.expirationTimeMillis = options.longs === String ? $util.Long.prototype.toString.call(message.expirationTimeMillis) : options.longs === Number ? new $util.LongBits(message.expirationTimeMillis.low >>> 0, message.expirationTimeMillis.high >>> 0).toNumber() : message.expirationTimeMillis;
        if (message.expirationDescription != null && message.hasOwnProperty("expirationDescription"))
            object.expirationDescription = message.expirationDescription;
        if (message.buttonLabel != null && message.hasOwnProperty("buttonLabel"))
            object.buttonLabel = message.buttonLabel;
        if (message.linkAction != null && message.hasOwnProperty("linkAction"))
            object.linkAction = $root.Link.toObject(message.linkAction, options);
        return object;
    };

    /**
     * Converts this MyRewardDetails to JSON.
     * @function toJSON
     * @memberof MyRewardDetails
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    MyRewardDetails.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return MyRewardDetails;
})();

$root.MySubscriptionDetails = (function() {

    /**
     * Properties of a MySubscriptionDetails.
     * @exports IMySubscriptionDetails
     * @interface IMySubscriptionDetails
     * @property {string|null} [subscriptionStatusHtml] MySubscriptionDetails subscriptionStatusHtml
     * @property {string|null} [title] MySubscriptionDetails title
     * @property {string|null} [titleByLineHtml] MySubscriptionDetails titleByLineHtml
     * @property {string|null} [formattedPrice] MySubscriptionDetails formattedPrice
     * @property {string|null} [priceByLineHtml] MySubscriptionDetails priceByLineHtml
     * @property {boolean|null} [cancelSubscription] MySubscriptionDetails cancelSubscription
     * @property {ILink|null} [paymentDeclinedLearnMoreLink] MySubscriptionDetails paymentDeclinedLearnMoreLink
     * @property {boolean|null} [inTrialPeriod] MySubscriptionDetails inTrialPeriod
     * @property {IImage|null} [titleByLineIcon] MySubscriptionDetails titleByLineIcon
     */

    /**
     * Constructs a new MySubscriptionDetails.
     * @exports MySubscriptionDetails
     * @classdesc Represents a MySubscriptionDetails.
     * @implements IMySubscriptionDetails
     * @constructor
     * @param {IMySubscriptionDetails=} [properties] Properties to set
     */
    function MySubscriptionDetails(properties) {
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * MySubscriptionDetails subscriptionStatusHtml.
     * @member {string} subscriptionStatusHtml
     * @memberof MySubscriptionDetails
     * @instance
     */
    MySubscriptionDetails.prototype.subscriptionStatusHtml = "";

    /**
     * MySubscriptionDetails title.
     * @member {string} title
     * @memberof MySubscriptionDetails
     * @instance
     */
    MySubscriptionDetails.prototype.title = "";

    /**
     * MySubscriptionDetails titleByLineHtml.
     * @member {string} titleByLineHtml
     * @memberof MySubscriptionDetails
     * @instance
     */
    MySubscriptionDetails.prototype.titleByLineHtml = "";

    /**
     * MySubscriptionDetails formattedPrice.
     * @member {string} formattedPrice
     * @memberof MySubscriptionDetails
     * @instance
     */
    MySubscriptionDetails.prototype.formattedPrice = "";

    /**
     * MySubscriptionDetails priceByLineHtml.
     * @member {string} priceByLineHtml
     * @memberof MySubscriptionDetails
     * @instance
     */
    MySubscriptionDetails.prototype.priceByLineHtml = "";

    /**
     * MySubscriptionDetails cancelSubscription.
     * @member {boolean} cancelSubscription
     * @memberof MySubscriptionDetails
     * @instance
     */
    MySubscriptionDetails.prototype.cancelSubscription = false;

    /**
     * MySubscriptionDetails paymentDeclinedLearnMoreLink.
     * @member {ILink|null|undefined} paymentDeclinedLearnMoreLink
     * @memberof MySubscriptionDetails
     * @instance
     */
    MySubscriptionDetails.prototype.paymentDeclinedLearnMoreLink = null;

    /**
     * MySubscriptionDetails inTrialPeriod.
     * @member {boolean} inTrialPeriod
     * @memberof MySubscriptionDetails
     * @instance
     */
    MySubscriptionDetails.prototype.inTrialPeriod = false;

    /**
     * MySubscriptionDetails titleByLineIcon.
     * @member {IImage|null|undefined} titleByLineIcon
     * @memberof MySubscriptionDetails
     * @instance
     */
    MySubscriptionDetails.prototype.titleByLineIcon = null;

    /**
     * Creates a new MySubscriptionDetails instance using the specified properties.
     * @function create
     * @memberof MySubscriptionDetails
     * @static
     * @param {IMySubscriptionDetails=} [properties] Properties to set
     * @returns {MySubscriptionDetails} MySubscriptionDetails instance
     */
    MySubscriptionDetails.create = function create(properties) {
        return new MySubscriptionDetails(properties);
    };

    /**
     * Encodes the specified MySubscriptionDetails message. Does not implicitly {@link MySubscriptionDetails.verify|verify} messages.
     * @function encode
     * @memberof MySubscriptionDetails
     * @static
     * @param {IMySubscriptionDetails} message MySubscriptionDetails message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    MySubscriptionDetails.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.subscriptionStatusHtml != null && Object.hasOwnProperty.call(message, "subscriptionStatusHtml"))
            writer.uint32(/* id 1, wireType 2 =*/10).string(message.subscriptionStatusHtml);
        if (message.title != null && Object.hasOwnProperty.call(message, "title"))
            writer.uint32(/* id 2, wireType 2 =*/18).string(message.title);
        if (message.titleByLineHtml != null && Object.hasOwnProperty.call(message, "titleByLineHtml"))
            writer.uint32(/* id 3, wireType 2 =*/26).string(message.titleByLineHtml);
        if (message.formattedPrice != null && Object.hasOwnProperty.call(message, "formattedPrice"))
            writer.uint32(/* id 4, wireType 2 =*/34).string(message.formattedPrice);
        if (message.priceByLineHtml != null && Object.hasOwnProperty.call(message, "priceByLineHtml"))
            writer.uint32(/* id 5, wireType 2 =*/42).string(message.priceByLineHtml);
        if (message.cancelSubscription != null && Object.hasOwnProperty.call(message, "cancelSubscription"))
            writer.uint32(/* id 6, wireType 0 =*/48).bool(message.cancelSubscription);
        if (message.paymentDeclinedLearnMoreLink != null && Object.hasOwnProperty.call(message, "paymentDeclinedLearnMoreLink"))
            $root.Link.encode(message.paymentDeclinedLearnMoreLink, writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
        if (message.inTrialPeriod != null && Object.hasOwnProperty.call(message, "inTrialPeriod"))
            writer.uint32(/* id 8, wireType 0 =*/64).bool(message.inTrialPeriod);
        if (message.titleByLineIcon != null && Object.hasOwnProperty.call(message, "titleByLineIcon"))
            $root.Image.encode(message.titleByLineIcon, writer.uint32(/* id 9, wireType 2 =*/74).fork()).ldelim();
        return writer;
    };

    /**
     * Encodes the specified MySubscriptionDetails message, length delimited. Does not implicitly {@link MySubscriptionDetails.verify|verify} messages.
     * @function encodeDelimited
     * @memberof MySubscriptionDetails
     * @static
     * @param {IMySubscriptionDetails} message MySubscriptionDetails message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    MySubscriptionDetails.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a MySubscriptionDetails message from the specified reader or buffer.
     * @function decode
     * @memberof MySubscriptionDetails
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {MySubscriptionDetails} MySubscriptionDetails
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    MySubscriptionDetails.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.MySubscriptionDetails();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.subscriptionStatusHtml = reader.string();
                break;
            case 2:
                message.title = reader.string();
                break;
            case 3:
                message.titleByLineHtml = reader.string();
                break;
            case 4:
                message.formattedPrice = reader.string();
                break;
            case 5:
                message.priceByLineHtml = reader.string();
                break;
            case 6:
                message.cancelSubscription = reader.bool();
                break;
            case 7:
                message.paymentDeclinedLearnMoreLink = $root.Link.decode(reader, reader.uint32());
                break;
            case 8:
                message.inTrialPeriod = reader.bool();
                break;
            case 9:
                message.titleByLineIcon = $root.Image.decode(reader, reader.uint32());
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a MySubscriptionDetails message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof MySubscriptionDetails
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {MySubscriptionDetails} MySubscriptionDetails
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    MySubscriptionDetails.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a MySubscriptionDetails message.
     * @function verify
     * @memberof MySubscriptionDetails
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    MySubscriptionDetails.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.subscriptionStatusHtml != null && message.hasOwnProperty("subscriptionStatusHtml"))
            if (!$util.isString(message.subscriptionStatusHtml))
                return "subscriptionStatusHtml: string expected";
        if (message.title != null && message.hasOwnProperty("title"))
            if (!$util.isString(message.title))
                return "title: string expected";
        if (message.titleByLineHtml != null && message.hasOwnProperty("titleByLineHtml"))
            if (!$util.isString(message.titleByLineHtml))
                return "titleByLineHtml: string expected";
        if (message.formattedPrice != null && message.hasOwnProperty("formattedPrice"))
            if (!$util.isString(message.formattedPrice))
                return "formattedPrice: string expected";
        if (message.priceByLineHtml != null && message.hasOwnProperty("priceByLineHtml"))
            if (!$util.isString(message.priceByLineHtml))
                return "priceByLineHtml: string expected";
        if (message.cancelSubscription != null && message.hasOwnProperty("cancelSubscription"))
            if (typeof message.cancelSubscription !== "boolean")
                return "cancelSubscription: boolean expected";
        if (message.paymentDeclinedLearnMoreLink != null && message.hasOwnProperty("paymentDeclinedLearnMoreLink")) {
            var error = $root.Link.verify(message.paymentDeclinedLearnMoreLink);
            if (error)
                return "paymentDeclinedLearnMoreLink." + error;
        }
        if (message.inTrialPeriod != null && message.hasOwnProperty("inTrialPeriod"))
            if (typeof message.inTrialPeriod !== "boolean")
                return "inTrialPeriod: boolean expected";
        if (message.titleByLineIcon != null && message.hasOwnProperty("titleByLineIcon")) {
            var error = $root.Image.verify(message.titleByLineIcon);
            if (error)
                return "titleByLineIcon." + error;
        }
        return null;
    };

    /**
     * Creates a MySubscriptionDetails message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof MySubscriptionDetails
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {MySubscriptionDetails} MySubscriptionDetails
     */
    MySubscriptionDetails.fromObject = function fromObject(object) {
        if (object instanceof $root.MySubscriptionDetails)
            return object;
        var message = new $root.MySubscriptionDetails();
        if (object.subscriptionStatusHtml != null)
            message.subscriptionStatusHtml = String(object.subscriptionStatusHtml);
        if (object.title != null)
            message.title = String(object.title);
        if (object.titleByLineHtml != null)
            message.titleByLineHtml = String(object.titleByLineHtml);
        if (object.formattedPrice != null)
            message.formattedPrice = String(object.formattedPrice);
        if (object.priceByLineHtml != null)
            message.priceByLineHtml = String(object.priceByLineHtml);
        if (object.cancelSubscription != null)
            message.cancelSubscription = Boolean(object.cancelSubscription);
        if (object.paymentDeclinedLearnMoreLink != null) {
            if (typeof object.paymentDeclinedLearnMoreLink !== "object")
                throw TypeError(".MySubscriptionDetails.paymentDeclinedLearnMoreLink: object expected");
            message.paymentDeclinedLearnMoreLink = $root.Link.fromObject(object.paymentDeclinedLearnMoreLink);
        }
        if (object.inTrialPeriod != null)
            message.inTrialPeriod = Boolean(object.inTrialPeriod);
        if (object.titleByLineIcon != null) {
            if (typeof object.titleByLineIcon !== "object")
                throw TypeError(".MySubscriptionDetails.titleByLineIcon: object expected");
            message.titleByLineIcon = $root.Image.fromObject(object.titleByLineIcon);
        }
        return message;
    };

    /**
     * Creates a plain object from a MySubscriptionDetails message. Also converts values to other types if specified.
     * @function toObject
     * @memberof MySubscriptionDetails
     * @static
     * @param {MySubscriptionDetails} message MySubscriptionDetails
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    MySubscriptionDetails.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        var object = {};
        if (options.defaults) {
            object.subscriptionStatusHtml = "";
            object.title = "";
            object.titleByLineHtml = "";
            object.formattedPrice = "";
            object.priceByLineHtml = "";
            object.cancelSubscription = false;
            object.paymentDeclinedLearnMoreLink = null;
            object.inTrialPeriod = false;
            object.titleByLineIcon = null;
        }
        if (message.subscriptionStatusHtml != null && message.hasOwnProperty("subscriptionStatusHtml"))
            object.subscriptionStatusHtml = message.subscriptionStatusHtml;
        if (message.title != null && message.hasOwnProperty("title"))
            object.title = message.title;
        if (message.titleByLineHtml != null && message.hasOwnProperty("titleByLineHtml"))
            object.titleByLineHtml = message.titleByLineHtml;
        if (message.formattedPrice != null && message.hasOwnProperty("formattedPrice"))
            object.formattedPrice = message.formattedPrice;
        if (message.priceByLineHtml != null && message.hasOwnProperty("priceByLineHtml"))
            object.priceByLineHtml = message.priceByLineHtml;
        if (message.cancelSubscription != null && message.hasOwnProperty("cancelSubscription"))
            object.cancelSubscription = message.cancelSubscription;
        if (message.paymentDeclinedLearnMoreLink != null && message.hasOwnProperty("paymentDeclinedLearnMoreLink"))
            object.paymentDeclinedLearnMoreLink = $root.Link.toObject(message.paymentDeclinedLearnMoreLink, options);
        if (message.inTrialPeriod != null && message.hasOwnProperty("inTrialPeriod"))
            object.inTrialPeriod = message.inTrialPeriod;
        if (message.titleByLineIcon != null && message.hasOwnProperty("titleByLineIcon"))
            object.titleByLineIcon = $root.Image.toObject(message.titleByLineIcon, options);
        return object;
    };

    /**
     * Converts this MySubscriptionDetails to JSON.
     * @function toJSON
     * @memberof MySubscriptionDetails
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    MySubscriptionDetails.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return MySubscriptionDetails;
})();

$root.VideoAnnotations = (function() {

    /**
     * Properties of a VideoAnnotations.
     * @exports IVideoAnnotations
     * @interface IVideoAnnotations
     * @property {boolean|null} [bundle] VideoAnnotations bundle
     * @property {string|null} [bundleContentListUrl] VideoAnnotations bundleContentListUrl
     * @property {string|null} [extrasContentListUrl] VideoAnnotations extrasContentListUrl
     * @property {string|null} [alsoAvailableInListUrl] VideoAnnotations alsoAvailableInListUrl
     * @property {Array.<IDocId>|null} [bundleDocId] VideoAnnotations bundleDocId
     */

    /**
     * Constructs a new VideoAnnotations.
     * @exports VideoAnnotations
     * @classdesc Represents a VideoAnnotations.
     * @implements IVideoAnnotations
     * @constructor
     * @param {IVideoAnnotations=} [properties] Properties to set
     */
    function VideoAnnotations(properties) {
        this.bundleDocId = [];
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * VideoAnnotations bundle.
     * @member {boolean} bundle
     * @memberof VideoAnnotations
     * @instance
     */
    VideoAnnotations.prototype.bundle = false;

    /**
     * VideoAnnotations bundleContentListUrl.
     * @member {string} bundleContentListUrl
     * @memberof VideoAnnotations
     * @instance
     */
    VideoAnnotations.prototype.bundleContentListUrl = "";

    /**
     * VideoAnnotations extrasContentListUrl.
     * @member {string} extrasContentListUrl
     * @memberof VideoAnnotations
     * @instance
     */
    VideoAnnotations.prototype.extrasContentListUrl = "";

    /**
     * VideoAnnotations alsoAvailableInListUrl.
     * @member {string} alsoAvailableInListUrl
     * @memberof VideoAnnotations
     * @instance
     */
    VideoAnnotations.prototype.alsoAvailableInListUrl = "";

    /**
     * VideoAnnotations bundleDocId.
     * @member {Array.<IDocId>} bundleDocId
     * @memberof VideoAnnotations
     * @instance
     */
    VideoAnnotations.prototype.bundleDocId = $util.emptyArray;

    /**
     * Creates a new VideoAnnotations instance using the specified properties.
     * @function create
     * @memberof VideoAnnotations
     * @static
     * @param {IVideoAnnotations=} [properties] Properties to set
     * @returns {VideoAnnotations} VideoAnnotations instance
     */
    VideoAnnotations.create = function create(properties) {
        return new VideoAnnotations(properties);
    };

    /**
     * Encodes the specified VideoAnnotations message. Does not implicitly {@link VideoAnnotations.verify|verify} messages.
     * @function encode
     * @memberof VideoAnnotations
     * @static
     * @param {IVideoAnnotations} message VideoAnnotations message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    VideoAnnotations.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.bundle != null && Object.hasOwnProperty.call(message, "bundle"))
            writer.uint32(/* id 1, wireType 0 =*/8).bool(message.bundle);
        if (message.bundleContentListUrl != null && Object.hasOwnProperty.call(message, "bundleContentListUrl"))
            writer.uint32(/* id 2, wireType 2 =*/18).string(message.bundleContentListUrl);
        if (message.extrasContentListUrl != null && Object.hasOwnProperty.call(message, "extrasContentListUrl"))
            writer.uint32(/* id 3, wireType 2 =*/26).string(message.extrasContentListUrl);
        if (message.alsoAvailableInListUrl != null && Object.hasOwnProperty.call(message, "alsoAvailableInListUrl"))
            writer.uint32(/* id 4, wireType 2 =*/34).string(message.alsoAvailableInListUrl);
        if (message.bundleDocId != null && message.bundleDocId.length)
            for (var i = 0; i < message.bundleDocId.length; ++i)
                $root.DocId.encode(message.bundleDocId[i], writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
        return writer;
    };

    /**
     * Encodes the specified VideoAnnotations message, length delimited. Does not implicitly {@link VideoAnnotations.verify|verify} messages.
     * @function encodeDelimited
     * @memberof VideoAnnotations
     * @static
     * @param {IVideoAnnotations} message VideoAnnotations message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    VideoAnnotations.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a VideoAnnotations message from the specified reader or buffer.
     * @function decode
     * @memberof VideoAnnotations
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {VideoAnnotations} VideoAnnotations
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    VideoAnnotations.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.VideoAnnotations();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.bundle = reader.bool();
                break;
            case 2:
                message.bundleContentListUrl = reader.string();
                break;
            case 3:
                message.extrasContentListUrl = reader.string();
                break;
            case 4:
                message.alsoAvailableInListUrl = reader.string();
                break;
            case 5:
                if (!(message.bundleDocId && message.bundleDocId.length))
                    message.bundleDocId = [];
                message.bundleDocId.push($root.DocId.decode(reader, reader.uint32()));
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a VideoAnnotations message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof VideoAnnotations
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {VideoAnnotations} VideoAnnotations
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    VideoAnnotations.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a VideoAnnotations message.
     * @function verify
     * @memberof VideoAnnotations
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    VideoAnnotations.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.bundle != null && message.hasOwnProperty("bundle"))
            if (typeof message.bundle !== "boolean")
                return "bundle: boolean expected";
        if (message.bundleContentListUrl != null && message.hasOwnProperty("bundleContentListUrl"))
            if (!$util.isString(message.bundleContentListUrl))
                return "bundleContentListUrl: string expected";
        if (message.extrasContentListUrl != null && message.hasOwnProperty("extrasContentListUrl"))
            if (!$util.isString(message.extrasContentListUrl))
                return "extrasContentListUrl: string expected";
        if (message.alsoAvailableInListUrl != null && message.hasOwnProperty("alsoAvailableInListUrl"))
            if (!$util.isString(message.alsoAvailableInListUrl))
                return "alsoAvailableInListUrl: string expected";
        if (message.bundleDocId != null && message.hasOwnProperty("bundleDocId")) {
            if (!Array.isArray(message.bundleDocId))
                return "bundleDocId: array expected";
            for (var i = 0; i < message.bundleDocId.length; ++i) {
                var error = $root.DocId.verify(message.bundleDocId[i]);
                if (error)
                    return "bundleDocId." + error;
            }
        }
        return null;
    };

    /**
     * Creates a VideoAnnotations message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof VideoAnnotations
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {VideoAnnotations} VideoAnnotations
     */
    VideoAnnotations.fromObject = function fromObject(object) {
        if (object instanceof $root.VideoAnnotations)
            return object;
        var message = new $root.VideoAnnotations();
        if (object.bundle != null)
            message.bundle = Boolean(object.bundle);
        if (object.bundleContentListUrl != null)
            message.bundleContentListUrl = String(object.bundleContentListUrl);
        if (object.extrasContentListUrl != null)
            message.extrasContentListUrl = String(object.extrasContentListUrl);
        if (object.alsoAvailableInListUrl != null)
            message.alsoAvailableInListUrl = String(object.alsoAvailableInListUrl);
        if (object.bundleDocId) {
            if (!Array.isArray(object.bundleDocId))
                throw TypeError(".VideoAnnotations.bundleDocId: array expected");
            message.bundleDocId = [];
            for (var i = 0; i < object.bundleDocId.length; ++i) {
                if (typeof object.bundleDocId[i] !== "object")
                    throw TypeError(".VideoAnnotations.bundleDocId: object expected");
                message.bundleDocId[i] = $root.DocId.fromObject(object.bundleDocId[i]);
            }
        }
        return message;
    };

    /**
     * Creates a plain object from a VideoAnnotations message. Also converts values to other types if specified.
     * @function toObject
     * @memberof VideoAnnotations
     * @static
     * @param {VideoAnnotations} message VideoAnnotations
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    VideoAnnotations.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        var object = {};
        if (options.arrays || options.defaults)
            object.bundleDocId = [];
        if (options.defaults) {
            object.bundle = false;
            object.bundleContentListUrl = "";
            object.extrasContentListUrl = "";
            object.alsoAvailableInListUrl = "";
        }
        if (message.bundle != null && message.hasOwnProperty("bundle"))
            object.bundle = message.bundle;
        if (message.bundleContentListUrl != null && message.hasOwnProperty("bundleContentListUrl"))
            object.bundleContentListUrl = message.bundleContentListUrl;
        if (message.extrasContentListUrl != null && message.hasOwnProperty("extrasContentListUrl"))
            object.extrasContentListUrl = message.extrasContentListUrl;
        if (message.alsoAvailableInListUrl != null && message.hasOwnProperty("alsoAvailableInListUrl"))
            object.alsoAvailableInListUrl = message.alsoAvailableInListUrl;
        if (message.bundleDocId && message.bundleDocId.length) {
            object.bundleDocId = [];
            for (var j = 0; j < message.bundleDocId.length; ++j)
                object.bundleDocId[j] = $root.DocId.toObject(message.bundleDocId[j], options);
        }
        return object;
    };

    /**
     * Converts this VideoAnnotations to JSON.
     * @function toJSON
     * @memberof VideoAnnotations
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    VideoAnnotations.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return VideoAnnotations;
})();

$root.VoucherInfo = (function() {

    /**
     * Properties of a VoucherInfo.
     * @exports IVoucherInfo
     * @interface IVoucherInfo
     * @property {IItem|null} [item] VoucherInfo item
     * @property {Array.<IOffer>|null} [offer] VoucherInfo offer
     */

    /**
     * Constructs a new VoucherInfo.
     * @exports VoucherInfo
     * @classdesc Represents a VoucherInfo.
     * @implements IVoucherInfo
     * @constructor
     * @param {IVoucherInfo=} [properties] Properties to set
     */
    function VoucherInfo(properties) {
        this.offer = [];
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * VoucherInfo item.
     * @member {IItem|null|undefined} item
     * @memberof VoucherInfo
     * @instance
     */
    VoucherInfo.prototype.item = null;

    /**
     * VoucherInfo offer.
     * @member {Array.<IOffer>} offer
     * @memberof VoucherInfo
     * @instance
     */
    VoucherInfo.prototype.offer = $util.emptyArray;

    /**
     * Creates a new VoucherInfo instance using the specified properties.
     * @function create
     * @memberof VoucherInfo
     * @static
     * @param {IVoucherInfo=} [properties] Properties to set
     * @returns {VoucherInfo} VoucherInfo instance
     */
    VoucherInfo.create = function create(properties) {
        return new VoucherInfo(properties);
    };

    /**
     * Encodes the specified VoucherInfo message. Does not implicitly {@link VoucherInfo.verify|verify} messages.
     * @function encode
     * @memberof VoucherInfo
     * @static
     * @param {IVoucherInfo} message VoucherInfo message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    VoucherInfo.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.item != null && Object.hasOwnProperty.call(message, "item"))
            $root.Item.encode(message.item, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
        if (message.offer != null && message.offer.length)
            for (var i = 0; i < message.offer.length; ++i)
                $root.Offer.encode(message.offer[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
        return writer;
    };

    /**
     * Encodes the specified VoucherInfo message, length delimited. Does not implicitly {@link VoucherInfo.verify|verify} messages.
     * @function encodeDelimited
     * @memberof VoucherInfo
     * @static
     * @param {IVoucherInfo} message VoucherInfo message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    VoucherInfo.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a VoucherInfo message from the specified reader or buffer.
     * @function decode
     * @memberof VoucherInfo
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {VoucherInfo} VoucherInfo
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    VoucherInfo.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.VoucherInfo();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.item = $root.Item.decode(reader, reader.uint32());
                break;
            case 2:
                if (!(message.offer && message.offer.length))
                    message.offer = [];
                message.offer.push($root.Offer.decode(reader, reader.uint32()));
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a VoucherInfo message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof VoucherInfo
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {VoucherInfo} VoucherInfo
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    VoucherInfo.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a VoucherInfo message.
     * @function verify
     * @memberof VoucherInfo
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    VoucherInfo.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.item != null && message.hasOwnProperty("item")) {
            var error = $root.Item.verify(message.item);
            if (error)
                return "item." + error;
        }
        if (message.offer != null && message.hasOwnProperty("offer")) {
            if (!Array.isArray(message.offer))
                return "offer: array expected";
            for (var i = 0; i < message.offer.length; ++i) {
                var error = $root.Offer.verify(message.offer[i]);
                if (error)
                    return "offer." + error;
            }
        }
        return null;
    };

    /**
     * Creates a VoucherInfo message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof VoucherInfo
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {VoucherInfo} VoucherInfo
     */
    VoucherInfo.fromObject = function fromObject(object) {
        if (object instanceof $root.VoucherInfo)
            return object;
        var message = new $root.VoucherInfo();
        if (object.item != null) {
            if (typeof object.item !== "object")
                throw TypeError(".VoucherInfo.item: object expected");
            message.item = $root.Item.fromObject(object.item);
        }
        if (object.offer) {
            if (!Array.isArray(object.offer))
                throw TypeError(".VoucherInfo.offer: array expected");
            message.offer = [];
            for (var i = 0; i < object.offer.length; ++i) {
                if (typeof object.offer[i] !== "object")
                    throw TypeError(".VoucherInfo.offer: object expected");
                message.offer[i] = $root.Offer.fromObject(object.offer[i]);
            }
        }
        return message;
    };

    /**
     * Creates a plain object from a VoucherInfo message. Also converts values to other types if specified.
     * @function toObject
     * @memberof VoucherInfo
     * @static
     * @param {VoucherInfo} message VoucherInfo
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    VoucherInfo.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        var object = {};
        if (options.arrays || options.defaults)
            object.offer = [];
        if (options.defaults)
            object.item = null;
        if (message.item != null && message.hasOwnProperty("item"))
            object.item = $root.Item.toObject(message.item, options);
        if (message.offer && message.offer.length) {
            object.offer = [];
            for (var j = 0; j < message.offer.length; ++j)
                object.offer[j] = $root.Offer.toObject(message.offer[j], options);
        }
        return object;
    };

    /**
     * Converts this VoucherInfo to JSON.
     * @function toJSON
     * @memberof VoucherInfo
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    VoucherInfo.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return VoucherInfo;
})();

$root.BadgeContainer = (function() {

    /**
     * Properties of a BadgeContainer.
     * @exports IBadgeContainer
     * @interface IBadgeContainer
     * @property {string|null} [title] BadgeContainer title
     * @property {Array.<IImage>|null} [image] BadgeContainer image
     * @property {Array.<IBadge>|null} [badge] BadgeContainer badge
     */

    /**
     * Constructs a new BadgeContainer.
     * @exports BadgeContainer
     * @classdesc Represents a BadgeContainer.
     * @implements IBadgeContainer
     * @constructor
     * @param {IBadgeContainer=} [properties] Properties to set
     */
    function BadgeContainer(properties) {
        this.image = [];
        this.badge = [];
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * BadgeContainer title.
     * @member {string} title
     * @memberof BadgeContainer
     * @instance
     */
    BadgeContainer.prototype.title = "";

    /**
     * BadgeContainer image.
     * @member {Array.<IImage>} image
     * @memberof BadgeContainer
     * @instance
     */
    BadgeContainer.prototype.image = $util.emptyArray;

    /**
     * BadgeContainer badge.
     * @member {Array.<IBadge>} badge
     * @memberof BadgeContainer
     * @instance
     */
    BadgeContainer.prototype.badge = $util.emptyArray;

    /**
     * Creates a new BadgeContainer instance using the specified properties.
     * @function create
     * @memberof BadgeContainer
     * @static
     * @param {IBadgeContainer=} [properties] Properties to set
     * @returns {BadgeContainer} BadgeContainer instance
     */
    BadgeContainer.create = function create(properties) {
        return new BadgeContainer(properties);
    };

    /**
     * Encodes the specified BadgeContainer message. Does not implicitly {@link BadgeContainer.verify|verify} messages.
     * @function encode
     * @memberof BadgeContainer
     * @static
     * @param {IBadgeContainer} message BadgeContainer message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    BadgeContainer.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.title != null && Object.hasOwnProperty.call(message, "title"))
            writer.uint32(/* id 1, wireType 2 =*/10).string(message.title);
        if (message.image != null && message.image.length)
            for (var i = 0; i < message.image.length; ++i)
                $root.Image.encode(message.image[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
        if (message.badge != null && message.badge.length)
            for (var i = 0; i < message.badge.length; ++i)
                $root.Badge.encode(message.badge[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
        return writer;
    };

    /**
     * Encodes the specified BadgeContainer message, length delimited. Does not implicitly {@link BadgeContainer.verify|verify} messages.
     * @function encodeDelimited
     * @memberof BadgeContainer
     * @static
     * @param {IBadgeContainer} message BadgeContainer message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    BadgeContainer.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a BadgeContainer message from the specified reader or buffer.
     * @function decode
     * @memberof BadgeContainer
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {BadgeContainer} BadgeContainer
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    BadgeContainer.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.BadgeContainer();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.title = reader.string();
                break;
            case 2:
                if (!(message.image && message.image.length))
                    message.image = [];
                message.image.push($root.Image.decode(reader, reader.uint32()));
                break;
            case 3:
                if (!(message.badge && message.badge.length))
                    message.badge = [];
                message.badge.push($root.Badge.decode(reader, reader.uint32()));
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a BadgeContainer message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof BadgeContainer
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {BadgeContainer} BadgeContainer
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    BadgeContainer.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a BadgeContainer message.
     * @function verify
     * @memberof BadgeContainer
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    BadgeContainer.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.title != null && message.hasOwnProperty("title"))
            if (!$util.isString(message.title))
                return "title: string expected";
        if (message.image != null && message.hasOwnProperty("image")) {
            if (!Array.isArray(message.image))
                return "image: array expected";
            for (var i = 0; i < message.image.length; ++i) {
                var error = $root.Image.verify(message.image[i]);
                if (error)
                    return "image." + error;
            }
        }
        if (message.badge != null && message.hasOwnProperty("badge")) {
            if (!Array.isArray(message.badge))
                return "badge: array expected";
            for (var i = 0; i < message.badge.length; ++i) {
                var error = $root.Badge.verify(message.badge[i]);
                if (error)
                    return "badge." + error;
            }
        }
        return null;
    };

    /**
     * Creates a BadgeContainer message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof BadgeContainer
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {BadgeContainer} BadgeContainer
     */
    BadgeContainer.fromObject = function fromObject(object) {
        if (object instanceof $root.BadgeContainer)
            return object;
        var message = new $root.BadgeContainer();
        if (object.title != null)
            message.title = String(object.title);
        if (object.image) {
            if (!Array.isArray(object.image))
                throw TypeError(".BadgeContainer.image: array expected");
            message.image = [];
            for (var i = 0; i < object.image.length; ++i) {
                if (typeof object.image[i] !== "object")
                    throw TypeError(".BadgeContainer.image: object expected");
                message.image[i] = $root.Image.fromObject(object.image[i]);
            }
        }
        if (object.badge) {
            if (!Array.isArray(object.badge))
                throw TypeError(".BadgeContainer.badge: array expected");
            message.badge = [];
            for (var i = 0; i < object.badge.length; ++i) {
                if (typeof object.badge[i] !== "object")
                    throw TypeError(".BadgeContainer.badge: object expected");
                message.badge[i] = $root.Badge.fromObject(object.badge[i]);
            }
        }
        return message;
    };

    /**
     * Creates a plain object from a BadgeContainer message. Also converts values to other types if specified.
     * @function toObject
     * @memberof BadgeContainer
     * @static
     * @param {BadgeContainer} message BadgeContainer
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    BadgeContainer.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        var object = {};
        if (options.arrays || options.defaults) {
            object.image = [];
            object.badge = [];
        }
        if (options.defaults)
            object.title = "";
        if (message.title != null && message.hasOwnProperty("title"))
            object.title = message.title;
        if (message.image && message.image.length) {
            object.image = [];
            for (var j = 0; j < message.image.length; ++j)
                object.image[j] = $root.Image.toObject(message.image[j], options);
        }
        if (message.badge && message.badge.length) {
            object.badge = [];
            for (var j = 0; j < message.badge.length; ++j)
                object.badge[j] = $root.Badge.toObject(message.badge[j], options);
        }
        return object;
    };

    /**
     * Converts this BadgeContainer to JSON.
     * @function toJSON
     * @memberof BadgeContainer
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    BadgeContainer.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return BadgeContainer;
})();

$root.OverflowLink = (function() {

    /**
     * Properties of an OverflowLink.
     * @exports IOverflowLink
     * @interface IOverflowLink
     * @property {string|null} [title] OverflowLink title
     * @property {ILink|null} [link] OverflowLink link
     */

    /**
     * Constructs a new OverflowLink.
     * @exports OverflowLink
     * @classdesc Represents an OverflowLink.
     * @implements IOverflowLink
     * @constructor
     * @param {IOverflowLink=} [properties] Properties to set
     */
    function OverflowLink(properties) {
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * OverflowLink title.
     * @member {string} title
     * @memberof OverflowLink
     * @instance
     */
    OverflowLink.prototype.title = "";

    /**
     * OverflowLink link.
     * @member {ILink|null|undefined} link
     * @memberof OverflowLink
     * @instance
     */
    OverflowLink.prototype.link = null;

    /**
     * Creates a new OverflowLink instance using the specified properties.
     * @function create
     * @memberof OverflowLink
     * @static
     * @param {IOverflowLink=} [properties] Properties to set
     * @returns {OverflowLink} OverflowLink instance
     */
    OverflowLink.create = function create(properties) {
        return new OverflowLink(properties);
    };

    /**
     * Encodes the specified OverflowLink message. Does not implicitly {@link OverflowLink.verify|verify} messages.
     * @function encode
     * @memberof OverflowLink
     * @static
     * @param {IOverflowLink} message OverflowLink message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    OverflowLink.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.title != null && Object.hasOwnProperty.call(message, "title"))
            writer.uint32(/* id 1, wireType 2 =*/10).string(message.title);
        if (message.link != null && Object.hasOwnProperty.call(message, "link"))
            $root.Link.encode(message.link, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
        return writer;
    };

    /**
     * Encodes the specified OverflowLink message, length delimited. Does not implicitly {@link OverflowLink.verify|verify} messages.
     * @function encodeDelimited
     * @memberof OverflowLink
     * @static
     * @param {IOverflowLink} message OverflowLink message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    OverflowLink.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes an OverflowLink message from the specified reader or buffer.
     * @function decode
     * @memberof OverflowLink
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {OverflowLink} OverflowLink
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    OverflowLink.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.OverflowLink();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.title = reader.string();
                break;
            case 2:
                message.link = $root.Link.decode(reader, reader.uint32());
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes an OverflowLink message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof OverflowLink
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {OverflowLink} OverflowLink
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    OverflowLink.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies an OverflowLink message.
     * @function verify
     * @memberof OverflowLink
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    OverflowLink.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.title != null && message.hasOwnProperty("title"))
            if (!$util.isString(message.title))
                return "title: string expected";
        if (message.link != null && message.hasOwnProperty("link")) {
            var error = $root.Link.verify(message.link);
            if (error)
                return "link." + error;
        }
        return null;
    };

    /**
     * Creates an OverflowLink message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof OverflowLink
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {OverflowLink} OverflowLink
     */
    OverflowLink.fromObject = function fromObject(object) {
        if (object instanceof $root.OverflowLink)
            return object;
        var message = new $root.OverflowLink();
        if (object.title != null)
            message.title = String(object.title);
        if (object.link != null) {
            if (typeof object.link !== "object")
                throw TypeError(".OverflowLink.link: object expected");
            message.link = $root.Link.fromObject(object.link);
        }
        return message;
    };

    /**
     * Creates a plain object from an OverflowLink message. Also converts values to other types if specified.
     * @function toObject
     * @memberof OverflowLink
     * @static
     * @param {OverflowLink} message OverflowLink
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    OverflowLink.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        var object = {};
        if (options.defaults) {
            object.title = "";
            object.link = null;
        }
        if (message.title != null && message.hasOwnProperty("title"))
            object.title = message.title;
        if (message.link != null && message.hasOwnProperty("link"))
            object.link = $root.Link.toObject(message.link, options);
        return object;
    };

    /**
     * Converts this OverflowLink to JSON.
     * @function toJSON
     * @memberof OverflowLink
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    OverflowLink.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return OverflowLink;
})();

$root.PromotedDoc = (function() {

    /**
     * Properties of a PromotedDoc.
     * @exports IPromotedDoc
     * @interface IPromotedDoc
     * @property {string|null} [title] PromotedDoc title
     * @property {string|null} [subtitle] PromotedDoc subtitle
     * @property {Array.<IImage>|null} [image] PromotedDoc image
     * @property {string|null} [description] PromotedDoc description
     * @property {string|null} [detailsUrl] PromotedDoc detailsUrl
     */

    /**
     * Constructs a new PromotedDoc.
     * @exports PromotedDoc
     * @classdesc Represents a PromotedDoc.
     * @implements IPromotedDoc
     * @constructor
     * @param {IPromotedDoc=} [properties] Properties to set
     */
    function PromotedDoc(properties) {
        this.image = [];
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * PromotedDoc title.
     * @member {string} title
     * @memberof PromotedDoc
     * @instance
     */
    PromotedDoc.prototype.title = "";

    /**
     * PromotedDoc subtitle.
     * @member {string} subtitle
     * @memberof PromotedDoc
     * @instance
     */
    PromotedDoc.prototype.subtitle = "";

    /**
     * PromotedDoc image.
     * @member {Array.<IImage>} image
     * @memberof PromotedDoc
     * @instance
     */
    PromotedDoc.prototype.image = $util.emptyArray;

    /**
     * PromotedDoc description.
     * @member {string} description
     * @memberof PromotedDoc
     * @instance
     */
    PromotedDoc.prototype.description = "";

    /**
     * PromotedDoc detailsUrl.
     * @member {string} detailsUrl
     * @memberof PromotedDoc
     * @instance
     */
    PromotedDoc.prototype.detailsUrl = "";

    /**
     * Creates a new PromotedDoc instance using the specified properties.
     * @function create
     * @memberof PromotedDoc
     * @static
     * @param {IPromotedDoc=} [properties] Properties to set
     * @returns {PromotedDoc} PromotedDoc instance
     */
    PromotedDoc.create = function create(properties) {
        return new PromotedDoc(properties);
    };

    /**
     * Encodes the specified PromotedDoc message. Does not implicitly {@link PromotedDoc.verify|verify} messages.
     * @function encode
     * @memberof PromotedDoc
     * @static
     * @param {IPromotedDoc} message PromotedDoc message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    PromotedDoc.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.title != null && Object.hasOwnProperty.call(message, "title"))
            writer.uint32(/* id 1, wireType 2 =*/10).string(message.title);
        if (message.subtitle != null && Object.hasOwnProperty.call(message, "subtitle"))
            writer.uint32(/* id 2, wireType 2 =*/18).string(message.subtitle);
        if (message.image != null && message.image.length)
            for (var i = 0; i < message.image.length; ++i)
                $root.Image.encode(message.image[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
        if (message.description != null && Object.hasOwnProperty.call(message, "description"))
            writer.uint32(/* id 4, wireType 2 =*/34).string(message.description);
        if (message.detailsUrl != null && Object.hasOwnProperty.call(message, "detailsUrl"))
            writer.uint32(/* id 5, wireType 2 =*/42).string(message.detailsUrl);
        return writer;
    };

    /**
     * Encodes the specified PromotedDoc message, length delimited. Does not implicitly {@link PromotedDoc.verify|verify} messages.
     * @function encodeDelimited
     * @memberof PromotedDoc
     * @static
     * @param {IPromotedDoc} message PromotedDoc message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    PromotedDoc.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a PromotedDoc message from the specified reader or buffer.
     * @function decode
     * @memberof PromotedDoc
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {PromotedDoc} PromotedDoc
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    PromotedDoc.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.PromotedDoc();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.title = reader.string();
                break;
            case 2:
                message.subtitle = reader.string();
                break;
            case 3:
                if (!(message.image && message.image.length))
                    message.image = [];
                message.image.push($root.Image.decode(reader, reader.uint32()));
                break;
            case 4:
                message.description = reader.string();
                break;
            case 5:
                message.detailsUrl = reader.string();
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a PromotedDoc message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof PromotedDoc
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {PromotedDoc} PromotedDoc
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    PromotedDoc.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a PromotedDoc message.
     * @function verify
     * @memberof PromotedDoc
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    PromotedDoc.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.title != null && message.hasOwnProperty("title"))
            if (!$util.isString(message.title))
                return "title: string expected";
        if (message.subtitle != null && message.hasOwnProperty("subtitle"))
            if (!$util.isString(message.subtitle))
                return "subtitle: string expected";
        if (message.image != null && message.hasOwnProperty("image")) {
            if (!Array.isArray(message.image))
                return "image: array expected";
            for (var i = 0; i < message.image.length; ++i) {
                var error = $root.Image.verify(message.image[i]);
                if (error)
                    return "image." + error;
            }
        }
        if (message.description != null && message.hasOwnProperty("description"))
            if (!$util.isString(message.description))
                return "description: string expected";
        if (message.detailsUrl != null && message.hasOwnProperty("detailsUrl"))
            if (!$util.isString(message.detailsUrl))
                return "detailsUrl: string expected";
        return null;
    };

    /**
     * Creates a PromotedDoc message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof PromotedDoc
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {PromotedDoc} PromotedDoc
     */
    PromotedDoc.fromObject = function fromObject(object) {
        if (object instanceof $root.PromotedDoc)
            return object;
        var message = new $root.PromotedDoc();
        if (object.title != null)
            message.title = String(object.title);
        if (object.subtitle != null)
            message.subtitle = String(object.subtitle);
        if (object.image) {
            if (!Array.isArray(object.image))
                throw TypeError(".PromotedDoc.image: array expected");
            message.image = [];
            for (var i = 0; i < object.image.length; ++i) {
                if (typeof object.image[i] !== "object")
                    throw TypeError(".PromotedDoc.image: object expected");
                message.image[i] = $root.Image.fromObject(object.image[i]);
            }
        }
        if (object.description != null)
            message.description = String(object.description);
        if (object.detailsUrl != null)
            message.detailsUrl = String(object.detailsUrl);
        return message;
    };

    /**
     * Creates a plain object from a PromotedDoc message. Also converts values to other types if specified.
     * @function toObject
     * @memberof PromotedDoc
     * @static
     * @param {PromotedDoc} message PromotedDoc
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    PromotedDoc.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        var object = {};
        if (options.arrays || options.defaults)
            object.image = [];
        if (options.defaults) {
            object.title = "";
            object.subtitle = "";
            object.description = "";
            object.detailsUrl = "";
        }
        if (message.title != null && message.hasOwnProperty("title"))
            object.title = message.title;
        if (message.subtitle != null && message.hasOwnProperty("subtitle"))
            object.subtitle = message.subtitle;
        if (message.image && message.image.length) {
            object.image = [];
            for (var j = 0; j < message.image.length; ++j)
                object.image[j] = $root.Image.toObject(message.image[j], options);
        }
        if (message.description != null && message.hasOwnProperty("description"))
            object.description = message.description;
        if (message.detailsUrl != null && message.hasOwnProperty("detailsUrl"))
            object.detailsUrl = message.detailsUrl;
        return object;
    };

    /**
     * Converts this PromotedDoc to JSON.
     * @function toJSON
     * @memberof PromotedDoc
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    PromotedDoc.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return PromotedDoc;
})();

$root.Warning = (function() {

    /**
     * Properties of a Warning.
     * @exports IWarning
     * @interface IWarning
     * @property {string|null} [localizedMessage] Warning localizedMessage
     */

    /**
     * Constructs a new Warning.
     * @exports Warning
     * @classdesc Represents a Warning.
     * @implements IWarning
     * @constructor
     * @param {IWarning=} [properties] Properties to set
     */
    function Warning(properties) {
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * Warning localizedMessage.
     * @member {string} localizedMessage
     * @memberof Warning
     * @instance
     */
    Warning.prototype.localizedMessage = "";

    /**
     * Creates a new Warning instance using the specified properties.
     * @function create
     * @memberof Warning
     * @static
     * @param {IWarning=} [properties] Properties to set
     * @returns {Warning} Warning instance
     */
    Warning.create = function create(properties) {
        return new Warning(properties);
    };

    /**
     * Encodes the specified Warning message. Does not implicitly {@link Warning.verify|verify} messages.
     * @function encode
     * @memberof Warning
     * @static
     * @param {IWarning} message Warning message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    Warning.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.localizedMessage != null && Object.hasOwnProperty.call(message, "localizedMessage"))
            writer.uint32(/* id 1, wireType 2 =*/10).string(message.localizedMessage);
        return writer;
    };

    /**
     * Encodes the specified Warning message, length delimited. Does not implicitly {@link Warning.verify|verify} messages.
     * @function encodeDelimited
     * @memberof Warning
     * @static
     * @param {IWarning} message Warning message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    Warning.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a Warning message from the specified reader or buffer.
     * @function decode
     * @memberof Warning
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {Warning} Warning
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    Warning.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Warning();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.localizedMessage = reader.string();
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a Warning message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof Warning
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {Warning} Warning
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    Warning.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a Warning message.
     * @function verify
     * @memberof Warning
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    Warning.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.localizedMessage != null && message.hasOwnProperty("localizedMessage"))
            if (!$util.isString(message.localizedMessage))
                return "localizedMessage: string expected";
        return null;
    };

    /**
     * Creates a Warning message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof Warning
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {Warning} Warning
     */
    Warning.fromObject = function fromObject(object) {
        if (object instanceof $root.Warning)
            return object;
        var message = new $root.Warning();
        if (object.localizedMessage != null)
            message.localizedMessage = String(object.localizedMessage);
        return message;
    };

    /**
     * Creates a plain object from a Warning message. Also converts values to other types if specified.
     * @function toObject
     * @memberof Warning
     * @static
     * @param {Warning} message Warning
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    Warning.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        var object = {};
        if (options.defaults)
            object.localizedMessage = "";
        if (message.localizedMessage != null && message.hasOwnProperty("localizedMessage"))
            object.localizedMessage = message.localizedMessage;
        return object;
    };

    /**
     * Converts this Warning to JSON.
     * @function toJSON
     * @memberof Warning
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    Warning.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return Warning;
})();

$root.AnnotationLink = (function() {

    /**
     * Properties of an AnnotationLink.
     * @exports IAnnotationLink
     * @interface IAnnotationLink
     * @property {string|null} [uri] AnnotationLink uri
     * @property {IResolvedLink|null} [resolvedLink] AnnotationLink resolvedLink
     * @property {number|null} [uriBackend] AnnotationLink uriBackend
     */

    /**
     * Constructs a new AnnotationLink.
     * @exports AnnotationLink
     * @classdesc Represents an AnnotationLink.
     * @implements IAnnotationLink
     * @constructor
     * @param {IAnnotationLink=} [properties] Properties to set
     */
    function AnnotationLink(properties) {
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * AnnotationLink uri.
     * @member {string} uri
     * @memberof AnnotationLink
     * @instance
     */
    AnnotationLink.prototype.uri = "";

    /**
     * AnnotationLink resolvedLink.
     * @member {IResolvedLink|null|undefined} resolvedLink
     * @memberof AnnotationLink
     * @instance
     */
    AnnotationLink.prototype.resolvedLink = null;

    /**
     * AnnotationLink uriBackend.
     * @member {number} uriBackend
     * @memberof AnnotationLink
     * @instance
     */
    AnnotationLink.prototype.uriBackend = 0;

    /**
     * Creates a new AnnotationLink instance using the specified properties.
     * @function create
     * @memberof AnnotationLink
     * @static
     * @param {IAnnotationLink=} [properties] Properties to set
     * @returns {AnnotationLink} AnnotationLink instance
     */
    AnnotationLink.create = function create(properties) {
        return new AnnotationLink(properties);
    };

    /**
     * Encodes the specified AnnotationLink message. Does not implicitly {@link AnnotationLink.verify|verify} messages.
     * @function encode
     * @memberof AnnotationLink
     * @static
     * @param {IAnnotationLink} message AnnotationLink message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    AnnotationLink.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.uri != null && Object.hasOwnProperty.call(message, "uri"))
            writer.uint32(/* id 1, wireType 2 =*/10).string(message.uri);
        if (message.resolvedLink != null && Object.hasOwnProperty.call(message, "resolvedLink"))
            $root.ResolvedLink.encode(message.resolvedLink, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
        if (message.uriBackend != null && Object.hasOwnProperty.call(message, "uriBackend"))
            writer.uint32(/* id 3, wireType 0 =*/24).int32(message.uriBackend);
        return writer;
    };

    /**
     * Encodes the specified AnnotationLink message, length delimited. Does not implicitly {@link AnnotationLink.verify|verify} messages.
     * @function encodeDelimited
     * @memberof AnnotationLink
     * @static
     * @param {IAnnotationLink} message AnnotationLink message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    AnnotationLink.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes an AnnotationLink message from the specified reader or buffer.
     * @function decode
     * @memberof AnnotationLink
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {AnnotationLink} AnnotationLink
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    AnnotationLink.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.AnnotationLink();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.uri = reader.string();
                break;
            case 2:
                message.resolvedLink = $root.ResolvedLink.decode(reader, reader.uint32());
                break;
            case 3:
                message.uriBackend = reader.int32();
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes an AnnotationLink message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof AnnotationLink
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {AnnotationLink} AnnotationLink
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    AnnotationLink.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies an AnnotationLink message.
     * @function verify
     * @memberof AnnotationLink
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    AnnotationLink.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.uri != null && message.hasOwnProperty("uri"))
            if (!$util.isString(message.uri))
                return "uri: string expected";
        if (message.resolvedLink != null && message.hasOwnProperty("resolvedLink")) {
            var error = $root.ResolvedLink.verify(message.resolvedLink);
            if (error)
                return "resolvedLink." + error;
        }
        if (message.uriBackend != null && message.hasOwnProperty("uriBackend"))
            if (!$util.isInteger(message.uriBackend))
                return "uriBackend: integer expected";
        return null;
    };

    /**
     * Creates an AnnotationLink message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof AnnotationLink
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {AnnotationLink} AnnotationLink
     */
    AnnotationLink.fromObject = function fromObject(object) {
        if (object instanceof $root.AnnotationLink)
            return object;
        var message = new $root.AnnotationLink();
        if (object.uri != null)
            message.uri = String(object.uri);
        if (object.resolvedLink != null) {
            if (typeof object.resolvedLink !== "object")
                throw TypeError(".AnnotationLink.resolvedLink: object expected");
            message.resolvedLink = $root.ResolvedLink.fromObject(object.resolvedLink);
        }
        if (object.uriBackend != null)
            message.uriBackend = object.uriBackend | 0;
        return message;
    };

    /**
     * Creates a plain object from an AnnotationLink message. Also converts values to other types if specified.
     * @function toObject
     * @memberof AnnotationLink
     * @static
     * @param {AnnotationLink} message AnnotationLink
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    AnnotationLink.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        var object = {};
        if (options.defaults) {
            object.uri = "";
            object.resolvedLink = null;
            object.uriBackend = 0;
        }
        if (message.uri != null && message.hasOwnProperty("uri"))
            object.uri = message.uri;
        if (message.resolvedLink != null && message.hasOwnProperty("resolvedLink"))
            object.resolvedLink = $root.ResolvedLink.toObject(message.resolvedLink, options);
        if (message.uriBackend != null && message.hasOwnProperty("uriBackend"))
            object.uriBackend = message.uriBackend;
        return object;
    };

    /**
     * Converts this AnnotationLink to JSON.
     * @function toJSON
     * @memberof AnnotationLink
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    AnnotationLink.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return AnnotationLink;
})();

$root.Rated = (function() {

    /**
     * Properties of a Rated.
     * @exports IRated
     * @interface IRated
     * @property {string|null} [label] Rated label
     * @property {IImage|null} [image] Rated image
     * @property {string|null} [learnMoreHtmlLink] Rated learnMoreHtmlLink
     */

    /**
     * Constructs a new Rated.
     * @exports Rated
     * @classdesc Represents a Rated.
     * @implements IRated
     * @constructor
     * @param {IRated=} [properties] Properties to set
     */
    function Rated(properties) {
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * Rated label.
     * @member {string} label
     * @memberof Rated
     * @instance
     */
    Rated.prototype.label = "";

    /**
     * Rated image.
     * @member {IImage|null|undefined} image
     * @memberof Rated
     * @instance
     */
    Rated.prototype.image = null;

    /**
     * Rated learnMoreHtmlLink.
     * @member {string} learnMoreHtmlLink
     * @memberof Rated
     * @instance
     */
    Rated.prototype.learnMoreHtmlLink = "";

    /**
     * Creates a new Rated instance using the specified properties.
     * @function create
     * @memberof Rated
     * @static
     * @param {IRated=} [properties] Properties to set
     * @returns {Rated} Rated instance
     */
    Rated.create = function create(properties) {
        return new Rated(properties);
    };

    /**
     * Encodes the specified Rated message. Does not implicitly {@link Rated.verify|verify} messages.
     * @function encode
     * @memberof Rated
     * @static
     * @param {IRated} message Rated message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    Rated.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.label != null && Object.hasOwnProperty.call(message, "label"))
            writer.uint32(/* id 1, wireType 2 =*/10).string(message.label);
        if (message.image != null && Object.hasOwnProperty.call(message, "image"))
            $root.Image.encode(message.image, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
        if (message.learnMoreHtmlLink != null && Object.hasOwnProperty.call(message, "learnMoreHtmlLink"))
            writer.uint32(/* id 4, wireType 2 =*/34).string(message.learnMoreHtmlLink);
        return writer;
    };

    /**
     * Encodes the specified Rated message, length delimited. Does not implicitly {@link Rated.verify|verify} messages.
     * @function encodeDelimited
     * @memberof Rated
     * @static
     * @param {IRated} message Rated message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    Rated.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a Rated message from the specified reader or buffer.
     * @function decode
     * @memberof Rated
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {Rated} Rated
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    Rated.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Rated();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.label = reader.string();
                break;
            case 2:
                message.image = $root.Image.decode(reader, reader.uint32());
                break;
            case 4:
                message.learnMoreHtmlLink = reader.string();
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a Rated message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof Rated
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {Rated} Rated
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    Rated.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a Rated message.
     * @function verify
     * @memberof Rated
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    Rated.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.label != null && message.hasOwnProperty("label"))
            if (!$util.isString(message.label))
                return "label: string expected";
        if (message.image != null && message.hasOwnProperty("image")) {
            var error = $root.Image.verify(message.image);
            if (error)
                return "image." + error;
        }
        if (message.learnMoreHtmlLink != null && message.hasOwnProperty("learnMoreHtmlLink"))
            if (!$util.isString(message.learnMoreHtmlLink))
                return "learnMoreHtmlLink: string expected";
        return null;
    };

    /**
     * Creates a Rated message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof Rated
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {Rated} Rated
     */
    Rated.fromObject = function fromObject(object) {
        if (object instanceof $root.Rated)
            return object;
        var message = new $root.Rated();
        if (object.label != null)
            message.label = String(object.label);
        if (object.image != null) {
            if (typeof object.image !== "object")
                throw TypeError(".Rated.image: object expected");
            message.image = $root.Image.fromObject(object.image);
        }
        if (object.learnMoreHtmlLink != null)
            message.learnMoreHtmlLink = String(object.learnMoreHtmlLink);
        return message;
    };

    /**
     * Creates a plain object from a Rated message. Also converts values to other types if specified.
     * @function toObject
     * @memberof Rated
     * @static
     * @param {Rated} message Rated
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    Rated.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        var object = {};
        if (options.defaults) {
            object.label = "";
            object.image = null;
            object.learnMoreHtmlLink = "";
        }
        if (message.label != null && message.hasOwnProperty("label"))
            object.label = message.label;
        if (message.image != null && message.hasOwnProperty("image"))
            object.image = $root.Image.toObject(message.image, options);
        if (message.learnMoreHtmlLink != null && message.hasOwnProperty("learnMoreHtmlLink"))
            object.learnMoreHtmlLink = message.learnMoreHtmlLink;
        return object;
    };

    /**
     * Converts this Rated to JSON.
     * @function toJSON
     * @memberof Rated
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    Rated.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return Rated;
})();

$root.Badge = (function() {

    /**
     * Properties of a Badge.
     * @exports IBadge
     * @interface IBadge
     * @property {string|null} [major] Badge major
     * @property {IImage|null} [image] Badge image
     * @property {string|null} [minor] Badge minor
     * @property {string|null} [minorHtml] Badge minorHtml
     * @property {ISubBadge|null} [subBadge] Badge subBadge
     * @property {IStreamLink|null} [link] Badge link
     * @property {string|null} [description] Badge description
     * @property {ISubStream|null} [stream] Badge stream
     */

    /**
     * Constructs a new Badge.
     * @exports Badge
     * @classdesc Represents a Badge.
     * @implements IBadge
     * @constructor
     * @param {IBadge=} [properties] Properties to set
     */
    function Badge(properties) {
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * Badge major.
     * @member {string} major
     * @memberof Badge
     * @instance
     */
    Badge.prototype.major = "";

    /**
     * Badge image.
     * @member {IImage|null|undefined} image
     * @memberof Badge
     * @instance
     */
    Badge.prototype.image = null;

    /**
     * Badge minor.
     * @member {string} minor
     * @memberof Badge
     * @instance
     */
    Badge.prototype.minor = "";

    /**
     * Badge minorHtml.
     * @member {string} minorHtml
     * @memberof Badge
     * @instance
     */
    Badge.prototype.minorHtml = "";

    /**
     * Badge subBadge.
     * @member {ISubBadge|null|undefined} subBadge
     * @memberof Badge
     * @instance
     */
    Badge.prototype.subBadge = null;

    /**
     * Badge link.
     * @member {IStreamLink|null|undefined} link
     * @memberof Badge
     * @instance
     */
    Badge.prototype.link = null;

    /**
     * Badge description.
     * @member {string} description
     * @memberof Badge
     * @instance
     */
    Badge.prototype.description = "";

    /**
     * Badge stream.
     * @member {ISubStream|null|undefined} stream
     * @memberof Badge
     * @instance
     */
    Badge.prototype.stream = null;

    /**
     * Creates a new Badge instance using the specified properties.
     * @function create
     * @memberof Badge
     * @static
     * @param {IBadge=} [properties] Properties to set
     * @returns {Badge} Badge instance
     */
    Badge.create = function create(properties) {
        return new Badge(properties);
    };

    /**
     * Encodes the specified Badge message. Does not implicitly {@link Badge.verify|verify} messages.
     * @function encode
     * @memberof Badge
     * @static
     * @param {IBadge} message Badge message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    Badge.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.major != null && Object.hasOwnProperty.call(message, "major"))
            writer.uint32(/* id 1, wireType 2 =*/10).string(message.major);
        if (message.image != null && Object.hasOwnProperty.call(message, "image"))
            $root.Image.encode(message.image, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
        if (message.minor != null && Object.hasOwnProperty.call(message, "minor"))
            writer.uint32(/* id 3, wireType 2 =*/26).string(message.minor);
        if (message.minorHtml != null && Object.hasOwnProperty.call(message, "minorHtml"))
            writer.uint32(/* id 4, wireType 2 =*/34).string(message.minorHtml);
        if (message.subBadge != null && Object.hasOwnProperty.call(message, "subBadge"))
            $root.SubBadge.encode(message.subBadge, writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
        if (message.link != null && Object.hasOwnProperty.call(message, "link"))
            $root.StreamLink.encode(message.link, writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
        if (message.description != null && Object.hasOwnProperty.call(message, "description"))
            writer.uint32(/* id 8, wireType 2 =*/66).string(message.description);
        if (message.stream != null && Object.hasOwnProperty.call(message, "stream"))
            $root.SubStream.encode(message.stream, writer.uint32(/* id 12, wireType 2 =*/98).fork()).ldelim();
        return writer;
    };

    /**
     * Encodes the specified Badge message, length delimited. Does not implicitly {@link Badge.verify|verify} messages.
     * @function encodeDelimited
     * @memberof Badge
     * @static
     * @param {IBadge} message Badge message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    Badge.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a Badge message from the specified reader or buffer.
     * @function decode
     * @memberof Badge
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {Badge} Badge
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    Badge.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Badge();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.major = reader.string();
                break;
            case 2:
                message.image = $root.Image.decode(reader, reader.uint32());
                break;
            case 3:
                message.minor = reader.string();
                break;
            case 4:
                message.minorHtml = reader.string();
                break;
            case 6:
                message.subBadge = $root.SubBadge.decode(reader, reader.uint32());
                break;
            case 7:
                message.link = $root.StreamLink.decode(reader, reader.uint32());
                break;
            case 8:
                message.description = reader.string();
                break;
            case 12:
                message.stream = $root.SubStream.decode(reader, reader.uint32());
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a Badge message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof Badge
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {Badge} Badge
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    Badge.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a Badge message.
     * @function verify
     * @memberof Badge
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    Badge.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.major != null && message.hasOwnProperty("major"))
            if (!$util.isString(message.major))
                return "major: string expected";
        if (message.image != null && message.hasOwnProperty("image")) {
            var error = $root.Image.verify(message.image);
            if (error)
                return "image." + error;
        }
        if (message.minor != null && message.hasOwnProperty("minor"))
            if (!$util.isString(message.minor))
                return "minor: string expected";
        if (message.minorHtml != null && message.hasOwnProperty("minorHtml"))
            if (!$util.isString(message.minorHtml))
                return "minorHtml: string expected";
        if (message.subBadge != null && message.hasOwnProperty("subBadge")) {
            var error = $root.SubBadge.verify(message.subBadge);
            if (error)
                return "subBadge." + error;
        }
        if (message.link != null && message.hasOwnProperty("link")) {
            var error = $root.StreamLink.verify(message.link);
            if (error)
                return "link." + error;
        }
        if (message.description != null && message.hasOwnProperty("description"))
            if (!$util.isString(message.description))
                return "description: string expected";
        if (message.stream != null && message.hasOwnProperty("stream")) {
            var error = $root.SubStream.verify(message.stream);
            if (error)
                return "stream." + error;
        }
        return null;
    };

    /**
     * Creates a Badge message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof Badge
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {Badge} Badge
     */
    Badge.fromObject = function fromObject(object) {
        if (object instanceof $root.Badge)
            return object;
        var message = new $root.Badge();
        if (object.major != null)
            message.major = String(object.major);
        if (object.image != null) {
            if (typeof object.image !== "object")
                throw TypeError(".Badge.image: object expected");
            message.image = $root.Image.fromObject(object.image);
        }
        if (object.minor != null)
            message.minor = String(object.minor);
        if (object.minorHtml != null)
            message.minorHtml = String(object.minorHtml);
        if (object.subBadge != null) {
            if (typeof object.subBadge !== "object")
                throw TypeError(".Badge.subBadge: object expected");
            message.subBadge = $root.SubBadge.fromObject(object.subBadge);
        }
        if (object.link != null) {
            if (typeof object.link !== "object")
                throw TypeError(".Badge.link: object expected");
            message.link = $root.StreamLink.fromObject(object.link);
        }
        if (object.description != null)
            message.description = String(object.description);
        if (object.stream != null) {
            if (typeof object.stream !== "object")
                throw TypeError(".Badge.stream: object expected");
            message.stream = $root.SubStream.fromObject(object.stream);
        }
        return message;
    };

    /**
     * Creates a plain object from a Badge message. Also converts values to other types if specified.
     * @function toObject
     * @memberof Badge
     * @static
     * @param {Badge} message Badge
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    Badge.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        var object = {};
        if (options.defaults) {
            object.major = "";
            object.image = null;
            object.minor = "";
            object.minorHtml = "";
            object.subBadge = null;
            object.link = null;
            object.description = "";
            object.stream = null;
        }
        if (message.major != null && message.hasOwnProperty("major"))
            object.major = message.major;
        if (message.image != null && message.hasOwnProperty("image"))
            object.image = $root.Image.toObject(message.image, options);
        if (message.minor != null && message.hasOwnProperty("minor"))
            object.minor = message.minor;
        if (message.minorHtml != null && message.hasOwnProperty("minorHtml"))
            object.minorHtml = message.minorHtml;
        if (message.subBadge != null && message.hasOwnProperty("subBadge"))
            object.subBadge = $root.SubBadge.toObject(message.subBadge, options);
        if (message.link != null && message.hasOwnProperty("link"))
            object.link = $root.StreamLink.toObject(message.link, options);
        if (message.description != null && message.hasOwnProperty("description"))
            object.description = message.description;
        if (message.stream != null && message.hasOwnProperty("stream"))
            object.stream = $root.SubStream.toObject(message.stream, options);
        return object;
    };

    /**
     * Converts this Badge to JSON.
     * @function toJSON
     * @memberof Badge
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    Badge.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return Badge;
})();

$root.SubBadge = (function() {

    /**
     * Properties of a SubBadge.
     * @exports ISubBadge
     * @interface ISubBadge
     * @property {IImage|null} [image] SubBadge image
     * @property {string|null} [description] SubBadge description
     * @property {IStreamLink|null} [link] SubBadge link
     */

    /**
     * Constructs a new SubBadge.
     * @exports SubBadge
     * @classdesc Represents a SubBadge.
     * @implements ISubBadge
     * @constructor
     * @param {ISubBadge=} [properties] Properties to set
     */
    function SubBadge(properties) {
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * SubBadge image.
     * @member {IImage|null|undefined} image
     * @memberof SubBadge
     * @instance
     */
    SubBadge.prototype.image = null;

    /**
     * SubBadge description.
     * @member {string} description
     * @memberof SubBadge
     * @instance
     */
    SubBadge.prototype.description = "";

    /**
     * SubBadge link.
     * @member {IStreamLink|null|undefined} link
     * @memberof SubBadge
     * @instance
     */
    SubBadge.prototype.link = null;

    /**
     * Creates a new SubBadge instance using the specified properties.
     * @function create
     * @memberof SubBadge
     * @static
     * @param {ISubBadge=} [properties] Properties to set
     * @returns {SubBadge} SubBadge instance
     */
    SubBadge.create = function create(properties) {
        return new SubBadge(properties);
    };

    /**
     * Encodes the specified SubBadge message. Does not implicitly {@link SubBadge.verify|verify} messages.
     * @function encode
     * @memberof SubBadge
     * @static
     * @param {ISubBadge} message SubBadge message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    SubBadge.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.image != null && Object.hasOwnProperty.call(message, "image"))
            $root.Image.encode(message.image, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
        if (message.description != null && Object.hasOwnProperty.call(message, "description"))
            writer.uint32(/* id 4, wireType 2 =*/34).string(message.description);
        if (message.link != null && Object.hasOwnProperty.call(message, "link"))
            $root.StreamLink.encode(message.link, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
        return writer;
    };

    /**
     * Encodes the specified SubBadge message, length delimited. Does not implicitly {@link SubBadge.verify|verify} messages.
     * @function encodeDelimited
     * @memberof SubBadge
     * @static
     * @param {ISubBadge} message SubBadge message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    SubBadge.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a SubBadge message from the specified reader or buffer.
     * @function decode
     * @memberof SubBadge
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {SubBadge} SubBadge
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    SubBadge.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.SubBadge();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.image = $root.Image.decode(reader, reader.uint32());
                break;
            case 4:
                message.description = reader.string();
                break;
            case 5:
                message.link = $root.StreamLink.decode(reader, reader.uint32());
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a SubBadge message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof SubBadge
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {SubBadge} SubBadge
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    SubBadge.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a SubBadge message.
     * @function verify
     * @memberof SubBadge
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    SubBadge.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.image != null && message.hasOwnProperty("image")) {
            var error = $root.Image.verify(message.image);
            if (error)
                return "image." + error;
        }
        if (message.description != null && message.hasOwnProperty("description"))
            if (!$util.isString(message.description))
                return "description: string expected";
        if (message.link != null && message.hasOwnProperty("link")) {
            var error = $root.StreamLink.verify(message.link);
            if (error)
                return "link." + error;
        }
        return null;
    };

    /**
     * Creates a SubBadge message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof SubBadge
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {SubBadge} SubBadge
     */
    SubBadge.fromObject = function fromObject(object) {
        if (object instanceof $root.SubBadge)
            return object;
        var message = new $root.SubBadge();
        if (object.image != null) {
            if (typeof object.image !== "object")
                throw TypeError(".SubBadge.image: object expected");
            message.image = $root.Image.fromObject(object.image);
        }
        if (object.description != null)
            message.description = String(object.description);
        if (object.link != null) {
            if (typeof object.link !== "object")
                throw TypeError(".SubBadge.link: object expected");
            message.link = $root.StreamLink.fromObject(object.link);
        }
        return message;
    };

    /**
     * Creates a plain object from a SubBadge message. Also converts values to other types if specified.
     * @function toObject
     * @memberof SubBadge
     * @static
     * @param {SubBadge} message SubBadge
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    SubBadge.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        var object = {};
        if (options.defaults) {
            object.image = null;
            object.description = "";
            object.link = null;
        }
        if (message.image != null && message.hasOwnProperty("image"))
            object.image = $root.Image.toObject(message.image, options);
        if (message.description != null && message.hasOwnProperty("description"))
            object.description = message.description;
        if (message.link != null && message.hasOwnProperty("link"))
            object.link = $root.StreamLink.toObject(message.link, options);
        return object;
    };

    /**
     * Converts this SubBadge to JSON.
     * @function toJSON
     * @memberof SubBadge
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    SubBadge.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return SubBadge;
})();

$root.Stream = (function() {

    /**
     * Properties of a Stream.
     * @exports IStream
     * @interface IStream
     * @property {string|null} [title] Stream title
     * @property {ISubStream|null} [stream] Stream stream
     * @property {string|null} [subtitle] Stream subtitle
     */

    /**
     * Constructs a new Stream.
     * @exports Stream
     * @classdesc Represents a Stream.
     * @implements IStream
     * @constructor
     * @param {IStream=} [properties] Properties to set
     */
    function Stream(properties) {
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * Stream title.
     * @member {string} title
     * @memberof Stream
     * @instance
     */
    Stream.prototype.title = "";

    /**
     * Stream stream.
     * @member {ISubStream|null|undefined} stream
     * @memberof Stream
     * @instance
     */
    Stream.prototype.stream = null;

    /**
     * Stream subtitle.
     * @member {string} subtitle
     * @memberof Stream
     * @instance
     */
    Stream.prototype.subtitle = "";

    /**
     * Creates a new Stream instance using the specified properties.
     * @function create
     * @memberof Stream
     * @static
     * @param {IStream=} [properties] Properties to set
     * @returns {Stream} Stream instance
     */
    Stream.create = function create(properties) {
        return new Stream(properties);
    };

    /**
     * Encodes the specified Stream message. Does not implicitly {@link Stream.verify|verify} messages.
     * @function encode
     * @memberof Stream
     * @static
     * @param {IStream} message Stream message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    Stream.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.title != null && Object.hasOwnProperty.call(message, "title"))
            writer.uint32(/* id 1, wireType 2 =*/10).string(message.title);
        if (message.stream != null && Object.hasOwnProperty.call(message, "stream"))
            $root.SubStream.encode(message.stream, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
        if (message.subtitle != null && Object.hasOwnProperty.call(message, "subtitle"))
            writer.uint32(/* id 3, wireType 2 =*/26).string(message.subtitle);
        return writer;
    };

    /**
     * Encodes the specified Stream message, length delimited. Does not implicitly {@link Stream.verify|verify} messages.
     * @function encodeDelimited
     * @memberof Stream
     * @static
     * @param {IStream} message Stream message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    Stream.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a Stream message from the specified reader or buffer.
     * @function decode
     * @memberof Stream
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {Stream} Stream
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    Stream.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Stream();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.title = reader.string();
                break;
            case 2:
                message.stream = $root.SubStream.decode(reader, reader.uint32());
                break;
            case 3:
                message.subtitle = reader.string();
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a Stream message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof Stream
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {Stream} Stream
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    Stream.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a Stream message.
     * @function verify
     * @memberof Stream
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    Stream.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.title != null && message.hasOwnProperty("title"))
            if (!$util.isString(message.title))
                return "title: string expected";
        if (message.stream != null && message.hasOwnProperty("stream")) {
            var error = $root.SubStream.verify(message.stream);
            if (error)
                return "stream." + error;
        }
        if (message.subtitle != null && message.hasOwnProperty("subtitle"))
            if (!$util.isString(message.subtitle))
                return "subtitle: string expected";
        return null;
    };

    /**
     * Creates a Stream message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof Stream
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {Stream} Stream
     */
    Stream.fromObject = function fromObject(object) {
        if (object instanceof $root.Stream)
            return object;
        var message = new $root.Stream();
        if (object.title != null)
            message.title = String(object.title);
        if (object.stream != null) {
            if (typeof object.stream !== "object")
                throw TypeError(".Stream.stream: object expected");
            message.stream = $root.SubStream.fromObject(object.stream);
        }
        if (object.subtitle != null)
            message.subtitle = String(object.subtitle);
        return message;
    };

    /**
     * Creates a plain object from a Stream message. Also converts values to other types if specified.
     * @function toObject
     * @memberof Stream
     * @static
     * @param {Stream} message Stream
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    Stream.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        var object = {};
        if (options.defaults) {
            object.title = "";
            object.stream = null;
            object.subtitle = "";
        }
        if (message.title != null && message.hasOwnProperty("title"))
            object.title = message.title;
        if (message.stream != null && message.hasOwnProperty("stream"))
            object.stream = $root.SubStream.toObject(message.stream, options);
        if (message.subtitle != null && message.hasOwnProperty("subtitle"))
            object.subtitle = message.subtitle;
        return object;
    };

    /**
     * Converts this Stream to JSON.
     * @function toJSON
     * @memberof Stream
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    Stream.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return Stream;
})();

$root.SubStream = (function() {

    /**
     * Properties of a SubStream.
     * @exports ISubStream
     * @interface ISubStream
     * @property {IStreamLink|null} [link] SubStream link
     */

    /**
     * Constructs a new SubStream.
     * @exports SubStream
     * @classdesc Represents a SubStream.
     * @implements ISubStream
     * @constructor
     * @param {ISubStream=} [properties] Properties to set
     */
    function SubStream(properties) {
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * SubStream link.
     * @member {IStreamLink|null|undefined} link
     * @memberof SubStream
     * @instance
     */
    SubStream.prototype.link = null;

    /**
     * Creates a new SubStream instance using the specified properties.
     * @function create
     * @memberof SubStream
     * @static
     * @param {ISubStream=} [properties] Properties to set
     * @returns {SubStream} SubStream instance
     */
    SubStream.create = function create(properties) {
        return new SubStream(properties);
    };

    /**
     * Encodes the specified SubStream message. Does not implicitly {@link SubStream.verify|verify} messages.
     * @function encode
     * @memberof SubStream
     * @static
     * @param {ISubStream} message SubStream message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    SubStream.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.link != null && Object.hasOwnProperty.call(message, "link"))
            $root.StreamLink.encode(message.link, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
        return writer;
    };

    /**
     * Encodes the specified SubStream message, length delimited. Does not implicitly {@link SubStream.verify|verify} messages.
     * @function encodeDelimited
     * @memberof SubStream
     * @static
     * @param {ISubStream} message SubStream message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    SubStream.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a SubStream message from the specified reader or buffer.
     * @function decode
     * @memberof SubStream
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {SubStream} SubStream
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    SubStream.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.SubStream();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            case 2:
                message.link = $root.StreamLink.decode(reader, reader.uint32());
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a SubStream message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof SubStream
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {SubStream} SubStream
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    SubStream.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a SubStream message.
     * @function verify
     * @memberof SubStream
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    SubStream.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.link != null && message.hasOwnProperty("link")) {
            var error = $root.StreamLink.verify(message.link);
            if (error)
                return "link." + error;
        }
        return null;
    };

    /**
     * Creates a SubStream message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof SubStream
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {SubStream} SubStream
     */
    SubStream.fromObject = function fromObject(object) {
        if (object instanceof $root.SubStream)
            return object;
        var message = new $root.SubStream();
        if (object.link != null) {
            if (typeof object.link !== "object")
                throw TypeError(".SubStream.link: object expected");
            message.link = $root.StreamLink.fromObject(object.link);
        }
        return message;
    };

    /**
     * Creates a plain object from a SubStream message. Also converts values to other types if specified.
     * @function toObject
     * @memberof SubStream
     * @static
     * @param {SubStream} message SubStream
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    SubStream.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        var object = {};
        if (options.defaults)
            object.link = null;
        if (message.link != null && message.hasOwnProperty("link"))
            object.link = $root.StreamLink.toObject(message.link, options);
        return object;
    };

    /**
     * Converts this SubStream to JSON.
     * @function toJSON
     * @memberof SubStream
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    SubStream.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return SubStream;
})();

$root.Link = (function() {

    /**
     * Properties of a Link.
     * @exports ILink
     * @interface ILink
     * @property {string|null} [uri] Link uri
     * @property {IResolvedLink|null} [resolvedLink] Link resolvedLink
     * @property {number|null} [uriBackend] Link uriBackend
     */

    /**
     * Constructs a new Link.
     * @exports Link
     * @classdesc Represents a Link.
     * @implements ILink
     * @constructor
     * @param {ILink=} [properties] Properties to set
     */
    function Link(properties) {
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * Link uri.
     * @member {string} uri
     * @memberof Link
     * @instance
     */
    Link.prototype.uri = "";

    /**
     * Link resolvedLink.
     * @member {IResolvedLink|null|undefined} resolvedLink
     * @memberof Link
     * @instance
     */
    Link.prototype.resolvedLink = null;

    /**
     * Link uriBackend.
     * @member {number} uriBackend
     * @memberof Link
     * @instance
     */
    Link.prototype.uriBackend = 0;

    /**
     * Creates a new Link instance using the specified properties.
     * @function create
     * @memberof Link
     * @static
     * @param {ILink=} [properties] Properties to set
     * @returns {Link} Link instance
     */
    Link.create = function create(properties) {
        return new Link(properties);
    };

    /**
     * Encodes the specified Link message. Does not implicitly {@link Link.verify|verify} messages.
     * @function encode
     * @memberof Link
     * @static
     * @param {ILink} message Link message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    Link.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.uri != null && Object.hasOwnProperty.call(message, "uri"))
            writer.uint32(/* id 1, wireType 2 =*/10).string(message.uri);
        if (message.resolvedLink != null && Object.hasOwnProperty.call(message, "resolvedLink"))
            $root.ResolvedLink.encode(message.resolvedLink, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
        if (message.uriBackend != null && Object.hasOwnProperty.call(message, "uriBackend"))
            writer.uint32(/* id 3, wireType 0 =*/24).int32(message.uriBackend);
        return writer;
    };

    /**
     * Encodes the specified Link message, length delimited. Does not implicitly {@link Link.verify|verify} messages.
     * @function encodeDelimited
     * @memberof Link
     * @static
     * @param {ILink} message Link message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    Link.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a Link message from the specified reader or buffer.
     * @function decode
     * @memberof Link
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {Link} Link
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    Link.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Link();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.uri = reader.string();
                break;
            case 2:
                message.resolvedLink = $root.ResolvedLink.decode(reader, reader.uint32());
                break;
            case 3:
                message.uriBackend = reader.int32();
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a Link message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof Link
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {Link} Link
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    Link.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a Link message.
     * @function verify
     * @memberof Link
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    Link.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.uri != null && message.hasOwnProperty("uri"))
            if (!$util.isString(message.uri))
                return "uri: string expected";
        if (message.resolvedLink != null && message.hasOwnProperty("resolvedLink")) {
            var error = $root.ResolvedLink.verify(message.resolvedLink);
            if (error)
                return "resolvedLink." + error;
        }
        if (message.uriBackend != null && message.hasOwnProperty("uriBackend"))
            if (!$util.isInteger(message.uriBackend))
                return "uriBackend: integer expected";
        return null;
    };

    /**
     * Creates a Link message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof Link
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {Link} Link
     */
    Link.fromObject = function fromObject(object) {
        if (object instanceof $root.Link)
            return object;
        var message = new $root.Link();
        if (object.uri != null)
            message.uri = String(object.uri);
        if (object.resolvedLink != null) {
            if (typeof object.resolvedLink !== "object")
                throw TypeError(".Link.resolvedLink: object expected");
            message.resolvedLink = $root.ResolvedLink.fromObject(object.resolvedLink);
        }
        if (object.uriBackend != null)
            message.uriBackend = object.uriBackend | 0;
        return message;
    };

    /**
     * Creates a plain object from a Link message. Also converts values to other types if specified.
     * @function toObject
     * @memberof Link
     * @static
     * @param {Link} message Link
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    Link.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        var object = {};
        if (options.defaults) {
            object.uri = "";
            object.resolvedLink = null;
            object.uriBackend = 0;
        }
        if (message.uri != null && message.hasOwnProperty("uri"))
            object.uri = message.uri;
        if (message.resolvedLink != null && message.hasOwnProperty("resolvedLink"))
            object.resolvedLink = $root.ResolvedLink.toObject(message.resolvedLink, options);
        if (message.uriBackend != null && message.hasOwnProperty("uriBackend"))
            object.uriBackend = message.uriBackend;
        return object;
    };

    /**
     * Converts this Link to JSON.
     * @function toJSON
     * @memberof Link
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    Link.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return Link;
})();

$root.StreamLink = (function() {

    /**
     * Properties of a StreamLink.
     * @exports IStreamLink
     * @interface IStreamLink
     * @property {string|null} [url] StreamLink url
     * @property {string|null} [streamUrl] StreamLink streamUrl
     * @property {string|null} [searchUrl] StreamLink searchUrl
     * @property {string|null} [subCategoryUrl] StreamLink subCategoryUrl
     * @property {string|null} [searchQuery] StreamLink searchQuery
     */

    /**
     * Constructs a new StreamLink.
     * @exports StreamLink
     * @classdesc Represents a StreamLink.
     * @implements IStreamLink
     * @constructor
     * @param {IStreamLink=} [properties] Properties to set
     */
    function StreamLink(properties) {
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * StreamLink url.
     * @member {string} url
     * @memberof StreamLink
     * @instance
     */
    StreamLink.prototype.url = "";

    /**
     * StreamLink streamUrl.
     * @member {string} streamUrl
     * @memberof StreamLink
     * @instance
     */
    StreamLink.prototype.streamUrl = "";

    /**
     * StreamLink searchUrl.
     * @member {string} searchUrl
     * @memberof StreamLink
     * @instance
     */
    StreamLink.prototype.searchUrl = "";

    /**
     * StreamLink subCategoryUrl.
     * @member {string} subCategoryUrl
     * @memberof StreamLink
     * @instance
     */
    StreamLink.prototype.subCategoryUrl = "";

    /**
     * StreamLink searchQuery.
     * @member {string} searchQuery
     * @memberof StreamLink
     * @instance
     */
    StreamLink.prototype.searchQuery = "";

    /**
     * Creates a new StreamLink instance using the specified properties.
     * @function create
     * @memberof StreamLink
     * @static
     * @param {IStreamLink=} [properties] Properties to set
     * @returns {StreamLink} StreamLink instance
     */
    StreamLink.create = function create(properties) {
        return new StreamLink(properties);
    };

    /**
     * Encodes the specified StreamLink message. Does not implicitly {@link StreamLink.verify|verify} messages.
     * @function encode
     * @memberof StreamLink
     * @static
     * @param {IStreamLink} message StreamLink message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    StreamLink.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.url != null && Object.hasOwnProperty.call(message, "url"))
            writer.uint32(/* id 1, wireType 2 =*/10).string(message.url);
        if (message.streamUrl != null && Object.hasOwnProperty.call(message, "streamUrl"))
            writer.uint32(/* id 2, wireType 2 =*/18).string(message.streamUrl);
        if (message.searchUrl != null && Object.hasOwnProperty.call(message, "searchUrl"))
            writer.uint32(/* id 3, wireType 2 =*/26).string(message.searchUrl);
        if (message.subCategoryUrl != null && Object.hasOwnProperty.call(message, "subCategoryUrl"))
            writer.uint32(/* id 5, wireType 2 =*/42).string(message.subCategoryUrl);
        if (message.searchQuery != null && Object.hasOwnProperty.call(message, "searchQuery"))
            writer.uint32(/* id 11, wireType 2 =*/90).string(message.searchQuery);
        return writer;
    };

    /**
     * Encodes the specified StreamLink message, length delimited. Does not implicitly {@link StreamLink.verify|verify} messages.
     * @function encodeDelimited
     * @memberof StreamLink
     * @static
     * @param {IStreamLink} message StreamLink message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    StreamLink.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a StreamLink message from the specified reader or buffer.
     * @function decode
     * @memberof StreamLink
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {StreamLink} StreamLink
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    StreamLink.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.StreamLink();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.url = reader.string();
                break;
            case 2:
                message.streamUrl = reader.string();
                break;
            case 3:
                message.searchUrl = reader.string();
                break;
            case 5:
                message.subCategoryUrl = reader.string();
                break;
            case 11:
                message.searchQuery = reader.string();
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a StreamLink message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof StreamLink
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {StreamLink} StreamLink
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    StreamLink.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a StreamLink message.
     * @function verify
     * @memberof StreamLink
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    StreamLink.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.url != null && message.hasOwnProperty("url"))
            if (!$util.isString(message.url))
                return "url: string expected";
        if (message.streamUrl != null && message.hasOwnProperty("streamUrl"))
            if (!$util.isString(message.streamUrl))
                return "streamUrl: string expected";
        if (message.searchUrl != null && message.hasOwnProperty("searchUrl"))
            if (!$util.isString(message.searchUrl))
                return "searchUrl: string expected";
        if (message.subCategoryUrl != null && message.hasOwnProperty("subCategoryUrl"))
            if (!$util.isString(message.subCategoryUrl))
                return "subCategoryUrl: string expected";
        if (message.searchQuery != null && message.hasOwnProperty("searchQuery"))
            if (!$util.isString(message.searchQuery))
                return "searchQuery: string expected";
        return null;
    };

    /**
     * Creates a StreamLink message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof StreamLink
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {StreamLink} StreamLink
     */
    StreamLink.fromObject = function fromObject(object) {
        if (object instanceof $root.StreamLink)
            return object;
        var message = new $root.StreamLink();
        if (object.url != null)
            message.url = String(object.url);
        if (object.streamUrl != null)
            message.streamUrl = String(object.streamUrl);
        if (object.searchUrl != null)
            message.searchUrl = String(object.searchUrl);
        if (object.subCategoryUrl != null)
            message.subCategoryUrl = String(object.subCategoryUrl);
        if (object.searchQuery != null)
            message.searchQuery = String(object.searchQuery);
        return message;
    };

    /**
     * Creates a plain object from a StreamLink message. Also converts values to other types if specified.
     * @function toObject
     * @memberof StreamLink
     * @static
     * @param {StreamLink} message StreamLink
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    StreamLink.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        var object = {};
        if (options.defaults) {
            object.url = "";
            object.streamUrl = "";
            object.searchUrl = "";
            object.subCategoryUrl = "";
            object.searchQuery = "";
        }
        if (message.url != null && message.hasOwnProperty("url"))
            object.url = message.url;
        if (message.streamUrl != null && message.hasOwnProperty("streamUrl"))
            object.streamUrl = message.streamUrl;
        if (message.searchUrl != null && message.hasOwnProperty("searchUrl"))
            object.searchUrl = message.searchUrl;
        if (message.subCategoryUrl != null && message.hasOwnProperty("subCategoryUrl"))
            object.subCategoryUrl = message.subCategoryUrl;
        if (message.searchQuery != null && message.hasOwnProperty("searchQuery"))
            object.searchQuery = message.searchQuery;
        return object;
    };

    /**
     * Converts this StreamLink to JSON.
     * @function toJSON
     * @memberof StreamLink
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    StreamLink.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return StreamLink;
})();

$root.Chip = (function() {

    /**
     * Properties of a Chip.
     * @exports IChip
     * @interface IChip
     * @property {string|null} [title] Chip title
     * @property {ISubStream|null} [stream] Chip stream
     */

    /**
     * Constructs a new Chip.
     * @exports Chip
     * @classdesc Represents a Chip.
     * @implements IChip
     * @constructor
     * @param {IChip=} [properties] Properties to set
     */
    function Chip(properties) {
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * Chip title.
     * @member {string} title
     * @memberof Chip
     * @instance
     */
    Chip.prototype.title = "";

    /**
     * Chip stream.
     * @member {ISubStream|null|undefined} stream
     * @memberof Chip
     * @instance
     */
    Chip.prototype.stream = null;

    /**
     * Creates a new Chip instance using the specified properties.
     * @function create
     * @memberof Chip
     * @static
     * @param {IChip=} [properties] Properties to set
     * @returns {Chip} Chip instance
     */
    Chip.create = function create(properties) {
        return new Chip(properties);
    };

    /**
     * Encodes the specified Chip message. Does not implicitly {@link Chip.verify|verify} messages.
     * @function encode
     * @memberof Chip
     * @static
     * @param {IChip} message Chip message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    Chip.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.title != null && Object.hasOwnProperty.call(message, "title"))
            writer.uint32(/* id 1, wireType 2 =*/10).string(message.title);
        if (message.stream != null && Object.hasOwnProperty.call(message, "stream"))
            $root.SubStream.encode(message.stream, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
        return writer;
    };

    /**
     * Encodes the specified Chip message, length delimited. Does not implicitly {@link Chip.verify|verify} messages.
     * @function encodeDelimited
     * @memberof Chip
     * @static
     * @param {IChip} message Chip message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    Chip.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a Chip message from the specified reader or buffer.
     * @function decode
     * @memberof Chip
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {Chip} Chip
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    Chip.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Chip();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.title = reader.string();
                break;
            case 2:
                message.stream = $root.SubStream.decode(reader, reader.uint32());
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a Chip message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof Chip
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {Chip} Chip
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    Chip.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a Chip message.
     * @function verify
     * @memberof Chip
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    Chip.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.title != null && message.hasOwnProperty("title"))
            if (!$util.isString(message.title))
                return "title: string expected";
        if (message.stream != null && message.hasOwnProperty("stream")) {
            var error = $root.SubStream.verify(message.stream);
            if (error)
                return "stream." + error;
        }
        return null;
    };

    /**
     * Creates a Chip message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof Chip
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {Chip} Chip
     */
    Chip.fromObject = function fromObject(object) {
        if (object instanceof $root.Chip)
            return object;
        var message = new $root.Chip();
        if (object.title != null)
            message.title = String(object.title);
        if (object.stream != null) {
            if (typeof object.stream !== "object")
                throw TypeError(".Chip.stream: object expected");
            message.stream = $root.SubStream.fromObject(object.stream);
        }
        return message;
    };

    /**
     * Creates a plain object from a Chip message. Also converts values to other types if specified.
     * @function toObject
     * @memberof Chip
     * @static
     * @param {Chip} message Chip
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    Chip.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        var object = {};
        if (options.defaults) {
            object.title = "";
            object.stream = null;
        }
        if (message.title != null && message.hasOwnProperty("title"))
            object.title = message.title;
        if (message.stream != null && message.hasOwnProperty("stream"))
            object.stream = $root.SubStream.toObject(message.stream, options);
        return object;
    };

    /**
     * Converts this Chip to JSON.
     * @function toJSON
     * @memberof Chip
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    Chip.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return Chip;
})();

$root.CategoryInfo = (function() {

    /**
     * Properties of a CategoryInfo.
     * @exports ICategoryInfo
     * @interface ICategoryInfo
     * @property {string|null} [category] CategoryInfo category
     * @property {string|null} [appCategory] CategoryInfo appCategory
     */

    /**
     * Constructs a new CategoryInfo.
     * @exports CategoryInfo
     * @classdesc Represents a CategoryInfo.
     * @implements ICategoryInfo
     * @constructor
     * @param {ICategoryInfo=} [properties] Properties to set
     */
    function CategoryInfo(properties) {
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * CategoryInfo category.
     * @member {string} category
     * @memberof CategoryInfo
     * @instance
     */
    CategoryInfo.prototype.category = "";

    /**
     * CategoryInfo appCategory.
     * @member {string} appCategory
     * @memberof CategoryInfo
     * @instance
     */
    CategoryInfo.prototype.appCategory = "";

    /**
     * Creates a new CategoryInfo instance using the specified properties.
     * @function create
     * @memberof CategoryInfo
     * @static
     * @param {ICategoryInfo=} [properties] Properties to set
     * @returns {CategoryInfo} CategoryInfo instance
     */
    CategoryInfo.create = function create(properties) {
        return new CategoryInfo(properties);
    };

    /**
     * Encodes the specified CategoryInfo message. Does not implicitly {@link CategoryInfo.verify|verify} messages.
     * @function encode
     * @memberof CategoryInfo
     * @static
     * @param {ICategoryInfo} message CategoryInfo message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    CategoryInfo.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.category != null && Object.hasOwnProperty.call(message, "category"))
            writer.uint32(/* id 1, wireType 2 =*/10).string(message.category);
        if (message.appCategory != null && Object.hasOwnProperty.call(message, "appCategory"))
            writer.uint32(/* id 2, wireType 2 =*/18).string(message.appCategory);
        return writer;
    };

    /**
     * Encodes the specified CategoryInfo message, length delimited. Does not implicitly {@link CategoryInfo.verify|verify} messages.
     * @function encodeDelimited
     * @memberof CategoryInfo
     * @static
     * @param {ICategoryInfo} message CategoryInfo message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    CategoryInfo.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a CategoryInfo message from the specified reader or buffer.
     * @function decode
     * @memberof CategoryInfo
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CategoryInfo} CategoryInfo
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CategoryInfo.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CategoryInfo();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.category = reader.string();
                break;
            case 2:
                message.appCategory = reader.string();
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a CategoryInfo message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof CategoryInfo
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {CategoryInfo} CategoryInfo
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CategoryInfo.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a CategoryInfo message.
     * @function verify
     * @memberof CategoryInfo
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    CategoryInfo.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.category != null && message.hasOwnProperty("category"))
            if (!$util.isString(message.category))
                return "category: string expected";
        if (message.appCategory != null && message.hasOwnProperty("appCategory"))
            if (!$util.isString(message.appCategory))
                return "appCategory: string expected";
        return null;
    };

    /**
     * Creates a CategoryInfo message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof CategoryInfo
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {CategoryInfo} CategoryInfo
     */
    CategoryInfo.fromObject = function fromObject(object) {
        if (object instanceof $root.CategoryInfo)
            return object;
        var message = new $root.CategoryInfo();
        if (object.category != null)
            message.category = String(object.category);
        if (object.appCategory != null)
            message.appCategory = String(object.appCategory);
        return message;
    };

    /**
     * Creates a plain object from a CategoryInfo message. Also converts values to other types if specified.
     * @function toObject
     * @memberof CategoryInfo
     * @static
     * @param {CategoryInfo} message CategoryInfo
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    CategoryInfo.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        var object = {};
        if (options.defaults) {
            object.category = "";
            object.appCategory = "";
        }
        if (message.category != null && message.hasOwnProperty("category"))
            object.category = message.category;
        if (message.appCategory != null && message.hasOwnProperty("appCategory"))
            object.appCategory = message.appCategory;
        return object;
    };

    /**
     * Converts this CategoryInfo to JSON.
     * @function toJSON
     * @memberof CategoryInfo
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    CategoryInfo.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return CategoryInfo;
})();

$root.EncryptedSubscriberInfo = (function() {

    /**
     * Properties of an EncryptedSubscriberInfo.
     * @exports IEncryptedSubscriberInfo
     * @interface IEncryptedSubscriberInfo
     * @property {string|null} [data] EncryptedSubscriberInfo data
     * @property {string|null} [encryptedKey] EncryptedSubscriberInfo encryptedKey
     * @property {string|null} [signature] EncryptedSubscriberInfo signature
     * @property {string|null} [initVector] EncryptedSubscriberInfo initVector
     * @property {number|null} [googleKeyVersion] EncryptedSubscriberInfo googleKeyVersion
     * @property {number|null} [carrierKeyVersion] EncryptedSubscriberInfo carrierKeyVersion
     */

    /**
     * Constructs a new EncryptedSubscriberInfo.
     * @exports EncryptedSubscriberInfo
     * @classdesc Represents an EncryptedSubscriberInfo.
     * @implements IEncryptedSubscriberInfo
     * @constructor
     * @param {IEncryptedSubscriberInfo=} [properties] Properties to set
     */
    function EncryptedSubscriberInfo(properties) {
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * EncryptedSubscriberInfo data.
     * @member {string} data
     * @memberof EncryptedSubscriberInfo
     * @instance
     */
    EncryptedSubscriberInfo.prototype.data = "";

    /**
     * EncryptedSubscriberInfo encryptedKey.
     * @member {string} encryptedKey
     * @memberof EncryptedSubscriberInfo
     * @instance
     */
    EncryptedSubscriberInfo.prototype.encryptedKey = "";

    /**
     * EncryptedSubscriberInfo signature.
     * @member {string} signature
     * @memberof EncryptedSubscriberInfo
     * @instance
     */
    EncryptedSubscriberInfo.prototype.signature = "";

    /**
     * EncryptedSubscriberInfo initVector.
     * @member {string} initVector
     * @memberof EncryptedSubscriberInfo
     * @instance
     */
    EncryptedSubscriberInfo.prototype.initVector = "";

    /**
     * EncryptedSubscriberInfo googleKeyVersion.
     * @member {number} googleKeyVersion
     * @memberof EncryptedSubscriberInfo
     * @instance
     */
    EncryptedSubscriberInfo.prototype.googleKeyVersion = 0;

    /**
     * EncryptedSubscriberInfo carrierKeyVersion.
     * @member {number} carrierKeyVersion
     * @memberof EncryptedSubscriberInfo
     * @instance
     */
    EncryptedSubscriberInfo.prototype.carrierKeyVersion = 0;

    /**
     * Creates a new EncryptedSubscriberInfo instance using the specified properties.
     * @function create
     * @memberof EncryptedSubscriberInfo
     * @static
     * @param {IEncryptedSubscriberInfo=} [properties] Properties to set
     * @returns {EncryptedSubscriberInfo} EncryptedSubscriberInfo instance
     */
    EncryptedSubscriberInfo.create = function create(properties) {
        return new EncryptedSubscriberInfo(properties);
    };

    /**
     * Encodes the specified EncryptedSubscriberInfo message. Does not implicitly {@link EncryptedSubscriberInfo.verify|verify} messages.
     * @function encode
     * @memberof EncryptedSubscriberInfo
     * @static
     * @param {IEncryptedSubscriberInfo} message EncryptedSubscriberInfo message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    EncryptedSubscriberInfo.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.data != null && Object.hasOwnProperty.call(message, "data"))
            writer.uint32(/* id 1, wireType 2 =*/10).string(message.data);
        if (message.encryptedKey != null && Object.hasOwnProperty.call(message, "encryptedKey"))
            writer.uint32(/* id 2, wireType 2 =*/18).string(message.encryptedKey);
        if (message.signature != null && Object.hasOwnProperty.call(message, "signature"))
            writer.uint32(/* id 3, wireType 2 =*/26).string(message.signature);
        if (message.initVector != null && Object.hasOwnProperty.call(message, "initVector"))
            writer.uint32(/* id 4, wireType 2 =*/34).string(message.initVector);
        if (message.googleKeyVersion != null && Object.hasOwnProperty.call(message, "googleKeyVersion"))
            writer.uint32(/* id 5, wireType 0 =*/40).int32(message.googleKeyVersion);
        if (message.carrierKeyVersion != null && Object.hasOwnProperty.call(message, "carrierKeyVersion"))
            writer.uint32(/* id 6, wireType 0 =*/48).int32(message.carrierKeyVersion);
        return writer;
    };

    /**
     * Encodes the specified EncryptedSubscriberInfo message, length delimited. Does not implicitly {@link EncryptedSubscriberInfo.verify|verify} messages.
     * @function encodeDelimited
     * @memberof EncryptedSubscriberInfo
     * @static
     * @param {IEncryptedSubscriberInfo} message EncryptedSubscriberInfo message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    EncryptedSubscriberInfo.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes an EncryptedSubscriberInfo message from the specified reader or buffer.
     * @function decode
     * @memberof EncryptedSubscriberInfo
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {EncryptedSubscriberInfo} EncryptedSubscriberInfo
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    EncryptedSubscriberInfo.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.EncryptedSubscriberInfo();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.data = reader.string();
                break;
            case 2:
                message.encryptedKey = reader.string();
                break;
            case 3:
                message.signature = reader.string();
                break;
            case 4:
                message.initVector = reader.string();
                break;
            case 5:
                message.googleKeyVersion = reader.int32();
                break;
            case 6:
                message.carrierKeyVersion = reader.int32();
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes an EncryptedSubscriberInfo message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof EncryptedSubscriberInfo
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {EncryptedSubscriberInfo} EncryptedSubscriberInfo
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    EncryptedSubscriberInfo.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies an EncryptedSubscriberInfo message.
     * @function verify
     * @memberof EncryptedSubscriberInfo
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    EncryptedSubscriberInfo.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.data != null && message.hasOwnProperty("data"))
            if (!$util.isString(message.data))
                return "data: string expected";
        if (message.encryptedKey != null && message.hasOwnProperty("encryptedKey"))
            if (!$util.isString(message.encryptedKey))
                return "encryptedKey: string expected";
        if (message.signature != null && message.hasOwnProperty("signature"))
            if (!$util.isString(message.signature))
                return "signature: string expected";
        if (message.initVector != null && message.hasOwnProperty("initVector"))
            if (!$util.isString(message.initVector))
                return "initVector: string expected";
        if (message.googleKeyVersion != null && message.hasOwnProperty("googleKeyVersion"))
            if (!$util.isInteger(message.googleKeyVersion))
                return "googleKeyVersion: integer expected";
        if (message.carrierKeyVersion != null && message.hasOwnProperty("carrierKeyVersion"))
            if (!$util.isInteger(message.carrierKeyVersion))
                return "carrierKeyVersion: integer expected";
        return null;
    };

    /**
     * Creates an EncryptedSubscriberInfo message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof EncryptedSubscriberInfo
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {EncryptedSubscriberInfo} EncryptedSubscriberInfo
     */
    EncryptedSubscriberInfo.fromObject = function fromObject(object) {
        if (object instanceof $root.EncryptedSubscriberInfo)
            return object;
        var message = new $root.EncryptedSubscriberInfo();
        if (object.data != null)
            message.data = String(object.data);
        if (object.encryptedKey != null)
            message.encryptedKey = String(object.encryptedKey);
        if (object.signature != null)
            message.signature = String(object.signature);
        if (object.initVector != null)
            message.initVector = String(object.initVector);
        if (object.googleKeyVersion != null)
            message.googleKeyVersion = object.googleKeyVersion | 0;
        if (object.carrierKeyVersion != null)
            message.carrierKeyVersion = object.carrierKeyVersion | 0;
        return message;
    };

    /**
     * Creates a plain object from an EncryptedSubscriberInfo message. Also converts values to other types if specified.
     * @function toObject
     * @memberof EncryptedSubscriberInfo
     * @static
     * @param {EncryptedSubscriberInfo} message EncryptedSubscriberInfo
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    EncryptedSubscriberInfo.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        var object = {};
        if (options.defaults) {
            object.data = "";
            object.encryptedKey = "";
            object.signature = "";
            object.initVector = "";
            object.googleKeyVersion = 0;
            object.carrierKeyVersion = 0;
        }
        if (message.data != null && message.hasOwnProperty("data"))
            object.data = message.data;
        if (message.encryptedKey != null && message.hasOwnProperty("encryptedKey"))
            object.encryptedKey = message.encryptedKey;
        if (message.signature != null && message.hasOwnProperty("signature"))
            object.signature = message.signature;
        if (message.initVector != null && message.hasOwnProperty("initVector"))
            object.initVector = message.initVector;
        if (message.googleKeyVersion != null && message.hasOwnProperty("googleKeyVersion"))
            object.googleKeyVersion = message.googleKeyVersion;
        if (message.carrierKeyVersion != null && message.hasOwnProperty("carrierKeyVersion"))
            object.carrierKeyVersion = message.carrierKeyVersion;
        return object;
    };

    /**
     * Converts this EncryptedSubscriberInfo to JSON.
     * @function toJSON
     * @memberof EncryptedSubscriberInfo
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    EncryptedSubscriberInfo.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return EncryptedSubscriberInfo;
})();

$root.Availability = (function() {

    /**
     * Properties of an Availability.
     * @exports IAvailability
     * @interface IAvailability
     * @property {number|null} [restriction] Availability restriction
     * @property {number|null} [offerType] Availability offerType
     * @property {IRule|null} [rule] Availability rule
     * @property {Array.<Availability.IPerDeviceAvailabilityRestriction>|null} [perDeviceAvailabilityRestriction] Availability perDeviceAvailabilityRestriction
     * @property {boolean|null} [availableIfOwned] Availability availableIfOwned
     * @property {Array.<IInstall>|null} [install] Availability install
     * @property {IFilterEvaluationInfo|null} [filterInfo] Availability filterInfo
     * @property {IOwnershipInfo|null} [ownershipInfo] Availability ownershipInfo
     * @property {Array.<IAvailabilityProblem>|null} [availabilityProblem] Availability availabilityProblem
     * @property {boolean|null} [hidden] Availability hidden
     */

    /**
     * Constructs a new Availability.
     * @exports Availability
     * @classdesc Represents an Availability.
     * @implements IAvailability
     * @constructor
     * @param {IAvailability=} [properties] Properties to set
     */
    function Availability(properties) {
        this.perDeviceAvailabilityRestriction = [];
        this.install = [];
        this.availabilityProblem = [];
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * Availability restriction.
     * @member {number} restriction
     * @memberof Availability
     * @instance
     */
    Availability.prototype.restriction = 0;

    /**
     * Availability offerType.
     * @member {number} offerType
     * @memberof Availability
     * @instance
     */
    Availability.prototype.offerType = 0;

    /**
     * Availability rule.
     * @member {IRule|null|undefined} rule
     * @memberof Availability
     * @instance
     */
    Availability.prototype.rule = null;

    /**
     * Availability perDeviceAvailabilityRestriction.
     * @member {Array.<Availability.IPerDeviceAvailabilityRestriction>} perDeviceAvailabilityRestriction
     * @memberof Availability
     * @instance
     */
    Availability.prototype.perDeviceAvailabilityRestriction = $util.emptyArray;

    /**
     * Availability availableIfOwned.
     * @member {boolean} availableIfOwned
     * @memberof Availability
     * @instance
     */
    Availability.prototype.availableIfOwned = false;

    /**
     * Availability install.
     * @member {Array.<IInstall>} install
     * @memberof Availability
     * @instance
     */
    Availability.prototype.install = $util.emptyArray;

    /**
     * Availability filterInfo.
     * @member {IFilterEvaluationInfo|null|undefined} filterInfo
     * @memberof Availability
     * @instance
     */
    Availability.prototype.filterInfo = null;

    /**
     * Availability ownershipInfo.
     * @member {IOwnershipInfo|null|undefined} ownershipInfo
     * @memberof Availability
     * @instance
     */
    Availability.prototype.ownershipInfo = null;

    /**
     * Availability availabilityProblem.
     * @member {Array.<IAvailabilityProblem>} availabilityProblem
     * @memberof Availability
     * @instance
     */
    Availability.prototype.availabilityProblem = $util.emptyArray;

    /**
     * Availability hidden.
     * @member {boolean} hidden
     * @memberof Availability
     * @instance
     */
    Availability.prototype.hidden = false;

    /**
     * Creates a new Availability instance using the specified properties.
     * @function create
     * @memberof Availability
     * @static
     * @param {IAvailability=} [properties] Properties to set
     * @returns {Availability} Availability instance
     */
    Availability.create = function create(properties) {
        return new Availability(properties);
    };

    /**
     * Encodes the specified Availability message. Does not implicitly {@link Availability.verify|verify} messages.
     * @function encode
     * @memberof Availability
     * @static
     * @param {IAvailability} message Availability message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    Availability.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.restriction != null && Object.hasOwnProperty.call(message, "restriction"))
            writer.uint32(/* id 5, wireType 0 =*/40).int32(message.restriction);
        if (message.offerType != null && Object.hasOwnProperty.call(message, "offerType"))
            writer.uint32(/* id 6, wireType 0 =*/48).int32(message.offerType);
        if (message.rule != null && Object.hasOwnProperty.call(message, "rule"))
            $root.Rule.encode(message.rule, writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
        if (message.perDeviceAvailabilityRestriction != null && message.perDeviceAvailabilityRestriction.length)
            for (var i = 0; i < message.perDeviceAvailabilityRestriction.length; ++i)
                $root.Availability.PerDeviceAvailabilityRestriction.encode(message.perDeviceAvailabilityRestriction[i], writer.uint32(/* id 9, wireType 3 =*/75)).uint32(/* id 9, wireType 4 =*/76);
        if (message.availableIfOwned != null && Object.hasOwnProperty.call(message, "availableIfOwned"))
            writer.uint32(/* id 13, wireType 0 =*/104).bool(message.availableIfOwned);
        if (message.install != null && message.install.length)
            for (var i = 0; i < message.install.length; ++i)
                $root.Install.encode(message.install[i], writer.uint32(/* id 14, wireType 2 =*/114).fork()).ldelim();
        if (message.filterInfo != null && Object.hasOwnProperty.call(message, "filterInfo"))
            $root.FilterEvaluationInfo.encode(message.filterInfo, writer.uint32(/* id 16, wireType 2 =*/130).fork()).ldelim();
        if (message.ownershipInfo != null && Object.hasOwnProperty.call(message, "ownershipInfo"))
            $root.OwnershipInfo.encode(message.ownershipInfo, writer.uint32(/* id 17, wireType 2 =*/138).fork()).ldelim();
        if (message.availabilityProblem != null && message.availabilityProblem.length)
            for (var i = 0; i < message.availabilityProblem.length; ++i)
                $root.AvailabilityProblem.encode(message.availabilityProblem[i], writer.uint32(/* id 18, wireType 2 =*/146).fork()).ldelim();
        if (message.hidden != null && Object.hasOwnProperty.call(message, "hidden"))
            writer.uint32(/* id 21, wireType 0 =*/168).bool(message.hidden);
        return writer;
    };

    /**
     * Encodes the specified Availability message, length delimited. Does not implicitly {@link Availability.verify|verify} messages.
     * @function encodeDelimited
     * @memberof Availability
     * @static
     * @param {IAvailability} message Availability message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    Availability.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes an Availability message from the specified reader or buffer.
     * @function decode
     * @memberof Availability
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {Availability} Availability
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    Availability.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Availability();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            case 5:
                message.restriction = reader.int32();
                break;
            case 6:
                message.offerType = reader.int32();
                break;
            case 7:
                message.rule = $root.Rule.decode(reader, reader.uint32());
                break;
            case 9:
                if (!(message.perDeviceAvailabilityRestriction && message.perDeviceAvailabilityRestriction.length))
                    message.perDeviceAvailabilityRestriction = [];
                message.perDeviceAvailabilityRestriction.push($root.Availability.PerDeviceAvailabilityRestriction.decode(reader));
                break;
            case 13:
                message.availableIfOwned = reader.bool();
                break;
            case 14:
                if (!(message.install && message.install.length))
                    message.install = [];
                message.install.push($root.Install.decode(reader, reader.uint32()));
                break;
            case 16:
                message.filterInfo = $root.FilterEvaluationInfo.decode(reader, reader.uint32());
                break;
            case 17:
                message.ownershipInfo = $root.OwnershipInfo.decode(reader, reader.uint32());
                break;
            case 18:
                if (!(message.availabilityProblem && message.availabilityProblem.length))
                    message.availabilityProblem = [];
                message.availabilityProblem.push($root.AvailabilityProblem.decode(reader, reader.uint32()));
                break;
            case 21:
                message.hidden = reader.bool();
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes an Availability message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof Availability
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {Availability} Availability
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    Availability.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies an Availability message.
     * @function verify
     * @memberof Availability
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    Availability.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.restriction != null && message.hasOwnProperty("restriction"))
            if (!$util.isInteger(message.restriction))
                return "restriction: integer expected";
        if (message.offerType != null && message.hasOwnProperty("offerType"))
            if (!$util.isInteger(message.offerType))
                return "offerType: integer expected";
        if (message.rule != null && message.hasOwnProperty("rule")) {
            var error = $root.Rule.verify(message.rule);
            if (error)
                return "rule." + error;
        }
        if (message.perDeviceAvailabilityRestriction != null && message.hasOwnProperty("perDeviceAvailabilityRestriction")) {
            if (!Array.isArray(message.perDeviceAvailabilityRestriction))
                return "perDeviceAvailabilityRestriction: array expected";
            for (var i = 0; i < message.perDeviceAvailabilityRestriction.length; ++i) {
                var error = $root.Availability.PerDeviceAvailabilityRestriction.verify(message.perDeviceAvailabilityRestriction[i]);
                if (error)
                    return "perDeviceAvailabilityRestriction." + error;
            }
        }
        if (message.availableIfOwned != null && message.hasOwnProperty("availableIfOwned"))
            if (typeof message.availableIfOwned !== "boolean")
                return "availableIfOwned: boolean expected";
        if (message.install != null && message.hasOwnProperty("install")) {
            if (!Array.isArray(message.install))
                return "install: array expected";
            for (var i = 0; i < message.install.length; ++i) {
                var error = $root.Install.verify(message.install[i]);
                if (error)
                    return "install." + error;
            }
        }
        if (message.filterInfo != null && message.hasOwnProperty("filterInfo")) {
            var error = $root.FilterEvaluationInfo.verify(message.filterInfo);
            if (error)
                return "filterInfo." + error;
        }
        if (message.ownershipInfo != null && message.hasOwnProperty("ownershipInfo")) {
            var error = $root.OwnershipInfo.verify(message.ownershipInfo);
            if (error)
                return "ownershipInfo." + error;
        }
        if (message.availabilityProblem != null && message.hasOwnProperty("availabilityProblem")) {
            if (!Array.isArray(message.availabilityProblem))
                return "availabilityProblem: array expected";
            for (var i = 0; i < message.availabilityProblem.length; ++i) {
                var error = $root.AvailabilityProblem.verify(message.availabilityProblem[i]);
                if (error)
                    return "availabilityProblem." + error;
            }
        }
        if (message.hidden != null && message.hasOwnProperty("hidden"))
            if (typeof message.hidden !== "boolean")
                return "hidden: boolean expected";
        return null;
    };

    /**
     * Creates an Availability message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof Availability
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {Availability} Availability
     */
    Availability.fromObject = function fromObject(object) {
        if (object instanceof $root.Availability)
            return object;
        var message = new $root.Availability();
        if (object.restriction != null)
            message.restriction = object.restriction | 0;
        if (object.offerType != null)
            message.offerType = object.offerType | 0;
        if (object.rule != null) {
            if (typeof object.rule !== "object")
                throw TypeError(".Availability.rule: object expected");
            message.rule = $root.Rule.fromObject(object.rule);
        }
        if (object.perDeviceAvailabilityRestriction) {
            if (!Array.isArray(object.perDeviceAvailabilityRestriction))
                throw TypeError(".Availability.perDeviceAvailabilityRestriction: array expected");
            message.perDeviceAvailabilityRestriction = [];
            for (var i = 0; i < object.perDeviceAvailabilityRestriction.length; ++i) {
                if (typeof object.perDeviceAvailabilityRestriction[i] !== "object")
                    throw TypeError(".Availability.perDeviceAvailabilityRestriction: object expected");
                message.perDeviceAvailabilityRestriction[i] = $root.Availability.PerDeviceAvailabilityRestriction.fromObject(object.perDeviceAvailabilityRestriction[i]);
            }
        }
        if (object.availableIfOwned != null)
            message.availableIfOwned = Boolean(object.availableIfOwned);
        if (object.install) {
            if (!Array.isArray(object.install))
                throw TypeError(".Availability.install: array expected");
            message.install = [];
            for (var i = 0; i < object.install.length; ++i) {
                if (typeof object.install[i] !== "object")
                    throw TypeError(".Availability.install: object expected");
                message.install[i] = $root.Install.fromObject(object.install[i]);
            }
        }
        if (object.filterInfo != null) {
            if (typeof object.filterInfo !== "object")
                throw TypeError(".Availability.filterInfo: object expected");
            message.filterInfo = $root.FilterEvaluationInfo.fromObject(object.filterInfo);
        }
        if (object.ownershipInfo != null) {
            if (typeof object.ownershipInfo !== "object")
                throw TypeError(".Availability.ownershipInfo: object expected");
            message.ownershipInfo = $root.OwnershipInfo.fromObject(object.ownershipInfo);
        }
        if (object.availabilityProblem) {
            if (!Array.isArray(object.availabilityProblem))
                throw TypeError(".Availability.availabilityProblem: array expected");
            message.availabilityProblem = [];
            for (var i = 0; i < object.availabilityProblem.length; ++i) {
                if (typeof object.availabilityProblem[i] !== "object")
                    throw TypeError(".Availability.availabilityProblem: object expected");
                message.availabilityProblem[i] = $root.AvailabilityProblem.fromObject(object.availabilityProblem[i]);
            }
        }
        if (object.hidden != null)
            message.hidden = Boolean(object.hidden);
        return message;
    };

    /**
     * Creates a plain object from an Availability message. Also converts values to other types if specified.
     * @function toObject
     * @memberof Availability
     * @static
     * @param {Availability} message Availability
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    Availability.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        var object = {};
        if (options.arrays || options.defaults) {
            object.perDeviceAvailabilityRestriction = [];
            object.install = [];
            object.availabilityProblem = [];
        }
        if (options.defaults) {
            object.restriction = 0;
            object.offerType = 0;
            object.rule = null;
            object.availableIfOwned = false;
            object.filterInfo = null;
            object.ownershipInfo = null;
            object.hidden = false;
        }
        if (message.restriction != null && message.hasOwnProperty("restriction"))
            object.restriction = message.restriction;
        if (message.offerType != null && message.hasOwnProperty("offerType"))
            object.offerType = message.offerType;
        if (message.rule != null && message.hasOwnProperty("rule"))
            object.rule = $root.Rule.toObject(message.rule, options);
        if (message.perDeviceAvailabilityRestriction && message.perDeviceAvailabilityRestriction.length) {
            object.perDeviceAvailabilityRestriction = [];
            for (var j = 0; j < message.perDeviceAvailabilityRestriction.length; ++j)
                object.perDeviceAvailabilityRestriction[j] = $root.Availability.PerDeviceAvailabilityRestriction.toObject(message.perDeviceAvailabilityRestriction[j], options);
        }
        if (message.availableIfOwned != null && message.hasOwnProperty("availableIfOwned"))
            object.availableIfOwned = message.availableIfOwned;
        if (message.install && message.install.length) {
            object.install = [];
            for (var j = 0; j < message.install.length; ++j)
                object.install[j] = $root.Install.toObject(message.install[j], options);
        }
        if (message.filterInfo != null && message.hasOwnProperty("filterInfo"))
            object.filterInfo = $root.FilterEvaluationInfo.toObject(message.filterInfo, options);
        if (message.ownershipInfo != null && message.hasOwnProperty("ownershipInfo"))
            object.ownershipInfo = $root.OwnershipInfo.toObject(message.ownershipInfo, options);
        if (message.availabilityProblem && message.availabilityProblem.length) {
            object.availabilityProblem = [];
            for (var j = 0; j < message.availabilityProblem.length; ++j)
                object.availabilityProblem[j] = $root.AvailabilityProblem.toObject(message.availabilityProblem[j], options);
        }
        if (message.hidden != null && message.hasOwnProperty("hidden"))
            object.hidden = message.hidden;
        return object;
    };

    /**
     * Converts this Availability to JSON.
     * @function toJSON
     * @memberof Availability
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    Availability.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    Availability.PerDeviceAvailabilityRestriction = (function() {

        /**
         * Properties of a PerDeviceAvailabilityRestriction.
         * @memberof Availability
         * @interface IPerDeviceAvailabilityRestriction
         * @property {number|Long|null} [androidId] PerDeviceAvailabilityRestriction androidId
         * @property {number|null} [deviceRestriction] PerDeviceAvailabilityRestriction deviceRestriction
         * @property {number|Long|null} [channelId] PerDeviceAvailabilityRestriction channelId
         * @property {IFilterEvaluationInfo|null} [filterInfo] PerDeviceAvailabilityRestriction filterInfo
         */

        /**
         * Constructs a new PerDeviceAvailabilityRestriction.
         * @memberof Availability
         * @classdesc Represents a PerDeviceAvailabilityRestriction.
         * @implements IPerDeviceAvailabilityRestriction
         * @constructor
         * @param {Availability.IPerDeviceAvailabilityRestriction=} [properties] Properties to set
         */
        function PerDeviceAvailabilityRestriction(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * PerDeviceAvailabilityRestriction androidId.
         * @member {number|Long} androidId
         * @memberof Availability.PerDeviceAvailabilityRestriction
         * @instance
         */
        PerDeviceAvailabilityRestriction.prototype.androidId = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * PerDeviceAvailabilityRestriction deviceRestriction.
         * @member {number} deviceRestriction
         * @memberof Availability.PerDeviceAvailabilityRestriction
         * @instance
         */
        PerDeviceAvailabilityRestriction.prototype.deviceRestriction = 0;

        /**
         * PerDeviceAvailabilityRestriction channelId.
         * @member {number|Long} channelId
         * @memberof Availability.PerDeviceAvailabilityRestriction
         * @instance
         */
        PerDeviceAvailabilityRestriction.prototype.channelId = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * PerDeviceAvailabilityRestriction filterInfo.
         * @member {IFilterEvaluationInfo|null|undefined} filterInfo
         * @memberof Availability.PerDeviceAvailabilityRestriction
         * @instance
         */
        PerDeviceAvailabilityRestriction.prototype.filterInfo = null;

        /**
         * Creates a new PerDeviceAvailabilityRestriction instance using the specified properties.
         * @function create
         * @memberof Availability.PerDeviceAvailabilityRestriction
         * @static
         * @param {Availability.IPerDeviceAvailabilityRestriction=} [properties] Properties to set
         * @returns {Availability.PerDeviceAvailabilityRestriction} PerDeviceAvailabilityRestriction instance
         */
        PerDeviceAvailabilityRestriction.create = function create(properties) {
            return new PerDeviceAvailabilityRestriction(properties);
        };

        /**
         * Encodes the specified PerDeviceAvailabilityRestriction message. Does not implicitly {@link Availability.PerDeviceAvailabilityRestriction.verify|verify} messages.
         * @function encode
         * @memberof Availability.PerDeviceAvailabilityRestriction
         * @static
         * @param {Availability.IPerDeviceAvailabilityRestriction} message PerDeviceAvailabilityRestriction message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PerDeviceAvailabilityRestriction.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.androidId != null && Object.hasOwnProperty.call(message, "androidId"))
                writer.uint32(/* id 10, wireType 1 =*/81).fixed64(message.androidId);
            if (message.deviceRestriction != null && Object.hasOwnProperty.call(message, "deviceRestriction"))
                writer.uint32(/* id 11, wireType 0 =*/88).int32(message.deviceRestriction);
            if (message.channelId != null && Object.hasOwnProperty.call(message, "channelId"))
                writer.uint32(/* id 12, wireType 0 =*/96).int64(message.channelId);
            if (message.filterInfo != null && Object.hasOwnProperty.call(message, "filterInfo"))
                $root.FilterEvaluationInfo.encode(message.filterInfo, writer.uint32(/* id 15, wireType 2 =*/122).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified PerDeviceAvailabilityRestriction message, length delimited. Does not implicitly {@link Availability.PerDeviceAvailabilityRestriction.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Availability.PerDeviceAvailabilityRestriction
         * @static
         * @param {Availability.IPerDeviceAvailabilityRestriction} message PerDeviceAvailabilityRestriction message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PerDeviceAvailabilityRestriction.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a PerDeviceAvailabilityRestriction message from the specified reader or buffer.
         * @function decode
         * @memberof Availability.PerDeviceAvailabilityRestriction
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Availability.PerDeviceAvailabilityRestriction} PerDeviceAvailabilityRestriction
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PerDeviceAvailabilityRestriction.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Availability.PerDeviceAvailabilityRestriction();
            while (reader.pos < end) {
                var tag = reader.uint32();
                if ((tag & 7) === 4)
                    break;
                switch (tag >>> 3) {
                case 10:
                    message.androidId = reader.fixed64();
                    break;
                case 11:
                    message.deviceRestriction = reader.int32();
                    break;
                case 12:
                    message.channelId = reader.int64();
                    break;
                case 15:
                    message.filterInfo = $root.FilterEvaluationInfo.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a PerDeviceAvailabilityRestriction message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Availability.PerDeviceAvailabilityRestriction
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Availability.PerDeviceAvailabilityRestriction} PerDeviceAvailabilityRestriction
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PerDeviceAvailabilityRestriction.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a PerDeviceAvailabilityRestriction message.
         * @function verify
         * @memberof Availability.PerDeviceAvailabilityRestriction
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PerDeviceAvailabilityRestriction.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.androidId != null && message.hasOwnProperty("androidId"))
                if (!$util.isInteger(message.androidId) && !(message.androidId && $util.isInteger(message.androidId.low) && $util.isInteger(message.androidId.high)))
                    return "androidId: integer|Long expected";
            if (message.deviceRestriction != null && message.hasOwnProperty("deviceRestriction"))
                if (!$util.isInteger(message.deviceRestriction))
                    return "deviceRestriction: integer expected";
            if (message.channelId != null && message.hasOwnProperty("channelId"))
                if (!$util.isInteger(message.channelId) && !(message.channelId && $util.isInteger(message.channelId.low) && $util.isInteger(message.channelId.high)))
                    return "channelId: integer|Long expected";
            if (message.filterInfo != null && message.hasOwnProperty("filterInfo")) {
                var error = $root.FilterEvaluationInfo.verify(message.filterInfo);
                if (error)
                    return "filterInfo." + error;
            }
            return null;
        };

        /**
         * Creates a PerDeviceAvailabilityRestriction message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Availability.PerDeviceAvailabilityRestriction
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Availability.PerDeviceAvailabilityRestriction} PerDeviceAvailabilityRestriction
         */
        PerDeviceAvailabilityRestriction.fromObject = function fromObject(object) {
            if (object instanceof $root.Availability.PerDeviceAvailabilityRestriction)
                return object;
            var message = new $root.Availability.PerDeviceAvailabilityRestriction();
            if (object.androidId != null)
                if ($util.Long)
                    (message.androidId = $util.Long.fromValue(object.androidId)).unsigned = false;
                else if (typeof object.androidId === "string")
                    message.androidId = parseInt(object.androidId, 10);
                else if (typeof object.androidId === "number")
                    message.androidId = object.androidId;
                else if (typeof object.androidId === "object")
                    message.androidId = new $util.LongBits(object.androidId.low >>> 0, object.androidId.high >>> 0).toNumber();
            if (object.deviceRestriction != null)
                message.deviceRestriction = object.deviceRestriction | 0;
            if (object.channelId != null)
                if ($util.Long)
                    (message.channelId = $util.Long.fromValue(object.channelId)).unsigned = false;
                else if (typeof object.channelId === "string")
                    message.channelId = parseInt(object.channelId, 10);
                else if (typeof object.channelId === "number")
                    message.channelId = object.channelId;
                else if (typeof object.channelId === "object")
                    message.channelId = new $util.LongBits(object.channelId.low >>> 0, object.channelId.high >>> 0).toNumber();
            if (object.filterInfo != null) {
                if (typeof object.filterInfo !== "object")
                    throw TypeError(".Availability.PerDeviceAvailabilityRestriction.filterInfo: object expected");
                message.filterInfo = $root.FilterEvaluationInfo.fromObject(object.filterInfo);
            }
            return message;
        };

        /**
         * Creates a plain object from a PerDeviceAvailabilityRestriction message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Availability.PerDeviceAvailabilityRestriction
         * @static
         * @param {Availability.PerDeviceAvailabilityRestriction} message PerDeviceAvailabilityRestriction
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PerDeviceAvailabilityRestriction.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.androidId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.androidId = options.longs === String ? "0" : 0;
                object.deviceRestriction = 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.channelId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.channelId = options.longs === String ? "0" : 0;
                object.filterInfo = null;
            }
            if (message.androidId != null && message.hasOwnProperty("androidId"))
                if (typeof message.androidId === "number")
                    object.androidId = options.longs === String ? String(message.androidId) : message.androidId;
                else
                    object.androidId = options.longs === String ? $util.Long.prototype.toString.call(message.androidId) : options.longs === Number ? new $util.LongBits(message.androidId.low >>> 0, message.androidId.high >>> 0).toNumber() : message.androidId;
            if (message.deviceRestriction != null && message.hasOwnProperty("deviceRestriction"))
                object.deviceRestriction = message.deviceRestriction;
            if (message.channelId != null && message.hasOwnProperty("channelId"))
                if (typeof message.channelId === "number")
                    object.channelId = options.longs === String ? String(message.channelId) : message.channelId;
                else
                    object.channelId = options.longs === String ? $util.Long.prototype.toString.call(message.channelId) : options.longs === Number ? new $util.LongBits(message.channelId.low >>> 0, message.channelId.high >>> 0).toNumber() : message.channelId;
            if (message.filterInfo != null && message.hasOwnProperty("filterInfo"))
                object.filterInfo = $root.FilterEvaluationInfo.toObject(message.filterInfo, options);
            return object;
        };

        /**
         * Converts this PerDeviceAvailabilityRestriction to JSON.
         * @function toJSON
         * @memberof Availability.PerDeviceAvailabilityRestriction
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PerDeviceAvailabilityRestriction.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return PerDeviceAvailabilityRestriction;
    })();

    return Availability;
})();

$root.AvailabilityProblem = (function() {

    /**
     * Properties of an AvailabilityProblem.
     * @exports IAvailabilityProblem
     * @interface IAvailabilityProblem
     * @property {number|null} [problemType] AvailabilityProblem problemType
     * @property {Array.<string>|null} [missingValue] AvailabilityProblem missingValue
     */

    /**
     * Constructs a new AvailabilityProblem.
     * @exports AvailabilityProblem
     * @classdesc Represents an AvailabilityProblem.
     * @implements IAvailabilityProblem
     * @constructor
     * @param {IAvailabilityProblem=} [properties] Properties to set
     */
    function AvailabilityProblem(properties) {
        this.missingValue = [];
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * AvailabilityProblem problemType.
     * @member {number} problemType
     * @memberof AvailabilityProblem
     * @instance
     */
    AvailabilityProblem.prototype.problemType = 0;

    /**
     * AvailabilityProblem missingValue.
     * @member {Array.<string>} missingValue
     * @memberof AvailabilityProblem
     * @instance
     */
    AvailabilityProblem.prototype.missingValue = $util.emptyArray;

    /**
     * Creates a new AvailabilityProblem instance using the specified properties.
     * @function create
     * @memberof AvailabilityProblem
     * @static
     * @param {IAvailabilityProblem=} [properties] Properties to set
     * @returns {AvailabilityProblem} AvailabilityProblem instance
     */
    AvailabilityProblem.create = function create(properties) {
        return new AvailabilityProblem(properties);
    };

    /**
     * Encodes the specified AvailabilityProblem message. Does not implicitly {@link AvailabilityProblem.verify|verify} messages.
     * @function encode
     * @memberof AvailabilityProblem
     * @static
     * @param {IAvailabilityProblem} message AvailabilityProblem message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    AvailabilityProblem.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.problemType != null && Object.hasOwnProperty.call(message, "problemType"))
            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.problemType);
        if (message.missingValue != null && message.missingValue.length)
            for (var i = 0; i < message.missingValue.length; ++i)
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.missingValue[i]);
        return writer;
    };

    /**
     * Encodes the specified AvailabilityProblem message, length delimited. Does not implicitly {@link AvailabilityProblem.verify|verify} messages.
     * @function encodeDelimited
     * @memberof AvailabilityProblem
     * @static
     * @param {IAvailabilityProblem} message AvailabilityProblem message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    AvailabilityProblem.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes an AvailabilityProblem message from the specified reader or buffer.
     * @function decode
     * @memberof AvailabilityProblem
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {AvailabilityProblem} AvailabilityProblem
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    AvailabilityProblem.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.AvailabilityProblem();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.problemType = reader.int32();
                break;
            case 2:
                if (!(message.missingValue && message.missingValue.length))
                    message.missingValue = [];
                message.missingValue.push(reader.string());
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes an AvailabilityProblem message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof AvailabilityProblem
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {AvailabilityProblem} AvailabilityProblem
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    AvailabilityProblem.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies an AvailabilityProblem message.
     * @function verify
     * @memberof AvailabilityProblem
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    AvailabilityProblem.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.problemType != null && message.hasOwnProperty("problemType"))
            if (!$util.isInteger(message.problemType))
                return "problemType: integer expected";
        if (message.missingValue != null && message.hasOwnProperty("missingValue")) {
            if (!Array.isArray(message.missingValue))
                return "missingValue: array expected";
            for (var i = 0; i < message.missingValue.length; ++i)
                if (!$util.isString(message.missingValue[i]))
                    return "missingValue: string[] expected";
        }
        return null;
    };

    /**
     * Creates an AvailabilityProblem message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof AvailabilityProblem
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {AvailabilityProblem} AvailabilityProblem
     */
    AvailabilityProblem.fromObject = function fromObject(object) {
        if (object instanceof $root.AvailabilityProblem)
            return object;
        var message = new $root.AvailabilityProblem();
        if (object.problemType != null)
            message.problemType = object.problemType | 0;
        if (object.missingValue) {
            if (!Array.isArray(object.missingValue))
                throw TypeError(".AvailabilityProblem.missingValue: array expected");
            message.missingValue = [];
            for (var i = 0; i < object.missingValue.length; ++i)
                message.missingValue[i] = String(object.missingValue[i]);
        }
        return message;
    };

    /**
     * Creates a plain object from an AvailabilityProblem message. Also converts values to other types if specified.
     * @function toObject
     * @memberof AvailabilityProblem
     * @static
     * @param {AvailabilityProblem} message AvailabilityProblem
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    AvailabilityProblem.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        var object = {};
        if (options.arrays || options.defaults)
            object.missingValue = [];
        if (options.defaults)
            object.problemType = 0;
        if (message.problemType != null && message.hasOwnProperty("problemType"))
            object.problemType = message.problemType;
        if (message.missingValue && message.missingValue.length) {
            object.missingValue = [];
            for (var j = 0; j < message.missingValue.length; ++j)
                object.missingValue[j] = message.missingValue[j];
        }
        return object;
    };

    /**
     * Converts this AvailabilityProblem to JSON.
     * @function toJSON
     * @memberof AvailabilityProblem
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    AvailabilityProblem.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return AvailabilityProblem;
})();

$root.FilterEvaluationInfo = (function() {

    /**
     * Properties of a FilterEvaluationInfo.
     * @exports IFilterEvaluationInfo
     * @interface IFilterEvaluationInfo
     * @property {Array.<IRuleEvaluation>|null} [ruleEvaluation] FilterEvaluationInfo ruleEvaluation
     */

    /**
     * Constructs a new FilterEvaluationInfo.
     * @exports FilterEvaluationInfo
     * @classdesc Represents a FilterEvaluationInfo.
     * @implements IFilterEvaluationInfo
     * @constructor
     * @param {IFilterEvaluationInfo=} [properties] Properties to set
     */
    function FilterEvaluationInfo(properties) {
        this.ruleEvaluation = [];
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * FilterEvaluationInfo ruleEvaluation.
     * @member {Array.<IRuleEvaluation>} ruleEvaluation
     * @memberof FilterEvaluationInfo
     * @instance
     */
    FilterEvaluationInfo.prototype.ruleEvaluation = $util.emptyArray;

    /**
     * Creates a new FilterEvaluationInfo instance using the specified properties.
     * @function create
     * @memberof FilterEvaluationInfo
     * @static
     * @param {IFilterEvaluationInfo=} [properties] Properties to set
     * @returns {FilterEvaluationInfo} FilterEvaluationInfo instance
     */
    FilterEvaluationInfo.create = function create(properties) {
        return new FilterEvaluationInfo(properties);
    };

    /**
     * Encodes the specified FilterEvaluationInfo message. Does not implicitly {@link FilterEvaluationInfo.verify|verify} messages.
     * @function encode
     * @memberof FilterEvaluationInfo
     * @static
     * @param {IFilterEvaluationInfo} message FilterEvaluationInfo message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    FilterEvaluationInfo.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.ruleEvaluation != null && message.ruleEvaluation.length)
            for (var i = 0; i < message.ruleEvaluation.length; ++i)
                $root.RuleEvaluation.encode(message.ruleEvaluation[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
        return writer;
    };

    /**
     * Encodes the specified FilterEvaluationInfo message, length delimited. Does not implicitly {@link FilterEvaluationInfo.verify|verify} messages.
     * @function encodeDelimited
     * @memberof FilterEvaluationInfo
     * @static
     * @param {IFilterEvaluationInfo} message FilterEvaluationInfo message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    FilterEvaluationInfo.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a FilterEvaluationInfo message from the specified reader or buffer.
     * @function decode
     * @memberof FilterEvaluationInfo
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {FilterEvaluationInfo} FilterEvaluationInfo
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    FilterEvaluationInfo.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.FilterEvaluationInfo();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                if (!(message.ruleEvaluation && message.ruleEvaluation.length))
                    message.ruleEvaluation = [];
                message.ruleEvaluation.push($root.RuleEvaluation.decode(reader, reader.uint32()));
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a FilterEvaluationInfo message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof FilterEvaluationInfo
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {FilterEvaluationInfo} FilterEvaluationInfo
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    FilterEvaluationInfo.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a FilterEvaluationInfo message.
     * @function verify
     * @memberof FilterEvaluationInfo
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    FilterEvaluationInfo.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.ruleEvaluation != null && message.hasOwnProperty("ruleEvaluation")) {
            if (!Array.isArray(message.ruleEvaluation))
                return "ruleEvaluation: array expected";
            for (var i = 0; i < message.ruleEvaluation.length; ++i) {
                var error = $root.RuleEvaluation.verify(message.ruleEvaluation[i]);
                if (error)
                    return "ruleEvaluation." + error;
            }
        }
        return null;
    };

    /**
     * Creates a FilterEvaluationInfo message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof FilterEvaluationInfo
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {FilterEvaluationInfo} FilterEvaluationInfo
     */
    FilterEvaluationInfo.fromObject = function fromObject(object) {
        if (object instanceof $root.FilterEvaluationInfo)
            return object;
        var message = new $root.FilterEvaluationInfo();
        if (object.ruleEvaluation) {
            if (!Array.isArray(object.ruleEvaluation))
                throw TypeError(".FilterEvaluationInfo.ruleEvaluation: array expected");
            message.ruleEvaluation = [];
            for (var i = 0; i < object.ruleEvaluation.length; ++i) {
                if (typeof object.ruleEvaluation[i] !== "object")
                    throw TypeError(".FilterEvaluationInfo.ruleEvaluation: object expected");
                message.ruleEvaluation[i] = $root.RuleEvaluation.fromObject(object.ruleEvaluation[i]);
            }
        }
        return message;
    };

    /**
     * Creates a plain object from a FilterEvaluationInfo message. Also converts values to other types if specified.
     * @function toObject
     * @memberof FilterEvaluationInfo
     * @static
     * @param {FilterEvaluationInfo} message FilterEvaluationInfo
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    FilterEvaluationInfo.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        var object = {};
        if (options.arrays || options.defaults)
            object.ruleEvaluation = [];
        if (message.ruleEvaluation && message.ruleEvaluation.length) {
            object.ruleEvaluation = [];
            for (var j = 0; j < message.ruleEvaluation.length; ++j)
                object.ruleEvaluation[j] = $root.RuleEvaluation.toObject(message.ruleEvaluation[j], options);
        }
        return object;
    };

    /**
     * Converts this FilterEvaluationInfo to JSON.
     * @function toJSON
     * @memberof FilterEvaluationInfo
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    FilterEvaluationInfo.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return FilterEvaluationInfo;
})();

$root.Rule = (function() {

    /**
     * Properties of a Rule.
     * @exports IRule
     * @interface IRule
     * @property {boolean|null} [negate] Rule negate
     * @property {number|null} [operator] Rule operator
     * @property {number|null} [key] Rule key
     * @property {Array.<string>|null} [stringArg] Rule stringArg
     * @property {Array.<number|Long>|null} [longArg] Rule longArg
     * @property {Array.<number>|null} [doubleArg] Rule doubleArg
     * @property {Array.<IRule>|null} [subRule] Rule subRule
     * @property {number|null} [responseCode] Rule responseCode
     * @property {string|null} [comment] Rule comment
     * @property {Array.<number|Long>|null} [stringArgHash] Rule stringArgHash
     * @property {Array.<number>|null} [constArg] Rule constArg
     * @property {number|null} [availabilityProblemType] Rule availabilityProblemType
     * @property {boolean|null} [includeMissingValues] Rule includeMissingValues
     */

    /**
     * Constructs a new Rule.
     * @exports Rule
     * @classdesc Represents a Rule.
     * @implements IRule
     * @constructor
     * @param {IRule=} [properties] Properties to set
     */
    function Rule(properties) {
        this.stringArg = [];
        this.longArg = [];
        this.doubleArg = [];
        this.subRule = [];
        this.stringArgHash = [];
        this.constArg = [];
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * Rule negate.
     * @member {boolean} negate
     * @memberof Rule
     * @instance
     */
    Rule.prototype.negate = false;

    /**
     * Rule operator.
     * @member {number} operator
     * @memberof Rule
     * @instance
     */
    Rule.prototype.operator = 0;

    /**
     * Rule key.
     * @member {number} key
     * @memberof Rule
     * @instance
     */
    Rule.prototype.key = 0;

    /**
     * Rule stringArg.
     * @member {Array.<string>} stringArg
     * @memberof Rule
     * @instance
     */
    Rule.prototype.stringArg = $util.emptyArray;

    /**
     * Rule longArg.
     * @member {Array.<number|Long>} longArg
     * @memberof Rule
     * @instance
     */
    Rule.prototype.longArg = $util.emptyArray;

    /**
     * Rule doubleArg.
     * @member {Array.<number>} doubleArg
     * @memberof Rule
     * @instance
     */
    Rule.prototype.doubleArg = $util.emptyArray;

    /**
     * Rule subRule.
     * @member {Array.<IRule>} subRule
     * @memberof Rule
     * @instance
     */
    Rule.prototype.subRule = $util.emptyArray;

    /**
     * Rule responseCode.
     * @member {number} responseCode
     * @memberof Rule
     * @instance
     */
    Rule.prototype.responseCode = 0;

    /**
     * Rule comment.
     * @member {string} comment
     * @memberof Rule
     * @instance
     */
    Rule.prototype.comment = "";

    /**
     * Rule stringArgHash.
     * @member {Array.<number|Long>} stringArgHash
     * @memberof Rule
     * @instance
     */
    Rule.prototype.stringArgHash = $util.emptyArray;

    /**
     * Rule constArg.
     * @member {Array.<number>} constArg
     * @memberof Rule
     * @instance
     */
    Rule.prototype.constArg = $util.emptyArray;

    /**
     * Rule availabilityProblemType.
     * @member {number} availabilityProblemType
     * @memberof Rule
     * @instance
     */
    Rule.prototype.availabilityProblemType = 0;

    /**
     * Rule includeMissingValues.
     * @member {boolean} includeMissingValues
     * @memberof Rule
     * @instance
     */
    Rule.prototype.includeMissingValues = false;

    /**
     * Creates a new Rule instance using the specified properties.
     * @function create
     * @memberof Rule
     * @static
     * @param {IRule=} [properties] Properties to set
     * @returns {Rule} Rule instance
     */
    Rule.create = function create(properties) {
        return new Rule(properties);
    };

    /**
     * Encodes the specified Rule message. Does not implicitly {@link Rule.verify|verify} messages.
     * @function encode
     * @memberof Rule
     * @static
     * @param {IRule} message Rule message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    Rule.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.negate != null && Object.hasOwnProperty.call(message, "negate"))
            writer.uint32(/* id 1, wireType 0 =*/8).bool(message.negate);
        if (message.operator != null && Object.hasOwnProperty.call(message, "operator"))
            writer.uint32(/* id 2, wireType 0 =*/16).int32(message.operator);
        if (message.key != null && Object.hasOwnProperty.call(message, "key"))
            writer.uint32(/* id 3, wireType 0 =*/24).int32(message.key);
        if (message.stringArg != null && message.stringArg.length)
            for (var i = 0; i < message.stringArg.length; ++i)
                writer.uint32(/* id 4, wireType 2 =*/34).string(message.stringArg[i]);
        if (message.longArg != null && message.longArg.length)
            for (var i = 0; i < message.longArg.length; ++i)
                writer.uint32(/* id 5, wireType 0 =*/40).int64(message.longArg[i]);
        if (message.doubleArg != null && message.doubleArg.length)
            for (var i = 0; i < message.doubleArg.length; ++i)
                writer.uint32(/* id 6, wireType 1 =*/49).double(message.doubleArg[i]);
        if (message.subRule != null && message.subRule.length)
            for (var i = 0; i < message.subRule.length; ++i)
                $root.Rule.encode(message.subRule[i], writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
        if (message.responseCode != null && Object.hasOwnProperty.call(message, "responseCode"))
            writer.uint32(/* id 8, wireType 0 =*/64).int32(message.responseCode);
        if (message.comment != null && Object.hasOwnProperty.call(message, "comment"))
            writer.uint32(/* id 9, wireType 2 =*/74).string(message.comment);
        if (message.stringArgHash != null && message.stringArgHash.length)
            for (var i = 0; i < message.stringArgHash.length; ++i)
                writer.uint32(/* id 10, wireType 1 =*/81).fixed64(message.stringArgHash[i]);
        if (message.constArg != null && message.constArg.length)
            for (var i = 0; i < message.constArg.length; ++i)
                writer.uint32(/* id 11, wireType 0 =*/88).int32(message.constArg[i]);
        if (message.availabilityProblemType != null && Object.hasOwnProperty.call(message, "availabilityProblemType"))
            writer.uint32(/* id 12, wireType 0 =*/96).int32(message.availabilityProblemType);
        if (message.includeMissingValues != null && Object.hasOwnProperty.call(message, "includeMissingValues"))
            writer.uint32(/* id 13, wireType 0 =*/104).bool(message.includeMissingValues);
        return writer;
    };

    /**
     * Encodes the specified Rule message, length delimited. Does not implicitly {@link Rule.verify|verify} messages.
     * @function encodeDelimited
     * @memberof Rule
     * @static
     * @param {IRule} message Rule message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    Rule.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a Rule message from the specified reader or buffer.
     * @function decode
     * @memberof Rule
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {Rule} Rule
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    Rule.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Rule();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.negate = reader.bool();
                break;
            case 2:
                message.operator = reader.int32();
                break;
            case 3:
                message.key = reader.int32();
                break;
            case 4:
                if (!(message.stringArg && message.stringArg.length))
                    message.stringArg = [];
                message.stringArg.push(reader.string());
                break;
            case 5:
                if (!(message.longArg && message.longArg.length))
                    message.longArg = [];
                if ((tag & 7) === 2) {
                    var end2 = reader.uint32() + reader.pos;
                    while (reader.pos < end2)
                        message.longArg.push(reader.int64());
                } else
                    message.longArg.push(reader.int64());
                break;
            case 6:
                if (!(message.doubleArg && message.doubleArg.length))
                    message.doubleArg = [];
                if ((tag & 7) === 2) {
                    var end2 = reader.uint32() + reader.pos;
                    while (reader.pos < end2)
                        message.doubleArg.push(reader.double());
                } else
                    message.doubleArg.push(reader.double());
                break;
            case 7:
                if (!(message.subRule && message.subRule.length))
                    message.subRule = [];
                message.subRule.push($root.Rule.decode(reader, reader.uint32()));
                break;
            case 8:
                message.responseCode = reader.int32();
                break;
            case 9:
                message.comment = reader.string();
                break;
            case 10:
                if (!(message.stringArgHash && message.stringArgHash.length))
                    message.stringArgHash = [];
                if ((tag & 7) === 2) {
                    var end2 = reader.uint32() + reader.pos;
                    while (reader.pos < end2)
                        message.stringArgHash.push(reader.fixed64());
                } else
                    message.stringArgHash.push(reader.fixed64());
                break;
            case 11:
                if (!(message.constArg && message.constArg.length))
                    message.constArg = [];
                if ((tag & 7) === 2) {
                    var end2 = reader.uint32() + reader.pos;
                    while (reader.pos < end2)
                        message.constArg.push(reader.int32());
                } else
                    message.constArg.push(reader.int32());
                break;
            case 12:
                message.availabilityProblemType = reader.int32();
                break;
            case 13:
                message.includeMissingValues = reader.bool();
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a Rule message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof Rule
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {Rule} Rule
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    Rule.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a Rule message.
     * @function verify
     * @memberof Rule
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    Rule.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.negate != null && message.hasOwnProperty("negate"))
            if (typeof message.negate !== "boolean")
                return "negate: boolean expected";
        if (message.operator != null && message.hasOwnProperty("operator"))
            if (!$util.isInteger(message.operator))
                return "operator: integer expected";
        if (message.key != null && message.hasOwnProperty("key"))
            if (!$util.isInteger(message.key))
                return "key: integer expected";
        if (message.stringArg != null && message.hasOwnProperty("stringArg")) {
            if (!Array.isArray(message.stringArg))
                return "stringArg: array expected";
            for (var i = 0; i < message.stringArg.length; ++i)
                if (!$util.isString(message.stringArg[i]))
                    return "stringArg: string[] expected";
        }
        if (message.longArg != null && message.hasOwnProperty("longArg")) {
            if (!Array.isArray(message.longArg))
                return "longArg: array expected";
            for (var i = 0; i < message.longArg.length; ++i)
                if (!$util.isInteger(message.longArg[i]) && !(message.longArg[i] && $util.isInteger(message.longArg[i].low) && $util.isInteger(message.longArg[i].high)))
                    return "longArg: integer|Long[] expected";
        }
        if (message.doubleArg != null && message.hasOwnProperty("doubleArg")) {
            if (!Array.isArray(message.doubleArg))
                return "doubleArg: array expected";
            for (var i = 0; i < message.doubleArg.length; ++i)
                if (typeof message.doubleArg[i] !== "number")
                    return "doubleArg: number[] expected";
        }
        if (message.subRule != null && message.hasOwnProperty("subRule")) {
            if (!Array.isArray(message.subRule))
                return "subRule: array expected";
            for (var i = 0; i < message.subRule.length; ++i) {
                var error = $root.Rule.verify(message.subRule[i]);
                if (error)
                    return "subRule." + error;
            }
        }
        if (message.responseCode != null && message.hasOwnProperty("responseCode"))
            if (!$util.isInteger(message.responseCode))
                return "responseCode: integer expected";
        if (message.comment != null && message.hasOwnProperty("comment"))
            if (!$util.isString(message.comment))
                return "comment: string expected";
        if (message.stringArgHash != null && message.hasOwnProperty("stringArgHash")) {
            if (!Array.isArray(message.stringArgHash))
                return "stringArgHash: array expected";
            for (var i = 0; i < message.stringArgHash.length; ++i)
                if (!$util.isInteger(message.stringArgHash[i]) && !(message.stringArgHash[i] && $util.isInteger(message.stringArgHash[i].low) && $util.isInteger(message.stringArgHash[i].high)))
                    return "stringArgHash: integer|Long[] expected";
        }
        if (message.constArg != null && message.hasOwnProperty("constArg")) {
            if (!Array.isArray(message.constArg))
                return "constArg: array expected";
            for (var i = 0; i < message.constArg.length; ++i)
                if (!$util.isInteger(message.constArg[i]))
                    return "constArg: integer[] expected";
        }
        if (message.availabilityProblemType != null && message.hasOwnProperty("availabilityProblemType"))
            if (!$util.isInteger(message.availabilityProblemType))
                return "availabilityProblemType: integer expected";
        if (message.includeMissingValues != null && message.hasOwnProperty("includeMissingValues"))
            if (typeof message.includeMissingValues !== "boolean")
                return "includeMissingValues: boolean expected";
        return null;
    };

    /**
     * Creates a Rule message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof Rule
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {Rule} Rule
     */
    Rule.fromObject = function fromObject(object) {
        if (object instanceof $root.Rule)
            return object;
        var message = new $root.Rule();
        if (object.negate != null)
            message.negate = Boolean(object.negate);
        if (object.operator != null)
            message.operator = object.operator | 0;
        if (object.key != null)
            message.key = object.key | 0;
        if (object.stringArg) {
            if (!Array.isArray(object.stringArg))
                throw TypeError(".Rule.stringArg: array expected");
            message.stringArg = [];
            for (var i = 0; i < object.stringArg.length; ++i)
                message.stringArg[i] = String(object.stringArg[i]);
        }
        if (object.longArg) {
            if (!Array.isArray(object.longArg))
                throw TypeError(".Rule.longArg: array expected");
            message.longArg = [];
            for (var i = 0; i < object.longArg.length; ++i)
                if ($util.Long)
                    (message.longArg[i] = $util.Long.fromValue(object.longArg[i])).unsigned = false;
                else if (typeof object.longArg[i] === "string")
                    message.longArg[i] = parseInt(object.longArg[i], 10);
                else if (typeof object.longArg[i] === "number")
                    message.longArg[i] = object.longArg[i];
                else if (typeof object.longArg[i] === "object")
                    message.longArg[i] = new $util.LongBits(object.longArg[i].low >>> 0, object.longArg[i].high >>> 0).toNumber();
        }
        if (object.doubleArg) {
            if (!Array.isArray(object.doubleArg))
                throw TypeError(".Rule.doubleArg: array expected");
            message.doubleArg = [];
            for (var i = 0; i < object.doubleArg.length; ++i)
                message.doubleArg[i] = Number(object.doubleArg[i]);
        }
        if (object.subRule) {
            if (!Array.isArray(object.subRule))
                throw TypeError(".Rule.subRule: array expected");
            message.subRule = [];
            for (var i = 0; i < object.subRule.length; ++i) {
                if (typeof object.subRule[i] !== "object")
                    throw TypeError(".Rule.subRule: object expected");
                message.subRule[i] = $root.Rule.fromObject(object.subRule[i]);
            }
        }
        if (object.responseCode != null)
            message.responseCode = object.responseCode | 0;
        if (object.comment != null)
            message.comment = String(object.comment);
        if (object.stringArgHash) {
            if (!Array.isArray(object.stringArgHash))
                throw TypeError(".Rule.stringArgHash: array expected");
            message.stringArgHash = [];
            for (var i = 0; i < object.stringArgHash.length; ++i)
                if ($util.Long)
                    (message.stringArgHash[i] = $util.Long.fromValue(object.stringArgHash[i])).unsigned = false;
                else if (typeof object.stringArgHash[i] === "string")
                    message.stringArgHash[i] = parseInt(object.stringArgHash[i], 10);
                else if (typeof object.stringArgHash[i] === "number")
                    message.stringArgHash[i] = object.stringArgHash[i];
                else if (typeof object.stringArgHash[i] === "object")
                    message.stringArgHash[i] = new $util.LongBits(object.stringArgHash[i].low >>> 0, object.stringArgHash[i].high >>> 0).toNumber();
        }
        if (object.constArg) {
            if (!Array.isArray(object.constArg))
                throw TypeError(".Rule.constArg: array expected");
            message.constArg = [];
            for (var i = 0; i < object.constArg.length; ++i)
                message.constArg[i] = object.constArg[i] | 0;
        }
        if (object.availabilityProblemType != null)
            message.availabilityProblemType = object.availabilityProblemType | 0;
        if (object.includeMissingValues != null)
            message.includeMissingValues = Boolean(object.includeMissingValues);
        return message;
    };

    /**
     * Creates a plain object from a Rule message. Also converts values to other types if specified.
     * @function toObject
     * @memberof Rule
     * @static
     * @param {Rule} message Rule
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    Rule.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        var object = {};
        if (options.arrays || options.defaults) {
            object.stringArg = [];
            object.longArg = [];
            object.doubleArg = [];
            object.subRule = [];
            object.stringArgHash = [];
            object.constArg = [];
        }
        if (options.defaults) {
            object.negate = false;
            object.operator = 0;
            object.key = 0;
            object.responseCode = 0;
            object.comment = "";
            object.availabilityProblemType = 0;
            object.includeMissingValues = false;
        }
        if (message.negate != null && message.hasOwnProperty("negate"))
            object.negate = message.negate;
        if (message.operator != null && message.hasOwnProperty("operator"))
            object.operator = message.operator;
        if (message.key != null && message.hasOwnProperty("key"))
            object.key = message.key;
        if (message.stringArg && message.stringArg.length) {
            object.stringArg = [];
            for (var j = 0; j < message.stringArg.length; ++j)
                object.stringArg[j] = message.stringArg[j];
        }
        if (message.longArg && message.longArg.length) {
            object.longArg = [];
            for (var j = 0; j < message.longArg.length; ++j)
                if (typeof message.longArg[j] === "number")
                    object.longArg[j] = options.longs === String ? String(message.longArg[j]) : message.longArg[j];
                else
                    object.longArg[j] = options.longs === String ? $util.Long.prototype.toString.call(message.longArg[j]) : options.longs === Number ? new $util.LongBits(message.longArg[j].low >>> 0, message.longArg[j].high >>> 0).toNumber() : message.longArg[j];
        }
        if (message.doubleArg && message.doubleArg.length) {
            object.doubleArg = [];
            for (var j = 0; j < message.doubleArg.length; ++j)
                object.doubleArg[j] = options.json && !isFinite(message.doubleArg[j]) ? String(message.doubleArg[j]) : message.doubleArg[j];
        }
        if (message.subRule && message.subRule.length) {
            object.subRule = [];
            for (var j = 0; j < message.subRule.length; ++j)
                object.subRule[j] = $root.Rule.toObject(message.subRule[j], options);
        }
        if (message.responseCode != null && message.hasOwnProperty("responseCode"))
            object.responseCode = message.responseCode;
        if (message.comment != null && message.hasOwnProperty("comment"))
            object.comment = message.comment;
        if (message.stringArgHash && message.stringArgHash.length) {
            object.stringArgHash = [];
            for (var j = 0; j < message.stringArgHash.length; ++j)
                if (typeof message.stringArgHash[j] === "number")
                    object.stringArgHash[j] = options.longs === String ? String(message.stringArgHash[j]) : message.stringArgHash[j];
                else
                    object.stringArgHash[j] = options.longs === String ? $util.Long.prototype.toString.call(message.stringArgHash[j]) : options.longs === Number ? new $util.LongBits(message.stringArgHash[j].low >>> 0, message.stringArgHash[j].high >>> 0).toNumber() : message.stringArgHash[j];
        }
        if (message.constArg && message.constArg.length) {
            object.constArg = [];
            for (var j = 0; j < message.constArg.length; ++j)
                object.constArg[j] = message.constArg[j];
        }
        if (message.availabilityProblemType != null && message.hasOwnProperty("availabilityProblemType"))
            object.availabilityProblemType = message.availabilityProblemType;
        if (message.includeMissingValues != null && message.hasOwnProperty("includeMissingValues"))
            object.includeMissingValues = message.includeMissingValues;
        return object;
    };

    /**
     * Converts this Rule to JSON.
     * @function toJSON
     * @memberof Rule
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    Rule.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return Rule;
})();

$root.RuleEvaluation = (function() {

    /**
     * Properties of a RuleEvaluation.
     * @exports IRuleEvaluation
     * @interface IRuleEvaluation
     * @property {IRule|null} [rule] RuleEvaluation rule
     * @property {Array.<string>|null} [actualStringValue] RuleEvaluation actualStringValue
     * @property {Array.<number|Long>|null} [actualLongValue] RuleEvaluation actualLongValue
     * @property {Array.<boolean>|null} [actualBoolValue] RuleEvaluation actualBoolValue
     * @property {Array.<number>|null} [actualDoubleValue] RuleEvaluation actualDoubleValue
     */

    /**
     * Constructs a new RuleEvaluation.
     * @exports RuleEvaluation
     * @classdesc Represents a RuleEvaluation.
     * @implements IRuleEvaluation
     * @constructor
     * @param {IRuleEvaluation=} [properties] Properties to set
     */
    function RuleEvaluation(properties) {
        this.actualStringValue = [];
        this.actualLongValue = [];
        this.actualBoolValue = [];
        this.actualDoubleValue = [];
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * RuleEvaluation rule.
     * @member {IRule|null|undefined} rule
     * @memberof RuleEvaluation
     * @instance
     */
    RuleEvaluation.prototype.rule = null;

    /**
     * RuleEvaluation actualStringValue.
     * @member {Array.<string>} actualStringValue
     * @memberof RuleEvaluation
     * @instance
     */
    RuleEvaluation.prototype.actualStringValue = $util.emptyArray;

    /**
     * RuleEvaluation actualLongValue.
     * @member {Array.<number|Long>} actualLongValue
     * @memberof RuleEvaluation
     * @instance
     */
    RuleEvaluation.prototype.actualLongValue = $util.emptyArray;

    /**
     * RuleEvaluation actualBoolValue.
     * @member {Array.<boolean>} actualBoolValue
     * @memberof RuleEvaluation
     * @instance
     */
    RuleEvaluation.prototype.actualBoolValue = $util.emptyArray;

    /**
     * RuleEvaluation actualDoubleValue.
     * @member {Array.<number>} actualDoubleValue
     * @memberof RuleEvaluation
     * @instance
     */
    RuleEvaluation.prototype.actualDoubleValue = $util.emptyArray;

    /**
     * Creates a new RuleEvaluation instance using the specified properties.
     * @function create
     * @memberof RuleEvaluation
     * @static
     * @param {IRuleEvaluation=} [properties] Properties to set
     * @returns {RuleEvaluation} RuleEvaluation instance
     */
    RuleEvaluation.create = function create(properties) {
        return new RuleEvaluation(properties);
    };

    /**
     * Encodes the specified RuleEvaluation message. Does not implicitly {@link RuleEvaluation.verify|verify} messages.
     * @function encode
     * @memberof RuleEvaluation
     * @static
     * @param {IRuleEvaluation} message RuleEvaluation message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    RuleEvaluation.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.rule != null && Object.hasOwnProperty.call(message, "rule"))
            $root.Rule.encode(message.rule, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
        if (message.actualStringValue != null && message.actualStringValue.length)
            for (var i = 0; i < message.actualStringValue.length; ++i)
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.actualStringValue[i]);
        if (message.actualLongValue != null && message.actualLongValue.length)
            for (var i = 0; i < message.actualLongValue.length; ++i)
                writer.uint32(/* id 3, wireType 0 =*/24).int64(message.actualLongValue[i]);
        if (message.actualBoolValue != null && message.actualBoolValue.length)
            for (var i = 0; i < message.actualBoolValue.length; ++i)
                writer.uint32(/* id 4, wireType 0 =*/32).bool(message.actualBoolValue[i]);
        if (message.actualDoubleValue != null && message.actualDoubleValue.length)
            for (var i = 0; i < message.actualDoubleValue.length; ++i)
                writer.uint32(/* id 5, wireType 1 =*/41).double(message.actualDoubleValue[i]);
        return writer;
    };

    /**
     * Encodes the specified RuleEvaluation message, length delimited. Does not implicitly {@link RuleEvaluation.verify|verify} messages.
     * @function encodeDelimited
     * @memberof RuleEvaluation
     * @static
     * @param {IRuleEvaluation} message RuleEvaluation message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    RuleEvaluation.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a RuleEvaluation message from the specified reader or buffer.
     * @function decode
     * @memberof RuleEvaluation
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {RuleEvaluation} RuleEvaluation
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    RuleEvaluation.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.RuleEvaluation();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.rule = $root.Rule.decode(reader, reader.uint32());
                break;
            case 2:
                if (!(message.actualStringValue && message.actualStringValue.length))
                    message.actualStringValue = [];
                message.actualStringValue.push(reader.string());
                break;
            case 3:
                if (!(message.actualLongValue && message.actualLongValue.length))
                    message.actualLongValue = [];
                if ((tag & 7) === 2) {
                    var end2 = reader.uint32() + reader.pos;
                    while (reader.pos < end2)
                        message.actualLongValue.push(reader.int64());
                } else
                    message.actualLongValue.push(reader.int64());
                break;
            case 4:
                if (!(message.actualBoolValue && message.actualBoolValue.length))
                    message.actualBoolValue = [];
                if ((tag & 7) === 2) {
                    var end2 = reader.uint32() + reader.pos;
                    while (reader.pos < end2)
                        message.actualBoolValue.push(reader.bool());
                } else
                    message.actualBoolValue.push(reader.bool());
                break;
            case 5:
                if (!(message.actualDoubleValue && message.actualDoubleValue.length))
                    message.actualDoubleValue = [];
                if ((tag & 7) === 2) {
                    var end2 = reader.uint32() + reader.pos;
                    while (reader.pos < end2)
                        message.actualDoubleValue.push(reader.double());
                } else
                    message.actualDoubleValue.push(reader.double());
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a RuleEvaluation message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof RuleEvaluation
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {RuleEvaluation} RuleEvaluation
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    RuleEvaluation.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a RuleEvaluation message.
     * @function verify
     * @memberof RuleEvaluation
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    RuleEvaluation.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.rule != null && message.hasOwnProperty("rule")) {
            var error = $root.Rule.verify(message.rule);
            if (error)
                return "rule." + error;
        }
        if (message.actualStringValue != null && message.hasOwnProperty("actualStringValue")) {
            if (!Array.isArray(message.actualStringValue))
                return "actualStringValue: array expected";
            for (var i = 0; i < message.actualStringValue.length; ++i)
                if (!$util.isString(message.actualStringValue[i]))
                    return "actualStringValue: string[] expected";
        }
        if (message.actualLongValue != null && message.hasOwnProperty("actualLongValue")) {
            if (!Array.isArray(message.actualLongValue))
                return "actualLongValue: array expected";
            for (var i = 0; i < message.actualLongValue.length; ++i)
                if (!$util.isInteger(message.actualLongValue[i]) && !(message.actualLongValue[i] && $util.isInteger(message.actualLongValue[i].low) && $util.isInteger(message.actualLongValue[i].high)))
                    return "actualLongValue: integer|Long[] expected";
        }
        if (message.actualBoolValue != null && message.hasOwnProperty("actualBoolValue")) {
            if (!Array.isArray(message.actualBoolValue))
                return "actualBoolValue: array expected";
            for (var i = 0; i < message.actualBoolValue.length; ++i)
                if (typeof message.actualBoolValue[i] !== "boolean")
                    return "actualBoolValue: boolean[] expected";
        }
        if (message.actualDoubleValue != null && message.hasOwnProperty("actualDoubleValue")) {
            if (!Array.isArray(message.actualDoubleValue))
                return "actualDoubleValue: array expected";
            for (var i = 0; i < message.actualDoubleValue.length; ++i)
                if (typeof message.actualDoubleValue[i] !== "number")
                    return "actualDoubleValue: number[] expected";
        }
        return null;
    };

    /**
     * Creates a RuleEvaluation message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof RuleEvaluation
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {RuleEvaluation} RuleEvaluation
     */
    RuleEvaluation.fromObject = function fromObject(object) {
        if (object instanceof $root.RuleEvaluation)
            return object;
        var message = new $root.RuleEvaluation();
        if (object.rule != null) {
            if (typeof object.rule !== "object")
                throw TypeError(".RuleEvaluation.rule: object expected");
            message.rule = $root.Rule.fromObject(object.rule);
        }
        if (object.actualStringValue) {
            if (!Array.isArray(object.actualStringValue))
                throw TypeError(".RuleEvaluation.actualStringValue: array expected");
            message.actualStringValue = [];
            for (var i = 0; i < object.actualStringValue.length; ++i)
                message.actualStringValue[i] = String(object.actualStringValue[i]);
        }
        if (object.actualLongValue) {
            if (!Array.isArray(object.actualLongValue))
                throw TypeError(".RuleEvaluation.actualLongValue: array expected");
            message.actualLongValue = [];
            for (var i = 0; i < object.actualLongValue.length; ++i)
                if ($util.Long)
                    (message.actualLongValue[i] = $util.Long.fromValue(object.actualLongValue[i])).unsigned = false;
                else if (typeof object.actualLongValue[i] === "string")
                    message.actualLongValue[i] = parseInt(object.actualLongValue[i], 10);
                else if (typeof object.actualLongValue[i] === "number")
                    message.actualLongValue[i] = object.actualLongValue[i];
                else if (typeof object.actualLongValue[i] === "object")
                    message.actualLongValue[i] = new $util.LongBits(object.actualLongValue[i].low >>> 0, object.actualLongValue[i].high >>> 0).toNumber();
        }
        if (object.actualBoolValue) {
            if (!Array.isArray(object.actualBoolValue))
                throw TypeError(".RuleEvaluation.actualBoolValue: array expected");
            message.actualBoolValue = [];
            for (var i = 0; i < object.actualBoolValue.length; ++i)
                message.actualBoolValue[i] = Boolean(object.actualBoolValue[i]);
        }
        if (object.actualDoubleValue) {
            if (!Array.isArray(object.actualDoubleValue))
                throw TypeError(".RuleEvaluation.actualDoubleValue: array expected");
            message.actualDoubleValue = [];
            for (var i = 0; i < object.actualDoubleValue.length; ++i)
                message.actualDoubleValue[i] = Number(object.actualDoubleValue[i]);
        }
        return message;
    };

    /**
     * Creates a plain object from a RuleEvaluation message. Also converts values to other types if specified.
     * @function toObject
     * @memberof RuleEvaluation
     * @static
     * @param {RuleEvaluation} message RuleEvaluation
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    RuleEvaluation.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        var object = {};
        if (options.arrays || options.defaults) {
            object.actualStringValue = [];
            object.actualLongValue = [];
            object.actualBoolValue = [];
            object.actualDoubleValue = [];
        }
        if (options.defaults)
            object.rule = null;
        if (message.rule != null && message.hasOwnProperty("rule"))
            object.rule = $root.Rule.toObject(message.rule, options);
        if (message.actualStringValue && message.actualStringValue.length) {
            object.actualStringValue = [];
            for (var j = 0; j < message.actualStringValue.length; ++j)
                object.actualStringValue[j] = message.actualStringValue[j];
        }
        if (message.actualLongValue && message.actualLongValue.length) {
            object.actualLongValue = [];
            for (var j = 0; j < message.actualLongValue.length; ++j)
                if (typeof message.actualLongValue[j] === "number")
                    object.actualLongValue[j] = options.longs === String ? String(message.actualLongValue[j]) : message.actualLongValue[j];
                else
                    object.actualLongValue[j] = options.longs === String ? $util.Long.prototype.toString.call(message.actualLongValue[j]) : options.longs === Number ? new $util.LongBits(message.actualLongValue[j].low >>> 0, message.actualLongValue[j].high >>> 0).toNumber() : message.actualLongValue[j];
        }
        if (message.actualBoolValue && message.actualBoolValue.length) {
            object.actualBoolValue = [];
            for (var j = 0; j < message.actualBoolValue.length; ++j)
                object.actualBoolValue[j] = message.actualBoolValue[j];
        }
        if (message.actualDoubleValue && message.actualDoubleValue.length) {
            object.actualDoubleValue = [];
            for (var j = 0; j < message.actualDoubleValue.length; ++j)
                object.actualDoubleValue[j] = options.json && !isFinite(message.actualDoubleValue[j]) ? String(message.actualDoubleValue[j]) : message.actualDoubleValue[j];
        }
        return object;
    };

    /**
     * Converts this RuleEvaluation to JSON.
     * @function toJSON
     * @memberof RuleEvaluation
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    RuleEvaluation.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return RuleEvaluation;
})();

$root.LibraryAppDetails = (function() {

    /**
     * Properties of a LibraryAppDetails.
     * @exports ILibraryAppDetails
     * @interface ILibraryAppDetails
     * @property {string|null} [certificateHash] LibraryAppDetails certificateHash
     * @property {number|Long|null} [refundTimeoutTimestamp] LibraryAppDetails refundTimeoutTimestamp
     * @property {number|Long|null} [postDeliveryRefundWindowMillis] LibraryAppDetails postDeliveryRefundWindowMillis
     */

    /**
     * Constructs a new LibraryAppDetails.
     * @exports LibraryAppDetails
     * @classdesc Represents a LibraryAppDetails.
     * @implements ILibraryAppDetails
     * @constructor
     * @param {ILibraryAppDetails=} [properties] Properties to set
     */
    function LibraryAppDetails(properties) {
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * LibraryAppDetails certificateHash.
     * @member {string} certificateHash
     * @memberof LibraryAppDetails
     * @instance
     */
    LibraryAppDetails.prototype.certificateHash = "";

    /**
     * LibraryAppDetails refundTimeoutTimestamp.
     * @member {number|Long} refundTimeoutTimestamp
     * @memberof LibraryAppDetails
     * @instance
     */
    LibraryAppDetails.prototype.refundTimeoutTimestamp = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

    /**
     * LibraryAppDetails postDeliveryRefundWindowMillis.
     * @member {number|Long} postDeliveryRefundWindowMillis
     * @memberof LibraryAppDetails
     * @instance
     */
    LibraryAppDetails.prototype.postDeliveryRefundWindowMillis = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

    /**
     * Creates a new LibraryAppDetails instance using the specified properties.
     * @function create
     * @memberof LibraryAppDetails
     * @static
     * @param {ILibraryAppDetails=} [properties] Properties to set
     * @returns {LibraryAppDetails} LibraryAppDetails instance
     */
    LibraryAppDetails.create = function create(properties) {
        return new LibraryAppDetails(properties);
    };

    /**
     * Encodes the specified LibraryAppDetails message. Does not implicitly {@link LibraryAppDetails.verify|verify} messages.
     * @function encode
     * @memberof LibraryAppDetails
     * @static
     * @param {ILibraryAppDetails} message LibraryAppDetails message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    LibraryAppDetails.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.certificateHash != null && Object.hasOwnProperty.call(message, "certificateHash"))
            writer.uint32(/* id 2, wireType 2 =*/18).string(message.certificateHash);
        if (message.refundTimeoutTimestamp != null && Object.hasOwnProperty.call(message, "refundTimeoutTimestamp"))
            writer.uint32(/* id 3, wireType 0 =*/24).int64(message.refundTimeoutTimestamp);
        if (message.postDeliveryRefundWindowMillis != null && Object.hasOwnProperty.call(message, "postDeliveryRefundWindowMillis"))
            writer.uint32(/* id 4, wireType 0 =*/32).int64(message.postDeliveryRefundWindowMillis);
        return writer;
    };

    /**
     * Encodes the specified LibraryAppDetails message, length delimited. Does not implicitly {@link LibraryAppDetails.verify|verify} messages.
     * @function encodeDelimited
     * @memberof LibraryAppDetails
     * @static
     * @param {ILibraryAppDetails} message LibraryAppDetails message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    LibraryAppDetails.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a LibraryAppDetails message from the specified reader or buffer.
     * @function decode
     * @memberof LibraryAppDetails
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {LibraryAppDetails} LibraryAppDetails
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    LibraryAppDetails.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.LibraryAppDetails();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            case 2:
                message.certificateHash = reader.string();
                break;
            case 3:
                message.refundTimeoutTimestamp = reader.int64();
                break;
            case 4:
                message.postDeliveryRefundWindowMillis = reader.int64();
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a LibraryAppDetails message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof LibraryAppDetails
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {LibraryAppDetails} LibraryAppDetails
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    LibraryAppDetails.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a LibraryAppDetails message.
     * @function verify
     * @memberof LibraryAppDetails
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    LibraryAppDetails.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.certificateHash != null && message.hasOwnProperty("certificateHash"))
            if (!$util.isString(message.certificateHash))
                return "certificateHash: string expected";
        if (message.refundTimeoutTimestamp != null && message.hasOwnProperty("refundTimeoutTimestamp"))
            if (!$util.isInteger(message.refundTimeoutTimestamp) && !(message.refundTimeoutTimestamp && $util.isInteger(message.refundTimeoutTimestamp.low) && $util.isInteger(message.refundTimeoutTimestamp.high)))
                return "refundTimeoutTimestamp: integer|Long expected";
        if (message.postDeliveryRefundWindowMillis != null && message.hasOwnProperty("postDeliveryRefundWindowMillis"))
            if (!$util.isInteger(message.postDeliveryRefundWindowMillis) && !(message.postDeliveryRefundWindowMillis && $util.isInteger(message.postDeliveryRefundWindowMillis.low) && $util.isInteger(message.postDeliveryRefundWindowMillis.high)))
                return "postDeliveryRefundWindowMillis: integer|Long expected";
        return null;
    };

    /**
     * Creates a LibraryAppDetails message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof LibraryAppDetails
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {LibraryAppDetails} LibraryAppDetails
     */
    LibraryAppDetails.fromObject = function fromObject(object) {
        if (object instanceof $root.LibraryAppDetails)
            return object;
        var message = new $root.LibraryAppDetails();
        if (object.certificateHash != null)
            message.certificateHash = String(object.certificateHash);
        if (object.refundTimeoutTimestamp != null)
            if ($util.Long)
                (message.refundTimeoutTimestamp = $util.Long.fromValue(object.refundTimeoutTimestamp)).unsigned = false;
            else if (typeof object.refundTimeoutTimestamp === "string")
                message.refundTimeoutTimestamp = parseInt(object.refundTimeoutTimestamp, 10);
            else if (typeof object.refundTimeoutTimestamp === "number")
                message.refundTimeoutTimestamp = object.refundTimeoutTimestamp;
            else if (typeof object.refundTimeoutTimestamp === "object")
                message.refundTimeoutTimestamp = new $util.LongBits(object.refundTimeoutTimestamp.low >>> 0, object.refundTimeoutTimestamp.high >>> 0).toNumber();
        if (object.postDeliveryRefundWindowMillis != null)
            if ($util.Long)
                (message.postDeliveryRefundWindowMillis = $util.Long.fromValue(object.postDeliveryRefundWindowMillis)).unsigned = false;
            else if (typeof object.postDeliveryRefundWindowMillis === "string")
                message.postDeliveryRefundWindowMillis = parseInt(object.postDeliveryRefundWindowMillis, 10);
            else if (typeof object.postDeliveryRefundWindowMillis === "number")
                message.postDeliveryRefundWindowMillis = object.postDeliveryRefundWindowMillis;
            else if (typeof object.postDeliveryRefundWindowMillis === "object")
                message.postDeliveryRefundWindowMillis = new $util.LongBits(object.postDeliveryRefundWindowMillis.low >>> 0, object.postDeliveryRefundWindowMillis.high >>> 0).toNumber();
        return message;
    };

    /**
     * Creates a plain object from a LibraryAppDetails message. Also converts values to other types if specified.
     * @function toObject
     * @memberof LibraryAppDetails
     * @static
     * @param {LibraryAppDetails} message LibraryAppDetails
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    LibraryAppDetails.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        var object = {};
        if (options.defaults) {
            object.certificateHash = "";
            if ($util.Long) {
                var long = new $util.Long(0, 0, false);
                object.refundTimeoutTimestamp = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
            } else
                object.refundTimeoutTimestamp = options.longs === String ? "0" : 0;
            if ($util.Long) {
                var long = new $util.Long(0, 0, false);
                object.postDeliveryRefundWindowMillis = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
            } else
                object.postDeliveryRefundWindowMillis = options.longs === String ? "0" : 0;
        }
        if (message.certificateHash != null && message.hasOwnProperty("certificateHash"))
            object.certificateHash = message.certificateHash;
        if (message.refundTimeoutTimestamp != null && message.hasOwnProperty("refundTimeoutTimestamp"))
            if (typeof message.refundTimeoutTimestamp === "number")
                object.refundTimeoutTimestamp = options.longs === String ? String(message.refundTimeoutTimestamp) : message.refundTimeoutTimestamp;
            else
                object.refundTimeoutTimestamp = options.longs === String ? $util.Long.prototype.toString.call(message.refundTimeoutTimestamp) : options.longs === Number ? new $util.LongBits(message.refundTimeoutTimestamp.low >>> 0, message.refundTimeoutTimestamp.high >>> 0).toNumber() : message.refundTimeoutTimestamp;
        if (message.postDeliveryRefundWindowMillis != null && message.hasOwnProperty("postDeliveryRefundWindowMillis"))
            if (typeof message.postDeliveryRefundWindowMillis === "number")
                object.postDeliveryRefundWindowMillis = options.longs === String ? String(message.postDeliveryRefundWindowMillis) : message.postDeliveryRefundWindowMillis;
            else
                object.postDeliveryRefundWindowMillis = options.longs === String ? $util.Long.prototype.toString.call(message.postDeliveryRefundWindowMillis) : options.longs === Number ? new $util.LongBits(message.postDeliveryRefundWindowMillis.low >>> 0, message.postDeliveryRefundWindowMillis.high >>> 0).toNumber() : message.postDeliveryRefundWindowMillis;
        return object;
    };

    /**
     * Converts this LibraryAppDetails to JSON.
     * @function toJSON
     * @memberof LibraryAppDetails
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    LibraryAppDetails.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return LibraryAppDetails;
})();

$root.LibraryInAppDetails = (function() {

    /**
     * Properties of a LibraryInAppDetails.
     * @exports ILibraryInAppDetails
     * @interface ILibraryInAppDetails
     * @property {string|null} [signedPurchaseData] LibraryInAppDetails signedPurchaseData
     * @property {string|null} [signature] LibraryInAppDetails signature
     */

    /**
     * Constructs a new LibraryInAppDetails.
     * @exports LibraryInAppDetails
     * @classdesc Represents a LibraryInAppDetails.
     * @implements ILibraryInAppDetails
     * @constructor
     * @param {ILibraryInAppDetails=} [properties] Properties to set
     */
    function LibraryInAppDetails(properties) {
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * LibraryInAppDetails signedPurchaseData.
     * @member {string} signedPurchaseData
     * @memberof LibraryInAppDetails
     * @instance
     */
    LibraryInAppDetails.prototype.signedPurchaseData = "";

    /**
     * LibraryInAppDetails signature.
     * @member {string} signature
     * @memberof LibraryInAppDetails
     * @instance
     */
    LibraryInAppDetails.prototype.signature = "";

    /**
     * Creates a new LibraryInAppDetails instance using the specified properties.
     * @function create
     * @memberof LibraryInAppDetails
     * @static
     * @param {ILibraryInAppDetails=} [properties] Properties to set
     * @returns {LibraryInAppDetails} LibraryInAppDetails instance
     */
    LibraryInAppDetails.create = function create(properties) {
        return new LibraryInAppDetails(properties);
    };

    /**
     * Encodes the specified LibraryInAppDetails message. Does not implicitly {@link LibraryInAppDetails.verify|verify} messages.
     * @function encode
     * @memberof LibraryInAppDetails
     * @static
     * @param {ILibraryInAppDetails} message LibraryInAppDetails message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    LibraryInAppDetails.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.signedPurchaseData != null && Object.hasOwnProperty.call(message, "signedPurchaseData"))
            writer.uint32(/* id 1, wireType 2 =*/10).string(message.signedPurchaseData);
        if (message.signature != null && Object.hasOwnProperty.call(message, "signature"))
            writer.uint32(/* id 2, wireType 2 =*/18).string(message.signature);
        return writer;
    };

    /**
     * Encodes the specified LibraryInAppDetails message, length delimited. Does not implicitly {@link LibraryInAppDetails.verify|verify} messages.
     * @function encodeDelimited
     * @memberof LibraryInAppDetails
     * @static
     * @param {ILibraryInAppDetails} message LibraryInAppDetails message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    LibraryInAppDetails.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a LibraryInAppDetails message from the specified reader or buffer.
     * @function decode
     * @memberof LibraryInAppDetails
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {LibraryInAppDetails} LibraryInAppDetails
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    LibraryInAppDetails.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.LibraryInAppDetails();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.signedPurchaseData = reader.string();
                break;
            case 2:
                message.signature = reader.string();
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a LibraryInAppDetails message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof LibraryInAppDetails
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {LibraryInAppDetails} LibraryInAppDetails
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    LibraryInAppDetails.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a LibraryInAppDetails message.
     * @function verify
     * @memberof LibraryInAppDetails
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    LibraryInAppDetails.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.signedPurchaseData != null && message.hasOwnProperty("signedPurchaseData"))
            if (!$util.isString(message.signedPurchaseData))
                return "signedPurchaseData: string expected";
        if (message.signature != null && message.hasOwnProperty("signature"))
            if (!$util.isString(message.signature))
                return "signature: string expected";
        return null;
    };

    /**
     * Creates a LibraryInAppDetails message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof LibraryInAppDetails
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {LibraryInAppDetails} LibraryInAppDetails
     */
    LibraryInAppDetails.fromObject = function fromObject(object) {
        if (object instanceof $root.LibraryInAppDetails)
            return object;
        var message = new $root.LibraryInAppDetails();
        if (object.signedPurchaseData != null)
            message.signedPurchaseData = String(object.signedPurchaseData);
        if (object.signature != null)
            message.signature = String(object.signature);
        return message;
    };

    /**
     * Creates a plain object from a LibraryInAppDetails message. Also converts values to other types if specified.
     * @function toObject
     * @memberof LibraryInAppDetails
     * @static
     * @param {LibraryInAppDetails} message LibraryInAppDetails
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    LibraryInAppDetails.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        var object = {};
        if (options.defaults) {
            object.signedPurchaseData = "";
            object.signature = "";
        }
        if (message.signedPurchaseData != null && message.hasOwnProperty("signedPurchaseData"))
            object.signedPurchaseData = message.signedPurchaseData;
        if (message.signature != null && message.hasOwnProperty("signature"))
            object.signature = message.signature;
        return object;
    };

    /**
     * Converts this LibraryInAppDetails to JSON.
     * @function toJSON
     * @memberof LibraryInAppDetails
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    LibraryInAppDetails.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return LibraryInAppDetails;
})();

$root.LibraryMutation = (function() {

    /**
     * Properties of a LibraryMutation.
     * @exports ILibraryMutation
     * @interface ILibraryMutation
     * @property {IDocId|null} [DocId] LibraryMutation DocId
     * @property {number|null} [offerType] LibraryMutation offerType
     * @property {number|Long|null} [documentHash] LibraryMutation documentHash
     * @property {boolean|null} [deleted] LibraryMutation deleted
     * @property {ILibraryAppDetails|null} [appDetails] LibraryMutation appDetails
     * @property {ILibrarySubscriptionDetails|null} [subscriptionDetails] LibraryMutation subscriptionDetails
     * @property {ILibraryInAppDetails|null} [inAppDetails] LibraryMutation inAppDetails
     */

    /**
     * Constructs a new LibraryMutation.
     * @exports LibraryMutation
     * @classdesc Represents a LibraryMutation.
     * @implements ILibraryMutation
     * @constructor
     * @param {ILibraryMutation=} [properties] Properties to set
     */
    function LibraryMutation(properties) {
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * LibraryMutation DocId.
     * @member {IDocId|null|undefined} DocId
     * @memberof LibraryMutation
     * @instance
     */
    LibraryMutation.prototype.DocId = null;

    /**
     * LibraryMutation offerType.
     * @member {number} offerType
     * @memberof LibraryMutation
     * @instance
     */
    LibraryMutation.prototype.offerType = 0;

    /**
     * LibraryMutation documentHash.
     * @member {number|Long} documentHash
     * @memberof LibraryMutation
     * @instance
     */
    LibraryMutation.prototype.documentHash = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

    /**
     * LibraryMutation deleted.
     * @member {boolean} deleted
     * @memberof LibraryMutation
     * @instance
     */
    LibraryMutation.prototype.deleted = false;

    /**
     * LibraryMutation appDetails.
     * @member {ILibraryAppDetails|null|undefined} appDetails
     * @memberof LibraryMutation
     * @instance
     */
    LibraryMutation.prototype.appDetails = null;

    /**
     * LibraryMutation subscriptionDetails.
     * @member {ILibrarySubscriptionDetails|null|undefined} subscriptionDetails
     * @memberof LibraryMutation
     * @instance
     */
    LibraryMutation.prototype.subscriptionDetails = null;

    /**
     * LibraryMutation inAppDetails.
     * @member {ILibraryInAppDetails|null|undefined} inAppDetails
     * @memberof LibraryMutation
     * @instance
     */
    LibraryMutation.prototype.inAppDetails = null;

    /**
     * Creates a new LibraryMutation instance using the specified properties.
     * @function create
     * @memberof LibraryMutation
     * @static
     * @param {ILibraryMutation=} [properties] Properties to set
     * @returns {LibraryMutation} LibraryMutation instance
     */
    LibraryMutation.create = function create(properties) {
        return new LibraryMutation(properties);
    };

    /**
     * Encodes the specified LibraryMutation message. Does not implicitly {@link LibraryMutation.verify|verify} messages.
     * @function encode
     * @memberof LibraryMutation
     * @static
     * @param {ILibraryMutation} message LibraryMutation message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    LibraryMutation.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.DocId != null && Object.hasOwnProperty.call(message, "DocId"))
            $root.DocId.encode(message.DocId, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
        if (message.offerType != null && Object.hasOwnProperty.call(message, "offerType"))
            writer.uint32(/* id 2, wireType 0 =*/16).int32(message.offerType);
        if (message.documentHash != null && Object.hasOwnProperty.call(message, "documentHash"))
            writer.uint32(/* id 3, wireType 0 =*/24).int64(message.documentHash);
        if (message.deleted != null && Object.hasOwnProperty.call(message, "deleted"))
            writer.uint32(/* id 4, wireType 0 =*/32).bool(message.deleted);
        if (message.appDetails != null && Object.hasOwnProperty.call(message, "appDetails"))
            $root.LibraryAppDetails.encode(message.appDetails, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
        if (message.subscriptionDetails != null && Object.hasOwnProperty.call(message, "subscriptionDetails"))
            $root.LibrarySubscriptionDetails.encode(message.subscriptionDetails, writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
        if (message.inAppDetails != null && Object.hasOwnProperty.call(message, "inAppDetails"))
            $root.LibraryInAppDetails.encode(message.inAppDetails, writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
        return writer;
    };

    /**
     * Encodes the specified LibraryMutation message, length delimited. Does not implicitly {@link LibraryMutation.verify|verify} messages.
     * @function encodeDelimited
     * @memberof LibraryMutation
     * @static
     * @param {ILibraryMutation} message LibraryMutation message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    LibraryMutation.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a LibraryMutation message from the specified reader or buffer.
     * @function decode
     * @memberof LibraryMutation
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {LibraryMutation} LibraryMutation
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    LibraryMutation.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.LibraryMutation();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.DocId = $root.DocId.decode(reader, reader.uint32());
                break;
            case 2:
                message.offerType = reader.int32();
                break;
            case 3:
                message.documentHash = reader.int64();
                break;
            case 4:
                message.deleted = reader.bool();
                break;
            case 5:
                message.appDetails = $root.LibraryAppDetails.decode(reader, reader.uint32());
                break;
            case 6:
                message.subscriptionDetails = $root.LibrarySubscriptionDetails.decode(reader, reader.uint32());
                break;
            case 7:
                message.inAppDetails = $root.LibraryInAppDetails.decode(reader, reader.uint32());
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a LibraryMutation message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof LibraryMutation
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {LibraryMutation} LibraryMutation
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    LibraryMutation.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a LibraryMutation message.
     * @function verify
     * @memberof LibraryMutation
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    LibraryMutation.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.DocId != null && message.hasOwnProperty("DocId")) {
            var error = $root.DocId.verify(message.DocId);
            if (error)
                return "DocId." + error;
        }
        if (message.offerType != null && message.hasOwnProperty("offerType"))
            if (!$util.isInteger(message.offerType))
                return "offerType: integer expected";
        if (message.documentHash != null && message.hasOwnProperty("documentHash"))
            if (!$util.isInteger(message.documentHash) && !(message.documentHash && $util.isInteger(message.documentHash.low) && $util.isInteger(message.documentHash.high)))
                return "documentHash: integer|Long expected";
        if (message.deleted != null && message.hasOwnProperty("deleted"))
            if (typeof message.deleted !== "boolean")
                return "deleted: boolean expected";
        if (message.appDetails != null && message.hasOwnProperty("appDetails")) {
            var error = $root.LibraryAppDetails.verify(message.appDetails);
            if (error)
                return "appDetails." + error;
        }
        if (message.subscriptionDetails != null && message.hasOwnProperty("subscriptionDetails")) {
            var error = $root.LibrarySubscriptionDetails.verify(message.subscriptionDetails);
            if (error)
                return "subscriptionDetails." + error;
        }
        if (message.inAppDetails != null && message.hasOwnProperty("inAppDetails")) {
            var error = $root.LibraryInAppDetails.verify(message.inAppDetails);
            if (error)
                return "inAppDetails." + error;
        }
        return null;
    };

    /**
     * Creates a LibraryMutation message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof LibraryMutation
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {LibraryMutation} LibraryMutation
     */
    LibraryMutation.fromObject = function fromObject(object) {
        if (object instanceof $root.LibraryMutation)
            return object;
        var message = new $root.LibraryMutation();
        if (object.DocId != null) {
            if (typeof object.DocId !== "object")
                throw TypeError(".LibraryMutation.DocId: object expected");
            message.DocId = $root.DocId.fromObject(object.DocId);
        }
        if (object.offerType != null)
            message.offerType = object.offerType | 0;
        if (object.documentHash != null)
            if ($util.Long)
                (message.documentHash = $util.Long.fromValue(object.documentHash)).unsigned = false;
            else if (typeof object.documentHash === "string")
                message.documentHash = parseInt(object.documentHash, 10);
            else if (typeof object.documentHash === "number")
                message.documentHash = object.documentHash;
            else if (typeof object.documentHash === "object")
                message.documentHash = new $util.LongBits(object.documentHash.low >>> 0, object.documentHash.high >>> 0).toNumber();
        if (object.deleted != null)
            message.deleted = Boolean(object.deleted);
        if (object.appDetails != null) {
            if (typeof object.appDetails !== "object")
                throw TypeError(".LibraryMutation.appDetails: object expected");
            message.appDetails = $root.LibraryAppDetails.fromObject(object.appDetails);
        }
        if (object.subscriptionDetails != null) {
            if (typeof object.subscriptionDetails !== "object")
                throw TypeError(".LibraryMutation.subscriptionDetails: object expected");
            message.subscriptionDetails = $root.LibrarySubscriptionDetails.fromObject(object.subscriptionDetails);
        }
        if (object.inAppDetails != null) {
            if (typeof object.inAppDetails !== "object")
                throw TypeError(".LibraryMutation.inAppDetails: object expected");
            message.inAppDetails = $root.LibraryInAppDetails.fromObject(object.inAppDetails);
        }
        return message;
    };

    /**
     * Creates a plain object from a LibraryMutation message. Also converts values to other types if specified.
     * @function toObject
     * @memberof LibraryMutation
     * @static
     * @param {LibraryMutation} message LibraryMutation
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    LibraryMutation.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        var object = {};
        if (options.defaults) {
            object.DocId = null;
            object.offerType = 0;
            if ($util.Long) {
                var long = new $util.Long(0, 0, false);
                object.documentHash = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
            } else
                object.documentHash = options.longs === String ? "0" : 0;
            object.deleted = false;
            object.appDetails = null;
            object.subscriptionDetails = null;
            object.inAppDetails = null;
        }
        if (message.DocId != null && message.hasOwnProperty("DocId"))
            object.DocId = $root.DocId.toObject(message.DocId, options);
        if (message.offerType != null && message.hasOwnProperty("offerType"))
            object.offerType = message.offerType;
        if (message.documentHash != null && message.hasOwnProperty("documentHash"))
            if (typeof message.documentHash === "number")
                object.documentHash = options.longs === String ? String(message.documentHash) : message.documentHash;
            else
                object.documentHash = options.longs === String ? $util.Long.prototype.toString.call(message.documentHash) : options.longs === Number ? new $util.LongBits(message.documentHash.low >>> 0, message.documentHash.high >>> 0).toNumber() : message.documentHash;
        if (message.deleted != null && message.hasOwnProperty("deleted"))
            object.deleted = message.deleted;
        if (message.appDetails != null && message.hasOwnProperty("appDetails"))
            object.appDetails = $root.LibraryAppDetails.toObject(message.appDetails, options);
        if (message.subscriptionDetails != null && message.hasOwnProperty("subscriptionDetails"))
            object.subscriptionDetails = $root.LibrarySubscriptionDetails.toObject(message.subscriptionDetails, options);
        if (message.inAppDetails != null && message.hasOwnProperty("inAppDetails"))
            object.inAppDetails = $root.LibraryInAppDetails.toObject(message.inAppDetails, options);
        return object;
    };

    /**
     * Converts this LibraryMutation to JSON.
     * @function toJSON
     * @memberof LibraryMutation
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    LibraryMutation.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return LibraryMutation;
})();

$root.LibrarySubscriptionDetails = (function() {

    /**
     * Properties of a LibrarySubscriptionDetails.
     * @exports ILibrarySubscriptionDetails
     * @interface ILibrarySubscriptionDetails
     * @property {number|Long|null} [initiationTimestamp] LibrarySubscriptionDetails initiationTimestamp
     * @property {number|Long|null} [validUntilTimestamp] LibrarySubscriptionDetails validUntilTimestamp
     * @property {boolean|null} [autoRenewing] LibrarySubscriptionDetails autoRenewing
     * @property {number|Long|null} [trialUntilTimestamp] LibrarySubscriptionDetails trialUntilTimestamp
     * @property {string|null} [signedPurchaseData] LibrarySubscriptionDetails signedPurchaseData
     * @property {string|null} [signature] LibrarySubscriptionDetails signature
     */

    /**
     * Constructs a new LibrarySubscriptionDetails.
     * @exports LibrarySubscriptionDetails
     * @classdesc Represents a LibrarySubscriptionDetails.
     * @implements ILibrarySubscriptionDetails
     * @constructor
     * @param {ILibrarySubscriptionDetails=} [properties] Properties to set
     */
    function LibrarySubscriptionDetails(properties) {
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * LibrarySubscriptionDetails initiationTimestamp.
     * @member {number|Long} initiationTimestamp
     * @memberof LibrarySubscriptionDetails
     * @instance
     */
    LibrarySubscriptionDetails.prototype.initiationTimestamp = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

    /**
     * LibrarySubscriptionDetails validUntilTimestamp.
     * @member {number|Long} validUntilTimestamp
     * @memberof LibrarySubscriptionDetails
     * @instance
     */
    LibrarySubscriptionDetails.prototype.validUntilTimestamp = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

    /**
     * LibrarySubscriptionDetails autoRenewing.
     * @member {boolean} autoRenewing
     * @memberof LibrarySubscriptionDetails
     * @instance
     */
    LibrarySubscriptionDetails.prototype.autoRenewing = false;

    /**
     * LibrarySubscriptionDetails trialUntilTimestamp.
     * @member {number|Long} trialUntilTimestamp
     * @memberof LibrarySubscriptionDetails
     * @instance
     */
    LibrarySubscriptionDetails.prototype.trialUntilTimestamp = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

    /**
     * LibrarySubscriptionDetails signedPurchaseData.
     * @member {string} signedPurchaseData
     * @memberof LibrarySubscriptionDetails
     * @instance
     */
    LibrarySubscriptionDetails.prototype.signedPurchaseData = "";

    /**
     * LibrarySubscriptionDetails signature.
     * @member {string} signature
     * @memberof LibrarySubscriptionDetails
     * @instance
     */
    LibrarySubscriptionDetails.prototype.signature = "";

    /**
     * Creates a new LibrarySubscriptionDetails instance using the specified properties.
     * @function create
     * @memberof LibrarySubscriptionDetails
     * @static
     * @param {ILibrarySubscriptionDetails=} [properties] Properties to set
     * @returns {LibrarySubscriptionDetails} LibrarySubscriptionDetails instance
     */
    LibrarySubscriptionDetails.create = function create(properties) {
        return new LibrarySubscriptionDetails(properties);
    };

    /**
     * Encodes the specified LibrarySubscriptionDetails message. Does not implicitly {@link LibrarySubscriptionDetails.verify|verify} messages.
     * @function encode
     * @memberof LibrarySubscriptionDetails
     * @static
     * @param {ILibrarySubscriptionDetails} message LibrarySubscriptionDetails message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    LibrarySubscriptionDetails.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.initiationTimestamp != null && Object.hasOwnProperty.call(message, "initiationTimestamp"))
            writer.uint32(/* id 1, wireType 0 =*/8).int64(message.initiationTimestamp);
        if (message.validUntilTimestamp != null && Object.hasOwnProperty.call(message, "validUntilTimestamp"))
            writer.uint32(/* id 2, wireType 0 =*/16).int64(message.validUntilTimestamp);
        if (message.autoRenewing != null && Object.hasOwnProperty.call(message, "autoRenewing"))
            writer.uint32(/* id 3, wireType 0 =*/24).bool(message.autoRenewing);
        if (message.trialUntilTimestamp != null && Object.hasOwnProperty.call(message, "trialUntilTimestamp"))
            writer.uint32(/* id 4, wireType 0 =*/32).int64(message.trialUntilTimestamp);
        if (message.signedPurchaseData != null && Object.hasOwnProperty.call(message, "signedPurchaseData"))
            writer.uint32(/* id 5, wireType 2 =*/42).string(message.signedPurchaseData);
        if (message.signature != null && Object.hasOwnProperty.call(message, "signature"))
            writer.uint32(/* id 6, wireType 2 =*/50).string(message.signature);
        return writer;
    };

    /**
     * Encodes the specified LibrarySubscriptionDetails message, length delimited. Does not implicitly {@link LibrarySubscriptionDetails.verify|verify} messages.
     * @function encodeDelimited
     * @memberof LibrarySubscriptionDetails
     * @static
     * @param {ILibrarySubscriptionDetails} message LibrarySubscriptionDetails message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    LibrarySubscriptionDetails.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a LibrarySubscriptionDetails message from the specified reader or buffer.
     * @function decode
     * @memberof LibrarySubscriptionDetails
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {LibrarySubscriptionDetails} LibrarySubscriptionDetails
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    LibrarySubscriptionDetails.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.LibrarySubscriptionDetails();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.initiationTimestamp = reader.int64();
                break;
            case 2:
                message.validUntilTimestamp = reader.int64();
                break;
            case 3:
                message.autoRenewing = reader.bool();
                break;
            case 4:
                message.trialUntilTimestamp = reader.int64();
                break;
            case 5:
                message.signedPurchaseData = reader.string();
                break;
            case 6:
                message.signature = reader.string();
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a LibrarySubscriptionDetails message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof LibrarySubscriptionDetails
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {LibrarySubscriptionDetails} LibrarySubscriptionDetails
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    LibrarySubscriptionDetails.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a LibrarySubscriptionDetails message.
     * @function verify
     * @memberof LibrarySubscriptionDetails
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    LibrarySubscriptionDetails.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.initiationTimestamp != null && message.hasOwnProperty("initiationTimestamp"))
            if (!$util.isInteger(message.initiationTimestamp) && !(message.initiationTimestamp && $util.isInteger(message.initiationTimestamp.low) && $util.isInteger(message.initiationTimestamp.high)))
                return "initiationTimestamp: integer|Long expected";
        if (message.validUntilTimestamp != null && message.hasOwnProperty("validUntilTimestamp"))
            if (!$util.isInteger(message.validUntilTimestamp) && !(message.validUntilTimestamp && $util.isInteger(message.validUntilTimestamp.low) && $util.isInteger(message.validUntilTimestamp.high)))
                return "validUntilTimestamp: integer|Long expected";
        if (message.autoRenewing != null && message.hasOwnProperty("autoRenewing"))
            if (typeof message.autoRenewing !== "boolean")
                return "autoRenewing: boolean expected";
        if (message.trialUntilTimestamp != null && message.hasOwnProperty("trialUntilTimestamp"))
            if (!$util.isInteger(message.trialUntilTimestamp) && !(message.trialUntilTimestamp && $util.isInteger(message.trialUntilTimestamp.low) && $util.isInteger(message.trialUntilTimestamp.high)))
                return "trialUntilTimestamp: integer|Long expected";
        if (message.signedPurchaseData != null && message.hasOwnProperty("signedPurchaseData"))
            if (!$util.isString(message.signedPurchaseData))
                return "signedPurchaseData: string expected";
        if (message.signature != null && message.hasOwnProperty("signature"))
            if (!$util.isString(message.signature))
                return "signature: string expected";
        return null;
    };

    /**
     * Creates a LibrarySubscriptionDetails message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof LibrarySubscriptionDetails
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {LibrarySubscriptionDetails} LibrarySubscriptionDetails
     */
    LibrarySubscriptionDetails.fromObject = function fromObject(object) {
        if (object instanceof $root.LibrarySubscriptionDetails)
            return object;
        var message = new $root.LibrarySubscriptionDetails();
        if (object.initiationTimestamp != null)
            if ($util.Long)
                (message.initiationTimestamp = $util.Long.fromValue(object.initiationTimestamp)).unsigned = false;
            else if (typeof object.initiationTimestamp === "string")
                message.initiationTimestamp = parseInt(object.initiationTimestamp, 10);
            else if (typeof object.initiationTimestamp === "number")
                message.initiationTimestamp = object.initiationTimestamp;
            else if (typeof object.initiationTimestamp === "object")
                message.initiationTimestamp = new $util.LongBits(object.initiationTimestamp.low >>> 0, object.initiationTimestamp.high >>> 0).toNumber();
        if (object.validUntilTimestamp != null)
            if ($util.Long)
                (message.validUntilTimestamp = $util.Long.fromValue(object.validUntilTimestamp)).unsigned = false;
            else if (typeof object.validUntilTimestamp === "string")
                message.validUntilTimestamp = parseInt(object.validUntilTimestamp, 10);
            else if (typeof object.validUntilTimestamp === "number")
                message.validUntilTimestamp = object.validUntilTimestamp;
            else if (typeof object.validUntilTimestamp === "object")
                message.validUntilTimestamp = new $util.LongBits(object.validUntilTimestamp.low >>> 0, object.validUntilTimestamp.high >>> 0).toNumber();
        if (object.autoRenewing != null)
            message.autoRenewing = Boolean(object.autoRenewing);
        if (object.trialUntilTimestamp != null)
            if ($util.Long)
                (message.trialUntilTimestamp = $util.Long.fromValue(object.trialUntilTimestamp)).unsigned = false;
            else if (typeof object.trialUntilTimestamp === "string")
                message.trialUntilTimestamp = parseInt(object.trialUntilTimestamp, 10);
            else if (typeof object.trialUntilTimestamp === "number")
                message.trialUntilTimestamp = object.trialUntilTimestamp;
            else if (typeof object.trialUntilTimestamp === "object")
                message.trialUntilTimestamp = new $util.LongBits(object.trialUntilTimestamp.low >>> 0, object.trialUntilTimestamp.high >>> 0).toNumber();
        if (object.signedPurchaseData != null)
            message.signedPurchaseData = String(object.signedPurchaseData);
        if (object.signature != null)
            message.signature = String(object.signature);
        return message;
    };

    /**
     * Creates a plain object from a LibrarySubscriptionDetails message. Also converts values to other types if specified.
     * @function toObject
     * @memberof LibrarySubscriptionDetails
     * @static
     * @param {LibrarySubscriptionDetails} message LibrarySubscriptionDetails
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    LibrarySubscriptionDetails.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        var object = {};
        if (options.defaults) {
            if ($util.Long) {
                var long = new $util.Long(0, 0, false);
                object.initiationTimestamp = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
            } else
                object.initiationTimestamp = options.longs === String ? "0" : 0;
            if ($util.Long) {
                var long = new $util.Long(0, 0, false);
                object.validUntilTimestamp = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
            } else
                object.validUntilTimestamp = options.longs === String ? "0" : 0;
            object.autoRenewing = false;
            if ($util.Long) {
                var long = new $util.Long(0, 0, false);
                object.trialUntilTimestamp = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
            } else
                object.trialUntilTimestamp = options.longs === String ? "0" : 0;
            object.signedPurchaseData = "";
            object.signature = "";
        }
        if (message.initiationTimestamp != null && message.hasOwnProperty("initiationTimestamp"))
            if (typeof message.initiationTimestamp === "number")
                object.initiationTimestamp = options.longs === String ? String(message.initiationTimestamp) : message.initiationTimestamp;
            else
                object.initiationTimestamp = options.longs === String ? $util.Long.prototype.toString.call(message.initiationTimestamp) : options.longs === Number ? new $util.LongBits(message.initiationTimestamp.low >>> 0, message.initiationTimestamp.high >>> 0).toNumber() : message.initiationTimestamp;
        if (message.validUntilTimestamp != null && message.hasOwnProperty("validUntilTimestamp"))
            if (typeof message.validUntilTimestamp === "number")
                object.validUntilTimestamp = options.longs === String ? String(message.validUntilTimestamp) : message.validUntilTimestamp;
            else
                object.validUntilTimestamp = options.longs === String ? $util.Long.prototype.toString.call(message.validUntilTimestamp) : options.longs === Number ? new $util.LongBits(message.validUntilTimestamp.low >>> 0, message.validUntilTimestamp.high >>> 0).toNumber() : message.validUntilTimestamp;
        if (message.autoRenewing != null && message.hasOwnProperty("autoRenewing"))
            object.autoRenewing = message.autoRenewing;
        if (message.trialUntilTimestamp != null && message.hasOwnProperty("trialUntilTimestamp"))
            if (typeof message.trialUntilTimestamp === "number")
                object.trialUntilTimestamp = options.longs === String ? String(message.trialUntilTimestamp) : message.trialUntilTimestamp;
            else
                object.trialUntilTimestamp = options.longs === String ? $util.Long.prototype.toString.call(message.trialUntilTimestamp) : options.longs === Number ? new $util.LongBits(message.trialUntilTimestamp.low >>> 0, message.trialUntilTimestamp.high >>> 0).toNumber() : message.trialUntilTimestamp;
        if (message.signedPurchaseData != null && message.hasOwnProperty("signedPurchaseData"))
            object.signedPurchaseData = message.signedPurchaseData;
        if (message.signature != null && message.hasOwnProperty("signature"))
            object.signature = message.signature;
        return object;
    };

    /**
     * Converts this LibrarySubscriptionDetails to JSON.
     * @function toJSON
     * @memberof LibrarySubscriptionDetails
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    LibrarySubscriptionDetails.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return LibrarySubscriptionDetails;
})();

$root.LibraryUpdate = (function() {

    /**
     * Properties of a LibraryUpdate.
     * @exports ILibraryUpdate
     * @interface ILibraryUpdate
     * @property {number|null} [status] LibraryUpdate status
     * @property {number|null} [corpus] LibraryUpdate corpus
     * @property {Uint8Array|null} [serverToken] LibraryUpdate serverToken
     * @property {Array.<ILibraryMutation>|null} [mutation] LibraryUpdate mutation
     * @property {boolean|null} [hasMore] LibraryUpdate hasMore
     * @property {string|null} [libraryId] LibraryUpdate libraryId
     */

    /**
     * Constructs a new LibraryUpdate.
     * @exports LibraryUpdate
     * @classdesc Represents a LibraryUpdate.
     * @implements ILibraryUpdate
     * @constructor
     * @param {ILibraryUpdate=} [properties] Properties to set
     */
    function LibraryUpdate(properties) {
        this.mutation = [];
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * LibraryUpdate status.
     * @member {number} status
     * @memberof LibraryUpdate
     * @instance
     */
    LibraryUpdate.prototype.status = 0;

    /**
     * LibraryUpdate corpus.
     * @member {number} corpus
     * @memberof LibraryUpdate
     * @instance
     */
    LibraryUpdate.prototype.corpus = 0;

    /**
     * LibraryUpdate serverToken.
     * @member {Uint8Array} serverToken
     * @memberof LibraryUpdate
     * @instance
     */
    LibraryUpdate.prototype.serverToken = $util.newBuffer([]);

    /**
     * LibraryUpdate mutation.
     * @member {Array.<ILibraryMutation>} mutation
     * @memberof LibraryUpdate
     * @instance
     */
    LibraryUpdate.prototype.mutation = $util.emptyArray;

    /**
     * LibraryUpdate hasMore.
     * @member {boolean} hasMore
     * @memberof LibraryUpdate
     * @instance
     */
    LibraryUpdate.prototype.hasMore = false;

    /**
     * LibraryUpdate libraryId.
     * @member {string} libraryId
     * @memberof LibraryUpdate
     * @instance
     */
    LibraryUpdate.prototype.libraryId = "";

    /**
     * Creates a new LibraryUpdate instance using the specified properties.
     * @function create
     * @memberof LibraryUpdate
     * @static
     * @param {ILibraryUpdate=} [properties] Properties to set
     * @returns {LibraryUpdate} LibraryUpdate instance
     */
    LibraryUpdate.create = function create(properties) {
        return new LibraryUpdate(properties);
    };

    /**
     * Encodes the specified LibraryUpdate message. Does not implicitly {@link LibraryUpdate.verify|verify} messages.
     * @function encode
     * @memberof LibraryUpdate
     * @static
     * @param {ILibraryUpdate} message LibraryUpdate message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    LibraryUpdate.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.status != null && Object.hasOwnProperty.call(message, "status"))
            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.status);
        if (message.corpus != null && Object.hasOwnProperty.call(message, "corpus"))
            writer.uint32(/* id 2, wireType 0 =*/16).int32(message.corpus);
        if (message.serverToken != null && Object.hasOwnProperty.call(message, "serverToken"))
            writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.serverToken);
        if (message.mutation != null && message.mutation.length)
            for (var i = 0; i < message.mutation.length; ++i)
                $root.LibraryMutation.encode(message.mutation[i], writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
        if (message.hasMore != null && Object.hasOwnProperty.call(message, "hasMore"))
            writer.uint32(/* id 5, wireType 0 =*/40).bool(message.hasMore);
        if (message.libraryId != null && Object.hasOwnProperty.call(message, "libraryId"))
            writer.uint32(/* id 6, wireType 2 =*/50).string(message.libraryId);
        return writer;
    };

    /**
     * Encodes the specified LibraryUpdate message, length delimited. Does not implicitly {@link LibraryUpdate.verify|verify} messages.
     * @function encodeDelimited
     * @memberof LibraryUpdate
     * @static
     * @param {ILibraryUpdate} message LibraryUpdate message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    LibraryUpdate.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a LibraryUpdate message from the specified reader or buffer.
     * @function decode
     * @memberof LibraryUpdate
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {LibraryUpdate} LibraryUpdate
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    LibraryUpdate.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.LibraryUpdate();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.status = reader.int32();
                break;
            case 2:
                message.corpus = reader.int32();
                break;
            case 3:
                message.serverToken = reader.bytes();
                break;
            case 4:
                if (!(message.mutation && message.mutation.length))
                    message.mutation = [];
                message.mutation.push($root.LibraryMutation.decode(reader, reader.uint32()));
                break;
            case 5:
                message.hasMore = reader.bool();
                break;
            case 6:
                message.libraryId = reader.string();
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a LibraryUpdate message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof LibraryUpdate
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {LibraryUpdate} LibraryUpdate
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    LibraryUpdate.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a LibraryUpdate message.
     * @function verify
     * @memberof LibraryUpdate
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    LibraryUpdate.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.status != null && message.hasOwnProperty("status"))
            if (!$util.isInteger(message.status))
                return "status: integer expected";
        if (message.corpus != null && message.hasOwnProperty("corpus"))
            if (!$util.isInteger(message.corpus))
                return "corpus: integer expected";
        if (message.serverToken != null && message.hasOwnProperty("serverToken"))
            if (!(message.serverToken && typeof message.serverToken.length === "number" || $util.isString(message.serverToken)))
                return "serverToken: buffer expected";
        if (message.mutation != null && message.hasOwnProperty("mutation")) {
            if (!Array.isArray(message.mutation))
                return "mutation: array expected";
            for (var i = 0; i < message.mutation.length; ++i) {
                var error = $root.LibraryMutation.verify(message.mutation[i]);
                if (error)
                    return "mutation." + error;
            }
        }
        if (message.hasMore != null && message.hasOwnProperty("hasMore"))
            if (typeof message.hasMore !== "boolean")
                return "hasMore: boolean expected";
        if (message.libraryId != null && message.hasOwnProperty("libraryId"))
            if (!$util.isString(message.libraryId))
                return "libraryId: string expected";
        return null;
    };

    /**
     * Creates a LibraryUpdate message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof LibraryUpdate
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {LibraryUpdate} LibraryUpdate
     */
    LibraryUpdate.fromObject = function fromObject(object) {
        if (object instanceof $root.LibraryUpdate)
            return object;
        var message = new $root.LibraryUpdate();
        if (object.status != null)
            message.status = object.status | 0;
        if (object.corpus != null)
            message.corpus = object.corpus | 0;
        if (object.serverToken != null)
            if (typeof object.serverToken === "string")
                $util.base64.decode(object.serverToken, message.serverToken = $util.newBuffer($util.base64.length(object.serverToken)), 0);
            else if (object.serverToken.length)
                message.serverToken = object.serverToken;
        if (object.mutation) {
            if (!Array.isArray(object.mutation))
                throw TypeError(".LibraryUpdate.mutation: array expected");
            message.mutation = [];
            for (var i = 0; i < object.mutation.length; ++i) {
                if (typeof object.mutation[i] !== "object")
                    throw TypeError(".LibraryUpdate.mutation: object expected");
                message.mutation[i] = $root.LibraryMutation.fromObject(object.mutation[i]);
            }
        }
        if (object.hasMore != null)
            message.hasMore = Boolean(object.hasMore);
        if (object.libraryId != null)
            message.libraryId = String(object.libraryId);
        return message;
    };

    /**
     * Creates a plain object from a LibraryUpdate message. Also converts values to other types if specified.
     * @function toObject
     * @memberof LibraryUpdate
     * @static
     * @param {LibraryUpdate} message LibraryUpdate
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    LibraryUpdate.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        var object = {};
        if (options.arrays || options.defaults)
            object.mutation = [];
        if (options.defaults) {
            object.status = 0;
            object.corpus = 0;
            if (options.bytes === String)
                object.serverToken = "";
            else {
                object.serverToken = [];
                if (options.bytes !== Array)
                    object.serverToken = $util.newBuffer(object.serverToken);
            }
            object.hasMore = false;
            object.libraryId = "";
        }
        if (message.status != null && message.hasOwnProperty("status"))
            object.status = message.status;
        if (message.corpus != null && message.hasOwnProperty("corpus"))
            object.corpus = message.corpus;
        if (message.serverToken != null && message.hasOwnProperty("serverToken"))
            object.serverToken = options.bytes === String ? $util.base64.encode(message.serverToken, 0, message.serverToken.length) : options.bytes === Array ? Array.prototype.slice.call(message.serverToken) : message.serverToken;
        if (message.mutation && message.mutation.length) {
            object.mutation = [];
            for (var j = 0; j < message.mutation.length; ++j)
                object.mutation[j] = $root.LibraryMutation.toObject(message.mutation[j], options);
        }
        if (message.hasMore != null && message.hasOwnProperty("hasMore"))
            object.hasMore = message.hasMore;
        if (message.libraryId != null && message.hasOwnProperty("libraryId"))
            object.libraryId = message.libraryId;
        return object;
    };

    /**
     * Converts this LibraryUpdate to JSON.
     * @function toJSON
     * @memberof LibraryUpdate
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    LibraryUpdate.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return LibraryUpdate;
})();

$root.AndroidAppNotificationData = (function() {

    /**
     * Properties of an AndroidAppNotificationData.
     * @exports IAndroidAppNotificationData
     * @interface IAndroidAppNotificationData
     * @property {number|null} [versionCode] AndroidAppNotificationData versionCode
     * @property {string|null} [assetId] AndroidAppNotificationData assetId
     */

    /**
     * Constructs a new AndroidAppNotificationData.
     * @exports AndroidAppNotificationData
     * @classdesc Represents an AndroidAppNotificationData.
     * @implements IAndroidAppNotificationData
     * @constructor
     * @param {IAndroidAppNotificationData=} [properties] Properties to set
     */
    function AndroidAppNotificationData(properties) {
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * AndroidAppNotificationData versionCode.
     * @member {number} versionCode
     * @memberof AndroidAppNotificationData
     * @instance
     */
    AndroidAppNotificationData.prototype.versionCode = 0;

    /**
     * AndroidAppNotificationData assetId.
     * @member {string} assetId
     * @memberof AndroidAppNotificationData
     * @instance
     */
    AndroidAppNotificationData.prototype.assetId = "";

    /**
     * Creates a new AndroidAppNotificationData instance using the specified properties.
     * @function create
     * @memberof AndroidAppNotificationData
     * @static
     * @param {IAndroidAppNotificationData=} [properties] Properties to set
     * @returns {AndroidAppNotificationData} AndroidAppNotificationData instance
     */
    AndroidAppNotificationData.create = function create(properties) {
        return new AndroidAppNotificationData(properties);
    };

    /**
     * Encodes the specified AndroidAppNotificationData message. Does not implicitly {@link AndroidAppNotificationData.verify|verify} messages.
     * @function encode
     * @memberof AndroidAppNotificationData
     * @static
     * @param {IAndroidAppNotificationData} message AndroidAppNotificationData message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    AndroidAppNotificationData.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.versionCode != null && Object.hasOwnProperty.call(message, "versionCode"))
            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.versionCode);
        if (message.assetId != null && Object.hasOwnProperty.call(message, "assetId"))
            writer.uint32(/* id 2, wireType 2 =*/18).string(message.assetId);
        return writer;
    };

    /**
     * Encodes the specified AndroidAppNotificationData message, length delimited. Does not implicitly {@link AndroidAppNotificationData.verify|verify} messages.
     * @function encodeDelimited
     * @memberof AndroidAppNotificationData
     * @static
     * @param {IAndroidAppNotificationData} message AndroidAppNotificationData message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    AndroidAppNotificationData.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes an AndroidAppNotificationData message from the specified reader or buffer.
     * @function decode
     * @memberof AndroidAppNotificationData
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {AndroidAppNotificationData} AndroidAppNotificationData
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    AndroidAppNotificationData.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.AndroidAppNotificationData();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.versionCode = reader.int32();
                break;
            case 2:
                message.assetId = reader.string();
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes an AndroidAppNotificationData message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof AndroidAppNotificationData
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {AndroidAppNotificationData} AndroidAppNotificationData
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    AndroidAppNotificationData.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies an AndroidAppNotificationData message.
     * @function verify
     * @memberof AndroidAppNotificationData
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    AndroidAppNotificationData.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.versionCode != null && message.hasOwnProperty("versionCode"))
            if (!$util.isInteger(message.versionCode))
                return "versionCode: integer expected";
        if (message.assetId != null && message.hasOwnProperty("assetId"))
            if (!$util.isString(message.assetId))
                return "assetId: string expected";
        return null;
    };

    /**
     * Creates an AndroidAppNotificationData message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof AndroidAppNotificationData
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {AndroidAppNotificationData} AndroidAppNotificationData
     */
    AndroidAppNotificationData.fromObject = function fromObject(object) {
        if (object instanceof $root.AndroidAppNotificationData)
            return object;
        var message = new $root.AndroidAppNotificationData();
        if (object.versionCode != null)
            message.versionCode = object.versionCode | 0;
        if (object.assetId != null)
            message.assetId = String(object.assetId);
        return message;
    };

    /**
     * Creates a plain object from an AndroidAppNotificationData message. Also converts values to other types if specified.
     * @function toObject
     * @memberof AndroidAppNotificationData
     * @static
     * @param {AndroidAppNotificationData} message AndroidAppNotificationData
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    AndroidAppNotificationData.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        var object = {};
        if (options.defaults) {
            object.versionCode = 0;
            object.assetId = "";
        }
        if (message.versionCode != null && message.hasOwnProperty("versionCode"))
            object.versionCode = message.versionCode;
        if (message.assetId != null && message.hasOwnProperty("assetId"))
            object.assetId = message.assetId;
        return object;
    };

    /**
     * Converts this AndroidAppNotificationData to JSON.
     * @function toJSON
     * @memberof AndroidAppNotificationData
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    AndroidAppNotificationData.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return AndroidAppNotificationData;
})();

$root.InAppNotificationData = (function() {

    /**
     * Properties of an InAppNotificationData.
     * @exports IInAppNotificationData
     * @interface IInAppNotificationData
     * @property {string|null} [checkoutOrderId] InAppNotificationData checkoutOrderId
     * @property {string|null} [inAppNotificationId] InAppNotificationData inAppNotificationId
     */

    /**
     * Constructs a new InAppNotificationData.
     * @exports InAppNotificationData
     * @classdesc Represents an InAppNotificationData.
     * @implements IInAppNotificationData
     * @constructor
     * @param {IInAppNotificationData=} [properties] Properties to set
     */
    function InAppNotificationData(properties) {
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * InAppNotificationData checkoutOrderId.
     * @member {string} checkoutOrderId
     * @memberof InAppNotificationData
     * @instance
     */
    InAppNotificationData.prototype.checkoutOrderId = "";

    /**
     * InAppNotificationData inAppNotificationId.
     * @member {string} inAppNotificationId
     * @memberof InAppNotificationData
     * @instance
     */
    InAppNotificationData.prototype.inAppNotificationId = "";

    /**
     * Creates a new InAppNotificationData instance using the specified properties.
     * @function create
     * @memberof InAppNotificationData
     * @static
     * @param {IInAppNotificationData=} [properties] Properties to set
     * @returns {InAppNotificationData} InAppNotificationData instance
     */
    InAppNotificationData.create = function create(properties) {
        return new InAppNotificationData(properties);
    };

    /**
     * Encodes the specified InAppNotificationData message. Does not implicitly {@link InAppNotificationData.verify|verify} messages.
     * @function encode
     * @memberof InAppNotificationData
     * @static
     * @param {IInAppNotificationData} message InAppNotificationData message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    InAppNotificationData.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.checkoutOrderId != null && Object.hasOwnProperty.call(message, "checkoutOrderId"))
            writer.uint32(/* id 1, wireType 2 =*/10).string(message.checkoutOrderId);
        if (message.inAppNotificationId != null && Object.hasOwnProperty.call(message, "inAppNotificationId"))
            writer.uint32(/* id 2, wireType 2 =*/18).string(message.inAppNotificationId);
        return writer;
    };

    /**
     * Encodes the specified InAppNotificationData message, length delimited. Does not implicitly {@link InAppNotificationData.verify|verify} messages.
     * @function encodeDelimited
     * @memberof InAppNotificationData
     * @static
     * @param {IInAppNotificationData} message InAppNotificationData message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    InAppNotificationData.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes an InAppNotificationData message from the specified reader or buffer.
     * @function decode
     * @memberof InAppNotificationData
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {InAppNotificationData} InAppNotificationData
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    InAppNotificationData.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.InAppNotificationData();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.checkoutOrderId = reader.string();
                break;
            case 2:
                message.inAppNotificationId = reader.string();
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes an InAppNotificationData message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof InAppNotificationData
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {InAppNotificationData} InAppNotificationData
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    InAppNotificationData.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies an InAppNotificationData message.
     * @function verify
     * @memberof InAppNotificationData
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    InAppNotificationData.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.checkoutOrderId != null && message.hasOwnProperty("checkoutOrderId"))
            if (!$util.isString(message.checkoutOrderId))
                return "checkoutOrderId: string expected";
        if (message.inAppNotificationId != null && message.hasOwnProperty("inAppNotificationId"))
            if (!$util.isString(message.inAppNotificationId))
                return "inAppNotificationId: string expected";
        return null;
    };

    /**
     * Creates an InAppNotificationData message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof InAppNotificationData
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {InAppNotificationData} InAppNotificationData
     */
    InAppNotificationData.fromObject = function fromObject(object) {
        if (object instanceof $root.InAppNotificationData)
            return object;
        var message = new $root.InAppNotificationData();
        if (object.checkoutOrderId != null)
            message.checkoutOrderId = String(object.checkoutOrderId);
        if (object.inAppNotificationId != null)
            message.inAppNotificationId = String(object.inAppNotificationId);
        return message;
    };

    /**
     * Creates a plain object from an InAppNotificationData message. Also converts values to other types if specified.
     * @function toObject
     * @memberof InAppNotificationData
     * @static
     * @param {InAppNotificationData} message InAppNotificationData
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    InAppNotificationData.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        var object = {};
        if (options.defaults) {
            object.checkoutOrderId = "";
            object.inAppNotificationId = "";
        }
        if (message.checkoutOrderId != null && message.hasOwnProperty("checkoutOrderId"))
            object.checkoutOrderId = message.checkoutOrderId;
        if (message.inAppNotificationId != null && message.hasOwnProperty("inAppNotificationId"))
            object.inAppNotificationId = message.inAppNotificationId;
        return object;
    };

    /**
     * Converts this InAppNotificationData to JSON.
     * @function toJSON
     * @memberof InAppNotificationData
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    InAppNotificationData.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return InAppNotificationData;
})();

$root.LibraryDirtyData = (function() {

    /**
     * Properties of a LibraryDirtyData.
     * @exports ILibraryDirtyData
     * @interface ILibraryDirtyData
     * @property {number|null} [backend] LibraryDirtyData backend
     * @property {string|null} [libraryId] LibraryDirtyData libraryId
     */

    /**
     * Constructs a new LibraryDirtyData.
     * @exports LibraryDirtyData
     * @classdesc Represents a LibraryDirtyData.
     * @implements ILibraryDirtyData
     * @constructor
     * @param {ILibraryDirtyData=} [properties] Properties to set
     */
    function LibraryDirtyData(properties) {
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * LibraryDirtyData backend.
     * @member {number} backend
     * @memberof LibraryDirtyData
     * @instance
     */
    LibraryDirtyData.prototype.backend = 0;

    /**
     * LibraryDirtyData libraryId.
     * @member {string} libraryId
     * @memberof LibraryDirtyData
     * @instance
     */
    LibraryDirtyData.prototype.libraryId = "";

    /**
     * Creates a new LibraryDirtyData instance using the specified properties.
     * @function create
     * @memberof LibraryDirtyData
     * @static
     * @param {ILibraryDirtyData=} [properties] Properties to set
     * @returns {LibraryDirtyData} LibraryDirtyData instance
     */
    LibraryDirtyData.create = function create(properties) {
        return new LibraryDirtyData(properties);
    };

    /**
     * Encodes the specified LibraryDirtyData message. Does not implicitly {@link LibraryDirtyData.verify|verify} messages.
     * @function encode
     * @memberof LibraryDirtyData
     * @static
     * @param {ILibraryDirtyData} message LibraryDirtyData message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    LibraryDirtyData.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.backend != null && Object.hasOwnProperty.call(message, "backend"))
            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.backend);
        if (message.libraryId != null && Object.hasOwnProperty.call(message, "libraryId"))
            writer.uint32(/* id 2, wireType 2 =*/18).string(message.libraryId);
        return writer;
    };

    /**
     * Encodes the specified LibraryDirtyData message, length delimited. Does not implicitly {@link LibraryDirtyData.verify|verify} messages.
     * @function encodeDelimited
     * @memberof LibraryDirtyData
     * @static
     * @param {ILibraryDirtyData} message LibraryDirtyData message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    LibraryDirtyData.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a LibraryDirtyData message from the specified reader or buffer.
     * @function decode
     * @memberof LibraryDirtyData
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {LibraryDirtyData} LibraryDirtyData
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    LibraryDirtyData.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.LibraryDirtyData();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.backend = reader.int32();
                break;
            case 2:
                message.libraryId = reader.string();
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a LibraryDirtyData message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof LibraryDirtyData
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {LibraryDirtyData} LibraryDirtyData
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    LibraryDirtyData.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a LibraryDirtyData message.
     * @function verify
     * @memberof LibraryDirtyData
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    LibraryDirtyData.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.backend != null && message.hasOwnProperty("backend"))
            if (!$util.isInteger(message.backend))
                return "backend: integer expected";
        if (message.libraryId != null && message.hasOwnProperty("libraryId"))
            if (!$util.isString(message.libraryId))
                return "libraryId: string expected";
        return null;
    };

    /**
     * Creates a LibraryDirtyData message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof LibraryDirtyData
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {LibraryDirtyData} LibraryDirtyData
     */
    LibraryDirtyData.fromObject = function fromObject(object) {
        if (object instanceof $root.LibraryDirtyData)
            return object;
        var message = new $root.LibraryDirtyData();
        if (object.backend != null)
            message.backend = object.backend | 0;
        if (object.libraryId != null)
            message.libraryId = String(object.libraryId);
        return message;
    };

    /**
     * Creates a plain object from a LibraryDirtyData message. Also converts values to other types if specified.
     * @function toObject
     * @memberof LibraryDirtyData
     * @static
     * @param {LibraryDirtyData} message LibraryDirtyData
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    LibraryDirtyData.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        var object = {};
        if (options.defaults) {
            object.backend = 0;
            object.libraryId = "";
        }
        if (message.backend != null && message.hasOwnProperty("backend"))
            object.backend = message.backend;
        if (message.libraryId != null && message.hasOwnProperty("libraryId"))
            object.libraryId = message.libraryId;
        return object;
    };

    /**
     * Converts this LibraryDirtyData to JSON.
     * @function toJSON
     * @memberof LibraryDirtyData
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    LibraryDirtyData.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return LibraryDirtyData;
})();

$root.Notification = (function() {

    /**
     * Properties of a Notification.
     * @exports INotification
     * @interface INotification
     * @property {number|null} [notificationType] Notification notificationType
     * @property {number|Long|null} [timestamp] Notification timestamp
     * @property {IDocId|null} [DocId] Notification DocId
     * @property {string|null} [docTitle] Notification docTitle
     * @property {string|null} [userEmail] Notification userEmail
     * @property {IAndroidAppNotificationData|null} [appData] Notification appData
     * @property {IAndroidAppDeliveryData|null} [appDeliveryData] Notification appDeliveryData
     * @property {IPurchaseRemovalData|null} [purchaseRemovalData] Notification purchaseRemovalData
     * @property {IUserNotificationData|null} [userNotificationData] Notification userNotificationData
     * @property {IInAppNotificationData|null} [inAppNotificationData] Notification inAppNotificationData
     * @property {IPurchaseDeclinedData|null} [purchaseDeclinedData] Notification purchaseDeclinedData
     * @property {string|null} [notificationId] Notification notificationId
     * @property {ILibraryUpdate|null} [libraryUpdate] Notification libraryUpdate
     * @property {ILibraryDirtyData|null} [libraryDirtyData] Notification libraryDirtyData
     */

    /**
     * Constructs a new Notification.
     * @exports Notification
     * @classdesc Represents a Notification.
     * @implements INotification
     * @constructor
     * @param {INotification=} [properties] Properties to set
     */
    function Notification(properties) {
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * Notification notificationType.
     * @member {number} notificationType
     * @memberof Notification
     * @instance
     */
    Notification.prototype.notificationType = 0;

    /**
     * Notification timestamp.
     * @member {number|Long} timestamp
     * @memberof Notification
     * @instance
     */
    Notification.prototype.timestamp = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

    /**
     * Notification DocId.
     * @member {IDocId|null|undefined} DocId
     * @memberof Notification
     * @instance
     */
    Notification.prototype.DocId = null;

    /**
     * Notification docTitle.
     * @member {string} docTitle
     * @memberof Notification
     * @instance
     */
    Notification.prototype.docTitle = "";

    /**
     * Notification userEmail.
     * @member {string} userEmail
     * @memberof Notification
     * @instance
     */
    Notification.prototype.userEmail = "";

    /**
     * Notification appData.
     * @member {IAndroidAppNotificationData|null|undefined} appData
     * @memberof Notification
     * @instance
     */
    Notification.prototype.appData = null;

    /**
     * Notification appDeliveryData.
     * @member {IAndroidAppDeliveryData|null|undefined} appDeliveryData
     * @memberof Notification
     * @instance
     */
    Notification.prototype.appDeliveryData = null;

    /**
     * Notification purchaseRemovalData.
     * @member {IPurchaseRemovalData|null|undefined} purchaseRemovalData
     * @memberof Notification
     * @instance
     */
    Notification.prototype.purchaseRemovalData = null;

    /**
     * Notification userNotificationData.
     * @member {IUserNotificationData|null|undefined} userNotificationData
     * @memberof Notification
     * @instance
     */
    Notification.prototype.userNotificationData = null;

    /**
     * Notification inAppNotificationData.
     * @member {IInAppNotificationData|null|undefined} inAppNotificationData
     * @memberof Notification
     * @instance
     */
    Notification.prototype.inAppNotificationData = null;

    /**
     * Notification purchaseDeclinedData.
     * @member {IPurchaseDeclinedData|null|undefined} purchaseDeclinedData
     * @memberof Notification
     * @instance
     */
    Notification.prototype.purchaseDeclinedData = null;

    /**
     * Notification notificationId.
     * @member {string} notificationId
     * @memberof Notification
     * @instance
     */
    Notification.prototype.notificationId = "";

    /**
     * Notification libraryUpdate.
     * @member {ILibraryUpdate|null|undefined} libraryUpdate
     * @memberof Notification
     * @instance
     */
    Notification.prototype.libraryUpdate = null;

    /**
     * Notification libraryDirtyData.
     * @member {ILibraryDirtyData|null|undefined} libraryDirtyData
     * @memberof Notification
     * @instance
     */
    Notification.prototype.libraryDirtyData = null;

    /**
     * Creates a new Notification instance using the specified properties.
     * @function create
     * @memberof Notification
     * @static
     * @param {INotification=} [properties] Properties to set
     * @returns {Notification} Notification instance
     */
    Notification.create = function create(properties) {
        return new Notification(properties);
    };

    /**
     * Encodes the specified Notification message. Does not implicitly {@link Notification.verify|verify} messages.
     * @function encode
     * @memberof Notification
     * @static
     * @param {INotification} message Notification message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    Notification.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.notificationType != null && Object.hasOwnProperty.call(message, "notificationType"))
            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.notificationType);
        if (message.timestamp != null && Object.hasOwnProperty.call(message, "timestamp"))
            writer.uint32(/* id 3, wireType 0 =*/24).int64(message.timestamp);
        if (message.DocId != null && Object.hasOwnProperty.call(message, "DocId"))
            $root.DocId.encode(message.DocId, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
        if (message.docTitle != null && Object.hasOwnProperty.call(message, "docTitle"))
            writer.uint32(/* id 5, wireType 2 =*/42).string(message.docTitle);
        if (message.userEmail != null && Object.hasOwnProperty.call(message, "userEmail"))
            writer.uint32(/* id 6, wireType 2 =*/50).string(message.userEmail);
        if (message.appData != null && Object.hasOwnProperty.call(message, "appData"))
            $root.AndroidAppNotificationData.encode(message.appData, writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
        if (message.appDeliveryData != null && Object.hasOwnProperty.call(message, "appDeliveryData"))
            $root.AndroidAppDeliveryData.encode(message.appDeliveryData, writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();
        if (message.purchaseRemovalData != null && Object.hasOwnProperty.call(message, "purchaseRemovalData"))
            $root.PurchaseRemovalData.encode(message.purchaseRemovalData, writer.uint32(/* id 9, wireType 2 =*/74).fork()).ldelim();
        if (message.userNotificationData != null && Object.hasOwnProperty.call(message, "userNotificationData"))
            $root.UserNotificationData.encode(message.userNotificationData, writer.uint32(/* id 10, wireType 2 =*/82).fork()).ldelim();
        if (message.inAppNotificationData != null && Object.hasOwnProperty.call(message, "inAppNotificationData"))
            $root.InAppNotificationData.encode(message.inAppNotificationData, writer.uint32(/* id 11, wireType 2 =*/90).fork()).ldelim();
        if (message.purchaseDeclinedData != null && Object.hasOwnProperty.call(message, "purchaseDeclinedData"))
            $root.PurchaseDeclinedData.encode(message.purchaseDeclinedData, writer.uint32(/* id 12, wireType 2 =*/98).fork()).ldelim();
        if (message.notificationId != null && Object.hasOwnProperty.call(message, "notificationId"))
            writer.uint32(/* id 13, wireType 2 =*/106).string(message.notificationId);
        if (message.libraryUpdate != null && Object.hasOwnProperty.call(message, "libraryUpdate"))
            $root.LibraryUpdate.encode(message.libraryUpdate, writer.uint32(/* id 14, wireType 2 =*/114).fork()).ldelim();
        if (message.libraryDirtyData != null && Object.hasOwnProperty.call(message, "libraryDirtyData"))
            $root.LibraryDirtyData.encode(message.libraryDirtyData, writer.uint32(/* id 15, wireType 2 =*/122).fork()).ldelim();
        return writer;
    };

    /**
     * Encodes the specified Notification message, length delimited. Does not implicitly {@link Notification.verify|verify} messages.
     * @function encodeDelimited
     * @memberof Notification
     * @static
     * @param {INotification} message Notification message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    Notification.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a Notification message from the specified reader or buffer.
     * @function decode
     * @memberof Notification
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {Notification} Notification
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    Notification.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Notification();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.notificationType = reader.int32();
                break;
            case 3:
                message.timestamp = reader.int64();
                break;
            case 4:
                message.DocId = $root.DocId.decode(reader, reader.uint32());
                break;
            case 5:
                message.docTitle = reader.string();
                break;
            case 6:
                message.userEmail = reader.string();
                break;
            case 7:
                message.appData = $root.AndroidAppNotificationData.decode(reader, reader.uint32());
                break;
            case 8:
                message.appDeliveryData = $root.AndroidAppDeliveryData.decode(reader, reader.uint32());
                break;
            case 9:
                message.purchaseRemovalData = $root.PurchaseRemovalData.decode(reader, reader.uint32());
                break;
            case 10:
                message.userNotificationData = $root.UserNotificationData.decode(reader, reader.uint32());
                break;
            case 11:
                message.inAppNotificationData = $root.InAppNotificationData.decode(reader, reader.uint32());
                break;
            case 12:
                message.purchaseDeclinedData = $root.PurchaseDeclinedData.decode(reader, reader.uint32());
                break;
            case 13:
                message.notificationId = reader.string();
                break;
            case 14:
                message.libraryUpdate = $root.LibraryUpdate.decode(reader, reader.uint32());
                break;
            case 15:
                message.libraryDirtyData = $root.LibraryDirtyData.decode(reader, reader.uint32());
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a Notification message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof Notification
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {Notification} Notification
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    Notification.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a Notification message.
     * @function verify
     * @memberof Notification
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    Notification.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.notificationType != null && message.hasOwnProperty("notificationType"))
            if (!$util.isInteger(message.notificationType))
                return "notificationType: integer expected";
        if (message.timestamp != null && message.hasOwnProperty("timestamp"))
            if (!$util.isInteger(message.timestamp) && !(message.timestamp && $util.isInteger(message.timestamp.low) && $util.isInteger(message.timestamp.high)))
                return "timestamp: integer|Long expected";
        if (message.DocId != null && message.hasOwnProperty("DocId")) {
            var error = $root.DocId.verify(message.DocId);
            if (error)
                return "DocId." + error;
        }
        if (message.docTitle != null && message.hasOwnProperty("docTitle"))
            if (!$util.isString(message.docTitle))
                return "docTitle: string expected";
        if (message.userEmail != null && message.hasOwnProperty("userEmail"))
            if (!$util.isString(message.userEmail))
                return "userEmail: string expected";
        if (message.appData != null && message.hasOwnProperty("appData")) {
            var error = $root.AndroidAppNotificationData.verify(message.appData);
            if (error)
                return "appData." + error;
        }
        if (message.appDeliveryData != null && message.hasOwnProperty("appDeliveryData")) {
            var error = $root.AndroidAppDeliveryData.verify(message.appDeliveryData);
            if (error)
                return "appDeliveryData." + error;
        }
        if (message.purchaseRemovalData != null && message.hasOwnProperty("purchaseRemovalData")) {
            var error = $root.PurchaseRemovalData.verify(message.purchaseRemovalData);
            if (error)
                return "purchaseRemovalData." + error;
        }
        if (message.userNotificationData != null && message.hasOwnProperty("userNotificationData")) {
            var error = $root.UserNotificationData.verify(message.userNotificationData);
            if (error)
                return "userNotificationData." + error;
        }
        if (message.inAppNotificationData != null && message.hasOwnProperty("inAppNotificationData")) {
            var error = $root.InAppNotificationData.verify(message.inAppNotificationData);
            if (error)
                return "inAppNotificationData." + error;
        }
        if (message.purchaseDeclinedData != null && message.hasOwnProperty("purchaseDeclinedData")) {
            var error = $root.PurchaseDeclinedData.verify(message.purchaseDeclinedData);
            if (error)
                return "purchaseDeclinedData." + error;
        }
        if (message.notificationId != null && message.hasOwnProperty("notificationId"))
            if (!$util.isString(message.notificationId))
                return "notificationId: string expected";
        if (message.libraryUpdate != null && message.hasOwnProperty("libraryUpdate")) {
            var error = $root.LibraryUpdate.verify(message.libraryUpdate);
            if (error)
                return "libraryUpdate." + error;
        }
        if (message.libraryDirtyData != null && message.hasOwnProperty("libraryDirtyData")) {
            var error = $root.LibraryDirtyData.verify(message.libraryDirtyData);
            if (error)
                return "libraryDirtyData." + error;
        }
        return null;
    };

    /**
     * Creates a Notification message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof Notification
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {Notification} Notification
     */
    Notification.fromObject = function fromObject(object) {
        if (object instanceof $root.Notification)
            return object;
        var message = new $root.Notification();
        if (object.notificationType != null)
            message.notificationType = object.notificationType | 0;
        if (object.timestamp != null)
            if ($util.Long)
                (message.timestamp = $util.Long.fromValue(object.timestamp)).unsigned = false;
            else if (typeof object.timestamp === "string")
                message.timestamp = parseInt(object.timestamp, 10);
            else if (typeof object.timestamp === "number")
                message.timestamp = object.timestamp;
            else if (typeof object.timestamp === "object")
                message.timestamp = new $util.LongBits(object.timestamp.low >>> 0, object.timestamp.high >>> 0).toNumber();
        if (object.DocId != null) {
            if (typeof object.DocId !== "object")
                throw TypeError(".Notification.DocId: object expected");
            message.DocId = $root.DocId.fromObject(object.DocId);
        }
        if (object.docTitle != null)
            message.docTitle = String(object.docTitle);
        if (object.userEmail != null)
            message.userEmail = String(object.userEmail);
        if (object.appData != null) {
            if (typeof object.appData !== "object")
                throw TypeError(".Notification.appData: object expected");
            message.appData = $root.AndroidAppNotificationData.fromObject(object.appData);
        }
        if (object.appDeliveryData != null) {
            if (typeof object.appDeliveryData !== "object")
                throw TypeError(".Notification.appDeliveryData: object expected");
            message.appDeliveryData = $root.AndroidAppDeliveryData.fromObject(object.appDeliveryData);
        }
        if (object.purchaseRemovalData != null) {
            if (typeof object.purchaseRemovalData !== "object")
                throw TypeError(".Notification.purchaseRemovalData: object expected");
            message.purchaseRemovalData = $root.PurchaseRemovalData.fromObject(object.purchaseRemovalData);
        }
        if (object.userNotificationData != null) {
            if (typeof object.userNotificationData !== "object")
                throw TypeError(".Notification.userNotificationData: object expected");
            message.userNotificationData = $root.UserNotificationData.fromObject(object.userNotificationData);
        }
        if (object.inAppNotificationData != null) {
            if (typeof object.inAppNotificationData !== "object")
                throw TypeError(".Notification.inAppNotificationData: object expected");
            message.inAppNotificationData = $root.InAppNotificationData.fromObject(object.inAppNotificationData);
        }
        if (object.purchaseDeclinedData != null) {
            if (typeof object.purchaseDeclinedData !== "object")
                throw TypeError(".Notification.purchaseDeclinedData: object expected");
            message.purchaseDeclinedData = $root.PurchaseDeclinedData.fromObject(object.purchaseDeclinedData);
        }
        if (object.notificationId != null)
            message.notificationId = String(object.notificationId);
        if (object.libraryUpdate != null) {
            if (typeof object.libraryUpdate !== "object")
                throw TypeError(".Notification.libraryUpdate: object expected");
            message.libraryUpdate = $root.LibraryUpdate.fromObject(object.libraryUpdate);
        }
        if (object.libraryDirtyData != null) {
            if (typeof object.libraryDirtyData !== "object")
                throw TypeError(".Notification.libraryDirtyData: object expected");
            message.libraryDirtyData = $root.LibraryDirtyData.fromObject(object.libraryDirtyData);
        }
        return message;
    };

    /**
     * Creates a plain object from a Notification message. Also converts values to other types if specified.
     * @function toObject
     * @memberof Notification
     * @static
     * @param {Notification} message Notification
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    Notification.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        var object = {};
        if (options.defaults) {
            object.notificationType = 0;
            if ($util.Long) {
                var long = new $util.Long(0, 0, false);
                object.timestamp = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
            } else
                object.timestamp = options.longs === String ? "0" : 0;
            object.DocId = null;
            object.docTitle = "";
            object.userEmail = "";
            object.appData = null;
            object.appDeliveryData = null;
            object.purchaseRemovalData = null;
            object.userNotificationData = null;
            object.inAppNotificationData = null;
            object.purchaseDeclinedData = null;
            object.notificationId = "";
            object.libraryUpdate = null;
            object.libraryDirtyData = null;
        }
        if (message.notificationType != null && message.hasOwnProperty("notificationType"))
            object.notificationType = message.notificationType;
        if (message.timestamp != null && message.hasOwnProperty("timestamp"))
            if (typeof message.timestamp === "number")
                object.timestamp = options.longs === String ? String(message.timestamp) : message.timestamp;
            else
                object.timestamp = options.longs === String ? $util.Long.prototype.toString.call(message.timestamp) : options.longs === Number ? new $util.LongBits(message.timestamp.low >>> 0, message.timestamp.high >>> 0).toNumber() : message.timestamp;
        if (message.DocId != null && message.hasOwnProperty("DocId"))
            object.DocId = $root.DocId.toObject(message.DocId, options);
        if (message.docTitle != null && message.hasOwnProperty("docTitle"))
            object.docTitle = message.docTitle;
        if (message.userEmail != null && message.hasOwnProperty("userEmail"))
            object.userEmail = message.userEmail;
        if (message.appData != null && message.hasOwnProperty("appData"))
            object.appData = $root.AndroidAppNotificationData.toObject(message.appData, options);
        if (message.appDeliveryData != null && message.hasOwnProperty("appDeliveryData"))
            object.appDeliveryData = $root.AndroidAppDeliveryData.toObject(message.appDeliveryData, options);
        if (message.purchaseRemovalData != null && message.hasOwnProperty("purchaseRemovalData"))
            object.purchaseRemovalData = $root.PurchaseRemovalData.toObject(message.purchaseRemovalData, options);
        if (message.userNotificationData != null && message.hasOwnProperty("userNotificationData"))
            object.userNotificationData = $root.UserNotificationData.toObject(message.userNotificationData, options);
        if (message.inAppNotificationData != null && message.hasOwnProperty("inAppNotificationData"))
            object.inAppNotificationData = $root.InAppNotificationData.toObject(message.inAppNotificationData, options);
        if (message.purchaseDeclinedData != null && message.hasOwnProperty("purchaseDeclinedData"))
            object.purchaseDeclinedData = $root.PurchaseDeclinedData.toObject(message.purchaseDeclinedData, options);
        if (message.notificationId != null && message.hasOwnProperty("notificationId"))
            object.notificationId = message.notificationId;
        if (message.libraryUpdate != null && message.hasOwnProperty("libraryUpdate"))
            object.libraryUpdate = $root.LibraryUpdate.toObject(message.libraryUpdate, options);
        if (message.libraryDirtyData != null && message.hasOwnProperty("libraryDirtyData"))
            object.libraryDirtyData = $root.LibraryDirtyData.toObject(message.libraryDirtyData, options);
        return object;
    };

    /**
     * Converts this Notification to JSON.
     * @function toJSON
     * @memberof Notification
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    Notification.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return Notification;
})();

$root.PurchaseDeclinedData = (function() {

    /**
     * Properties of a PurchaseDeclinedData.
     * @exports IPurchaseDeclinedData
     * @interface IPurchaseDeclinedData
     * @property {number|null} [reason] PurchaseDeclinedData reason
     * @property {boolean|null} [showNotification] PurchaseDeclinedData showNotification
     */

    /**
     * Constructs a new PurchaseDeclinedData.
     * @exports PurchaseDeclinedData
     * @classdesc Represents a PurchaseDeclinedData.
     * @implements IPurchaseDeclinedData
     * @constructor
     * @param {IPurchaseDeclinedData=} [properties] Properties to set
     */
    function PurchaseDeclinedData(properties) {
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * PurchaseDeclinedData reason.
     * @member {number} reason
     * @memberof PurchaseDeclinedData
     * @instance
     */
    PurchaseDeclinedData.prototype.reason = 0;

    /**
     * PurchaseDeclinedData showNotification.
     * @member {boolean} showNotification
     * @memberof PurchaseDeclinedData
     * @instance
     */
    PurchaseDeclinedData.prototype.showNotification = false;

    /**
     * Creates a new PurchaseDeclinedData instance using the specified properties.
     * @function create
     * @memberof PurchaseDeclinedData
     * @static
     * @param {IPurchaseDeclinedData=} [properties] Properties to set
     * @returns {PurchaseDeclinedData} PurchaseDeclinedData instance
     */
    PurchaseDeclinedData.create = function create(properties) {
        return new PurchaseDeclinedData(properties);
    };

    /**
     * Encodes the specified PurchaseDeclinedData message. Does not implicitly {@link PurchaseDeclinedData.verify|verify} messages.
     * @function encode
     * @memberof PurchaseDeclinedData
     * @static
     * @param {IPurchaseDeclinedData} message PurchaseDeclinedData message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    PurchaseDeclinedData.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.reason != null && Object.hasOwnProperty.call(message, "reason"))
            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.reason);
        if (message.showNotification != null && Object.hasOwnProperty.call(message, "showNotification"))
            writer.uint32(/* id 2, wireType 0 =*/16).bool(message.showNotification);
        return writer;
    };

    /**
     * Encodes the specified PurchaseDeclinedData message, length delimited. Does not implicitly {@link PurchaseDeclinedData.verify|verify} messages.
     * @function encodeDelimited
     * @memberof PurchaseDeclinedData
     * @static
     * @param {IPurchaseDeclinedData} message PurchaseDeclinedData message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    PurchaseDeclinedData.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a PurchaseDeclinedData message from the specified reader or buffer.
     * @function decode
     * @memberof PurchaseDeclinedData
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {PurchaseDeclinedData} PurchaseDeclinedData
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    PurchaseDeclinedData.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.PurchaseDeclinedData();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.reason = reader.int32();
                break;
            case 2:
                message.showNotification = reader.bool();
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a PurchaseDeclinedData message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof PurchaseDeclinedData
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {PurchaseDeclinedData} PurchaseDeclinedData
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    PurchaseDeclinedData.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a PurchaseDeclinedData message.
     * @function verify
     * @memberof PurchaseDeclinedData
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    PurchaseDeclinedData.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.reason != null && message.hasOwnProperty("reason"))
            if (!$util.isInteger(message.reason))
                return "reason: integer expected";
        if (message.showNotification != null && message.hasOwnProperty("showNotification"))
            if (typeof message.showNotification !== "boolean")
                return "showNotification: boolean expected";
        return null;
    };

    /**
     * Creates a PurchaseDeclinedData message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof PurchaseDeclinedData
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {PurchaseDeclinedData} PurchaseDeclinedData
     */
    PurchaseDeclinedData.fromObject = function fromObject(object) {
        if (object instanceof $root.PurchaseDeclinedData)
            return object;
        var message = new $root.PurchaseDeclinedData();
        if (object.reason != null)
            message.reason = object.reason | 0;
        if (object.showNotification != null)
            message.showNotification = Boolean(object.showNotification);
        return message;
    };

    /**
     * Creates a plain object from a PurchaseDeclinedData message. Also converts values to other types if specified.
     * @function toObject
     * @memberof PurchaseDeclinedData
     * @static
     * @param {PurchaseDeclinedData} message PurchaseDeclinedData
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    PurchaseDeclinedData.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        var object = {};
        if (options.defaults) {
            object.reason = 0;
            object.showNotification = false;
        }
        if (message.reason != null && message.hasOwnProperty("reason"))
            object.reason = message.reason;
        if (message.showNotification != null && message.hasOwnProperty("showNotification"))
            object.showNotification = message.showNotification;
        return object;
    };

    /**
     * Converts this PurchaseDeclinedData to JSON.
     * @function toJSON
     * @memberof PurchaseDeclinedData
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    PurchaseDeclinedData.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return PurchaseDeclinedData;
})();

$root.PurchaseRemovalData = (function() {

    /**
     * Properties of a PurchaseRemovalData.
     * @exports IPurchaseRemovalData
     * @interface IPurchaseRemovalData
     * @property {boolean|null} [malicious] PurchaseRemovalData malicious
     */

    /**
     * Constructs a new PurchaseRemovalData.
     * @exports PurchaseRemovalData
     * @classdesc Represents a PurchaseRemovalData.
     * @implements IPurchaseRemovalData
     * @constructor
     * @param {IPurchaseRemovalData=} [properties] Properties to set
     */
    function PurchaseRemovalData(properties) {
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * PurchaseRemovalData malicious.
     * @member {boolean} malicious
     * @memberof PurchaseRemovalData
     * @instance
     */
    PurchaseRemovalData.prototype.malicious = false;

    /**
     * Creates a new PurchaseRemovalData instance using the specified properties.
     * @function create
     * @memberof PurchaseRemovalData
     * @static
     * @param {IPurchaseRemovalData=} [properties] Properties to set
     * @returns {PurchaseRemovalData} PurchaseRemovalData instance
     */
    PurchaseRemovalData.create = function create(properties) {
        return new PurchaseRemovalData(properties);
    };

    /**
     * Encodes the specified PurchaseRemovalData message. Does not implicitly {@link PurchaseRemovalData.verify|verify} messages.
     * @function encode
     * @memberof PurchaseRemovalData
     * @static
     * @param {IPurchaseRemovalData} message PurchaseRemovalData message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    PurchaseRemovalData.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.malicious != null && Object.hasOwnProperty.call(message, "malicious"))
            writer.uint32(/* id 1, wireType 0 =*/8).bool(message.malicious);
        return writer;
    };

    /**
     * Encodes the specified PurchaseRemovalData message, length delimited. Does not implicitly {@link PurchaseRemovalData.verify|verify} messages.
     * @function encodeDelimited
     * @memberof PurchaseRemovalData
     * @static
     * @param {IPurchaseRemovalData} message PurchaseRemovalData message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    PurchaseRemovalData.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a PurchaseRemovalData message from the specified reader or buffer.
     * @function decode
     * @memberof PurchaseRemovalData
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {PurchaseRemovalData} PurchaseRemovalData
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    PurchaseRemovalData.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.PurchaseRemovalData();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.malicious = reader.bool();
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a PurchaseRemovalData message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof PurchaseRemovalData
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {PurchaseRemovalData} PurchaseRemovalData
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    PurchaseRemovalData.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a PurchaseRemovalData message.
     * @function verify
     * @memberof PurchaseRemovalData
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    PurchaseRemovalData.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.malicious != null && message.hasOwnProperty("malicious"))
            if (typeof message.malicious !== "boolean")
                return "malicious: boolean expected";
        return null;
    };

    /**
     * Creates a PurchaseRemovalData message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof PurchaseRemovalData
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {PurchaseRemovalData} PurchaseRemovalData
     */
    PurchaseRemovalData.fromObject = function fromObject(object) {
        if (object instanceof $root.PurchaseRemovalData)
            return object;
        var message = new $root.PurchaseRemovalData();
        if (object.malicious != null)
            message.malicious = Boolean(object.malicious);
        return message;
    };

    /**
     * Creates a plain object from a PurchaseRemovalData message. Also converts values to other types if specified.
     * @function toObject
     * @memberof PurchaseRemovalData
     * @static
     * @param {PurchaseRemovalData} message PurchaseRemovalData
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    PurchaseRemovalData.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        var object = {};
        if (options.defaults)
            object.malicious = false;
        if (message.malicious != null && message.hasOwnProperty("malicious"))
            object.malicious = message.malicious;
        return object;
    };

    /**
     * Converts this PurchaseRemovalData to JSON.
     * @function toJSON
     * @memberof PurchaseRemovalData
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    PurchaseRemovalData.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return PurchaseRemovalData;
})();

$root.UserNotificationData = (function() {

    /**
     * Properties of a UserNotificationData.
     * @exports IUserNotificationData
     * @interface IUserNotificationData
     * @property {string|null} [notificationTitle] UserNotificationData notificationTitle
     * @property {string|null} [notificationText] UserNotificationData notificationText
     * @property {string|null} [tickerText] UserNotificationData tickerText
     * @property {string|null} [dialogTitle] UserNotificationData dialogTitle
     * @property {string|null} [dialogText] UserNotificationData dialogText
     */

    /**
     * Constructs a new UserNotificationData.
     * @exports UserNotificationData
     * @classdesc Represents a UserNotificationData.
     * @implements IUserNotificationData
     * @constructor
     * @param {IUserNotificationData=} [properties] Properties to set
     */
    function UserNotificationData(properties) {
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * UserNotificationData notificationTitle.
     * @member {string} notificationTitle
     * @memberof UserNotificationData
     * @instance
     */
    UserNotificationData.prototype.notificationTitle = "";

    /**
     * UserNotificationData notificationText.
     * @member {string} notificationText
     * @memberof UserNotificationData
     * @instance
     */
    UserNotificationData.prototype.notificationText = "";

    /**
     * UserNotificationData tickerText.
     * @member {string} tickerText
     * @memberof UserNotificationData
     * @instance
     */
    UserNotificationData.prototype.tickerText = "";

    /**
     * UserNotificationData dialogTitle.
     * @member {string} dialogTitle
     * @memberof UserNotificationData
     * @instance
     */
    UserNotificationData.prototype.dialogTitle = "";

    /**
     * UserNotificationData dialogText.
     * @member {string} dialogText
     * @memberof UserNotificationData
     * @instance
     */
    UserNotificationData.prototype.dialogText = "";

    /**
     * Creates a new UserNotificationData instance using the specified properties.
     * @function create
     * @memberof UserNotificationData
     * @static
     * @param {IUserNotificationData=} [properties] Properties to set
     * @returns {UserNotificationData} UserNotificationData instance
     */
    UserNotificationData.create = function create(properties) {
        return new UserNotificationData(properties);
    };

    /**
     * Encodes the specified UserNotificationData message. Does not implicitly {@link UserNotificationData.verify|verify} messages.
     * @function encode
     * @memberof UserNotificationData
     * @static
     * @param {IUserNotificationData} message UserNotificationData message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    UserNotificationData.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.notificationTitle != null && Object.hasOwnProperty.call(message, "notificationTitle"))
            writer.uint32(/* id 1, wireType 2 =*/10).string(message.notificationTitle);
        if (message.notificationText != null && Object.hasOwnProperty.call(message, "notificationText"))
            writer.uint32(/* id 2, wireType 2 =*/18).string(message.notificationText);
        if (message.tickerText != null && Object.hasOwnProperty.call(message, "tickerText"))
            writer.uint32(/* id 3, wireType 2 =*/26).string(message.tickerText);
        if (message.dialogTitle != null && Object.hasOwnProperty.call(message, "dialogTitle"))
            writer.uint32(/* id 4, wireType 2 =*/34).string(message.dialogTitle);
        if (message.dialogText != null && Object.hasOwnProperty.call(message, "dialogText"))
            writer.uint32(/* id 5, wireType 2 =*/42).string(message.dialogText);
        return writer;
    };

    /**
     * Encodes the specified UserNotificationData message, length delimited. Does not implicitly {@link UserNotificationData.verify|verify} messages.
     * @function encodeDelimited
     * @memberof UserNotificationData
     * @static
     * @param {IUserNotificationData} message UserNotificationData message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    UserNotificationData.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a UserNotificationData message from the specified reader or buffer.
     * @function decode
     * @memberof UserNotificationData
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {UserNotificationData} UserNotificationData
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    UserNotificationData.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.UserNotificationData();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.notificationTitle = reader.string();
                break;
            case 2:
                message.notificationText = reader.string();
                break;
            case 3:
                message.tickerText = reader.string();
                break;
            case 4:
                message.dialogTitle = reader.string();
                break;
            case 5:
                message.dialogText = reader.string();
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a UserNotificationData message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof UserNotificationData
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {UserNotificationData} UserNotificationData
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    UserNotificationData.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a UserNotificationData message.
     * @function verify
     * @memberof UserNotificationData
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    UserNotificationData.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.notificationTitle != null && message.hasOwnProperty("notificationTitle"))
            if (!$util.isString(message.notificationTitle))
                return "notificationTitle: string expected";
        if (message.notificationText != null && message.hasOwnProperty("notificationText"))
            if (!$util.isString(message.notificationText))
                return "notificationText: string expected";
        if (message.tickerText != null && message.hasOwnProperty("tickerText"))
            if (!$util.isString(message.tickerText))
                return "tickerText: string expected";
        if (message.dialogTitle != null && message.hasOwnProperty("dialogTitle"))
            if (!$util.isString(message.dialogTitle))
                return "dialogTitle: string expected";
        if (message.dialogText != null && message.hasOwnProperty("dialogText"))
            if (!$util.isString(message.dialogText))
                return "dialogText: string expected";
        return null;
    };

    /**
     * Creates a UserNotificationData message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof UserNotificationData
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {UserNotificationData} UserNotificationData
     */
    UserNotificationData.fromObject = function fromObject(object) {
        if (object instanceof $root.UserNotificationData)
            return object;
        var message = new $root.UserNotificationData();
        if (object.notificationTitle != null)
            message.notificationTitle = String(object.notificationTitle);
        if (object.notificationText != null)
            message.notificationText = String(object.notificationText);
        if (object.tickerText != null)
            message.tickerText = String(object.tickerText);
        if (object.dialogTitle != null)
            message.dialogTitle = String(object.dialogTitle);
        if (object.dialogText != null)
            message.dialogText = String(object.dialogText);
        return message;
    };

    /**
     * Creates a plain object from a UserNotificationData message. Also converts values to other types if specified.
     * @function toObject
     * @memberof UserNotificationData
     * @static
     * @param {UserNotificationData} message UserNotificationData
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    UserNotificationData.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        var object = {};
        if (options.defaults) {
            object.notificationTitle = "";
            object.notificationText = "";
            object.tickerText = "";
            object.dialogTitle = "";
            object.dialogText = "";
        }
        if (message.notificationTitle != null && message.hasOwnProperty("notificationTitle"))
            object.notificationTitle = message.notificationTitle;
        if (message.notificationText != null && message.hasOwnProperty("notificationText"))
            object.notificationText = message.notificationText;
        if (message.tickerText != null && message.hasOwnProperty("tickerText"))
            object.tickerText = message.tickerText;
        if (message.dialogTitle != null && message.hasOwnProperty("dialogTitle"))
            object.dialogTitle = message.dialogTitle;
        if (message.dialogText != null && message.hasOwnProperty("dialogText"))
            object.dialogText = message.dialogText;
        return object;
    };

    /**
     * Converts this UserNotificationData to JSON.
     * @function toJSON
     * @memberof UserNotificationData
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    UserNotificationData.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return UserNotificationData;
})();

$root.AggregateRating = (function() {

    /**
     * Properties of an AggregateRating.
     * @exports IAggregateRating
     * @interface IAggregateRating
     * @property {number|null} [type] AggregateRating type
     * @property {number|null} [starRating] AggregateRating starRating
     * @property {number|Long|null} [ratingsCount] AggregateRating ratingsCount
     * @property {number|Long|null} [oneStarRatings] AggregateRating oneStarRatings
     * @property {number|Long|null} [twoStarRatings] AggregateRating twoStarRatings
     * @property {number|Long|null} [threeStarRatings] AggregateRating threeStarRatings
     * @property {number|Long|null} [fourStarRatings] AggregateRating fourStarRatings
     * @property {number|Long|null} [fiveStarRatings] AggregateRating fiveStarRatings
     * @property {number|Long|null} [thumbsUpCount] AggregateRating thumbsUpCount
     * @property {number|Long|null} [thumbsDownCount] AggregateRating thumbsDownCount
     * @property {number|Long|null} [commentCount] AggregateRating commentCount
     * @property {number|null} [bayesianMeanRating] AggregateRating bayesianMeanRating
     * @property {Array.<ITip>|null} [tip] AggregateRating tip
     * @property {string|null} [ratingLabel] AggregateRating ratingLabel
     * @property {string|null} [ratingCountLabelAbbreviated] AggregateRating ratingCountLabelAbbreviated
     * @property {string|null} [ratingCountLabel] AggregateRating ratingCountLabel
     */

    /**
     * Constructs a new AggregateRating.
     * @exports AggregateRating
     * @classdesc Represents an AggregateRating.
     * @implements IAggregateRating
     * @constructor
     * @param {IAggregateRating=} [properties] Properties to set
     */
    function AggregateRating(properties) {
        this.tip = [];
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * AggregateRating type.
     * @member {number} type
     * @memberof AggregateRating
     * @instance
     */
    AggregateRating.prototype.type = 1;

    /**
     * AggregateRating starRating.
     * @member {number} starRating
     * @memberof AggregateRating
     * @instance
     */
    AggregateRating.prototype.starRating = 0;

    /**
     * AggregateRating ratingsCount.
     * @member {number|Long} ratingsCount
     * @memberof AggregateRating
     * @instance
     */
    AggregateRating.prototype.ratingsCount = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

    /**
     * AggregateRating oneStarRatings.
     * @member {number|Long} oneStarRatings
     * @memberof AggregateRating
     * @instance
     */
    AggregateRating.prototype.oneStarRatings = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

    /**
     * AggregateRating twoStarRatings.
     * @member {number|Long} twoStarRatings
     * @memberof AggregateRating
     * @instance
     */
    AggregateRating.prototype.twoStarRatings = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

    /**
     * AggregateRating threeStarRatings.
     * @member {number|Long} threeStarRatings
     * @memberof AggregateRating
     * @instance
     */
    AggregateRating.prototype.threeStarRatings = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

    /**
     * AggregateRating fourStarRatings.
     * @member {number|Long} fourStarRatings
     * @memberof AggregateRating
     * @instance
     */
    AggregateRating.prototype.fourStarRatings = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

    /**
     * AggregateRating fiveStarRatings.
     * @member {number|Long} fiveStarRatings
     * @memberof AggregateRating
     * @instance
     */
    AggregateRating.prototype.fiveStarRatings = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

    /**
     * AggregateRating thumbsUpCount.
     * @member {number|Long} thumbsUpCount
     * @memberof AggregateRating
     * @instance
     */
    AggregateRating.prototype.thumbsUpCount = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

    /**
     * AggregateRating thumbsDownCount.
     * @member {number|Long} thumbsDownCount
     * @memberof AggregateRating
     * @instance
     */
    AggregateRating.prototype.thumbsDownCount = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

    /**
     * AggregateRating commentCount.
     * @member {number|Long} commentCount
     * @memberof AggregateRating
     * @instance
     */
    AggregateRating.prototype.commentCount = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

    /**
     * AggregateRating bayesianMeanRating.
     * @member {number} bayesianMeanRating
     * @memberof AggregateRating
     * @instance
     */
    AggregateRating.prototype.bayesianMeanRating = 0;

    /**
     * AggregateRating tip.
     * @member {Array.<ITip>} tip
     * @memberof AggregateRating
     * @instance
     */
    AggregateRating.prototype.tip = $util.emptyArray;

    /**
     * AggregateRating ratingLabel.
     * @member {string} ratingLabel
     * @memberof AggregateRating
     * @instance
     */
    AggregateRating.prototype.ratingLabel = "";

    /**
     * AggregateRating ratingCountLabelAbbreviated.
     * @member {string} ratingCountLabelAbbreviated
     * @memberof AggregateRating
     * @instance
     */
    AggregateRating.prototype.ratingCountLabelAbbreviated = "";

    /**
     * AggregateRating ratingCountLabel.
     * @member {string} ratingCountLabel
     * @memberof AggregateRating
     * @instance
     */
    AggregateRating.prototype.ratingCountLabel = "";

    /**
     * Creates a new AggregateRating instance using the specified properties.
     * @function create
     * @memberof AggregateRating
     * @static
     * @param {IAggregateRating=} [properties] Properties to set
     * @returns {AggregateRating} AggregateRating instance
     */
    AggregateRating.create = function create(properties) {
        return new AggregateRating(properties);
    };

    /**
     * Encodes the specified AggregateRating message. Does not implicitly {@link AggregateRating.verify|verify} messages.
     * @function encode
     * @memberof AggregateRating
     * @static
     * @param {IAggregateRating} message AggregateRating message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    AggregateRating.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.type != null && Object.hasOwnProperty.call(message, "type"))
            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.type);
        if (message.starRating != null && Object.hasOwnProperty.call(message, "starRating"))
            writer.uint32(/* id 2, wireType 5 =*/21).float(message.starRating);
        if (message.ratingsCount != null && Object.hasOwnProperty.call(message, "ratingsCount"))
            writer.uint32(/* id 3, wireType 0 =*/24).uint64(message.ratingsCount);
        if (message.oneStarRatings != null && Object.hasOwnProperty.call(message, "oneStarRatings"))
            writer.uint32(/* id 4, wireType 0 =*/32).uint64(message.oneStarRatings);
        if (message.twoStarRatings != null && Object.hasOwnProperty.call(message, "twoStarRatings"))
            writer.uint32(/* id 5, wireType 0 =*/40).uint64(message.twoStarRatings);
        if (message.threeStarRatings != null && Object.hasOwnProperty.call(message, "threeStarRatings"))
            writer.uint32(/* id 6, wireType 0 =*/48).uint64(message.threeStarRatings);
        if (message.fourStarRatings != null && Object.hasOwnProperty.call(message, "fourStarRatings"))
            writer.uint32(/* id 7, wireType 0 =*/56).uint64(message.fourStarRatings);
        if (message.fiveStarRatings != null && Object.hasOwnProperty.call(message, "fiveStarRatings"))
            writer.uint32(/* id 8, wireType 0 =*/64).uint64(message.fiveStarRatings);
        if (message.thumbsUpCount != null && Object.hasOwnProperty.call(message, "thumbsUpCount"))
            writer.uint32(/* id 9, wireType 0 =*/72).uint64(message.thumbsUpCount);
        if (message.thumbsDownCount != null && Object.hasOwnProperty.call(message, "thumbsDownCount"))
            writer.uint32(/* id 10, wireType 0 =*/80).uint64(message.thumbsDownCount);
        if (message.commentCount != null && Object.hasOwnProperty.call(message, "commentCount"))
            writer.uint32(/* id 11, wireType 0 =*/88).uint64(message.commentCount);
        if (message.bayesianMeanRating != null && Object.hasOwnProperty.call(message, "bayesianMeanRating"))
            writer.uint32(/* id 12, wireType 1 =*/97).double(message.bayesianMeanRating);
        if (message.tip != null && message.tip.length)
            for (var i = 0; i < message.tip.length; ++i)
                $root.Tip.encode(message.tip[i], writer.uint32(/* id 13, wireType 2 =*/106).fork()).ldelim();
        if (message.ratingLabel != null && Object.hasOwnProperty.call(message, "ratingLabel"))
            writer.uint32(/* id 17, wireType 2 =*/138).string(message.ratingLabel);
        if (message.ratingCountLabelAbbreviated != null && Object.hasOwnProperty.call(message, "ratingCountLabelAbbreviated"))
            writer.uint32(/* id 18, wireType 2 =*/146).string(message.ratingCountLabelAbbreviated);
        if (message.ratingCountLabel != null && Object.hasOwnProperty.call(message, "ratingCountLabel"))
            writer.uint32(/* id 19, wireType 2 =*/154).string(message.ratingCountLabel);
        return writer;
    };

    /**
     * Encodes the specified AggregateRating message, length delimited. Does not implicitly {@link AggregateRating.verify|verify} messages.
     * @function encodeDelimited
     * @memberof AggregateRating
     * @static
     * @param {IAggregateRating} message AggregateRating message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    AggregateRating.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes an AggregateRating message from the specified reader or buffer.
     * @function decode
     * @memberof AggregateRating
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {AggregateRating} AggregateRating
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    AggregateRating.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.AggregateRating();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.type = reader.int32();
                break;
            case 2:
                message.starRating = reader.float();
                break;
            case 3:
                message.ratingsCount = reader.uint64();
                break;
            case 4:
                message.oneStarRatings = reader.uint64();
                break;
            case 5:
                message.twoStarRatings = reader.uint64();
                break;
            case 6:
                message.threeStarRatings = reader.uint64();
                break;
            case 7:
                message.fourStarRatings = reader.uint64();
                break;
            case 8:
                message.fiveStarRatings = reader.uint64();
                break;
            case 9:
                message.thumbsUpCount = reader.uint64();
                break;
            case 10:
                message.thumbsDownCount = reader.uint64();
                break;
            case 11:
                message.commentCount = reader.uint64();
                break;
            case 12:
                message.bayesianMeanRating = reader.double();
                break;
            case 13:
                if (!(message.tip && message.tip.length))
                    message.tip = [];
                message.tip.push($root.Tip.decode(reader, reader.uint32()));
                break;
            case 17:
                message.ratingLabel = reader.string();
                break;
            case 18:
                message.ratingCountLabelAbbreviated = reader.string();
                break;
            case 19:
                message.ratingCountLabel = reader.string();
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes an AggregateRating message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof AggregateRating
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {AggregateRating} AggregateRating
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    AggregateRating.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies an AggregateRating message.
     * @function verify
     * @memberof AggregateRating
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    AggregateRating.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.type != null && message.hasOwnProperty("type"))
            if (!$util.isInteger(message.type))
                return "type: integer expected";
        if (message.starRating != null && message.hasOwnProperty("starRating"))
            if (typeof message.starRating !== "number")
                return "starRating: number expected";
        if (message.ratingsCount != null && message.hasOwnProperty("ratingsCount"))
            if (!$util.isInteger(message.ratingsCount) && !(message.ratingsCount && $util.isInteger(message.ratingsCount.low) && $util.isInteger(message.ratingsCount.high)))
                return "ratingsCount: integer|Long expected";
        if (message.oneStarRatings != null && message.hasOwnProperty("oneStarRatings"))
            if (!$util.isInteger(message.oneStarRatings) && !(message.oneStarRatings && $util.isInteger(message.oneStarRatings.low) && $util.isInteger(message.oneStarRatings.high)))
                return "oneStarRatings: integer|Long expected";
        if (message.twoStarRatings != null && message.hasOwnProperty("twoStarRatings"))
            if (!$util.isInteger(message.twoStarRatings) && !(message.twoStarRatings && $util.isInteger(message.twoStarRatings.low) && $util.isInteger(message.twoStarRatings.high)))
                return "twoStarRatings: integer|Long expected";
        if (message.threeStarRatings != null && message.hasOwnProperty("threeStarRatings"))
            if (!$util.isInteger(message.threeStarRatings) && !(message.threeStarRatings && $util.isInteger(message.threeStarRatings.low) && $util.isInteger(message.threeStarRatings.high)))
                return "threeStarRatings: integer|Long expected";
        if (message.fourStarRatings != null && message.hasOwnProperty("fourStarRatings"))
            if (!$util.isInteger(message.fourStarRatings) && !(message.fourStarRatings && $util.isInteger(message.fourStarRatings.low) && $util.isInteger(message.fourStarRatings.high)))
                return "fourStarRatings: integer|Long expected";
        if (message.fiveStarRatings != null && message.hasOwnProperty("fiveStarRatings"))
            if (!$util.isInteger(message.fiveStarRatings) && !(message.fiveStarRatings && $util.isInteger(message.fiveStarRatings.low) && $util.isInteger(message.fiveStarRatings.high)))
                return "fiveStarRatings: integer|Long expected";
        if (message.thumbsUpCount != null && message.hasOwnProperty("thumbsUpCount"))
            if (!$util.isInteger(message.thumbsUpCount) && !(message.thumbsUpCount && $util.isInteger(message.thumbsUpCount.low) && $util.isInteger(message.thumbsUpCount.high)))
                return "thumbsUpCount: integer|Long expected";
        if (message.thumbsDownCount != null && message.hasOwnProperty("thumbsDownCount"))
            if (!$util.isInteger(message.thumbsDownCount) && !(message.thumbsDownCount && $util.isInteger(message.thumbsDownCount.low) && $util.isInteger(message.thumbsDownCount.high)))
                return "thumbsDownCount: integer|Long expected";
        if (message.commentCount != null && message.hasOwnProperty("commentCount"))
            if (!$util.isInteger(message.commentCount) && !(message.commentCount && $util.isInteger(message.commentCount.low) && $util.isInteger(message.commentCount.high)))
                return "commentCount: integer|Long expected";
        if (message.bayesianMeanRating != null && message.hasOwnProperty("bayesianMeanRating"))
            if (typeof message.bayesianMeanRating !== "number")
                return "bayesianMeanRating: number expected";
        if (message.tip != null && message.hasOwnProperty("tip")) {
            if (!Array.isArray(message.tip))
                return "tip: array expected";
            for (var i = 0; i < message.tip.length; ++i) {
                var error = $root.Tip.verify(message.tip[i]);
                if (error)
                    return "tip." + error;
            }
        }
        if (message.ratingLabel != null && message.hasOwnProperty("ratingLabel"))
            if (!$util.isString(message.ratingLabel))
                return "ratingLabel: string expected";
        if (message.ratingCountLabelAbbreviated != null && message.hasOwnProperty("ratingCountLabelAbbreviated"))
            if (!$util.isString(message.ratingCountLabelAbbreviated))
                return "ratingCountLabelAbbreviated: string expected";
        if (message.ratingCountLabel != null && message.hasOwnProperty("ratingCountLabel"))
            if (!$util.isString(message.ratingCountLabel))
                return "ratingCountLabel: string expected";
        return null;
    };

    /**
     * Creates an AggregateRating message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof AggregateRating
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {AggregateRating} AggregateRating
     */
    AggregateRating.fromObject = function fromObject(object) {
        if (object instanceof $root.AggregateRating)
            return object;
        var message = new $root.AggregateRating();
        if (object.type != null)
            message.type = object.type | 0;
        if (object.starRating != null)
            message.starRating = Number(object.starRating);
        if (object.ratingsCount != null)
            if ($util.Long)
                (message.ratingsCount = $util.Long.fromValue(object.ratingsCount)).unsigned = true;
            else if (typeof object.ratingsCount === "string")
                message.ratingsCount = parseInt(object.ratingsCount, 10);
            else if (typeof object.ratingsCount === "number")
                message.ratingsCount = object.ratingsCount;
            else if (typeof object.ratingsCount === "object")
                message.ratingsCount = new $util.LongBits(object.ratingsCount.low >>> 0, object.ratingsCount.high >>> 0).toNumber(true);
        if (object.oneStarRatings != null)
            if ($util.Long)
                (message.oneStarRatings = $util.Long.fromValue(object.oneStarRatings)).unsigned = true;
            else if (typeof object.oneStarRatings === "string")
                message.oneStarRatings = parseInt(object.oneStarRatings, 10);
            else if (typeof object.oneStarRatings === "number")
                message.oneStarRatings = object.oneStarRatings;
            else if (typeof object.oneStarRatings === "object")
                message.oneStarRatings = new $util.LongBits(object.oneStarRatings.low >>> 0, object.oneStarRatings.high >>> 0).toNumber(true);
        if (object.twoStarRatings != null)
            if ($util.Long)
                (message.twoStarRatings = $util.Long.fromValue(object.twoStarRatings)).unsigned = true;
            else if (typeof object.twoStarRatings === "string")
                message.twoStarRatings = parseInt(object.twoStarRatings, 10);
            else if (typeof object.twoStarRatings === "number")
                message.twoStarRatings = object.twoStarRatings;
            else if (typeof object.twoStarRatings === "object")
                message.twoStarRatings = new $util.LongBits(object.twoStarRatings.low >>> 0, object.twoStarRatings.high >>> 0).toNumber(true);
        if (object.threeStarRatings != null)
            if ($util.Long)
                (message.threeStarRatings = $util.Long.fromValue(object.threeStarRatings)).unsigned = true;
            else if (typeof object.threeStarRatings === "string")
                message.threeStarRatings = parseInt(object.threeStarRatings, 10);
            else if (typeof object.threeStarRatings === "number")
                message.threeStarRatings = object.threeStarRatings;
            else if (typeof object.threeStarRatings === "object")
                message.threeStarRatings = new $util.LongBits(object.threeStarRatings.low >>> 0, object.threeStarRatings.high >>> 0).toNumber(true);
        if (object.fourStarRatings != null)
            if ($util.Long)
                (message.fourStarRatings = $util.Long.fromValue(object.fourStarRatings)).unsigned = true;
            else if (typeof object.fourStarRatings === "string")
                message.fourStarRatings = parseInt(object.fourStarRatings, 10);
            else if (typeof object.fourStarRatings === "number")
                message.fourStarRatings = object.fourStarRatings;
            else if (typeof object.fourStarRatings === "object")
                message.fourStarRatings = new $util.LongBits(object.fourStarRatings.low >>> 0, object.fourStarRatings.high >>> 0).toNumber(true);
        if (object.fiveStarRatings != null)
            if ($util.Long)
                (message.fiveStarRatings = $util.Long.fromValue(object.fiveStarRatings)).unsigned = true;
            else if (typeof object.fiveStarRatings === "string")
                message.fiveStarRatings = parseInt(object.fiveStarRatings, 10);
            else if (typeof object.fiveStarRatings === "number")
                message.fiveStarRatings = object.fiveStarRatings;
            else if (typeof object.fiveStarRatings === "object")
                message.fiveStarRatings = new $util.LongBits(object.fiveStarRatings.low >>> 0, object.fiveStarRatings.high >>> 0).toNumber(true);
        if (object.thumbsUpCount != null)
            if ($util.Long)
                (message.thumbsUpCount = $util.Long.fromValue(object.thumbsUpCount)).unsigned = true;
            else if (typeof object.thumbsUpCount === "string")
                message.thumbsUpCount = parseInt(object.thumbsUpCount, 10);
            else if (typeof object.thumbsUpCount === "number")
                message.thumbsUpCount = object.thumbsUpCount;
            else if (typeof object.thumbsUpCount === "object")
                message.thumbsUpCount = new $util.LongBits(object.thumbsUpCount.low >>> 0, object.thumbsUpCount.high >>> 0).toNumber(true);
        if (object.thumbsDownCount != null)
            if ($util.Long)
                (message.thumbsDownCount = $util.Long.fromValue(object.thumbsDownCount)).unsigned = true;
            else if (typeof object.thumbsDownCount === "string")
                message.thumbsDownCount = parseInt(object.thumbsDownCount, 10);
            else if (typeof object.thumbsDownCount === "number")
                message.thumbsDownCount = object.thumbsDownCount;
            else if (typeof object.thumbsDownCount === "object")
                message.thumbsDownCount = new $util.LongBits(object.thumbsDownCount.low >>> 0, object.thumbsDownCount.high >>> 0).toNumber(true);
        if (object.commentCount != null)
            if ($util.Long)
                (message.commentCount = $util.Long.fromValue(object.commentCount)).unsigned = true;
            else if (typeof object.commentCount === "string")
                message.commentCount = parseInt(object.commentCount, 10);
            else if (typeof object.commentCount === "number")
                message.commentCount = object.commentCount;
            else if (typeof object.commentCount === "object")
                message.commentCount = new $util.LongBits(object.commentCount.low >>> 0, object.commentCount.high >>> 0).toNumber(true);
        if (object.bayesianMeanRating != null)
            message.bayesianMeanRating = Number(object.bayesianMeanRating);
        if (object.tip) {
            if (!Array.isArray(object.tip))
                throw TypeError(".AggregateRating.tip: array expected");
            message.tip = [];
            for (var i = 0; i < object.tip.length; ++i) {
                if (typeof object.tip[i] !== "object")
                    throw TypeError(".AggregateRating.tip: object expected");
                message.tip[i] = $root.Tip.fromObject(object.tip[i]);
            }
        }
        if (object.ratingLabel != null)
            message.ratingLabel = String(object.ratingLabel);
        if (object.ratingCountLabelAbbreviated != null)
            message.ratingCountLabelAbbreviated = String(object.ratingCountLabelAbbreviated);
        if (object.ratingCountLabel != null)
            message.ratingCountLabel = String(object.ratingCountLabel);
        return message;
    };

    /**
     * Creates a plain object from an AggregateRating message. Also converts values to other types if specified.
     * @function toObject
     * @memberof AggregateRating
     * @static
     * @param {AggregateRating} message AggregateRating
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    AggregateRating.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        var object = {};
        if (options.arrays || options.defaults)
            object.tip = [];
        if (options.defaults) {
            object.type = 1;
            object.starRating = 0;
            if ($util.Long) {
                var long = new $util.Long(0, 0, true);
                object.ratingsCount = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
            } else
                object.ratingsCount = options.longs === String ? "0" : 0;
            if ($util.Long) {
                var long = new $util.Long(0, 0, true);
                object.oneStarRatings = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
            } else
                object.oneStarRatings = options.longs === String ? "0" : 0;
            if ($util.Long) {
                var long = new $util.Long(0, 0, true);
                object.twoStarRatings = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
            } else
                object.twoStarRatings = options.longs === String ? "0" : 0;
            if ($util.Long) {
                var long = new $util.Long(0, 0, true);
                object.threeStarRatings = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
            } else
                object.threeStarRatings = options.longs === String ? "0" : 0;
            if ($util.Long) {
                var long = new $util.Long(0, 0, true);
                object.fourStarRatings = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
            } else
                object.fourStarRatings = options.longs === String ? "0" : 0;
            if ($util.Long) {
                var long = new $util.Long(0, 0, true);
                object.fiveStarRatings = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
            } else
                object.fiveStarRatings = options.longs === String ? "0" : 0;
            if ($util.Long) {
                var long = new $util.Long(0, 0, true);
                object.thumbsUpCount = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
            } else
                object.thumbsUpCount = options.longs === String ? "0" : 0;
            if ($util.Long) {
                var long = new $util.Long(0, 0, true);
                object.thumbsDownCount = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
            } else
                object.thumbsDownCount = options.longs === String ? "0" : 0;
            if ($util.Long) {
                var long = new $util.Long(0, 0, true);
                object.commentCount = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
            } else
                object.commentCount = options.longs === String ? "0" : 0;
            object.bayesianMeanRating = 0;
            object.ratingLabel = "";
            object.ratingCountLabelAbbreviated = "";
            object.ratingCountLabel = "";
        }
        if (message.type != null && message.hasOwnProperty("type"))
            object.type = message.type;
        if (message.starRating != null && message.hasOwnProperty("starRating"))
            object.starRating = options.json && !isFinite(message.starRating) ? String(message.starRating) : message.starRating;
        if (message.ratingsCount != null && message.hasOwnProperty("ratingsCount"))
            if (typeof message.ratingsCount === "number")
                object.ratingsCount = options.longs === String ? String(message.ratingsCount) : message.ratingsCount;
            else
                object.ratingsCount = options.longs === String ? $util.Long.prototype.toString.call(message.ratingsCount) : options.longs === Number ? new $util.LongBits(message.ratingsCount.low >>> 0, message.ratingsCount.high >>> 0).toNumber(true) : message.ratingsCount;
        if (message.oneStarRatings != null && message.hasOwnProperty("oneStarRatings"))
            if (typeof message.oneStarRatings === "number")
                object.oneStarRatings = options.longs === String ? String(message.oneStarRatings) : message.oneStarRatings;
            else
                object.oneStarRatings = options.longs === String ? $util.Long.prototype.toString.call(message.oneStarRatings) : options.longs === Number ? new $util.LongBits(message.oneStarRatings.low >>> 0, message.oneStarRatings.high >>> 0).toNumber(true) : message.oneStarRatings;
        if (message.twoStarRatings != null && message.hasOwnProperty("twoStarRatings"))
            if (typeof message.twoStarRatings === "number")
                object.twoStarRatings = options.longs === String ? String(message.twoStarRatings) : message.twoStarRatings;
            else
                object.twoStarRatings = options.longs === String ? $util.Long.prototype.toString.call(message.twoStarRatings) : options.longs === Number ? new $util.LongBits(message.twoStarRatings.low >>> 0, message.twoStarRatings.high >>> 0).toNumber(true) : message.twoStarRatings;
        if (message.threeStarRatings != null && message.hasOwnProperty("threeStarRatings"))
            if (typeof message.threeStarRatings === "number")
                object.threeStarRatings = options.longs === String ? String(message.threeStarRatings) : message.threeStarRatings;
            else
                object.threeStarRatings = options.longs === String ? $util.Long.prototype.toString.call(message.threeStarRatings) : options.longs === Number ? new $util.LongBits(message.threeStarRatings.low >>> 0, message.threeStarRatings.high >>> 0).toNumber(true) : message.threeStarRatings;
        if (message.fourStarRatings != null && message.hasOwnProperty("fourStarRatings"))
            if (typeof message.fourStarRatings === "number")
                object.fourStarRatings = options.longs === String ? String(message.fourStarRatings) : message.fourStarRatings;
            else
                object.fourStarRatings = options.longs === String ? $util.Long.prototype.toString.call(message.fourStarRatings) : options.longs === Number ? new $util.LongBits(message.fourStarRatings.low >>> 0, message.fourStarRatings.high >>> 0).toNumber(true) : message.fourStarRatings;
        if (message.fiveStarRatings != null && message.hasOwnProperty("fiveStarRatings"))
            if (typeof message.fiveStarRatings === "number")
                object.fiveStarRatings = options.longs === String ? String(message.fiveStarRatings) : message.fiveStarRatings;
            else
                object.fiveStarRatings = options.longs === String ? $util.Long.prototype.toString.call(message.fiveStarRatings) : options.longs === Number ? new $util.LongBits(message.fiveStarRatings.low >>> 0, message.fiveStarRatings.high >>> 0).toNumber(true) : message.fiveStarRatings;
        if (message.thumbsUpCount != null && message.hasOwnProperty("thumbsUpCount"))
            if (typeof message.thumbsUpCount === "number")
                object.thumbsUpCount = options.longs === String ? String(message.thumbsUpCount) : message.thumbsUpCount;
            else
                object.thumbsUpCount = options.longs === String ? $util.Long.prototype.toString.call(message.thumbsUpCount) : options.longs === Number ? new $util.LongBits(message.thumbsUpCount.low >>> 0, message.thumbsUpCount.high >>> 0).toNumber(true) : message.thumbsUpCount;
        if (message.thumbsDownCount != null && message.hasOwnProperty("thumbsDownCount"))
            if (typeof message.thumbsDownCount === "number")
                object.thumbsDownCount = options.longs === String ? String(message.thumbsDownCount) : message.thumbsDownCount;
            else
                object.thumbsDownCount = options.longs === String ? $util.Long.prototype.toString.call(message.thumbsDownCount) : options.longs === Number ? new $util.LongBits(message.thumbsDownCount.low >>> 0, message.thumbsDownCount.high >>> 0).toNumber(true) : message.thumbsDownCount;
        if (message.commentCount != null && message.hasOwnProperty("commentCount"))
            if (typeof message.commentCount === "number")
                object.commentCount = options.longs === String ? String(message.commentCount) : message.commentCount;
            else
                object.commentCount = options.longs === String ? $util.Long.prototype.toString.call(message.commentCount) : options.longs === Number ? new $util.LongBits(message.commentCount.low >>> 0, message.commentCount.high >>> 0).toNumber(true) : message.commentCount;
        if (message.bayesianMeanRating != null && message.hasOwnProperty("bayesianMeanRating"))
            object.bayesianMeanRating = options.json && !isFinite(message.bayesianMeanRating) ? String(message.bayesianMeanRating) : message.bayesianMeanRating;
        if (message.tip && message.tip.length) {
            object.tip = [];
            for (var j = 0; j < message.tip.length; ++j)
                object.tip[j] = $root.Tip.toObject(message.tip[j], options);
        }
        if (message.ratingLabel != null && message.hasOwnProperty("ratingLabel"))
            object.ratingLabel = message.ratingLabel;
        if (message.ratingCountLabelAbbreviated != null && message.hasOwnProperty("ratingCountLabelAbbreviated"))
            object.ratingCountLabelAbbreviated = message.ratingCountLabelAbbreviated;
        if (message.ratingCountLabel != null && message.hasOwnProperty("ratingCountLabel"))
            object.ratingCountLabel = message.ratingCountLabel;
        return object;
    };

    /**
     * Converts this AggregateRating to JSON.
     * @function toJSON
     * @memberof AggregateRating
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    AggregateRating.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return AggregateRating;
})();

$root.Tip = (function() {

    /**
     * Properties of a Tip.
     * @exports ITip
     * @interface ITip
     * @property {string|null} [tipId] Tip tipId
     * @property {string|null} [text] Tip text
     * @property {number|null} [polarity] Tip polarity
     * @property {number|Long|null} [reviewCount] Tip reviewCount
     * @property {string|null} [language] Tip language
     * @property {Array.<string>|null} [snippetReviewId] Tip snippetReviewId
     */

    /**
     * Constructs a new Tip.
     * @exports Tip
     * @classdesc Represents a Tip.
     * @implements ITip
     * @constructor
     * @param {ITip=} [properties] Properties to set
     */
    function Tip(properties) {
        this.snippetReviewId = [];
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * Tip tipId.
     * @member {string} tipId
     * @memberof Tip
     * @instance
     */
    Tip.prototype.tipId = "";

    /**
     * Tip text.
     * @member {string} text
     * @memberof Tip
     * @instance
     */
    Tip.prototype.text = "";

    /**
     * Tip polarity.
     * @member {number} polarity
     * @memberof Tip
     * @instance
     */
    Tip.prototype.polarity = 0;

    /**
     * Tip reviewCount.
     * @member {number|Long} reviewCount
     * @memberof Tip
     * @instance
     */
    Tip.prototype.reviewCount = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

    /**
     * Tip language.
     * @member {string} language
     * @memberof Tip
     * @instance
     */
    Tip.prototype.language = "";

    /**
     * Tip snippetReviewId.
     * @member {Array.<string>} snippetReviewId
     * @memberof Tip
     * @instance
     */
    Tip.prototype.snippetReviewId = $util.emptyArray;

    /**
     * Creates a new Tip instance using the specified properties.
     * @function create
     * @memberof Tip
     * @static
     * @param {ITip=} [properties] Properties to set
     * @returns {Tip} Tip instance
     */
    Tip.create = function create(properties) {
        return new Tip(properties);
    };

    /**
     * Encodes the specified Tip message. Does not implicitly {@link Tip.verify|verify} messages.
     * @function encode
     * @memberof Tip
     * @static
     * @param {ITip} message Tip message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    Tip.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.tipId != null && Object.hasOwnProperty.call(message, "tipId"))
            writer.uint32(/* id 1, wireType 2 =*/10).string(message.tipId);
        if (message.text != null && Object.hasOwnProperty.call(message, "text"))
            writer.uint32(/* id 2, wireType 2 =*/18).string(message.text);
        if (message.polarity != null && Object.hasOwnProperty.call(message, "polarity"))
            writer.uint32(/* id 3, wireType 0 =*/24).int32(message.polarity);
        if (message.reviewCount != null && Object.hasOwnProperty.call(message, "reviewCount"))
            writer.uint32(/* id 4, wireType 0 =*/32).int64(message.reviewCount);
        if (message.language != null && Object.hasOwnProperty.call(message, "language"))
            writer.uint32(/* id 5, wireType 2 =*/42).string(message.language);
        if (message.snippetReviewId != null && message.snippetReviewId.length)
            for (var i = 0; i < message.snippetReviewId.length; ++i)
                writer.uint32(/* id 6, wireType 2 =*/50).string(message.snippetReviewId[i]);
        return writer;
    };

    /**
     * Encodes the specified Tip message, length delimited. Does not implicitly {@link Tip.verify|verify} messages.
     * @function encodeDelimited
     * @memberof Tip
     * @static
     * @param {ITip} message Tip message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    Tip.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a Tip message from the specified reader or buffer.
     * @function decode
     * @memberof Tip
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {Tip} Tip
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    Tip.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Tip();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.tipId = reader.string();
                break;
            case 2:
                message.text = reader.string();
                break;
            case 3:
                message.polarity = reader.int32();
                break;
            case 4:
                message.reviewCount = reader.int64();
                break;
            case 5:
                message.language = reader.string();
                break;
            case 6:
                if (!(message.snippetReviewId && message.snippetReviewId.length))
                    message.snippetReviewId = [];
                message.snippetReviewId.push(reader.string());
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a Tip message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof Tip
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {Tip} Tip
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    Tip.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a Tip message.
     * @function verify
     * @memberof Tip
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    Tip.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.tipId != null && message.hasOwnProperty("tipId"))
            if (!$util.isString(message.tipId))
                return "tipId: string expected";
        if (message.text != null && message.hasOwnProperty("text"))
            if (!$util.isString(message.text))
                return "text: string expected";
        if (message.polarity != null && message.hasOwnProperty("polarity"))
            if (!$util.isInteger(message.polarity))
                return "polarity: integer expected";
        if (message.reviewCount != null && message.hasOwnProperty("reviewCount"))
            if (!$util.isInteger(message.reviewCount) && !(message.reviewCount && $util.isInteger(message.reviewCount.low) && $util.isInteger(message.reviewCount.high)))
                return "reviewCount: integer|Long expected";
        if (message.language != null && message.hasOwnProperty("language"))
            if (!$util.isString(message.language))
                return "language: string expected";
        if (message.snippetReviewId != null && message.hasOwnProperty("snippetReviewId")) {
            if (!Array.isArray(message.snippetReviewId))
                return "snippetReviewId: array expected";
            for (var i = 0; i < message.snippetReviewId.length; ++i)
                if (!$util.isString(message.snippetReviewId[i]))
                    return "snippetReviewId: string[] expected";
        }
        return null;
    };

    /**
     * Creates a Tip message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof Tip
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {Tip} Tip
     */
    Tip.fromObject = function fromObject(object) {
        if (object instanceof $root.Tip)
            return object;
        var message = new $root.Tip();
        if (object.tipId != null)
            message.tipId = String(object.tipId);
        if (object.text != null)
            message.text = String(object.text);
        if (object.polarity != null)
            message.polarity = object.polarity | 0;
        if (object.reviewCount != null)
            if ($util.Long)
                (message.reviewCount = $util.Long.fromValue(object.reviewCount)).unsigned = false;
            else if (typeof object.reviewCount === "string")
                message.reviewCount = parseInt(object.reviewCount, 10);
            else if (typeof object.reviewCount === "number")
                message.reviewCount = object.reviewCount;
            else if (typeof object.reviewCount === "object")
                message.reviewCount = new $util.LongBits(object.reviewCount.low >>> 0, object.reviewCount.high >>> 0).toNumber();
        if (object.language != null)
            message.language = String(object.language);
        if (object.snippetReviewId) {
            if (!Array.isArray(object.snippetReviewId))
                throw TypeError(".Tip.snippetReviewId: array expected");
            message.snippetReviewId = [];
            for (var i = 0; i < object.snippetReviewId.length; ++i)
                message.snippetReviewId[i] = String(object.snippetReviewId[i]);
        }
        return message;
    };

    /**
     * Creates a plain object from a Tip message. Also converts values to other types if specified.
     * @function toObject
     * @memberof Tip
     * @static
     * @param {Tip} message Tip
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    Tip.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        var object = {};
        if (options.arrays || options.defaults)
            object.snippetReviewId = [];
        if (options.defaults) {
            object.tipId = "";
            object.text = "";
            object.polarity = 0;
            if ($util.Long) {
                var long = new $util.Long(0, 0, false);
                object.reviewCount = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
            } else
                object.reviewCount = options.longs === String ? "0" : 0;
            object.language = "";
        }
        if (message.tipId != null && message.hasOwnProperty("tipId"))
            object.tipId = message.tipId;
        if (message.text != null && message.hasOwnProperty("text"))
            object.text = message.text;
        if (message.polarity != null && message.hasOwnProperty("polarity"))
            object.polarity = message.polarity;
        if (message.reviewCount != null && message.hasOwnProperty("reviewCount"))
            if (typeof message.reviewCount === "number")
                object.reviewCount = options.longs === String ? String(message.reviewCount) : message.reviewCount;
            else
                object.reviewCount = options.longs === String ? $util.Long.prototype.toString.call(message.reviewCount) : options.longs === Number ? new $util.LongBits(message.reviewCount.low >>> 0, message.reviewCount.high >>> 0).toNumber() : message.reviewCount;
        if (message.language != null && message.hasOwnProperty("language"))
            object.language = message.language;
        if (message.snippetReviewId && message.snippetReviewId.length) {
            object.snippetReviewId = [];
            for (var j = 0; j < message.snippetReviewId.length; ++j)
                object.snippetReviewId[j] = message.snippetReviewId[j];
        }
        return object;
    };

    /**
     * Converts this Tip to JSON.
     * @function toJSON
     * @memberof Tip
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    Tip.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return Tip;
})();

$root.ReviewTip = (function() {

    /**
     * Properties of a ReviewTip.
     * @exports IReviewTip
     * @interface IReviewTip
     * @property {string|null} [tipUrl] ReviewTip tipUrl
     * @property {string|null} [text] ReviewTip text
     * @property {number|null} [polarity] ReviewTip polarity
     * @property {number|Long|null} [reviewCount] ReviewTip reviewCount
     */

    /**
     * Constructs a new ReviewTip.
     * @exports ReviewTip
     * @classdesc Represents a ReviewTip.
     * @implements IReviewTip
     * @constructor
     * @param {IReviewTip=} [properties] Properties to set
     */
    function ReviewTip(properties) {
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * ReviewTip tipUrl.
     * @member {string} tipUrl
     * @memberof ReviewTip
     * @instance
     */
    ReviewTip.prototype.tipUrl = "";

    /**
     * ReviewTip text.
     * @member {string} text
     * @memberof ReviewTip
     * @instance
     */
    ReviewTip.prototype.text = "";

    /**
     * ReviewTip polarity.
     * @member {number} polarity
     * @memberof ReviewTip
     * @instance
     */
    ReviewTip.prototype.polarity = 0;

    /**
     * ReviewTip reviewCount.
     * @member {number|Long} reviewCount
     * @memberof ReviewTip
     * @instance
     */
    ReviewTip.prototype.reviewCount = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

    /**
     * Creates a new ReviewTip instance using the specified properties.
     * @function create
     * @memberof ReviewTip
     * @static
     * @param {IReviewTip=} [properties] Properties to set
     * @returns {ReviewTip} ReviewTip instance
     */
    ReviewTip.create = function create(properties) {
        return new ReviewTip(properties);
    };

    /**
     * Encodes the specified ReviewTip message. Does not implicitly {@link ReviewTip.verify|verify} messages.
     * @function encode
     * @memberof ReviewTip
     * @static
     * @param {IReviewTip} message ReviewTip message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    ReviewTip.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.tipUrl != null && Object.hasOwnProperty.call(message, "tipUrl"))
            writer.uint32(/* id 1, wireType 2 =*/10).string(message.tipUrl);
        if (message.text != null && Object.hasOwnProperty.call(message, "text"))
            writer.uint32(/* id 2, wireType 2 =*/18).string(message.text);
        if (message.polarity != null && Object.hasOwnProperty.call(message, "polarity"))
            writer.uint32(/* id 3, wireType 0 =*/24).int32(message.polarity);
        if (message.reviewCount != null && Object.hasOwnProperty.call(message, "reviewCount"))
            writer.uint32(/* id 4, wireType 0 =*/32).int64(message.reviewCount);
        return writer;
    };

    /**
     * Encodes the specified ReviewTip message, length delimited. Does not implicitly {@link ReviewTip.verify|verify} messages.
     * @function encodeDelimited
     * @memberof ReviewTip
     * @static
     * @param {IReviewTip} message ReviewTip message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    ReviewTip.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a ReviewTip message from the specified reader or buffer.
     * @function decode
     * @memberof ReviewTip
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {ReviewTip} ReviewTip
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    ReviewTip.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ReviewTip();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.tipUrl = reader.string();
                break;
            case 2:
                message.text = reader.string();
                break;
            case 3:
                message.polarity = reader.int32();
                break;
            case 4:
                message.reviewCount = reader.int64();
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a ReviewTip message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof ReviewTip
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {ReviewTip} ReviewTip
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    ReviewTip.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a ReviewTip message.
     * @function verify
     * @memberof ReviewTip
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    ReviewTip.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.tipUrl != null && message.hasOwnProperty("tipUrl"))
            if (!$util.isString(message.tipUrl))
                return "tipUrl: string expected";
        if (message.text != null && message.hasOwnProperty("text"))
            if (!$util.isString(message.text))
                return "text: string expected";
        if (message.polarity != null && message.hasOwnProperty("polarity"))
            if (!$util.isInteger(message.polarity))
                return "polarity: integer expected";
        if (message.reviewCount != null && message.hasOwnProperty("reviewCount"))
            if (!$util.isInteger(message.reviewCount) && !(message.reviewCount && $util.isInteger(message.reviewCount.low) && $util.isInteger(message.reviewCount.high)))
                return "reviewCount: integer|Long expected";
        return null;
    };

    /**
     * Creates a ReviewTip message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof ReviewTip
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {ReviewTip} ReviewTip
     */
    ReviewTip.fromObject = function fromObject(object) {
        if (object instanceof $root.ReviewTip)
            return object;
        var message = new $root.ReviewTip();
        if (object.tipUrl != null)
            message.tipUrl = String(object.tipUrl);
        if (object.text != null)
            message.text = String(object.text);
        if (object.polarity != null)
            message.polarity = object.polarity | 0;
        if (object.reviewCount != null)
            if ($util.Long)
                (message.reviewCount = $util.Long.fromValue(object.reviewCount)).unsigned = false;
            else if (typeof object.reviewCount === "string")
                message.reviewCount = parseInt(object.reviewCount, 10);
            else if (typeof object.reviewCount === "number")
                message.reviewCount = object.reviewCount;
            else if (typeof object.reviewCount === "object")
                message.reviewCount = new $util.LongBits(object.reviewCount.low >>> 0, object.reviewCount.high >>> 0).toNumber();
        return message;
    };

    /**
     * Creates a plain object from a ReviewTip message. Also converts values to other types if specified.
     * @function toObject
     * @memberof ReviewTip
     * @static
     * @param {ReviewTip} message ReviewTip
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    ReviewTip.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        var object = {};
        if (options.defaults) {
            object.tipUrl = "";
            object.text = "";
            object.polarity = 0;
            if ($util.Long) {
                var long = new $util.Long(0, 0, false);
                object.reviewCount = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
            } else
                object.reviewCount = options.longs === String ? "0" : 0;
        }
        if (message.tipUrl != null && message.hasOwnProperty("tipUrl"))
            object.tipUrl = message.tipUrl;
        if (message.text != null && message.hasOwnProperty("text"))
            object.text = message.text;
        if (message.polarity != null && message.hasOwnProperty("polarity"))
            object.polarity = message.polarity;
        if (message.reviewCount != null && message.hasOwnProperty("reviewCount"))
            if (typeof message.reviewCount === "number")
                object.reviewCount = options.longs === String ? String(message.reviewCount) : message.reviewCount;
            else
                object.reviewCount = options.longs === String ? $util.Long.prototype.toString.call(message.reviewCount) : options.longs === Number ? new $util.LongBits(message.reviewCount.low >>> 0, message.reviewCount.high >>> 0).toNumber() : message.reviewCount;
        return object;
    };

    /**
     * Converts this ReviewTip to JSON.
     * @function toJSON
     * @memberof ReviewTip
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    ReviewTip.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return ReviewTip;
})();

$root.AcceptTosResponse = (function() {

    /**
     * Properties of an AcceptTosResponse.
     * @exports IAcceptTosResponse
     * @interface IAcceptTosResponse
     */

    /**
     * Constructs a new AcceptTosResponse.
     * @exports AcceptTosResponse
     * @classdesc Represents an AcceptTosResponse.
     * @implements IAcceptTosResponse
     * @constructor
     * @param {IAcceptTosResponse=} [properties] Properties to set
     */
    function AcceptTosResponse(properties) {
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * Creates a new AcceptTosResponse instance using the specified properties.
     * @function create
     * @memberof AcceptTosResponse
     * @static
     * @param {IAcceptTosResponse=} [properties] Properties to set
     * @returns {AcceptTosResponse} AcceptTosResponse instance
     */
    AcceptTosResponse.create = function create(properties) {
        return new AcceptTosResponse(properties);
    };

    /**
     * Encodes the specified AcceptTosResponse message. Does not implicitly {@link AcceptTosResponse.verify|verify} messages.
     * @function encode
     * @memberof AcceptTosResponse
     * @static
     * @param {IAcceptTosResponse} message AcceptTosResponse message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    AcceptTosResponse.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        return writer;
    };

    /**
     * Encodes the specified AcceptTosResponse message, length delimited. Does not implicitly {@link AcceptTosResponse.verify|verify} messages.
     * @function encodeDelimited
     * @memberof AcceptTosResponse
     * @static
     * @param {IAcceptTosResponse} message AcceptTosResponse message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    AcceptTosResponse.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes an AcceptTosResponse message from the specified reader or buffer.
     * @function decode
     * @memberof AcceptTosResponse
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {AcceptTosResponse} AcceptTosResponse
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    AcceptTosResponse.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.AcceptTosResponse();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes an AcceptTosResponse message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof AcceptTosResponse
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {AcceptTosResponse} AcceptTosResponse
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    AcceptTosResponse.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies an AcceptTosResponse message.
     * @function verify
     * @memberof AcceptTosResponse
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    AcceptTosResponse.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        return null;
    };

    /**
     * Creates an AcceptTosResponse message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof AcceptTosResponse
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {AcceptTosResponse} AcceptTosResponse
     */
    AcceptTosResponse.fromObject = function fromObject(object) {
        if (object instanceof $root.AcceptTosResponse)
            return object;
        return new $root.AcceptTosResponse();
    };

    /**
     * Creates a plain object from an AcceptTosResponse message. Also converts values to other types if specified.
     * @function toObject
     * @memberof AcceptTosResponse
     * @static
     * @param {AcceptTosResponse} message AcceptTosResponse
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    AcceptTosResponse.toObject = function toObject() {
        return {};
    };

    /**
     * Converts this AcceptTosResponse to JSON.
     * @function toJSON
     * @memberof AcceptTosResponse
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    AcceptTosResponse.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return AcceptTosResponse;
})();

$root.CarrierBillingConfig = (function() {

    /**
     * Properties of a CarrierBillingConfig.
     * @exports ICarrierBillingConfig
     * @interface ICarrierBillingConfig
     * @property {string|null} [id] CarrierBillingConfig id
     * @property {string|null} [name] CarrierBillingConfig name
     * @property {number|null} [apiVersion] CarrierBillingConfig apiVersion
     * @property {string|null} [provisioningUrl] CarrierBillingConfig provisioningUrl
     * @property {string|null} [credentialsUrl] CarrierBillingConfig credentialsUrl
     * @property {boolean|null} [tosRequired] CarrierBillingConfig tosRequired
     * @property {boolean|null} [perTransactionCredentialsRequired] CarrierBillingConfig perTransactionCredentialsRequired
     * @property {boolean|null} [sendSubscriberIdWithCarrierBillingRequests] CarrierBillingConfig sendSubscriberIdWithCarrierBillingRequests
     */

    /**
     * Constructs a new CarrierBillingConfig.
     * @exports CarrierBillingConfig
     * @classdesc Represents a CarrierBillingConfig.
     * @implements ICarrierBillingConfig
     * @constructor
     * @param {ICarrierBillingConfig=} [properties] Properties to set
     */
    function CarrierBillingConfig(properties) {
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * CarrierBillingConfig id.
     * @member {string} id
     * @memberof CarrierBillingConfig
     * @instance
     */
    CarrierBillingConfig.prototype.id = "";

    /**
     * CarrierBillingConfig name.
     * @member {string} name
     * @memberof CarrierBillingConfig
     * @instance
     */
    CarrierBillingConfig.prototype.name = "";

    /**
     * CarrierBillingConfig apiVersion.
     * @member {number} apiVersion
     * @memberof CarrierBillingConfig
     * @instance
     */
    CarrierBillingConfig.prototype.apiVersion = 0;

    /**
     * CarrierBillingConfig provisioningUrl.
     * @member {string} provisioningUrl
     * @memberof CarrierBillingConfig
     * @instance
     */
    CarrierBillingConfig.prototype.provisioningUrl = "";

    /**
     * CarrierBillingConfig credentialsUrl.
     * @member {string} credentialsUrl
     * @memberof CarrierBillingConfig
     * @instance
     */
    CarrierBillingConfig.prototype.credentialsUrl = "";

    /**
     * CarrierBillingConfig tosRequired.
     * @member {boolean} tosRequired
     * @memberof CarrierBillingConfig
     * @instance
     */
    CarrierBillingConfig.prototype.tosRequired = false;

    /**
     * CarrierBillingConfig perTransactionCredentialsRequired.
     * @member {boolean} perTransactionCredentialsRequired
     * @memberof CarrierBillingConfig
     * @instance
     */
    CarrierBillingConfig.prototype.perTransactionCredentialsRequired = false;

    /**
     * CarrierBillingConfig sendSubscriberIdWithCarrierBillingRequests.
     * @member {boolean} sendSubscriberIdWithCarrierBillingRequests
     * @memberof CarrierBillingConfig
     * @instance
     */
    CarrierBillingConfig.prototype.sendSubscriberIdWithCarrierBillingRequests = false;

    /**
     * Creates a new CarrierBillingConfig instance using the specified properties.
     * @function create
     * @memberof CarrierBillingConfig
     * @static
     * @param {ICarrierBillingConfig=} [properties] Properties to set
     * @returns {CarrierBillingConfig} CarrierBillingConfig instance
     */
    CarrierBillingConfig.create = function create(properties) {
        return new CarrierBillingConfig(properties);
    };

    /**
     * Encodes the specified CarrierBillingConfig message. Does not implicitly {@link CarrierBillingConfig.verify|verify} messages.
     * @function encode
     * @memberof CarrierBillingConfig
     * @static
     * @param {ICarrierBillingConfig} message CarrierBillingConfig message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    CarrierBillingConfig.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.id != null && Object.hasOwnProperty.call(message, "id"))
            writer.uint32(/* id 1, wireType 2 =*/10).string(message.id);
        if (message.name != null && Object.hasOwnProperty.call(message, "name"))
            writer.uint32(/* id 2, wireType 2 =*/18).string(message.name);
        if (message.apiVersion != null && Object.hasOwnProperty.call(message, "apiVersion"))
            writer.uint32(/* id 3, wireType 0 =*/24).int32(message.apiVersion);
        if (message.provisioningUrl != null && Object.hasOwnProperty.call(message, "provisioningUrl"))
            writer.uint32(/* id 4, wireType 2 =*/34).string(message.provisioningUrl);
        if (message.credentialsUrl != null && Object.hasOwnProperty.call(message, "credentialsUrl"))
            writer.uint32(/* id 5, wireType 2 =*/42).string(message.credentialsUrl);
        if (message.tosRequired != null && Object.hasOwnProperty.call(message, "tosRequired"))
            writer.uint32(/* id 6, wireType 0 =*/48).bool(message.tosRequired);
        if (message.perTransactionCredentialsRequired != null && Object.hasOwnProperty.call(message, "perTransactionCredentialsRequired"))
            writer.uint32(/* id 7, wireType 0 =*/56).bool(message.perTransactionCredentialsRequired);
        if (message.sendSubscriberIdWithCarrierBillingRequests != null && Object.hasOwnProperty.call(message, "sendSubscriberIdWithCarrierBillingRequests"))
            writer.uint32(/* id 8, wireType 0 =*/64).bool(message.sendSubscriberIdWithCarrierBillingRequests);
        return writer;
    };

    /**
     * Encodes the specified CarrierBillingConfig message, length delimited. Does not implicitly {@link CarrierBillingConfig.verify|verify} messages.
     * @function encodeDelimited
     * @memberof CarrierBillingConfig
     * @static
     * @param {ICarrierBillingConfig} message CarrierBillingConfig message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    CarrierBillingConfig.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a CarrierBillingConfig message from the specified reader or buffer.
     * @function decode
     * @memberof CarrierBillingConfig
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CarrierBillingConfig} CarrierBillingConfig
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CarrierBillingConfig.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CarrierBillingConfig();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.id = reader.string();
                break;
            case 2:
                message.name = reader.string();
                break;
            case 3:
                message.apiVersion = reader.int32();
                break;
            case 4:
                message.provisioningUrl = reader.string();
                break;
            case 5:
                message.credentialsUrl = reader.string();
                break;
            case 6:
                message.tosRequired = reader.bool();
                break;
            case 7:
                message.perTransactionCredentialsRequired = reader.bool();
                break;
            case 8:
                message.sendSubscriberIdWithCarrierBillingRequests = reader.bool();
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a CarrierBillingConfig message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof CarrierBillingConfig
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {CarrierBillingConfig} CarrierBillingConfig
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CarrierBillingConfig.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a CarrierBillingConfig message.
     * @function verify
     * @memberof CarrierBillingConfig
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    CarrierBillingConfig.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.id != null && message.hasOwnProperty("id"))
            if (!$util.isString(message.id))
                return "id: string expected";
        if (message.name != null && message.hasOwnProperty("name"))
            if (!$util.isString(message.name))
                return "name: string expected";
        if (message.apiVersion != null && message.hasOwnProperty("apiVersion"))
            if (!$util.isInteger(message.apiVersion))
                return "apiVersion: integer expected";
        if (message.provisioningUrl != null && message.hasOwnProperty("provisioningUrl"))
            if (!$util.isString(message.provisioningUrl))
                return "provisioningUrl: string expected";
        if (message.credentialsUrl != null && message.hasOwnProperty("credentialsUrl"))
            if (!$util.isString(message.credentialsUrl))
                return "credentialsUrl: string expected";
        if (message.tosRequired != null && message.hasOwnProperty("tosRequired"))
            if (typeof message.tosRequired !== "boolean")
                return "tosRequired: boolean expected";
        if (message.perTransactionCredentialsRequired != null && message.hasOwnProperty("perTransactionCredentialsRequired"))
            if (typeof message.perTransactionCredentialsRequired !== "boolean")
                return "perTransactionCredentialsRequired: boolean expected";
        if (message.sendSubscriberIdWithCarrierBillingRequests != null && message.hasOwnProperty("sendSubscriberIdWithCarrierBillingRequests"))
            if (typeof message.sendSubscriberIdWithCarrierBillingRequests !== "boolean")
                return "sendSubscriberIdWithCarrierBillingRequests: boolean expected";
        return null;
    };

    /**
     * Creates a CarrierBillingConfig message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof CarrierBillingConfig
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {CarrierBillingConfig} CarrierBillingConfig
     */
    CarrierBillingConfig.fromObject = function fromObject(object) {
        if (object instanceof $root.CarrierBillingConfig)
            return object;
        var message = new $root.CarrierBillingConfig();
        if (object.id != null)
            message.id = String(object.id);
        if (object.name != null)
            message.name = String(object.name);
        if (object.apiVersion != null)
            message.apiVersion = object.apiVersion | 0;
        if (object.provisioningUrl != null)
            message.provisioningUrl = String(object.provisioningUrl);
        if (object.credentialsUrl != null)
            message.credentialsUrl = String(object.credentialsUrl);
        if (object.tosRequired != null)
            message.tosRequired = Boolean(object.tosRequired);
        if (object.perTransactionCredentialsRequired != null)
            message.perTransactionCredentialsRequired = Boolean(object.perTransactionCredentialsRequired);
        if (object.sendSubscriberIdWithCarrierBillingRequests != null)
            message.sendSubscriberIdWithCarrierBillingRequests = Boolean(object.sendSubscriberIdWithCarrierBillingRequests);
        return message;
    };

    /**
     * Creates a plain object from a CarrierBillingConfig message. Also converts values to other types if specified.
     * @function toObject
     * @memberof CarrierBillingConfig
     * @static
     * @param {CarrierBillingConfig} message CarrierBillingConfig
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    CarrierBillingConfig.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        var object = {};
        if (options.defaults) {
            object.id = "";
            object.name = "";
            object.apiVersion = 0;
            object.provisioningUrl = "";
            object.credentialsUrl = "";
            object.tosRequired = false;
            object.perTransactionCredentialsRequired = false;
            object.sendSubscriberIdWithCarrierBillingRequests = false;
        }
        if (message.id != null && message.hasOwnProperty("id"))
            object.id = message.id;
        if (message.name != null && message.hasOwnProperty("name"))
            object.name = message.name;
        if (message.apiVersion != null && message.hasOwnProperty("apiVersion"))
            object.apiVersion = message.apiVersion;
        if (message.provisioningUrl != null && message.hasOwnProperty("provisioningUrl"))
            object.provisioningUrl = message.provisioningUrl;
        if (message.credentialsUrl != null && message.hasOwnProperty("credentialsUrl"))
            object.credentialsUrl = message.credentialsUrl;
        if (message.tosRequired != null && message.hasOwnProperty("tosRequired"))
            object.tosRequired = message.tosRequired;
        if (message.perTransactionCredentialsRequired != null && message.hasOwnProperty("perTransactionCredentialsRequired"))
            object.perTransactionCredentialsRequired = message.perTransactionCredentialsRequired;
        if (message.sendSubscriberIdWithCarrierBillingRequests != null && message.hasOwnProperty("sendSubscriberIdWithCarrierBillingRequests"))
            object.sendSubscriberIdWithCarrierBillingRequests = message.sendSubscriberIdWithCarrierBillingRequests;
        return object;
    };

    /**
     * Converts this CarrierBillingConfig to JSON.
     * @function toJSON
     * @memberof CarrierBillingConfig
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    CarrierBillingConfig.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return CarrierBillingConfig;
})();

$root.BillingConfig = (function() {

    /**
     * Properties of a BillingConfig.
     * @exports IBillingConfig
     * @interface IBillingConfig
     * @property {ICarrierBillingConfig|null} [carrierBillingConfig] BillingConfig carrierBillingConfig
     * @property {number|null} [maxIabApiVersion] BillingConfig maxIabApiVersion
     */

    /**
     * Constructs a new BillingConfig.
     * @exports BillingConfig
     * @classdesc Represents a BillingConfig.
     * @implements IBillingConfig
     * @constructor
     * @param {IBillingConfig=} [properties] Properties to set
     */
    function BillingConfig(properties) {
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * BillingConfig carrierBillingConfig.
     * @member {ICarrierBillingConfig|null|undefined} carrierBillingConfig
     * @memberof BillingConfig
     * @instance
     */
    BillingConfig.prototype.carrierBillingConfig = null;

    /**
     * BillingConfig maxIabApiVersion.
     * @member {number} maxIabApiVersion
     * @memberof BillingConfig
     * @instance
     */
    BillingConfig.prototype.maxIabApiVersion = 0;

    /**
     * Creates a new BillingConfig instance using the specified properties.
     * @function create
     * @memberof BillingConfig
     * @static
     * @param {IBillingConfig=} [properties] Properties to set
     * @returns {BillingConfig} BillingConfig instance
     */
    BillingConfig.create = function create(properties) {
        return new BillingConfig(properties);
    };

    /**
     * Encodes the specified BillingConfig message. Does not implicitly {@link BillingConfig.verify|verify} messages.
     * @function encode
     * @memberof BillingConfig
     * @static
     * @param {IBillingConfig} message BillingConfig message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    BillingConfig.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.carrierBillingConfig != null && Object.hasOwnProperty.call(message, "carrierBillingConfig"))
            $root.CarrierBillingConfig.encode(message.carrierBillingConfig, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
        if (message.maxIabApiVersion != null && Object.hasOwnProperty.call(message, "maxIabApiVersion"))
            writer.uint32(/* id 2, wireType 0 =*/16).int32(message.maxIabApiVersion);
        return writer;
    };

    /**
     * Encodes the specified BillingConfig message, length delimited. Does not implicitly {@link BillingConfig.verify|verify} messages.
     * @function encodeDelimited
     * @memberof BillingConfig
     * @static
     * @param {IBillingConfig} message BillingConfig message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    BillingConfig.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a BillingConfig message from the specified reader or buffer.
     * @function decode
     * @memberof BillingConfig
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {BillingConfig} BillingConfig
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    BillingConfig.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.BillingConfig();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.carrierBillingConfig = $root.CarrierBillingConfig.decode(reader, reader.uint32());
                break;
            case 2:
                message.maxIabApiVersion = reader.int32();
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a BillingConfig message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof BillingConfig
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {BillingConfig} BillingConfig
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    BillingConfig.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a BillingConfig message.
     * @function verify
     * @memberof BillingConfig
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    BillingConfig.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.carrierBillingConfig != null && message.hasOwnProperty("carrierBillingConfig")) {
            var error = $root.CarrierBillingConfig.verify(message.carrierBillingConfig);
            if (error)
                return "carrierBillingConfig." + error;
        }
        if (message.maxIabApiVersion != null && message.hasOwnProperty("maxIabApiVersion"))
            if (!$util.isInteger(message.maxIabApiVersion))
                return "maxIabApiVersion: integer expected";
        return null;
    };

    /**
     * Creates a BillingConfig message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof BillingConfig
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {BillingConfig} BillingConfig
     */
    BillingConfig.fromObject = function fromObject(object) {
        if (object instanceof $root.BillingConfig)
            return object;
        var message = new $root.BillingConfig();
        if (object.carrierBillingConfig != null) {
            if (typeof object.carrierBillingConfig !== "object")
                throw TypeError(".BillingConfig.carrierBillingConfig: object expected");
            message.carrierBillingConfig = $root.CarrierBillingConfig.fromObject(object.carrierBillingConfig);
        }
        if (object.maxIabApiVersion != null)
            message.maxIabApiVersion = object.maxIabApiVersion | 0;
        return message;
    };

    /**
     * Creates a plain object from a BillingConfig message. Also converts values to other types if specified.
     * @function toObject
     * @memberof BillingConfig
     * @static
     * @param {BillingConfig} message BillingConfig
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    BillingConfig.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        var object = {};
        if (options.defaults) {
            object.carrierBillingConfig = null;
            object.maxIabApiVersion = 0;
        }
        if (message.carrierBillingConfig != null && message.hasOwnProperty("carrierBillingConfig"))
            object.carrierBillingConfig = $root.CarrierBillingConfig.toObject(message.carrierBillingConfig, options);
        if (message.maxIabApiVersion != null && message.hasOwnProperty("maxIabApiVersion"))
            object.maxIabApiVersion = message.maxIabApiVersion;
        return object;
    };

    /**
     * Converts this BillingConfig to JSON.
     * @function toJSON
     * @memberof BillingConfig
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    BillingConfig.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return BillingConfig;
})();

$root.CorpusMetadata = (function() {

    /**
     * Properties of a CorpusMetadata.
     * @exports ICorpusMetadata
     * @interface ICorpusMetadata
     * @property {number|null} [backend] CorpusMetadata backend
     * @property {string|null} [name] CorpusMetadata name
     * @property {string|null} [landingUrl] CorpusMetadata landingUrl
     * @property {string|null} [libraryName] CorpusMetadata libraryName
     * @property {string|null} [recsWidgetUrl] CorpusMetadata recsWidgetUrl
     * @property {string|null} [shopName] CorpusMetadata shopName
     */

    /**
     * Constructs a new CorpusMetadata.
     * @exports CorpusMetadata
     * @classdesc Represents a CorpusMetadata.
     * @implements ICorpusMetadata
     * @constructor
     * @param {ICorpusMetadata=} [properties] Properties to set
     */
    function CorpusMetadata(properties) {
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * CorpusMetadata backend.
     * @member {number} backend
     * @memberof CorpusMetadata
     * @instance
     */
    CorpusMetadata.prototype.backend = 0;

    /**
     * CorpusMetadata name.
     * @member {string} name
     * @memberof CorpusMetadata
     * @instance
     */
    CorpusMetadata.prototype.name = "";

    /**
     * CorpusMetadata landingUrl.
     * @member {string} landingUrl
     * @memberof CorpusMetadata
     * @instance
     */
    CorpusMetadata.prototype.landingUrl = "";

    /**
     * CorpusMetadata libraryName.
     * @member {string} libraryName
     * @memberof CorpusMetadata
     * @instance
     */
    CorpusMetadata.prototype.libraryName = "";

    /**
     * CorpusMetadata recsWidgetUrl.
     * @member {string} recsWidgetUrl
     * @memberof CorpusMetadata
     * @instance
     */
    CorpusMetadata.prototype.recsWidgetUrl = "";

    /**
     * CorpusMetadata shopName.
     * @member {string} shopName
     * @memberof CorpusMetadata
     * @instance
     */
    CorpusMetadata.prototype.shopName = "";

    /**
     * Creates a new CorpusMetadata instance using the specified properties.
     * @function create
     * @memberof CorpusMetadata
     * @static
     * @param {ICorpusMetadata=} [properties] Properties to set
     * @returns {CorpusMetadata} CorpusMetadata instance
     */
    CorpusMetadata.create = function create(properties) {
        return new CorpusMetadata(properties);
    };

    /**
     * Encodes the specified CorpusMetadata message. Does not implicitly {@link CorpusMetadata.verify|verify} messages.
     * @function encode
     * @memberof CorpusMetadata
     * @static
     * @param {ICorpusMetadata} message CorpusMetadata message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    CorpusMetadata.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.backend != null && Object.hasOwnProperty.call(message, "backend"))
            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.backend);
        if (message.name != null && Object.hasOwnProperty.call(message, "name"))
            writer.uint32(/* id 2, wireType 2 =*/18).string(message.name);
        if (message.landingUrl != null && Object.hasOwnProperty.call(message, "landingUrl"))
            writer.uint32(/* id 3, wireType 2 =*/26).string(message.landingUrl);
        if (message.libraryName != null && Object.hasOwnProperty.call(message, "libraryName"))
            writer.uint32(/* id 4, wireType 2 =*/34).string(message.libraryName);
        if (message.recsWidgetUrl != null && Object.hasOwnProperty.call(message, "recsWidgetUrl"))
            writer.uint32(/* id 6, wireType 2 =*/50).string(message.recsWidgetUrl);
        if (message.shopName != null && Object.hasOwnProperty.call(message, "shopName"))
            writer.uint32(/* id 7, wireType 2 =*/58).string(message.shopName);
        return writer;
    };

    /**
     * Encodes the specified CorpusMetadata message, length delimited. Does not implicitly {@link CorpusMetadata.verify|verify} messages.
     * @function encodeDelimited
     * @memberof CorpusMetadata
     * @static
     * @param {ICorpusMetadata} message CorpusMetadata message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    CorpusMetadata.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a CorpusMetadata message from the specified reader or buffer.
     * @function decode
     * @memberof CorpusMetadata
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CorpusMetadata} CorpusMetadata
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CorpusMetadata.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CorpusMetadata();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.backend = reader.int32();
                break;
            case 2:
                message.name = reader.string();
                break;
            case 3:
                message.landingUrl = reader.string();
                break;
            case 4:
                message.libraryName = reader.string();
                break;
            case 6:
                message.recsWidgetUrl = reader.string();
                break;
            case 7:
                message.shopName = reader.string();
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a CorpusMetadata message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof CorpusMetadata
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {CorpusMetadata} CorpusMetadata
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CorpusMetadata.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a CorpusMetadata message.
     * @function verify
     * @memberof CorpusMetadata
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    CorpusMetadata.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.backend != null && message.hasOwnProperty("backend"))
            if (!$util.isInteger(message.backend))
                return "backend: integer expected";
        if (message.name != null && message.hasOwnProperty("name"))
            if (!$util.isString(message.name))
                return "name: string expected";
        if (message.landingUrl != null && message.hasOwnProperty("landingUrl"))
            if (!$util.isString(message.landingUrl))
                return "landingUrl: string expected";
        if (message.libraryName != null && message.hasOwnProperty("libraryName"))
            if (!$util.isString(message.libraryName))
                return "libraryName: string expected";
        if (message.recsWidgetUrl != null && message.hasOwnProperty("recsWidgetUrl"))
            if (!$util.isString(message.recsWidgetUrl))
                return "recsWidgetUrl: string expected";
        if (message.shopName != null && message.hasOwnProperty("shopName"))
            if (!$util.isString(message.shopName))
                return "shopName: string expected";
        return null;
    };

    /**
     * Creates a CorpusMetadata message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof CorpusMetadata
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {CorpusMetadata} CorpusMetadata
     */
    CorpusMetadata.fromObject = function fromObject(object) {
        if (object instanceof $root.CorpusMetadata)
            return object;
        var message = new $root.CorpusMetadata();
        if (object.backend != null)
            message.backend = object.backend | 0;
        if (object.name != null)
            message.name = String(object.name);
        if (object.landingUrl != null)
            message.landingUrl = String(object.landingUrl);
        if (object.libraryName != null)
            message.libraryName = String(object.libraryName);
        if (object.recsWidgetUrl != null)
            message.recsWidgetUrl = String(object.recsWidgetUrl);
        if (object.shopName != null)
            message.shopName = String(object.shopName);
        return message;
    };

    /**
     * Creates a plain object from a CorpusMetadata message. Also converts values to other types if specified.
     * @function toObject
     * @memberof CorpusMetadata
     * @static
     * @param {CorpusMetadata} message CorpusMetadata
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    CorpusMetadata.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        var object = {};
        if (options.defaults) {
            object.backend = 0;
            object.name = "";
            object.landingUrl = "";
            object.libraryName = "";
            object.recsWidgetUrl = "";
            object.shopName = "";
        }
        if (message.backend != null && message.hasOwnProperty("backend"))
            object.backend = message.backend;
        if (message.name != null && message.hasOwnProperty("name"))
            object.name = message.name;
        if (message.landingUrl != null && message.hasOwnProperty("landingUrl"))
            object.landingUrl = message.landingUrl;
        if (message.libraryName != null && message.hasOwnProperty("libraryName"))
            object.libraryName = message.libraryName;
        if (message.recsWidgetUrl != null && message.hasOwnProperty("recsWidgetUrl"))
            object.recsWidgetUrl = message.recsWidgetUrl;
        if (message.shopName != null && message.hasOwnProperty("shopName"))
            object.shopName = message.shopName;
        return object;
    };

    /**
     * Converts this CorpusMetadata to JSON.
     * @function toJSON
     * @memberof CorpusMetadata
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    CorpusMetadata.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return CorpusMetadata;
})();

$root.Experiments = (function() {

    /**
     * Properties of an Experiments.
     * @exports IExperiments
     * @interface IExperiments
     * @property {Array.<string>|null} [experimentId] Experiments experimentId
     */

    /**
     * Constructs a new Experiments.
     * @exports Experiments
     * @classdesc Represents an Experiments.
     * @implements IExperiments
     * @constructor
     * @param {IExperiments=} [properties] Properties to set
     */
    function Experiments(properties) {
        this.experimentId = [];
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * Experiments experimentId.
     * @member {Array.<string>} experimentId
     * @memberof Experiments
     * @instance
     */
    Experiments.prototype.experimentId = $util.emptyArray;

    /**
     * Creates a new Experiments instance using the specified properties.
     * @function create
     * @memberof Experiments
     * @static
     * @param {IExperiments=} [properties] Properties to set
     * @returns {Experiments} Experiments instance
     */
    Experiments.create = function create(properties) {
        return new Experiments(properties);
    };

    /**
     * Encodes the specified Experiments message. Does not implicitly {@link Experiments.verify|verify} messages.
     * @function encode
     * @memberof Experiments
     * @static
     * @param {IExperiments} message Experiments message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    Experiments.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.experimentId != null && message.experimentId.length)
            for (var i = 0; i < message.experimentId.length; ++i)
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.experimentId[i]);
        return writer;
    };

    /**
     * Encodes the specified Experiments message, length delimited. Does not implicitly {@link Experiments.verify|verify} messages.
     * @function encodeDelimited
     * @memberof Experiments
     * @static
     * @param {IExperiments} message Experiments message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    Experiments.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes an Experiments message from the specified reader or buffer.
     * @function decode
     * @memberof Experiments
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {Experiments} Experiments
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    Experiments.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Experiments();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                if (!(message.experimentId && message.experimentId.length))
                    message.experimentId = [];
                message.experimentId.push(reader.string());
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes an Experiments message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof Experiments
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {Experiments} Experiments
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    Experiments.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies an Experiments message.
     * @function verify
     * @memberof Experiments
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    Experiments.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.experimentId != null && message.hasOwnProperty("experimentId")) {
            if (!Array.isArray(message.experimentId))
                return "experimentId: array expected";
            for (var i = 0; i < message.experimentId.length; ++i)
                if (!$util.isString(message.experimentId[i]))
                    return "experimentId: string[] expected";
        }
        return null;
    };

    /**
     * Creates an Experiments message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof Experiments
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {Experiments} Experiments
     */
    Experiments.fromObject = function fromObject(object) {
        if (object instanceof $root.Experiments)
            return object;
        var message = new $root.Experiments();
        if (object.experimentId) {
            if (!Array.isArray(object.experimentId))
                throw TypeError(".Experiments.experimentId: array expected");
            message.experimentId = [];
            for (var i = 0; i < object.experimentId.length; ++i)
                message.experimentId[i] = String(object.experimentId[i]);
        }
        return message;
    };

    /**
     * Creates a plain object from an Experiments message. Also converts values to other types if specified.
     * @function toObject
     * @memberof Experiments
     * @static
     * @param {Experiments} message Experiments
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    Experiments.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        var object = {};
        if (options.arrays || options.defaults)
            object.experimentId = [];
        if (message.experimentId && message.experimentId.length) {
            object.experimentId = [];
            for (var j = 0; j < message.experimentId.length; ++j)
                object.experimentId[j] = message.experimentId[j];
        }
        return object;
    };

    /**
     * Converts this Experiments to JSON.
     * @function toJSON
     * @memberof Experiments
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    Experiments.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return Experiments;
})();

$root.SelfUpdateConfig = (function() {

    /**
     * Properties of a SelfUpdateConfig.
     * @exports ISelfUpdateConfig
     * @interface ISelfUpdateConfig
     * @property {number|null} [latestClientVersionCode] SelfUpdateConfig latestClientVersionCode
     */

    /**
     * Constructs a new SelfUpdateConfig.
     * @exports SelfUpdateConfig
     * @classdesc Represents a SelfUpdateConfig.
     * @implements ISelfUpdateConfig
     * @constructor
     * @param {ISelfUpdateConfig=} [properties] Properties to set
     */
    function SelfUpdateConfig(properties) {
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * SelfUpdateConfig latestClientVersionCode.
     * @member {number} latestClientVersionCode
     * @memberof SelfUpdateConfig
     * @instance
     */
    SelfUpdateConfig.prototype.latestClientVersionCode = 0;

    /**
     * Creates a new SelfUpdateConfig instance using the specified properties.
     * @function create
     * @memberof SelfUpdateConfig
     * @static
     * @param {ISelfUpdateConfig=} [properties] Properties to set
     * @returns {SelfUpdateConfig} SelfUpdateConfig instance
     */
    SelfUpdateConfig.create = function create(properties) {
        return new SelfUpdateConfig(properties);
    };

    /**
     * Encodes the specified SelfUpdateConfig message. Does not implicitly {@link SelfUpdateConfig.verify|verify} messages.
     * @function encode
     * @memberof SelfUpdateConfig
     * @static
     * @param {ISelfUpdateConfig} message SelfUpdateConfig message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    SelfUpdateConfig.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.latestClientVersionCode != null && Object.hasOwnProperty.call(message, "latestClientVersionCode"))
            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.latestClientVersionCode);
        return writer;
    };

    /**
     * Encodes the specified SelfUpdateConfig message, length delimited. Does not implicitly {@link SelfUpdateConfig.verify|verify} messages.
     * @function encodeDelimited
     * @memberof SelfUpdateConfig
     * @static
     * @param {ISelfUpdateConfig} message SelfUpdateConfig message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    SelfUpdateConfig.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a SelfUpdateConfig message from the specified reader or buffer.
     * @function decode
     * @memberof SelfUpdateConfig
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {SelfUpdateConfig} SelfUpdateConfig
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    SelfUpdateConfig.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.SelfUpdateConfig();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.latestClientVersionCode = reader.int32();
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a SelfUpdateConfig message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof SelfUpdateConfig
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {SelfUpdateConfig} SelfUpdateConfig
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    SelfUpdateConfig.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a SelfUpdateConfig message.
     * @function verify
     * @memberof SelfUpdateConfig
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    SelfUpdateConfig.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.latestClientVersionCode != null && message.hasOwnProperty("latestClientVersionCode"))
            if (!$util.isInteger(message.latestClientVersionCode))
                return "latestClientVersionCode: integer expected";
        return null;
    };

    /**
     * Creates a SelfUpdateConfig message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof SelfUpdateConfig
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {SelfUpdateConfig} SelfUpdateConfig
     */
    SelfUpdateConfig.fromObject = function fromObject(object) {
        if (object instanceof $root.SelfUpdateConfig)
            return object;
        var message = new $root.SelfUpdateConfig();
        if (object.latestClientVersionCode != null)
            message.latestClientVersionCode = object.latestClientVersionCode | 0;
        return message;
    };

    /**
     * Creates a plain object from a SelfUpdateConfig message. Also converts values to other types if specified.
     * @function toObject
     * @memberof SelfUpdateConfig
     * @static
     * @param {SelfUpdateConfig} message SelfUpdateConfig
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    SelfUpdateConfig.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        var object = {};
        if (options.defaults)
            object.latestClientVersionCode = 0;
        if (message.latestClientVersionCode != null && message.hasOwnProperty("latestClientVersionCode"))
            object.latestClientVersionCode = message.latestClientVersionCode;
        return object;
    };

    /**
     * Converts this SelfUpdateConfig to JSON.
     * @function toJSON
     * @memberof SelfUpdateConfig
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    SelfUpdateConfig.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return SelfUpdateConfig;
})();

$root.TocResponse = (function() {

    /**
     * Properties of a TocResponse.
     * @exports ITocResponse
     * @interface ITocResponse
     * @property {Array.<ICorpusMetadata>|null} [corpus] TocResponse corpus
     * @property {number|null} [tosVersionDeprecated] TocResponse tosVersionDeprecated
     * @property {string|null} [tosContent] TocResponse tosContent
     * @property {string|null} [homeUrl] TocResponse homeUrl
     * @property {IExperiments|null} [experiments] TocResponse experiments
     * @property {string|null} [tosCheckboxTextMarketingEmails] TocResponse tosCheckboxTextMarketingEmails
     * @property {string|null} [tosToken] TocResponse tosToken
     * @property {IUserSettings|null} [userSettings] TocResponse userSettings
     * @property {string|null} [iconOverrideUrl] TocResponse iconOverrideUrl
     * @property {ISelfUpdateConfig|null} [selfUpdateConfig] TocResponse selfUpdateConfig
     * @property {boolean|null} [requiresUploadDeviceConfig] TocResponse requiresUploadDeviceConfig
     * @property {IBillingConfig|null} [billingConfig] TocResponse billingConfig
     * @property {string|null} [recsWidgetUrl] TocResponse recsWidgetUrl
     * @property {string|null} [socialHomeUrl] TocResponse socialHomeUrl
     * @property {boolean|null} [ageVerificationRequired] TocResponse ageVerificationRequired
     * @property {boolean|null} [gPlusSignupEnabled] TocResponse gPlusSignupEnabled
     * @property {boolean|null} [redeemEnabled] TocResponse redeemEnabled
     * @property {string|null} [helpUrl] TocResponse helpUrl
     * @property {number|null} [themeId] TocResponse themeId
     * @property {string|null} [entertainmentHomeUrl] TocResponse entertainmentHomeUrl
     * @property {string|null} [cookie] TocResponse cookie
     */

    /**
     * Constructs a new TocResponse.
     * @exports TocResponse
     * @classdesc Represents a TocResponse.
     * @implements ITocResponse
     * @constructor
     * @param {ITocResponse=} [properties] Properties to set
     */
    function TocResponse(properties) {
        this.corpus = [];
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * TocResponse corpus.
     * @member {Array.<ICorpusMetadata>} corpus
     * @memberof TocResponse
     * @instance
     */
    TocResponse.prototype.corpus = $util.emptyArray;

    /**
     * TocResponse tosVersionDeprecated.
     * @member {number} tosVersionDeprecated
     * @memberof TocResponse
     * @instance
     */
    TocResponse.prototype.tosVersionDeprecated = 0;

    /**
     * TocResponse tosContent.
     * @member {string} tosContent
     * @memberof TocResponse
     * @instance
     */
    TocResponse.prototype.tosContent = "";

    /**
     * TocResponse homeUrl.
     * @member {string} homeUrl
     * @memberof TocResponse
     * @instance
     */
    TocResponse.prototype.homeUrl = "";

    /**
     * TocResponse experiments.
     * @member {IExperiments|null|undefined} experiments
     * @memberof TocResponse
     * @instance
     */
    TocResponse.prototype.experiments = null;

    /**
     * TocResponse tosCheckboxTextMarketingEmails.
     * @member {string} tosCheckboxTextMarketingEmails
     * @memberof TocResponse
     * @instance
     */
    TocResponse.prototype.tosCheckboxTextMarketingEmails = "";

    /**
     * TocResponse tosToken.
     * @member {string} tosToken
     * @memberof TocResponse
     * @instance
     */
    TocResponse.prototype.tosToken = "";

    /**
     * TocResponse userSettings.
     * @member {IUserSettings|null|undefined} userSettings
     * @memberof TocResponse
     * @instance
     */
    TocResponse.prototype.userSettings = null;

    /**
     * TocResponse iconOverrideUrl.
     * @member {string} iconOverrideUrl
     * @memberof TocResponse
     * @instance
     */
    TocResponse.prototype.iconOverrideUrl = "";

    /**
     * TocResponse selfUpdateConfig.
     * @member {ISelfUpdateConfig|null|undefined} selfUpdateConfig
     * @memberof TocResponse
     * @instance
     */
    TocResponse.prototype.selfUpdateConfig = null;

    /**
     * TocResponse requiresUploadDeviceConfig.
     * @member {boolean} requiresUploadDeviceConfig
     * @memberof TocResponse
     * @instance
     */
    TocResponse.prototype.requiresUploadDeviceConfig = false;

    /**
     * TocResponse billingConfig.
     * @member {IBillingConfig|null|undefined} billingConfig
     * @memberof TocResponse
     * @instance
     */
    TocResponse.prototype.billingConfig = null;

    /**
     * TocResponse recsWidgetUrl.
     * @member {string} recsWidgetUrl
     * @memberof TocResponse
     * @instance
     */
    TocResponse.prototype.recsWidgetUrl = "";

    /**
     * TocResponse socialHomeUrl.
     * @member {string} socialHomeUrl
     * @memberof TocResponse
     * @instance
     */
    TocResponse.prototype.socialHomeUrl = "";

    /**
     * TocResponse ageVerificationRequired.
     * @member {boolean} ageVerificationRequired
     * @memberof TocResponse
     * @instance
     */
    TocResponse.prototype.ageVerificationRequired = false;

    /**
     * TocResponse gPlusSignupEnabled.
     * @member {boolean} gPlusSignupEnabled
     * @memberof TocResponse
     * @instance
     */
    TocResponse.prototype.gPlusSignupEnabled = false;

    /**
     * TocResponse redeemEnabled.
     * @member {boolean} redeemEnabled
     * @memberof TocResponse
     * @instance
     */
    TocResponse.prototype.redeemEnabled = false;

    /**
     * TocResponse helpUrl.
     * @member {string} helpUrl
     * @memberof TocResponse
     * @instance
     */
    TocResponse.prototype.helpUrl = "";

    /**
     * TocResponse themeId.
     * @member {number} themeId
     * @memberof TocResponse
     * @instance
     */
    TocResponse.prototype.themeId = 0;

    /**
     * TocResponse entertainmentHomeUrl.
     * @member {string} entertainmentHomeUrl
     * @memberof TocResponse
     * @instance
     */
    TocResponse.prototype.entertainmentHomeUrl = "";

    /**
     * TocResponse cookie.
     * @member {string} cookie
     * @memberof TocResponse
     * @instance
     */
    TocResponse.prototype.cookie = "";

    /**
     * Creates a new TocResponse instance using the specified properties.
     * @function create
     * @memberof TocResponse
     * @static
     * @param {ITocResponse=} [properties] Properties to set
     * @returns {TocResponse} TocResponse instance
     */
    TocResponse.create = function create(properties) {
        return new TocResponse(properties);
    };

    /**
     * Encodes the specified TocResponse message. Does not implicitly {@link TocResponse.verify|verify} messages.
     * @function encode
     * @memberof TocResponse
     * @static
     * @param {ITocResponse} message TocResponse message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    TocResponse.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.corpus != null && message.corpus.length)
            for (var i = 0; i < message.corpus.length; ++i)
                $root.CorpusMetadata.encode(message.corpus[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
        if (message.tosVersionDeprecated != null && Object.hasOwnProperty.call(message, "tosVersionDeprecated"))
            writer.uint32(/* id 2, wireType 0 =*/16).int32(message.tosVersionDeprecated);
        if (message.tosContent != null && Object.hasOwnProperty.call(message, "tosContent"))
            writer.uint32(/* id 3, wireType 2 =*/26).string(message.tosContent);
        if (message.homeUrl != null && Object.hasOwnProperty.call(message, "homeUrl"))
            writer.uint32(/* id 4, wireType 2 =*/34).string(message.homeUrl);
        if (message.experiments != null && Object.hasOwnProperty.call(message, "experiments"))
            $root.Experiments.encode(message.experiments, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
        if (message.tosCheckboxTextMarketingEmails != null && Object.hasOwnProperty.call(message, "tosCheckboxTextMarketingEmails"))
            writer.uint32(/* id 6, wireType 2 =*/50).string(message.tosCheckboxTextMarketingEmails);
        if (message.tosToken != null && Object.hasOwnProperty.call(message, "tosToken"))
            writer.uint32(/* id 7, wireType 2 =*/58).string(message.tosToken);
        if (message.userSettings != null && Object.hasOwnProperty.call(message, "userSettings"))
            $root.UserSettings.encode(message.userSettings, writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();
        if (message.iconOverrideUrl != null && Object.hasOwnProperty.call(message, "iconOverrideUrl"))
            writer.uint32(/* id 9, wireType 2 =*/74).string(message.iconOverrideUrl);
        if (message.selfUpdateConfig != null && Object.hasOwnProperty.call(message, "selfUpdateConfig"))
            $root.SelfUpdateConfig.encode(message.selfUpdateConfig, writer.uint32(/* id 10, wireType 2 =*/82).fork()).ldelim();
        if (message.requiresUploadDeviceConfig != null && Object.hasOwnProperty.call(message, "requiresUploadDeviceConfig"))
            writer.uint32(/* id 11, wireType 0 =*/88).bool(message.requiresUploadDeviceConfig);
        if (message.billingConfig != null && Object.hasOwnProperty.call(message, "billingConfig"))
            $root.BillingConfig.encode(message.billingConfig, writer.uint32(/* id 12, wireType 2 =*/98).fork()).ldelim();
        if (message.recsWidgetUrl != null && Object.hasOwnProperty.call(message, "recsWidgetUrl"))
            writer.uint32(/* id 13, wireType 2 =*/106).string(message.recsWidgetUrl);
        if (message.socialHomeUrl != null && Object.hasOwnProperty.call(message, "socialHomeUrl"))
            writer.uint32(/* id 15, wireType 2 =*/122).string(message.socialHomeUrl);
        if (message.ageVerificationRequired != null && Object.hasOwnProperty.call(message, "ageVerificationRequired"))
            writer.uint32(/* id 16, wireType 0 =*/128).bool(message.ageVerificationRequired);
        if (message.gPlusSignupEnabled != null && Object.hasOwnProperty.call(message, "gPlusSignupEnabled"))
            writer.uint32(/* id 17, wireType 0 =*/136).bool(message.gPlusSignupEnabled);
        if (message.redeemEnabled != null && Object.hasOwnProperty.call(message, "redeemEnabled"))
            writer.uint32(/* id 18, wireType 0 =*/144).bool(message.redeemEnabled);
        if (message.helpUrl != null && Object.hasOwnProperty.call(message, "helpUrl"))
            writer.uint32(/* id 19, wireType 2 =*/154).string(message.helpUrl);
        if (message.themeId != null && Object.hasOwnProperty.call(message, "themeId"))
            writer.uint32(/* id 20, wireType 0 =*/160).int32(message.themeId);
        if (message.entertainmentHomeUrl != null && Object.hasOwnProperty.call(message, "entertainmentHomeUrl"))
            writer.uint32(/* id 21, wireType 2 =*/170).string(message.entertainmentHomeUrl);
        if (message.cookie != null && Object.hasOwnProperty.call(message, "cookie"))
            writer.uint32(/* id 22, wireType 2 =*/178).string(message.cookie);
        return writer;
    };

    /**
     * Encodes the specified TocResponse message, length delimited. Does not implicitly {@link TocResponse.verify|verify} messages.
     * @function encodeDelimited
     * @memberof TocResponse
     * @static
     * @param {ITocResponse} message TocResponse message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    TocResponse.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a TocResponse message from the specified reader or buffer.
     * @function decode
     * @memberof TocResponse
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {TocResponse} TocResponse
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    TocResponse.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.TocResponse();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                if (!(message.corpus && message.corpus.length))
                    message.corpus = [];
                message.corpus.push($root.CorpusMetadata.decode(reader, reader.uint32()));
                break;
            case 2:
                message.tosVersionDeprecated = reader.int32();
                break;
            case 3:
                message.tosContent = reader.string();
                break;
            case 4:
                message.homeUrl = reader.string();
                break;
            case 5:
                message.experiments = $root.Experiments.decode(reader, reader.uint32());
                break;
            case 6:
                message.tosCheckboxTextMarketingEmails = reader.string();
                break;
            case 7:
                message.tosToken = reader.string();
                break;
            case 8:
                message.userSettings = $root.UserSettings.decode(reader, reader.uint32());
                break;
            case 9:
                message.iconOverrideUrl = reader.string();
                break;
            case 10:
                message.selfUpdateConfig = $root.SelfUpdateConfig.decode(reader, reader.uint32());
                break;
            case 11:
                message.requiresUploadDeviceConfig = reader.bool();
                break;
            case 12:
                message.billingConfig = $root.BillingConfig.decode(reader, reader.uint32());
                break;
            case 13:
                message.recsWidgetUrl = reader.string();
                break;
            case 15:
                message.socialHomeUrl = reader.string();
                break;
            case 16:
                message.ageVerificationRequired = reader.bool();
                break;
            case 17:
                message.gPlusSignupEnabled = reader.bool();
                break;
            case 18:
                message.redeemEnabled = reader.bool();
                break;
            case 19:
                message.helpUrl = reader.string();
                break;
            case 20:
                message.themeId = reader.int32();
                break;
            case 21:
                message.entertainmentHomeUrl = reader.string();
                break;
            case 22:
                message.cookie = reader.string();
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a TocResponse message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof TocResponse
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {TocResponse} TocResponse
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    TocResponse.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a TocResponse message.
     * @function verify
     * @memberof TocResponse
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    TocResponse.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.corpus != null && message.hasOwnProperty("corpus")) {
            if (!Array.isArray(message.corpus))
                return "corpus: array expected";
            for (var i = 0; i < message.corpus.length; ++i) {
                var error = $root.CorpusMetadata.verify(message.corpus[i]);
                if (error)
                    return "corpus." + error;
            }
        }
        if (message.tosVersionDeprecated != null && message.hasOwnProperty("tosVersionDeprecated"))
            if (!$util.isInteger(message.tosVersionDeprecated))
                return "tosVersionDeprecated: integer expected";
        if (message.tosContent != null && message.hasOwnProperty("tosContent"))
            if (!$util.isString(message.tosContent))
                return "tosContent: string expected";
        if (message.homeUrl != null && message.hasOwnProperty("homeUrl"))
            if (!$util.isString(message.homeUrl))
                return "homeUrl: string expected";
        if (message.experiments != null && message.hasOwnProperty("experiments")) {
            var error = $root.Experiments.verify(message.experiments);
            if (error)
                return "experiments." + error;
        }
        if (message.tosCheckboxTextMarketingEmails != null && message.hasOwnProperty("tosCheckboxTextMarketingEmails"))
            if (!$util.isString(message.tosCheckboxTextMarketingEmails))
                return "tosCheckboxTextMarketingEmails: string expected";
        if (message.tosToken != null && message.hasOwnProperty("tosToken"))
            if (!$util.isString(message.tosToken))
                return "tosToken: string expected";
        if (message.userSettings != null && message.hasOwnProperty("userSettings")) {
            var error = $root.UserSettings.verify(message.userSettings);
            if (error)
                return "userSettings." + error;
        }
        if (message.iconOverrideUrl != null && message.hasOwnProperty("iconOverrideUrl"))
            if (!$util.isString(message.iconOverrideUrl))
                return "iconOverrideUrl: string expected";
        if (message.selfUpdateConfig != null && message.hasOwnProperty("selfUpdateConfig")) {
            var error = $root.SelfUpdateConfig.verify(message.selfUpdateConfig);
            if (error)
                return "selfUpdateConfig." + error;
        }
        if (message.requiresUploadDeviceConfig != null && message.hasOwnProperty("requiresUploadDeviceConfig"))
            if (typeof message.requiresUploadDeviceConfig !== "boolean")
                return "requiresUploadDeviceConfig: boolean expected";
        if (message.billingConfig != null && message.hasOwnProperty("billingConfig")) {
            var error = $root.BillingConfig.verify(message.billingConfig);
            if (error)
                return "billingConfig." + error;
        }
        if (message.recsWidgetUrl != null && message.hasOwnProperty("recsWidgetUrl"))
            if (!$util.isString(message.recsWidgetUrl))
                return "recsWidgetUrl: string expected";
        if (message.socialHomeUrl != null && message.hasOwnProperty("socialHomeUrl"))
            if (!$util.isString(message.socialHomeUrl))
                return "socialHomeUrl: string expected";
        if (message.ageVerificationRequired != null && message.hasOwnProperty("ageVerificationRequired"))
            if (typeof message.ageVerificationRequired !== "boolean")
                return "ageVerificationRequired: boolean expected";
        if (message.gPlusSignupEnabled != null && message.hasOwnProperty("gPlusSignupEnabled"))
            if (typeof message.gPlusSignupEnabled !== "boolean")
                return "gPlusSignupEnabled: boolean expected";
        if (message.redeemEnabled != null && message.hasOwnProperty("redeemEnabled"))
            if (typeof message.redeemEnabled !== "boolean")
                return "redeemEnabled: boolean expected";
        if (message.helpUrl != null && message.hasOwnProperty("helpUrl"))
            if (!$util.isString(message.helpUrl))
                return "helpUrl: string expected";
        if (message.themeId != null && message.hasOwnProperty("themeId"))
            if (!$util.isInteger(message.themeId))
                return "themeId: integer expected";
        if (message.entertainmentHomeUrl != null && message.hasOwnProperty("entertainmentHomeUrl"))
            if (!$util.isString(message.entertainmentHomeUrl))
                return "entertainmentHomeUrl: string expected";
        if (message.cookie != null && message.hasOwnProperty("cookie"))
            if (!$util.isString(message.cookie))
                return "cookie: string expected";
        return null;
    };

    /**
     * Creates a TocResponse message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof TocResponse
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {TocResponse} TocResponse
     */
    TocResponse.fromObject = function fromObject(object) {
        if (object instanceof $root.TocResponse)
            return object;
        var message = new $root.TocResponse();
        if (object.corpus) {
            if (!Array.isArray(object.corpus))
                throw TypeError(".TocResponse.corpus: array expected");
            message.corpus = [];
            for (var i = 0; i < object.corpus.length; ++i) {
                if (typeof object.corpus[i] !== "object")
                    throw TypeError(".TocResponse.corpus: object expected");
                message.corpus[i] = $root.CorpusMetadata.fromObject(object.corpus[i]);
            }
        }
        if (object.tosVersionDeprecated != null)
            message.tosVersionDeprecated = object.tosVersionDeprecated | 0;
        if (object.tosContent != null)
            message.tosContent = String(object.tosContent);
        if (object.homeUrl != null)
            message.homeUrl = String(object.homeUrl);
        if (object.experiments != null) {
            if (typeof object.experiments !== "object")
                throw TypeError(".TocResponse.experiments: object expected");
            message.experiments = $root.Experiments.fromObject(object.experiments);
        }
        if (object.tosCheckboxTextMarketingEmails != null)
            message.tosCheckboxTextMarketingEmails = String(object.tosCheckboxTextMarketingEmails);
        if (object.tosToken != null)
            message.tosToken = String(object.tosToken);
        if (object.userSettings != null) {
            if (typeof object.userSettings !== "object")
                throw TypeError(".TocResponse.userSettings: object expected");
            message.userSettings = $root.UserSettings.fromObject(object.userSettings);
        }
        if (object.iconOverrideUrl != null)
            message.iconOverrideUrl = String(object.iconOverrideUrl);
        if (object.selfUpdateConfig != null) {
            if (typeof object.selfUpdateConfig !== "object")
                throw TypeError(".TocResponse.selfUpdateConfig: object expected");
            message.selfUpdateConfig = $root.SelfUpdateConfig.fromObject(object.selfUpdateConfig);
        }
        if (object.requiresUploadDeviceConfig != null)
            message.requiresUploadDeviceConfig = Boolean(object.requiresUploadDeviceConfig);
        if (object.billingConfig != null) {
            if (typeof object.billingConfig !== "object")
                throw TypeError(".TocResponse.billingConfig: object expected");
            message.billingConfig = $root.BillingConfig.fromObject(object.billingConfig);
        }
        if (object.recsWidgetUrl != null)
            message.recsWidgetUrl = String(object.recsWidgetUrl);
        if (object.socialHomeUrl != null)
            message.socialHomeUrl = String(object.socialHomeUrl);
        if (object.ageVerificationRequired != null)
            message.ageVerificationRequired = Boolean(object.ageVerificationRequired);
        if (object.gPlusSignupEnabled != null)
            message.gPlusSignupEnabled = Boolean(object.gPlusSignupEnabled);
        if (object.redeemEnabled != null)
            message.redeemEnabled = Boolean(object.redeemEnabled);
        if (object.helpUrl != null)
            message.helpUrl = String(object.helpUrl);
        if (object.themeId != null)
            message.themeId = object.themeId | 0;
        if (object.entertainmentHomeUrl != null)
            message.entertainmentHomeUrl = String(object.entertainmentHomeUrl);
        if (object.cookie != null)
            message.cookie = String(object.cookie);
        return message;
    };

    /**
     * Creates a plain object from a TocResponse message. Also converts values to other types if specified.
     * @function toObject
     * @memberof TocResponse
     * @static
     * @param {TocResponse} message TocResponse
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    TocResponse.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        var object = {};
        if (options.arrays || options.defaults)
            object.corpus = [];
        if (options.defaults) {
            object.tosVersionDeprecated = 0;
            object.tosContent = "";
            object.homeUrl = "";
            object.experiments = null;
            object.tosCheckboxTextMarketingEmails = "";
            object.tosToken = "";
            object.userSettings = null;
            object.iconOverrideUrl = "";
            object.selfUpdateConfig = null;
            object.requiresUploadDeviceConfig = false;
            object.billingConfig = null;
            object.recsWidgetUrl = "";
            object.socialHomeUrl = "";
            object.ageVerificationRequired = false;
            object.gPlusSignupEnabled = false;
            object.redeemEnabled = false;
            object.helpUrl = "";
            object.themeId = 0;
            object.entertainmentHomeUrl = "";
            object.cookie = "";
        }
        if (message.corpus && message.corpus.length) {
            object.corpus = [];
            for (var j = 0; j < message.corpus.length; ++j)
                object.corpus[j] = $root.CorpusMetadata.toObject(message.corpus[j], options);
        }
        if (message.tosVersionDeprecated != null && message.hasOwnProperty("tosVersionDeprecated"))
            object.tosVersionDeprecated = message.tosVersionDeprecated;
        if (message.tosContent != null && message.hasOwnProperty("tosContent"))
            object.tosContent = message.tosContent;
        if (message.homeUrl != null && message.hasOwnProperty("homeUrl"))
            object.homeUrl = message.homeUrl;
        if (message.experiments != null && message.hasOwnProperty("experiments"))
            object.experiments = $root.Experiments.toObject(message.experiments, options);
        if (message.tosCheckboxTextMarketingEmails != null && message.hasOwnProperty("tosCheckboxTextMarketingEmails"))
            object.tosCheckboxTextMarketingEmails = message.tosCheckboxTextMarketingEmails;
        if (message.tosToken != null && message.hasOwnProperty("tosToken"))
            object.tosToken = message.tosToken;
        if (message.userSettings != null && message.hasOwnProperty("userSettings"))
            object.userSettings = $root.UserSettings.toObject(message.userSettings, options);
        if (message.iconOverrideUrl != null && message.hasOwnProperty("iconOverrideUrl"))
            object.iconOverrideUrl = message.iconOverrideUrl;
        if (message.selfUpdateConfig != null && message.hasOwnProperty("selfUpdateConfig"))
            object.selfUpdateConfig = $root.SelfUpdateConfig.toObject(message.selfUpdateConfig, options);
        if (message.requiresUploadDeviceConfig != null && message.hasOwnProperty("requiresUploadDeviceConfig"))
            object.requiresUploadDeviceConfig = message.requiresUploadDeviceConfig;
        if (message.billingConfig != null && message.hasOwnProperty("billingConfig"))
            object.billingConfig = $root.BillingConfig.toObject(message.billingConfig, options);
        if (message.recsWidgetUrl != null && message.hasOwnProperty("recsWidgetUrl"))
            object.recsWidgetUrl = message.recsWidgetUrl;
        if (message.socialHomeUrl != null && message.hasOwnProperty("socialHomeUrl"))
            object.socialHomeUrl = message.socialHomeUrl;
        if (message.ageVerificationRequired != null && message.hasOwnProperty("ageVerificationRequired"))
            object.ageVerificationRequired = message.ageVerificationRequired;
        if (message.gPlusSignupEnabled != null && message.hasOwnProperty("gPlusSignupEnabled"))
            object.gPlusSignupEnabled = message.gPlusSignupEnabled;
        if (message.redeemEnabled != null && message.hasOwnProperty("redeemEnabled"))
            object.redeemEnabled = message.redeemEnabled;
        if (message.helpUrl != null && message.hasOwnProperty("helpUrl"))
            object.helpUrl = message.helpUrl;
        if (message.themeId != null && message.hasOwnProperty("themeId"))
            object.themeId = message.themeId;
        if (message.entertainmentHomeUrl != null && message.hasOwnProperty("entertainmentHomeUrl"))
            object.entertainmentHomeUrl = message.entertainmentHomeUrl;
        if (message.cookie != null && message.hasOwnProperty("cookie"))
            object.cookie = message.cookie;
        return object;
    };

    /**
     * Converts this TocResponse to JSON.
     * @function toJSON
     * @memberof TocResponse
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    TocResponse.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return TocResponse;
})();

$root.UserSettings = (function() {

    /**
     * Properties of a UserSettings.
     * @exports IUserSettings
     * @interface IUserSettings
     * @property {boolean|null} [tosCheckboxMarketingEmailsOptedIn] UserSettings tosCheckboxMarketingEmailsOptedIn
     * @property {IPrivacySetting|null} [privacySetting] UserSettings privacySetting
     */

    /**
     * Constructs a new UserSettings.
     * @exports UserSettings
     * @classdesc Represents a UserSettings.
     * @implements IUserSettings
     * @constructor
     * @param {IUserSettings=} [properties] Properties to set
     */
    function UserSettings(properties) {
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * UserSettings tosCheckboxMarketingEmailsOptedIn.
     * @member {boolean} tosCheckboxMarketingEmailsOptedIn
     * @memberof UserSettings
     * @instance
     */
    UserSettings.prototype.tosCheckboxMarketingEmailsOptedIn = false;

    /**
     * UserSettings privacySetting.
     * @member {IPrivacySetting|null|undefined} privacySetting
     * @memberof UserSettings
     * @instance
     */
    UserSettings.prototype.privacySetting = null;

    /**
     * Creates a new UserSettings instance using the specified properties.
     * @function create
     * @memberof UserSettings
     * @static
     * @param {IUserSettings=} [properties] Properties to set
     * @returns {UserSettings} UserSettings instance
     */
    UserSettings.create = function create(properties) {
        return new UserSettings(properties);
    };

    /**
     * Encodes the specified UserSettings message. Does not implicitly {@link UserSettings.verify|verify} messages.
     * @function encode
     * @memberof UserSettings
     * @static
     * @param {IUserSettings} message UserSettings message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    UserSettings.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.tosCheckboxMarketingEmailsOptedIn != null && Object.hasOwnProperty.call(message, "tosCheckboxMarketingEmailsOptedIn"))
            writer.uint32(/* id 1, wireType 0 =*/8).bool(message.tosCheckboxMarketingEmailsOptedIn);
        if (message.privacySetting != null && Object.hasOwnProperty.call(message, "privacySetting"))
            $root.PrivacySetting.encode(message.privacySetting, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
        return writer;
    };

    /**
     * Encodes the specified UserSettings message, length delimited. Does not implicitly {@link UserSettings.verify|verify} messages.
     * @function encodeDelimited
     * @memberof UserSettings
     * @static
     * @param {IUserSettings} message UserSettings message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    UserSettings.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a UserSettings message from the specified reader or buffer.
     * @function decode
     * @memberof UserSettings
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {UserSettings} UserSettings
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    UserSettings.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.UserSettings();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.tosCheckboxMarketingEmailsOptedIn = reader.bool();
                break;
            case 2:
                message.privacySetting = $root.PrivacySetting.decode(reader, reader.uint32());
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a UserSettings message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof UserSettings
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {UserSettings} UserSettings
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    UserSettings.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a UserSettings message.
     * @function verify
     * @memberof UserSettings
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    UserSettings.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.tosCheckboxMarketingEmailsOptedIn != null && message.hasOwnProperty("tosCheckboxMarketingEmailsOptedIn"))
            if (typeof message.tosCheckboxMarketingEmailsOptedIn !== "boolean")
                return "tosCheckboxMarketingEmailsOptedIn: boolean expected";
        if (message.privacySetting != null && message.hasOwnProperty("privacySetting")) {
            var error = $root.PrivacySetting.verify(message.privacySetting);
            if (error)
                return "privacySetting." + error;
        }
        return null;
    };

    /**
     * Creates a UserSettings message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof UserSettings
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {UserSettings} UserSettings
     */
    UserSettings.fromObject = function fromObject(object) {
        if (object instanceof $root.UserSettings)
            return object;
        var message = new $root.UserSettings();
        if (object.tosCheckboxMarketingEmailsOptedIn != null)
            message.tosCheckboxMarketingEmailsOptedIn = Boolean(object.tosCheckboxMarketingEmailsOptedIn);
        if (object.privacySetting != null) {
            if (typeof object.privacySetting !== "object")
                throw TypeError(".UserSettings.privacySetting: object expected");
            message.privacySetting = $root.PrivacySetting.fromObject(object.privacySetting);
        }
        return message;
    };

    /**
     * Creates a plain object from a UserSettings message. Also converts values to other types if specified.
     * @function toObject
     * @memberof UserSettings
     * @static
     * @param {UserSettings} message UserSettings
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    UserSettings.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        var object = {};
        if (options.defaults) {
            object.tosCheckboxMarketingEmailsOptedIn = false;
            object.privacySetting = null;
        }
        if (message.tosCheckboxMarketingEmailsOptedIn != null && message.hasOwnProperty("tosCheckboxMarketingEmailsOptedIn"))
            object.tosCheckboxMarketingEmailsOptedIn = message.tosCheckboxMarketingEmailsOptedIn;
        if (message.privacySetting != null && message.hasOwnProperty("privacySetting"))
            object.privacySetting = $root.PrivacySetting.toObject(message.privacySetting, options);
        return object;
    };

    /**
     * Converts this UserSettings to JSON.
     * @function toJSON
     * @memberof UserSettings
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    UserSettings.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return UserSettings;
})();

$root.PrivacySetting = (function() {

    /**
     * Properties of a PrivacySetting.
     * @exports IPrivacySetting
     * @interface IPrivacySetting
     * @property {number|null} [type] PrivacySetting type
     * @property {number|null} [currentStatus] PrivacySetting currentStatus
     * @property {boolean|null} [enabledByDefault] PrivacySetting enabledByDefault
     */

    /**
     * Constructs a new PrivacySetting.
     * @exports PrivacySetting
     * @classdesc Represents a PrivacySetting.
     * @implements IPrivacySetting
     * @constructor
     * @param {IPrivacySetting=} [properties] Properties to set
     */
    function PrivacySetting(properties) {
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * PrivacySetting type.
     * @member {number} type
     * @memberof PrivacySetting
     * @instance
     */
    PrivacySetting.prototype.type = 0;

    /**
     * PrivacySetting currentStatus.
     * @member {number} currentStatus
     * @memberof PrivacySetting
     * @instance
     */
    PrivacySetting.prototype.currentStatus = 0;

    /**
     * PrivacySetting enabledByDefault.
     * @member {boolean} enabledByDefault
     * @memberof PrivacySetting
     * @instance
     */
    PrivacySetting.prototype.enabledByDefault = false;

    /**
     * Creates a new PrivacySetting instance using the specified properties.
     * @function create
     * @memberof PrivacySetting
     * @static
     * @param {IPrivacySetting=} [properties] Properties to set
     * @returns {PrivacySetting} PrivacySetting instance
     */
    PrivacySetting.create = function create(properties) {
        return new PrivacySetting(properties);
    };

    /**
     * Encodes the specified PrivacySetting message. Does not implicitly {@link PrivacySetting.verify|verify} messages.
     * @function encode
     * @memberof PrivacySetting
     * @static
     * @param {IPrivacySetting} message PrivacySetting message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    PrivacySetting.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.type != null && Object.hasOwnProperty.call(message, "type"))
            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.type);
        if (message.currentStatus != null && Object.hasOwnProperty.call(message, "currentStatus"))
            writer.uint32(/* id 2, wireType 0 =*/16).int32(message.currentStatus);
        if (message.enabledByDefault != null && Object.hasOwnProperty.call(message, "enabledByDefault"))
            writer.uint32(/* id 3, wireType 0 =*/24).bool(message.enabledByDefault);
        return writer;
    };

    /**
     * Encodes the specified PrivacySetting message, length delimited. Does not implicitly {@link PrivacySetting.verify|verify} messages.
     * @function encodeDelimited
     * @memberof PrivacySetting
     * @static
     * @param {IPrivacySetting} message PrivacySetting message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    PrivacySetting.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a PrivacySetting message from the specified reader or buffer.
     * @function decode
     * @memberof PrivacySetting
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {PrivacySetting} PrivacySetting
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    PrivacySetting.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.PrivacySetting();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.type = reader.int32();
                break;
            case 2:
                message.currentStatus = reader.int32();
                break;
            case 3:
                message.enabledByDefault = reader.bool();
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a PrivacySetting message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof PrivacySetting
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {PrivacySetting} PrivacySetting
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    PrivacySetting.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a PrivacySetting message.
     * @function verify
     * @memberof PrivacySetting
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    PrivacySetting.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.type != null && message.hasOwnProperty("type"))
            if (!$util.isInteger(message.type))
                return "type: integer expected";
        if (message.currentStatus != null && message.hasOwnProperty("currentStatus"))
            if (!$util.isInteger(message.currentStatus))
                return "currentStatus: integer expected";
        if (message.enabledByDefault != null && message.hasOwnProperty("enabledByDefault"))
            if (typeof message.enabledByDefault !== "boolean")
                return "enabledByDefault: boolean expected";
        return null;
    };

    /**
     * Creates a PrivacySetting message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof PrivacySetting
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {PrivacySetting} PrivacySetting
     */
    PrivacySetting.fromObject = function fromObject(object) {
        if (object instanceof $root.PrivacySetting)
            return object;
        var message = new $root.PrivacySetting();
        if (object.type != null)
            message.type = object.type | 0;
        if (object.currentStatus != null)
            message.currentStatus = object.currentStatus | 0;
        if (object.enabledByDefault != null)
            message.enabledByDefault = Boolean(object.enabledByDefault);
        return message;
    };

    /**
     * Creates a plain object from a PrivacySetting message. Also converts values to other types if specified.
     * @function toObject
     * @memberof PrivacySetting
     * @static
     * @param {PrivacySetting} message PrivacySetting
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    PrivacySetting.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        var object = {};
        if (options.defaults) {
            object.type = 0;
            object.currentStatus = 0;
            object.enabledByDefault = false;
        }
        if (message.type != null && message.hasOwnProperty("type"))
            object.type = message.type;
        if (message.currentStatus != null && message.hasOwnProperty("currentStatus"))
            object.currentStatus = message.currentStatus;
        if (message.enabledByDefault != null && message.hasOwnProperty("enabledByDefault"))
            object.enabledByDefault = message.enabledByDefault;
        return object;
    };

    /**
     * Converts this PrivacySetting to JSON.
     * @function toJSON
     * @memberof PrivacySetting
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    PrivacySetting.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return PrivacySetting;
})();

$root.Payload = (function() {

    /**
     * Properties of a Payload.
     * @exports IPayload
     * @interface IPayload
     * @property {IListResponse|null} [listResponse] Payload listResponse
     * @property {IDetailsResponse|null} [detailsResponse] Payload detailsResponse
     * @property {IReviewResponse|null} [reviewResponse] Payload reviewResponse
     * @property {IBuyResponse|null} [buyResponse] Payload buyResponse
     * @property {ISearchResponse|null} [searchResponse] Payload searchResponse
     * @property {ITocResponse|null} [tocResponse] Payload tocResponse
     * @property {IBrowseResponse|null} [browseResponse] Payload browseResponse
     * @property {IPurchaseStatusResponse|null} [purchaseStatusResponse] Payload purchaseStatusResponse
     * @property {string|null} [logResponse] Payload logResponse
     * @property {string|null} [flagContentResponse] Payload flagContentResponse
     * @property {IBulkDetailsResponse|null} [bulkDetailsResponse] Payload bulkDetailsResponse
     * @property {IDeliveryResponse|null} [deliveryResponse] Payload deliveryResponse
     * @property {IAcceptTosResponse|null} [acceptTosResponse] Payload acceptTosResponse
     * @property {ICheckPromoOfferResponse|null} [checkPromoOfferResponse] Payload checkPromoOfferResponse
     * @property {IInstrumentSetupInfoResponse|null} [instrumentSetupInfoResponse] Payload instrumentSetupInfoResponse
     * @property {IAndroidCheckinResponse|null} [androidCheckinResponse] Payload androidCheckinResponse
     * @property {IUploadDeviceConfigResponse|null} [uploadDeviceConfigResponse] Payload uploadDeviceConfigResponse
     * @property {ISearchSuggestResponse|null} [searchSuggestResponse] Payload searchSuggestResponse
     * @property {IConsumePurchaseResponse|null} [consumePurchaseResponse] Payload consumePurchaseResponse
     * @property {IBillingProfileResponse|null} [billingProfileResponse] Payload billingProfileResponse
     * @property {IDebugSettingsResponse|null} [debugSettingsResponse] Payload debugSettingsResponse
     * @property {ICheckIabPromoResponse|null} [checkIabPromoResponse] Payload checkIabPromoResponse
     * @property {IUserActivitySettingsResponse|null} [userActivitySettingsResponse] Payload userActivitySettingsResponse
     * @property {IRecordUserActivityResponse|null} [recordUserActivityResponse] Payload recordUserActivityResponse
     * @property {IRedeemCodeResponse|null} [redeemCodeResponse] Payload redeemCodeResponse
     * @property {ISelfUpdateResponse|null} [selfUpdateResponse] Payload selfUpdateResponse
     * @property {IGetInitialInstrumentFlowStateResponse|null} [getInitialInstrumentFlowStateResponse] Payload getInitialInstrumentFlowStateResponse
     * @property {ICreateInstrumentResponse|null} [createInstrumentResponse] Payload createInstrumentResponse
     * @property {IChallengeResponse|null} [challengeResponse] Payload challengeResponse
     * @property {IBackDeviceChoicesResponse|null} [backupDeviceChoicesResponse] Payload backupDeviceChoicesResponse
     * @property {IBackupDocumentChoicesResponse|null} [backupDocumentChoicesResponse] Payload backupDocumentChoicesResponse
     * @property {IEarlyUpdateResponse|null} [earlyUpdateResponse] Payload earlyUpdateResponse
     * @property {IPreloadsResponse|null} [preloadsResponse] Payload preloadsResponse
     * @property {IMyAccountsResponse|null} [myAccountsResponse] Payload myAccountsResponse
     * @property {IContentFilterResponse|null} [contentFilterResponse] Payload contentFilterResponse
     * @property {IExperimentsResponse|null} [experimentsResponse] Payload experimentsResponse
     * @property {ISurveyResponse|null} [surveyResponse] Payload surveyResponse
     * @property {IPingResponse|null} [pingResponse] Payload pingResponse
     * @property {IUpdateUserSettingResponse|null} [updateUserSettingResponse] Payload updateUserSettingResponse
     * @property {IGetUserSettingsResponse|null} [getUserSettingsResponse] Payload getUserSettingsResponse
     * @property {IGetSharingSettingsResponse|null} [getSharingSettingsResponse] Payload getSharingSettingsResponse
     * @property {IUpdateSharingSettingsResponse|null} [updateSharingSettingsResponse] Payload updateSharingSettingsResponse
     * @property {IReviewSnippetsResponse|null} [reviewSnippetsResponse] Payload reviewSnippetsResponse
     * @property {IDocumentSharingStateResponse|null} [documentSharingStateResponse] Payload documentSharingStateResponse
     * @property {IModuleDeliveryResponse|null} [moduleDeliveryResponse] Payload moduleDeliveryResponse
     * @property {ITestingProgramResponse|null} [testingProgramResponse] Payload testingProgramResponse
     * @property {IReviewResponse|null} [reviewSummaryResponse] Payload reviewSummaryResponse
     */

    /**
     * Constructs a new Payload.
     * @exports Payload
     * @classdesc Represents a Payload.
     * @implements IPayload
     * @constructor
     * @param {IPayload=} [properties] Properties to set
     */
    function Payload(properties) {
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * Payload listResponse.
     * @member {IListResponse|null|undefined} listResponse
     * @memberof Payload
     * @instance
     */
    Payload.prototype.listResponse = null;

    /**
     * Payload detailsResponse.
     * @member {IDetailsResponse|null|undefined} detailsResponse
     * @memberof Payload
     * @instance
     */
    Payload.prototype.detailsResponse = null;

    /**
     * Payload reviewResponse.
     * @member {IReviewResponse|null|undefined} reviewResponse
     * @memberof Payload
     * @instance
     */
    Payload.prototype.reviewResponse = null;

    /**
     * Payload buyResponse.
     * @member {IBuyResponse|null|undefined} buyResponse
     * @memberof Payload
     * @instance
     */
    Payload.prototype.buyResponse = null;

    /**
     * Payload searchResponse.
     * @member {ISearchResponse|null|undefined} searchResponse
     * @memberof Payload
     * @instance
     */
    Payload.prototype.searchResponse = null;

    /**
     * Payload tocResponse.
     * @member {ITocResponse|null|undefined} tocResponse
     * @memberof Payload
     * @instance
     */
    Payload.prototype.tocResponse = null;

    /**
     * Payload browseResponse.
     * @member {IBrowseResponse|null|undefined} browseResponse
     * @memberof Payload
     * @instance
     */
    Payload.prototype.browseResponse = null;

    /**
     * Payload purchaseStatusResponse.
     * @member {IPurchaseStatusResponse|null|undefined} purchaseStatusResponse
     * @memberof Payload
     * @instance
     */
    Payload.prototype.purchaseStatusResponse = null;

    /**
     * Payload logResponse.
     * @member {string} logResponse
     * @memberof Payload
     * @instance
     */
    Payload.prototype.logResponse = "";

    /**
     * Payload flagContentResponse.
     * @member {string} flagContentResponse
     * @memberof Payload
     * @instance
     */
    Payload.prototype.flagContentResponse = "";

    /**
     * Payload bulkDetailsResponse.
     * @member {IBulkDetailsResponse|null|undefined} bulkDetailsResponse
     * @memberof Payload
     * @instance
     */
    Payload.prototype.bulkDetailsResponse = null;

    /**
     * Payload deliveryResponse.
     * @member {IDeliveryResponse|null|undefined} deliveryResponse
     * @memberof Payload
     * @instance
     */
    Payload.prototype.deliveryResponse = null;

    /**
     * Payload acceptTosResponse.
     * @member {IAcceptTosResponse|null|undefined} acceptTosResponse
     * @memberof Payload
     * @instance
     */
    Payload.prototype.acceptTosResponse = null;

    /**
     * Payload checkPromoOfferResponse.
     * @member {ICheckPromoOfferResponse|null|undefined} checkPromoOfferResponse
     * @memberof Payload
     * @instance
     */
    Payload.prototype.checkPromoOfferResponse = null;

    /**
     * Payload instrumentSetupInfoResponse.
     * @member {IInstrumentSetupInfoResponse|null|undefined} instrumentSetupInfoResponse
     * @memberof Payload
     * @instance
     */
    Payload.prototype.instrumentSetupInfoResponse = null;

    /**
     * Payload androidCheckinResponse.
     * @member {IAndroidCheckinResponse|null|undefined} androidCheckinResponse
     * @memberof Payload
     * @instance
     */
    Payload.prototype.androidCheckinResponse = null;

    /**
     * Payload uploadDeviceConfigResponse.
     * @member {IUploadDeviceConfigResponse|null|undefined} uploadDeviceConfigResponse
     * @memberof Payload
     * @instance
     */
    Payload.prototype.uploadDeviceConfigResponse = null;

    /**
     * Payload searchSuggestResponse.
     * @member {ISearchSuggestResponse|null|undefined} searchSuggestResponse
     * @memberof Payload
     * @instance
     */
    Payload.prototype.searchSuggestResponse = null;

    /**
     * Payload consumePurchaseResponse.
     * @member {IConsumePurchaseResponse|null|undefined} consumePurchaseResponse
     * @memberof Payload
     * @instance
     */
    Payload.prototype.consumePurchaseResponse = null;

    /**
     * Payload billingProfileResponse.
     * @member {IBillingProfileResponse|null|undefined} billingProfileResponse
     * @memberof Payload
     * @instance
     */
    Payload.prototype.billingProfileResponse = null;

    /**
     * Payload debugSettingsResponse.
     * @member {IDebugSettingsResponse|null|undefined} debugSettingsResponse
     * @memberof Payload
     * @instance
     */
    Payload.prototype.debugSettingsResponse = null;

    /**
     * Payload checkIabPromoResponse.
     * @member {ICheckIabPromoResponse|null|undefined} checkIabPromoResponse
     * @memberof Payload
     * @instance
     */
    Payload.prototype.checkIabPromoResponse = null;

    /**
     * Payload userActivitySettingsResponse.
     * @member {IUserActivitySettingsResponse|null|undefined} userActivitySettingsResponse
     * @memberof Payload
     * @instance
     */
    Payload.prototype.userActivitySettingsResponse = null;

    /**
     * Payload recordUserActivityResponse.
     * @member {IRecordUserActivityResponse|null|undefined} recordUserActivityResponse
     * @memberof Payload
     * @instance
     */
    Payload.prototype.recordUserActivityResponse = null;

    /**
     * Payload redeemCodeResponse.
     * @member {IRedeemCodeResponse|null|undefined} redeemCodeResponse
     * @memberof Payload
     * @instance
     */
    Payload.prototype.redeemCodeResponse = null;

    /**
     * Payload selfUpdateResponse.
     * @member {ISelfUpdateResponse|null|undefined} selfUpdateResponse
     * @memberof Payload
     * @instance
     */
    Payload.prototype.selfUpdateResponse = null;

    /**
     * Payload getInitialInstrumentFlowStateResponse.
     * @member {IGetInitialInstrumentFlowStateResponse|null|undefined} getInitialInstrumentFlowStateResponse
     * @memberof Payload
     * @instance
     */
    Payload.prototype.getInitialInstrumentFlowStateResponse = null;

    /**
     * Payload createInstrumentResponse.
     * @member {ICreateInstrumentResponse|null|undefined} createInstrumentResponse
     * @memberof Payload
     * @instance
     */
    Payload.prototype.createInstrumentResponse = null;

    /**
     * Payload challengeResponse.
     * @member {IChallengeResponse|null|undefined} challengeResponse
     * @memberof Payload
     * @instance
     */
    Payload.prototype.challengeResponse = null;

    /**
     * Payload backupDeviceChoicesResponse.
     * @member {IBackDeviceChoicesResponse|null|undefined} backupDeviceChoicesResponse
     * @memberof Payload
     * @instance
     */
    Payload.prototype.backupDeviceChoicesResponse = null;

    /**
     * Payload backupDocumentChoicesResponse.
     * @member {IBackupDocumentChoicesResponse|null|undefined} backupDocumentChoicesResponse
     * @memberof Payload
     * @instance
     */
    Payload.prototype.backupDocumentChoicesResponse = null;

    /**
     * Payload earlyUpdateResponse.
     * @member {IEarlyUpdateResponse|null|undefined} earlyUpdateResponse
     * @memberof Payload
     * @instance
     */
    Payload.prototype.earlyUpdateResponse = null;

    /**
     * Payload preloadsResponse.
     * @member {IPreloadsResponse|null|undefined} preloadsResponse
     * @memberof Payload
     * @instance
     */
    Payload.prototype.preloadsResponse = null;

    /**
     * Payload myAccountsResponse.
     * @member {IMyAccountsResponse|null|undefined} myAccountsResponse
     * @memberof Payload
     * @instance
     */
    Payload.prototype.myAccountsResponse = null;

    /**
     * Payload contentFilterResponse.
     * @member {IContentFilterResponse|null|undefined} contentFilterResponse
     * @memberof Payload
     * @instance
     */
    Payload.prototype.contentFilterResponse = null;

    /**
     * Payload experimentsResponse.
     * @member {IExperimentsResponse|null|undefined} experimentsResponse
     * @memberof Payload
     * @instance
     */
    Payload.prototype.experimentsResponse = null;

    /**
     * Payload surveyResponse.
     * @member {ISurveyResponse|null|undefined} surveyResponse
     * @memberof Payload
     * @instance
     */
    Payload.prototype.surveyResponse = null;

    /**
     * Payload pingResponse.
     * @member {IPingResponse|null|undefined} pingResponse
     * @memberof Payload
     * @instance
     */
    Payload.prototype.pingResponse = null;

    /**
     * Payload updateUserSettingResponse.
     * @member {IUpdateUserSettingResponse|null|undefined} updateUserSettingResponse
     * @memberof Payload
     * @instance
     */
    Payload.prototype.updateUserSettingResponse = null;

    /**
     * Payload getUserSettingsResponse.
     * @member {IGetUserSettingsResponse|null|undefined} getUserSettingsResponse
     * @memberof Payload
     * @instance
     */
    Payload.prototype.getUserSettingsResponse = null;

    /**
     * Payload getSharingSettingsResponse.
     * @member {IGetSharingSettingsResponse|null|undefined} getSharingSettingsResponse
     * @memberof Payload
     * @instance
     */
    Payload.prototype.getSharingSettingsResponse = null;

    /**
     * Payload updateSharingSettingsResponse.
     * @member {IUpdateSharingSettingsResponse|null|undefined} updateSharingSettingsResponse
     * @memberof Payload
     * @instance
     */
    Payload.prototype.updateSharingSettingsResponse = null;

    /**
     * Payload reviewSnippetsResponse.
     * @member {IReviewSnippetsResponse|null|undefined} reviewSnippetsResponse
     * @memberof Payload
     * @instance
     */
    Payload.prototype.reviewSnippetsResponse = null;

    /**
     * Payload documentSharingStateResponse.
     * @member {IDocumentSharingStateResponse|null|undefined} documentSharingStateResponse
     * @memberof Payload
     * @instance
     */
    Payload.prototype.documentSharingStateResponse = null;

    /**
     * Payload moduleDeliveryResponse.
     * @member {IModuleDeliveryResponse|null|undefined} moduleDeliveryResponse
     * @memberof Payload
     * @instance
     */
    Payload.prototype.moduleDeliveryResponse = null;

    /**
     * Payload testingProgramResponse.
     * @member {ITestingProgramResponse|null|undefined} testingProgramResponse
     * @memberof Payload
     * @instance
     */
    Payload.prototype.testingProgramResponse = null;

    /**
     * Payload reviewSummaryResponse.
     * @member {IReviewResponse|null|undefined} reviewSummaryResponse
     * @memberof Payload
     * @instance
     */
    Payload.prototype.reviewSummaryResponse = null;

    /**
     * Creates a new Payload instance using the specified properties.
     * @function create
     * @memberof Payload
     * @static
     * @param {IPayload=} [properties] Properties to set
     * @returns {Payload} Payload instance
     */
    Payload.create = function create(properties) {
        return new Payload(properties);
    };

    /**
     * Encodes the specified Payload message. Does not implicitly {@link Payload.verify|verify} messages.
     * @function encode
     * @memberof Payload
     * @static
     * @param {IPayload} message Payload message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    Payload.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.listResponse != null && Object.hasOwnProperty.call(message, "listResponse"))
            $root.ListResponse.encode(message.listResponse, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
        if (message.detailsResponse != null && Object.hasOwnProperty.call(message, "detailsResponse"))
            $root.DetailsResponse.encode(message.detailsResponse, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
        if (message.reviewResponse != null && Object.hasOwnProperty.call(message, "reviewResponse"))
            $root.ReviewResponse.encode(message.reviewResponse, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
        if (message.buyResponse != null && Object.hasOwnProperty.call(message, "buyResponse"))
            $root.BuyResponse.encode(message.buyResponse, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
        if (message.searchResponse != null && Object.hasOwnProperty.call(message, "searchResponse"))
            $root.SearchResponse.encode(message.searchResponse, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
        if (message.tocResponse != null && Object.hasOwnProperty.call(message, "tocResponse"))
            $root.TocResponse.encode(message.tocResponse, writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
        if (message.browseResponse != null && Object.hasOwnProperty.call(message, "browseResponse"))
            $root.BrowseResponse.encode(message.browseResponse, writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
        if (message.purchaseStatusResponse != null && Object.hasOwnProperty.call(message, "purchaseStatusResponse"))
            $root.PurchaseStatusResponse.encode(message.purchaseStatusResponse, writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();
        if (message.logResponse != null && Object.hasOwnProperty.call(message, "logResponse"))
            writer.uint32(/* id 10, wireType 2 =*/82).string(message.logResponse);
        if (message.flagContentResponse != null && Object.hasOwnProperty.call(message, "flagContentResponse"))
            writer.uint32(/* id 13, wireType 2 =*/106).string(message.flagContentResponse);
        if (message.bulkDetailsResponse != null && Object.hasOwnProperty.call(message, "bulkDetailsResponse"))
            $root.BulkDetailsResponse.encode(message.bulkDetailsResponse, writer.uint32(/* id 19, wireType 2 =*/154).fork()).ldelim();
        if (message.deliveryResponse != null && Object.hasOwnProperty.call(message, "deliveryResponse"))
            $root.DeliveryResponse.encode(message.deliveryResponse, writer.uint32(/* id 21, wireType 2 =*/170).fork()).ldelim();
        if (message.acceptTosResponse != null && Object.hasOwnProperty.call(message, "acceptTosResponse"))
            $root.AcceptTosResponse.encode(message.acceptTosResponse, writer.uint32(/* id 22, wireType 2 =*/178).fork()).ldelim();
        if (message.checkPromoOfferResponse != null && Object.hasOwnProperty.call(message, "checkPromoOfferResponse"))
            $root.CheckPromoOfferResponse.encode(message.checkPromoOfferResponse, writer.uint32(/* id 24, wireType 2 =*/194).fork()).ldelim();
        if (message.instrumentSetupInfoResponse != null && Object.hasOwnProperty.call(message, "instrumentSetupInfoResponse"))
            $root.InstrumentSetupInfoResponse.encode(message.instrumentSetupInfoResponse, writer.uint32(/* id 25, wireType 2 =*/202).fork()).ldelim();
        if (message.androidCheckinResponse != null && Object.hasOwnProperty.call(message, "androidCheckinResponse"))
            $root.AndroidCheckinResponse.encode(message.androidCheckinResponse, writer.uint32(/* id 26, wireType 2 =*/210).fork()).ldelim();
        if (message.uploadDeviceConfigResponse != null && Object.hasOwnProperty.call(message, "uploadDeviceConfigResponse"))
            $root.UploadDeviceConfigResponse.encode(message.uploadDeviceConfigResponse, writer.uint32(/* id 28, wireType 2 =*/226).fork()).ldelim();
        if (message.consumePurchaseResponse != null && Object.hasOwnProperty.call(message, "consumePurchaseResponse"))
            $root.ConsumePurchaseResponse.encode(message.consumePurchaseResponse, writer.uint32(/* id 30, wireType 2 =*/242).fork()).ldelim();
        if (message.billingProfileResponse != null && Object.hasOwnProperty.call(message, "billingProfileResponse"))
            $root.BillingProfileResponse.encode(message.billingProfileResponse, writer.uint32(/* id 31, wireType 2 =*/250).fork()).ldelim();
        if (message.debugSettingsResponse != null && Object.hasOwnProperty.call(message, "debugSettingsResponse"))
            $root.DebugSettingsResponse.encode(message.debugSettingsResponse, writer.uint32(/* id 34, wireType 2 =*/274).fork()).ldelim();
        if (message.checkIabPromoResponse != null && Object.hasOwnProperty.call(message, "checkIabPromoResponse"))
            $root.CheckIabPromoResponse.encode(message.checkIabPromoResponse, writer.uint32(/* id 35, wireType 2 =*/282).fork()).ldelim();
        if (message.userActivitySettingsResponse != null && Object.hasOwnProperty.call(message, "userActivitySettingsResponse"))
            $root.UserActivitySettingsResponse.encode(message.userActivitySettingsResponse, writer.uint32(/* id 36, wireType 2 =*/290).fork()).ldelim();
        if (message.recordUserActivityResponse != null && Object.hasOwnProperty.call(message, "recordUserActivityResponse"))
            $root.RecordUserActivityResponse.encode(message.recordUserActivityResponse, writer.uint32(/* id 37, wireType 2 =*/298).fork()).ldelim();
        if (message.redeemCodeResponse != null && Object.hasOwnProperty.call(message, "redeemCodeResponse"))
            $root.RedeemCodeResponse.encode(message.redeemCodeResponse, writer.uint32(/* id 38, wireType 2 =*/306).fork()).ldelim();
        if (message.selfUpdateResponse != null && Object.hasOwnProperty.call(message, "selfUpdateResponse"))
            $root.SelfUpdateResponse.encode(message.selfUpdateResponse, writer.uint32(/* id 39, wireType 2 =*/314).fork()).ldelim();
        if (message.searchSuggestResponse != null && Object.hasOwnProperty.call(message, "searchSuggestResponse"))
            $root.SearchSuggestResponse.encode(message.searchSuggestResponse, writer.uint32(/* id 40, wireType 2 =*/322).fork()).ldelim();
        if (message.getInitialInstrumentFlowStateResponse != null && Object.hasOwnProperty.call(message, "getInitialInstrumentFlowStateResponse"))
            $root.GetInitialInstrumentFlowStateResponse.encode(message.getInitialInstrumentFlowStateResponse, writer.uint32(/* id 41, wireType 2 =*/330).fork()).ldelim();
        if (message.createInstrumentResponse != null && Object.hasOwnProperty.call(message, "createInstrumentResponse"))
            $root.CreateInstrumentResponse.encode(message.createInstrumentResponse, writer.uint32(/* id 42, wireType 2 =*/338).fork()).ldelim();
        if (message.challengeResponse != null && Object.hasOwnProperty.call(message, "challengeResponse"))
            $root.ChallengeResponse.encode(message.challengeResponse, writer.uint32(/* id 43, wireType 2 =*/346).fork()).ldelim();
        if (message.backupDeviceChoicesResponse != null && Object.hasOwnProperty.call(message, "backupDeviceChoicesResponse"))
            $root.BackDeviceChoicesResponse.encode(message.backupDeviceChoicesResponse, writer.uint32(/* id 44, wireType 2 =*/354).fork()).ldelim();
        if (message.backupDocumentChoicesResponse != null && Object.hasOwnProperty.call(message, "backupDocumentChoicesResponse"))
            $root.BackupDocumentChoicesResponse.encode(message.backupDocumentChoicesResponse, writer.uint32(/* id 45, wireType 2 =*/362).fork()).ldelim();
        if (message.earlyUpdateResponse != null && Object.hasOwnProperty.call(message, "earlyUpdateResponse"))
            $root.EarlyUpdateResponse.encode(message.earlyUpdateResponse, writer.uint32(/* id 46, wireType 2 =*/370).fork()).ldelim();
        if (message.preloadsResponse != null && Object.hasOwnProperty.call(message, "preloadsResponse"))
            $root.PreloadsResponse.encode(message.preloadsResponse, writer.uint32(/* id 47, wireType 2 =*/378).fork()).ldelim();
        if (message.myAccountsResponse != null && Object.hasOwnProperty.call(message, "myAccountsResponse"))
            $root.MyAccountsResponse.encode(message.myAccountsResponse, writer.uint32(/* id 48, wireType 2 =*/386).fork()).ldelim();
        if (message.contentFilterResponse != null && Object.hasOwnProperty.call(message, "contentFilterResponse"))
            $root.ContentFilterResponse.encode(message.contentFilterResponse, writer.uint32(/* id 49, wireType 2 =*/394).fork()).ldelim();
        if (message.experimentsResponse != null && Object.hasOwnProperty.call(message, "experimentsResponse"))
            $root.ExperimentsResponse.encode(message.experimentsResponse, writer.uint32(/* id 50, wireType 2 =*/402).fork()).ldelim();
        if (message.surveyResponse != null && Object.hasOwnProperty.call(message, "surveyResponse"))
            $root.SurveyResponse.encode(message.surveyResponse, writer.uint32(/* id 51, wireType 2 =*/410).fork()).ldelim();
        if (message.pingResponse != null && Object.hasOwnProperty.call(message, "pingResponse"))
            $root.PingResponse.encode(message.pingResponse, writer.uint32(/* id 52, wireType 2 =*/418).fork()).ldelim();
        if (message.updateUserSettingResponse != null && Object.hasOwnProperty.call(message, "updateUserSettingResponse"))
            $root.UpdateUserSettingResponse.encode(message.updateUserSettingResponse, writer.uint32(/* id 53, wireType 2 =*/426).fork()).ldelim();
        if (message.getUserSettingsResponse != null && Object.hasOwnProperty.call(message, "getUserSettingsResponse"))
            $root.GetUserSettingsResponse.encode(message.getUserSettingsResponse, writer.uint32(/* id 54, wireType 2 =*/434).fork()).ldelim();
        if (message.getSharingSettingsResponse != null && Object.hasOwnProperty.call(message, "getSharingSettingsResponse"))
            $root.GetSharingSettingsResponse.encode(message.getSharingSettingsResponse, writer.uint32(/* id 56, wireType 2 =*/450).fork()).ldelim();
        if (message.updateSharingSettingsResponse != null && Object.hasOwnProperty.call(message, "updateSharingSettingsResponse"))
            $root.UpdateSharingSettingsResponse.encode(message.updateSharingSettingsResponse, writer.uint32(/* id 57, wireType 2 =*/458).fork()).ldelim();
        if (message.reviewSnippetsResponse != null && Object.hasOwnProperty.call(message, "reviewSnippetsResponse"))
            $root.ReviewSnippetsResponse.encode(message.reviewSnippetsResponse, writer.uint32(/* id 58, wireType 2 =*/466).fork()).ldelim();
        if (message.documentSharingStateResponse != null && Object.hasOwnProperty.call(message, "documentSharingStateResponse"))
            $root.DocumentSharingStateResponse.encode(message.documentSharingStateResponse, writer.uint32(/* id 59, wireType 2 =*/474).fork()).ldelim();
        if (message.moduleDeliveryResponse != null && Object.hasOwnProperty.call(message, "moduleDeliveryResponse"))
            $root.ModuleDeliveryResponse.encode(message.moduleDeliveryResponse, writer.uint32(/* id 70, wireType 2 =*/562).fork()).ldelim();
        if (message.testingProgramResponse != null && Object.hasOwnProperty.call(message, "testingProgramResponse"))
            $root.TestingProgramResponse.encode(message.testingProgramResponse, writer.uint32(/* id 80, wireType 2 =*/642).fork()).ldelim();
        if (message.reviewSummaryResponse != null && Object.hasOwnProperty.call(message, "reviewSummaryResponse"))
            $root.ReviewResponse.encode(message.reviewSummaryResponse, writer.uint32(/* id 129, wireType 2 =*/1034).fork()).ldelim();
        return writer;
    };

    /**
     * Encodes the specified Payload message, length delimited. Does not implicitly {@link Payload.verify|verify} messages.
     * @function encodeDelimited
     * @memberof Payload
     * @static
     * @param {IPayload} message Payload message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    Payload.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a Payload message from the specified reader or buffer.
     * @function decode
     * @memberof Payload
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {Payload} Payload
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    Payload.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Payload();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.listResponse = $root.ListResponse.decode(reader, reader.uint32());
                break;
            case 2:
                message.detailsResponse = $root.DetailsResponse.decode(reader, reader.uint32());
                break;
            case 3:
                message.reviewResponse = $root.ReviewResponse.decode(reader, reader.uint32());
                break;
            case 4:
                message.buyResponse = $root.BuyResponse.decode(reader, reader.uint32());
                break;
            case 5:
                message.searchResponse = $root.SearchResponse.decode(reader, reader.uint32());
                break;
            case 6:
                message.tocResponse = $root.TocResponse.decode(reader, reader.uint32());
                break;
            case 7:
                message.browseResponse = $root.BrowseResponse.decode(reader, reader.uint32());
                break;
            case 8:
                message.purchaseStatusResponse = $root.PurchaseStatusResponse.decode(reader, reader.uint32());
                break;
            case 10:
                message.logResponse = reader.string();
                break;
            case 13:
                message.flagContentResponse = reader.string();
                break;
            case 19:
                message.bulkDetailsResponse = $root.BulkDetailsResponse.decode(reader, reader.uint32());
                break;
            case 21:
                message.deliveryResponse = $root.DeliveryResponse.decode(reader, reader.uint32());
                break;
            case 22:
                message.acceptTosResponse = $root.AcceptTosResponse.decode(reader, reader.uint32());
                break;
            case 24:
                message.checkPromoOfferResponse = $root.CheckPromoOfferResponse.decode(reader, reader.uint32());
                break;
            case 25:
                message.instrumentSetupInfoResponse = $root.InstrumentSetupInfoResponse.decode(reader, reader.uint32());
                break;
            case 26:
                message.androidCheckinResponse = $root.AndroidCheckinResponse.decode(reader, reader.uint32());
                break;
            case 28:
                message.uploadDeviceConfigResponse = $root.UploadDeviceConfigResponse.decode(reader, reader.uint32());
                break;
            case 40:
                message.searchSuggestResponse = $root.SearchSuggestResponse.decode(reader, reader.uint32());
                break;
            case 30:
                message.consumePurchaseResponse = $root.ConsumePurchaseResponse.decode(reader, reader.uint32());
                break;
            case 31:
                message.billingProfileResponse = $root.BillingProfileResponse.decode(reader, reader.uint32());
                break;
            case 34:
                message.debugSettingsResponse = $root.DebugSettingsResponse.decode(reader, reader.uint32());
                break;
            case 35:
                message.checkIabPromoResponse = $root.CheckIabPromoResponse.decode(reader, reader.uint32());
                break;
            case 36:
                message.userActivitySettingsResponse = $root.UserActivitySettingsResponse.decode(reader, reader.uint32());
                break;
            case 37:
                message.recordUserActivityResponse = $root.RecordUserActivityResponse.decode(reader, reader.uint32());
                break;
            case 38:
                message.redeemCodeResponse = $root.RedeemCodeResponse.decode(reader, reader.uint32());
                break;
            case 39:
                message.selfUpdateResponse = $root.SelfUpdateResponse.decode(reader, reader.uint32());
                break;
            case 41:
                message.getInitialInstrumentFlowStateResponse = $root.GetInitialInstrumentFlowStateResponse.decode(reader, reader.uint32());
                break;
            case 42:
                message.createInstrumentResponse = $root.CreateInstrumentResponse.decode(reader, reader.uint32());
                break;
            case 43:
                message.challengeResponse = $root.ChallengeResponse.decode(reader, reader.uint32());
                break;
            case 44:
                message.backupDeviceChoicesResponse = $root.BackDeviceChoicesResponse.decode(reader, reader.uint32());
                break;
            case 45:
                message.backupDocumentChoicesResponse = $root.BackupDocumentChoicesResponse.decode(reader, reader.uint32());
                break;
            case 46:
                message.earlyUpdateResponse = $root.EarlyUpdateResponse.decode(reader, reader.uint32());
                break;
            case 47:
                message.preloadsResponse = $root.PreloadsResponse.decode(reader, reader.uint32());
                break;
            case 48:
                message.myAccountsResponse = $root.MyAccountsResponse.decode(reader, reader.uint32());
                break;
            case 49:
                message.contentFilterResponse = $root.ContentFilterResponse.decode(reader, reader.uint32());
                break;
            case 50:
                message.experimentsResponse = $root.ExperimentsResponse.decode(reader, reader.uint32());
                break;
            case 51:
                message.surveyResponse = $root.SurveyResponse.decode(reader, reader.uint32());
                break;
            case 52:
                message.pingResponse = $root.PingResponse.decode(reader, reader.uint32());
                break;
            case 53:
                message.updateUserSettingResponse = $root.UpdateUserSettingResponse.decode(reader, reader.uint32());
                break;
            case 54:
                message.getUserSettingsResponse = $root.GetUserSettingsResponse.decode(reader, reader.uint32());
                break;
            case 56:
                message.getSharingSettingsResponse = $root.GetSharingSettingsResponse.decode(reader, reader.uint32());
                break;
            case 57:
                message.updateSharingSettingsResponse = $root.UpdateSharingSettingsResponse.decode(reader, reader.uint32());
                break;
            case 58:
                message.reviewSnippetsResponse = $root.ReviewSnippetsResponse.decode(reader, reader.uint32());
                break;
            case 59:
                message.documentSharingStateResponse = $root.DocumentSharingStateResponse.decode(reader, reader.uint32());
                break;
            case 70:
                message.moduleDeliveryResponse = $root.ModuleDeliveryResponse.decode(reader, reader.uint32());
                break;
            case 80:
                message.testingProgramResponse = $root.TestingProgramResponse.decode(reader, reader.uint32());
                break;
            case 129:
                message.reviewSummaryResponse = $root.ReviewResponse.decode(reader, reader.uint32());
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a Payload message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof Payload
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {Payload} Payload
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    Payload.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a Payload message.
     * @function verify
     * @memberof Payload
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    Payload.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.listResponse != null && message.hasOwnProperty("listResponse")) {
            var error = $root.ListResponse.verify(message.listResponse);
            if (error)
                return "listResponse." + error;
        }
        if (message.detailsResponse != null && message.hasOwnProperty("detailsResponse")) {
            var error = $root.DetailsResponse.verify(message.detailsResponse);
            if (error)
                return "detailsResponse." + error;
        }
        if (message.reviewResponse != null && message.hasOwnProperty("reviewResponse")) {
            var error = $root.ReviewResponse.verify(message.reviewResponse);
            if (error)
                return "reviewResponse." + error;
        }
        if (message.buyResponse != null && message.hasOwnProperty("buyResponse")) {
            var error = $root.BuyResponse.verify(message.buyResponse);
            if (error)
                return "buyResponse." + error;
        }
        if (message.searchResponse != null && message.hasOwnProperty("searchResponse")) {
            var error = $root.SearchResponse.verify(message.searchResponse);
            if (error)
                return "searchResponse." + error;
        }
        if (message.tocResponse != null && message.hasOwnProperty("tocResponse")) {
            var error = $root.TocResponse.verify(message.tocResponse);
            if (error)
                return "tocResponse." + error;
        }
        if (message.browseResponse != null && message.hasOwnProperty("browseResponse")) {
            var error = $root.BrowseResponse.verify(message.browseResponse);
            if (error)
                return "browseResponse." + error;
        }
        if (message.purchaseStatusResponse != null && message.hasOwnProperty("purchaseStatusResponse")) {
            var error = $root.PurchaseStatusResponse.verify(message.purchaseStatusResponse);
            if (error)
                return "purchaseStatusResponse." + error;
        }
        if (message.logResponse != null && message.hasOwnProperty("logResponse"))
            if (!$util.isString(message.logResponse))
                return "logResponse: string expected";
        if (message.flagContentResponse != null && message.hasOwnProperty("flagContentResponse"))
            if (!$util.isString(message.flagContentResponse))
                return "flagContentResponse: string expected";
        if (message.bulkDetailsResponse != null && message.hasOwnProperty("bulkDetailsResponse")) {
            var error = $root.BulkDetailsResponse.verify(message.bulkDetailsResponse);
            if (error)
                return "bulkDetailsResponse." + error;
        }
        if (message.deliveryResponse != null && message.hasOwnProperty("deliveryResponse")) {
            var error = $root.DeliveryResponse.verify(message.deliveryResponse);
            if (error)
                return "deliveryResponse." + error;
        }
        if (message.acceptTosResponse != null && message.hasOwnProperty("acceptTosResponse")) {
            var error = $root.AcceptTosResponse.verify(message.acceptTosResponse);
            if (error)
                return "acceptTosResponse." + error;
        }
        if (message.checkPromoOfferResponse != null && message.hasOwnProperty("checkPromoOfferResponse")) {
            var error = $root.CheckPromoOfferResponse.verify(message.checkPromoOfferResponse);
            if (error)
                return "checkPromoOfferResponse." + error;
        }
        if (message.instrumentSetupInfoResponse != null && message.hasOwnProperty("instrumentSetupInfoResponse")) {
            var error = $root.InstrumentSetupInfoResponse.verify(message.instrumentSetupInfoResponse);
            if (error)
                return "instrumentSetupInfoResponse." + error;
        }
        if (message.androidCheckinResponse != null && message.hasOwnProperty("androidCheckinResponse")) {
            var error = $root.AndroidCheckinResponse.verify(message.androidCheckinResponse);
            if (error)
                return "androidCheckinResponse." + error;
        }
        if (message.uploadDeviceConfigResponse != null && message.hasOwnProperty("uploadDeviceConfigResponse")) {
            var error = $root.UploadDeviceConfigResponse.verify(message.uploadDeviceConfigResponse);
            if (error)
                return "uploadDeviceConfigResponse." + error;
        }
        if (message.searchSuggestResponse != null && message.hasOwnProperty("searchSuggestResponse")) {
            var error = $root.SearchSuggestResponse.verify(message.searchSuggestResponse);
            if (error)
                return "searchSuggestResponse." + error;
        }
        if (message.consumePurchaseResponse != null && message.hasOwnProperty("consumePurchaseResponse")) {
            var error = $root.ConsumePurchaseResponse.verify(message.consumePurchaseResponse);
            if (error)
                return "consumePurchaseResponse." + error;
        }
        if (message.billingProfileResponse != null && message.hasOwnProperty("billingProfileResponse")) {
            var error = $root.BillingProfileResponse.verify(message.billingProfileResponse);
            if (error)
                return "billingProfileResponse." + error;
        }
        if (message.debugSettingsResponse != null && message.hasOwnProperty("debugSettingsResponse")) {
            var error = $root.DebugSettingsResponse.verify(message.debugSettingsResponse);
            if (error)
                return "debugSettingsResponse." + error;
        }
        if (message.checkIabPromoResponse != null && message.hasOwnProperty("checkIabPromoResponse")) {
            var error = $root.CheckIabPromoResponse.verify(message.checkIabPromoResponse);
            if (error)
                return "checkIabPromoResponse." + error;
        }
        if (message.userActivitySettingsResponse != null && message.hasOwnProperty("userActivitySettingsResponse")) {
            var error = $root.UserActivitySettingsResponse.verify(message.userActivitySettingsResponse);
            if (error)
                return "userActivitySettingsResponse." + error;
        }
        if (message.recordUserActivityResponse != null && message.hasOwnProperty("recordUserActivityResponse")) {
            var error = $root.RecordUserActivityResponse.verify(message.recordUserActivityResponse);
            if (error)
                return "recordUserActivityResponse." + error;
        }
        if (message.redeemCodeResponse != null && message.hasOwnProperty("redeemCodeResponse")) {
            var error = $root.RedeemCodeResponse.verify(message.redeemCodeResponse);
            if (error)
                return "redeemCodeResponse." + error;
        }
        if (message.selfUpdateResponse != null && message.hasOwnProperty("selfUpdateResponse")) {
            var error = $root.SelfUpdateResponse.verify(message.selfUpdateResponse);
            if (error)
                return "selfUpdateResponse." + error;
        }
        if (message.getInitialInstrumentFlowStateResponse != null && message.hasOwnProperty("getInitialInstrumentFlowStateResponse")) {
            var error = $root.GetInitialInstrumentFlowStateResponse.verify(message.getInitialInstrumentFlowStateResponse);
            if (error)
                return "getInitialInstrumentFlowStateResponse." + error;
        }
        if (message.createInstrumentResponse != null && message.hasOwnProperty("createInstrumentResponse")) {
            var error = $root.CreateInstrumentResponse.verify(message.createInstrumentResponse);
            if (error)
                return "createInstrumentResponse." + error;
        }
        if (message.challengeResponse != null && message.hasOwnProperty("challengeResponse")) {
            var error = $root.ChallengeResponse.verify(message.challengeResponse);
            if (error)
                return "challengeResponse." + error;
        }
        if (message.backupDeviceChoicesResponse != null && message.hasOwnProperty("backupDeviceChoicesResponse")) {
            var error = $root.BackDeviceChoicesResponse.verify(message.backupDeviceChoicesResponse);
            if (error)
                return "backupDeviceChoicesResponse." + error;
        }
        if (message.backupDocumentChoicesResponse != null && message.hasOwnProperty("backupDocumentChoicesResponse")) {
            var error = $root.BackupDocumentChoicesResponse.verify(message.backupDocumentChoicesResponse);
            if (error)
                return "backupDocumentChoicesResponse." + error;
        }
        if (message.earlyUpdateResponse != null && message.hasOwnProperty("earlyUpdateResponse")) {
            var error = $root.EarlyUpdateResponse.verify(message.earlyUpdateResponse);
            if (error)
                return "earlyUpdateResponse." + error;
        }
        if (message.preloadsResponse != null && message.hasOwnProperty("preloadsResponse")) {
            var error = $root.PreloadsResponse.verify(message.preloadsResponse);
            if (error)
                return "preloadsResponse." + error;
        }
        if (message.myAccountsResponse != null && message.hasOwnProperty("myAccountsResponse")) {
            var error = $root.MyAccountsResponse.verify(message.myAccountsResponse);
            if (error)
                return "myAccountsResponse." + error;
        }
        if (message.contentFilterResponse != null && message.hasOwnProperty("contentFilterResponse")) {
            var error = $root.ContentFilterResponse.verify(message.contentFilterResponse);
            if (error)
                return "contentFilterResponse." + error;
        }
        if (message.experimentsResponse != null && message.hasOwnProperty("experimentsResponse")) {
            var error = $root.ExperimentsResponse.verify(message.experimentsResponse);
            if (error)
                return "experimentsResponse." + error;
        }
        if (message.surveyResponse != null && message.hasOwnProperty("surveyResponse")) {
            var error = $root.SurveyResponse.verify(message.surveyResponse);
            if (error)
                return "surveyResponse." + error;
        }
        if (message.pingResponse != null && message.hasOwnProperty("pingResponse")) {
            var error = $root.PingResponse.verify(message.pingResponse);
            if (error)
                return "pingResponse." + error;
        }
        if (message.updateUserSettingResponse != null && message.hasOwnProperty("updateUserSettingResponse")) {
            var error = $root.UpdateUserSettingResponse.verify(message.updateUserSettingResponse);
            if (error)
                return "updateUserSettingResponse." + error;
        }
        if (message.getUserSettingsResponse != null && message.hasOwnProperty("getUserSettingsResponse")) {
            var error = $root.GetUserSettingsResponse.verify(message.getUserSettingsResponse);
            if (error)
                return "getUserSettingsResponse." + error;
        }
        if (message.getSharingSettingsResponse != null && message.hasOwnProperty("getSharingSettingsResponse")) {
            var error = $root.GetSharingSettingsResponse.verify(message.getSharingSettingsResponse);
            if (error)
                return "getSharingSettingsResponse." + error;
        }
        if (message.updateSharingSettingsResponse != null && message.hasOwnProperty("updateSharingSettingsResponse")) {
            var error = $root.UpdateSharingSettingsResponse.verify(message.updateSharingSettingsResponse);
            if (error)
                return "updateSharingSettingsResponse." + error;
        }
        if (message.reviewSnippetsResponse != null && message.hasOwnProperty("reviewSnippetsResponse")) {
            var error = $root.ReviewSnippetsResponse.verify(message.reviewSnippetsResponse);
            if (error)
                return "reviewSnippetsResponse." + error;
        }
        if (message.documentSharingStateResponse != null && message.hasOwnProperty("documentSharingStateResponse")) {
            var error = $root.DocumentSharingStateResponse.verify(message.documentSharingStateResponse);
            if (error)
                return "documentSharingStateResponse." + error;
        }
        if (message.moduleDeliveryResponse != null && message.hasOwnProperty("moduleDeliveryResponse")) {
            var error = $root.ModuleDeliveryResponse.verify(message.moduleDeliveryResponse);
            if (error)
                return "moduleDeliveryResponse." + error;
        }
        if (message.testingProgramResponse != null && message.hasOwnProperty("testingProgramResponse")) {
            var error = $root.TestingProgramResponse.verify(message.testingProgramResponse);
            if (error)
                return "testingProgramResponse." + error;
        }
        if (message.reviewSummaryResponse != null && message.hasOwnProperty("reviewSummaryResponse")) {
            var error = $root.ReviewResponse.verify(message.reviewSummaryResponse);
            if (error)
                return "reviewSummaryResponse." + error;
        }
        return null;
    };

    /**
     * Creates a Payload message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof Payload
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {Payload} Payload
     */
    Payload.fromObject = function fromObject(object) {
        if (object instanceof $root.Payload)
            return object;
        var message = new $root.Payload();
        if (object.listResponse != null) {
            if (typeof object.listResponse !== "object")
                throw TypeError(".Payload.listResponse: object expected");
            message.listResponse = $root.ListResponse.fromObject(object.listResponse);
        }
        if (object.detailsResponse != null) {
            if (typeof object.detailsResponse !== "object")
                throw TypeError(".Payload.detailsResponse: object expected");
            message.detailsResponse = $root.DetailsResponse.fromObject(object.detailsResponse);
        }
        if (object.reviewResponse != null) {
            if (typeof object.reviewResponse !== "object")
                throw TypeError(".Payload.reviewResponse: object expected");
            message.reviewResponse = $root.ReviewResponse.fromObject(object.reviewResponse);
        }
        if (object.buyResponse != null) {
            if (typeof object.buyResponse !== "object")
                throw TypeError(".Payload.buyResponse: object expected");
            message.buyResponse = $root.BuyResponse.fromObject(object.buyResponse);
        }
        if (object.searchResponse != null) {
            if (typeof object.searchResponse !== "object")
                throw TypeError(".Payload.searchResponse: object expected");
            message.searchResponse = $root.SearchResponse.fromObject(object.searchResponse);
        }
        if (object.tocResponse != null) {
            if (typeof object.tocResponse !== "object")
                throw TypeError(".Payload.tocResponse: object expected");
            message.tocResponse = $root.TocResponse.fromObject(object.tocResponse);
        }
        if (object.browseResponse != null) {
            if (typeof object.browseResponse !== "object")
                throw TypeError(".Payload.browseResponse: object expected");
            message.browseResponse = $root.BrowseResponse.fromObject(object.browseResponse);
        }
        if (object.purchaseStatusResponse != null) {
            if (typeof object.purchaseStatusResponse !== "object")
                throw TypeError(".Payload.purchaseStatusResponse: object expected");
            message.purchaseStatusResponse = $root.PurchaseStatusResponse.fromObject(object.purchaseStatusResponse);
        }
        if (object.logResponse != null)
            message.logResponse = String(object.logResponse);
        if (object.flagContentResponse != null)
            message.flagContentResponse = String(object.flagContentResponse);
        if (object.bulkDetailsResponse != null) {
            if (typeof object.bulkDetailsResponse !== "object")
                throw TypeError(".Payload.bulkDetailsResponse: object expected");
            message.bulkDetailsResponse = $root.BulkDetailsResponse.fromObject(object.bulkDetailsResponse);
        }
        if (object.deliveryResponse != null) {
            if (typeof object.deliveryResponse !== "object")
                throw TypeError(".Payload.deliveryResponse: object expected");
            message.deliveryResponse = $root.DeliveryResponse.fromObject(object.deliveryResponse);
        }
        if (object.acceptTosResponse != null) {
            if (typeof object.acceptTosResponse !== "object")
                throw TypeError(".Payload.acceptTosResponse: object expected");
            message.acceptTosResponse = $root.AcceptTosResponse.fromObject(object.acceptTosResponse);
        }
        if (object.checkPromoOfferResponse != null) {
            if (typeof object.checkPromoOfferResponse !== "object")
                throw TypeError(".Payload.checkPromoOfferResponse: object expected");
            message.checkPromoOfferResponse = $root.CheckPromoOfferResponse.fromObject(object.checkPromoOfferResponse);
        }
        if (object.instrumentSetupInfoResponse != null) {
            if (typeof object.instrumentSetupInfoResponse !== "object")
                throw TypeError(".Payload.instrumentSetupInfoResponse: object expected");
            message.instrumentSetupInfoResponse = $root.InstrumentSetupInfoResponse.fromObject(object.instrumentSetupInfoResponse);
        }
        if (object.androidCheckinResponse != null) {
            if (typeof object.androidCheckinResponse !== "object")
                throw TypeError(".Payload.androidCheckinResponse: object expected");
            message.androidCheckinResponse = $root.AndroidCheckinResponse.fromObject(object.androidCheckinResponse);
        }
        if (object.uploadDeviceConfigResponse != null) {
            if (typeof object.uploadDeviceConfigResponse !== "object")
                throw TypeError(".Payload.uploadDeviceConfigResponse: object expected");
            message.uploadDeviceConfigResponse = $root.UploadDeviceConfigResponse.fromObject(object.uploadDeviceConfigResponse);
        }
        if (object.searchSuggestResponse != null) {
            if (typeof object.searchSuggestResponse !== "object")
                throw TypeError(".Payload.searchSuggestResponse: object expected");
            message.searchSuggestResponse = $root.SearchSuggestResponse.fromObject(object.searchSuggestResponse);
        }
        if (object.consumePurchaseResponse != null) {
            if (typeof object.consumePurchaseResponse !== "object")
                throw TypeError(".Payload.consumePurchaseResponse: object expected");
            message.consumePurchaseResponse = $root.ConsumePurchaseResponse.fromObject(object.consumePurchaseResponse);
        }
        if (object.billingProfileResponse != null) {
            if (typeof object.billingProfileResponse !== "object")
                throw TypeError(".Payload.billingProfileResponse: object expected");
            message.billingProfileResponse = $root.BillingProfileResponse.fromObject(object.billingProfileResponse);
        }
        if (object.debugSettingsResponse != null) {
            if (typeof object.debugSettingsResponse !== "object")
                throw TypeError(".Payload.debugSettingsResponse: object expected");
            message.debugSettingsResponse = $root.DebugSettingsResponse.fromObject(object.debugSettingsResponse);
        }
        if (object.checkIabPromoResponse != null) {
            if (typeof object.checkIabPromoResponse !== "object")
                throw TypeError(".Payload.checkIabPromoResponse: object expected");
            message.checkIabPromoResponse = $root.CheckIabPromoResponse.fromObject(object.checkIabPromoResponse);
        }
        if (object.userActivitySettingsResponse != null) {
            if (typeof object.userActivitySettingsResponse !== "object")
                throw TypeError(".Payload.userActivitySettingsResponse: object expected");
            message.userActivitySettingsResponse = $root.UserActivitySettingsResponse.fromObject(object.userActivitySettingsResponse);
        }
        if (object.recordUserActivityResponse != null) {
            if (typeof object.recordUserActivityResponse !== "object")
                throw TypeError(".Payload.recordUserActivityResponse: object expected");
            message.recordUserActivityResponse = $root.RecordUserActivityResponse.fromObject(object.recordUserActivityResponse);
        }
        if (object.redeemCodeResponse != null) {
            if (typeof object.redeemCodeResponse !== "object")
                throw TypeError(".Payload.redeemCodeResponse: object expected");
            message.redeemCodeResponse = $root.RedeemCodeResponse.fromObject(object.redeemCodeResponse);
        }
        if (object.selfUpdateResponse != null) {
            if (typeof object.selfUpdateResponse !== "object")
                throw TypeError(".Payload.selfUpdateResponse: object expected");
            message.selfUpdateResponse = $root.SelfUpdateResponse.fromObject(object.selfUpdateResponse);
        }
        if (object.getInitialInstrumentFlowStateResponse != null) {
            if (typeof object.getInitialInstrumentFlowStateResponse !== "object")
                throw TypeError(".Payload.getInitialInstrumentFlowStateResponse: object expected");
            message.getInitialInstrumentFlowStateResponse = $root.GetInitialInstrumentFlowStateResponse.fromObject(object.getInitialInstrumentFlowStateResponse);
        }
        if (object.createInstrumentResponse != null) {
            if (typeof object.createInstrumentResponse !== "object")
                throw TypeError(".Payload.createInstrumentResponse: object expected");
            message.createInstrumentResponse = $root.CreateInstrumentResponse.fromObject(object.createInstrumentResponse);
        }
        if (object.challengeResponse != null) {
            if (typeof object.challengeResponse !== "object")
                throw TypeError(".Payload.challengeResponse: object expected");
            message.challengeResponse = $root.ChallengeResponse.fromObject(object.challengeResponse);
        }
        if (object.backupDeviceChoicesResponse != null) {
            if (typeof object.backupDeviceChoicesResponse !== "object")
                throw TypeError(".Payload.backupDeviceChoicesResponse: object expected");
            message.backupDeviceChoicesResponse = $root.BackDeviceChoicesResponse.fromObject(object.backupDeviceChoicesResponse);
        }
        if (object.backupDocumentChoicesResponse != null) {
            if (typeof object.backupDocumentChoicesResponse !== "object")
                throw TypeError(".Payload.backupDocumentChoicesResponse: object expected");
            message.backupDocumentChoicesResponse = $root.BackupDocumentChoicesResponse.fromObject(object.backupDocumentChoicesResponse);
        }
        if (object.earlyUpdateResponse != null) {
            if (typeof object.earlyUpdateResponse !== "object")
                throw TypeError(".Payload.earlyUpdateResponse: object expected");
            message.earlyUpdateResponse = $root.EarlyUpdateResponse.fromObject(object.earlyUpdateResponse);
        }
        if (object.preloadsResponse != null) {
            if (typeof object.preloadsResponse !== "object")
                throw TypeError(".Payload.preloadsResponse: object expected");
            message.preloadsResponse = $root.PreloadsResponse.fromObject(object.preloadsResponse);
        }
        if (object.myAccountsResponse != null) {
            if (typeof object.myAccountsResponse !== "object")
                throw TypeError(".Payload.myAccountsResponse: object expected");
            message.myAccountsResponse = $root.MyAccountsResponse.fromObject(object.myAccountsResponse);
        }
        if (object.contentFilterResponse != null) {
            if (typeof object.contentFilterResponse !== "object")
                throw TypeError(".Payload.contentFilterResponse: object expected");
            message.contentFilterResponse = $root.ContentFilterResponse.fromObject(object.contentFilterResponse);
        }
        if (object.experimentsResponse != null) {
            if (typeof object.experimentsResponse !== "object")
                throw TypeError(".Payload.experimentsResponse: object expected");
            message.experimentsResponse = $root.ExperimentsResponse.fromObject(object.experimentsResponse);
        }
        if (object.surveyResponse != null) {
            if (typeof object.surveyResponse !== "object")
                throw TypeError(".Payload.surveyResponse: object expected");
            message.surveyResponse = $root.SurveyResponse.fromObject(object.surveyResponse);
        }
        if (object.pingResponse != null) {
            if (typeof object.pingResponse !== "object")
                throw TypeError(".Payload.pingResponse: object expected");
            message.pingResponse = $root.PingResponse.fromObject(object.pingResponse);
        }
        if (object.updateUserSettingResponse != null) {
            if (typeof object.updateUserSettingResponse !== "object")
                throw TypeError(".Payload.updateUserSettingResponse: object expected");
            message.updateUserSettingResponse = $root.UpdateUserSettingResponse.fromObject(object.updateUserSettingResponse);
        }
        if (object.getUserSettingsResponse != null) {
            if (typeof object.getUserSettingsResponse !== "object")
                throw TypeError(".Payload.getUserSettingsResponse: object expected");
            message.getUserSettingsResponse = $root.GetUserSettingsResponse.fromObject(object.getUserSettingsResponse);
        }
        if (object.getSharingSettingsResponse != null) {
            if (typeof object.getSharingSettingsResponse !== "object")
                throw TypeError(".Payload.getSharingSettingsResponse: object expected");
            message.getSharingSettingsResponse = $root.GetSharingSettingsResponse.fromObject(object.getSharingSettingsResponse);
        }
        if (object.updateSharingSettingsResponse != null) {
            if (typeof object.updateSharingSettingsResponse !== "object")
                throw TypeError(".Payload.updateSharingSettingsResponse: object expected");
            message.updateSharingSettingsResponse = $root.UpdateSharingSettingsResponse.fromObject(object.updateSharingSettingsResponse);
        }
        if (object.reviewSnippetsResponse != null) {
            if (typeof object.reviewSnippetsResponse !== "object")
                throw TypeError(".Payload.reviewSnippetsResponse: object expected");
            message.reviewSnippetsResponse = $root.ReviewSnippetsResponse.fromObject(object.reviewSnippetsResponse);
        }
        if (object.documentSharingStateResponse != null) {
            if (typeof object.documentSharingStateResponse !== "object")
                throw TypeError(".Payload.documentSharingStateResponse: object expected");
            message.documentSharingStateResponse = $root.DocumentSharingStateResponse.fromObject(object.documentSharingStateResponse);
        }
        if (object.moduleDeliveryResponse != null) {
            if (typeof object.moduleDeliveryResponse !== "object")
                throw TypeError(".Payload.moduleDeliveryResponse: object expected");
            message.moduleDeliveryResponse = $root.ModuleDeliveryResponse.fromObject(object.moduleDeliveryResponse);
        }
        if (object.testingProgramResponse != null) {
            if (typeof object.testingProgramResponse !== "object")
                throw TypeError(".Payload.testingProgramResponse: object expected");
            message.testingProgramResponse = $root.TestingProgramResponse.fromObject(object.testingProgramResponse);
        }
        if (object.reviewSummaryResponse != null) {
            if (typeof object.reviewSummaryResponse !== "object")
                throw TypeError(".Payload.reviewSummaryResponse: object expected");
            message.reviewSummaryResponse = $root.ReviewResponse.fromObject(object.reviewSummaryResponse);
        }
        return message;
    };

    /**
     * Creates a plain object from a Payload message. Also converts values to other types if specified.
     * @function toObject
     * @memberof Payload
     * @static
     * @param {Payload} message Payload
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    Payload.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        var object = {};
        if (options.defaults) {
            object.listResponse = null;
            object.detailsResponse = null;
            object.reviewResponse = null;
            object.buyResponse = null;
            object.searchResponse = null;
            object.tocResponse = null;
            object.browseResponse = null;
            object.purchaseStatusResponse = null;
            object.logResponse = "";
            object.flagContentResponse = "";
            object.bulkDetailsResponse = null;
            object.deliveryResponse = null;
            object.acceptTosResponse = null;
            object.checkPromoOfferResponse = null;
            object.instrumentSetupInfoResponse = null;
            object.androidCheckinResponse = null;
            object.uploadDeviceConfigResponse = null;
            object.consumePurchaseResponse = null;
            object.billingProfileResponse = null;
            object.debugSettingsResponse = null;
            object.checkIabPromoResponse = null;
            object.userActivitySettingsResponse = null;
            object.recordUserActivityResponse = null;
            object.redeemCodeResponse = null;
            object.selfUpdateResponse = null;
            object.searchSuggestResponse = null;
            object.getInitialInstrumentFlowStateResponse = null;
            object.createInstrumentResponse = null;
            object.challengeResponse = null;
            object.backupDeviceChoicesResponse = null;
            object.backupDocumentChoicesResponse = null;
            object.earlyUpdateResponse = null;
            object.preloadsResponse = null;
            object.myAccountsResponse = null;
            object.contentFilterResponse = null;
            object.experimentsResponse = null;
            object.surveyResponse = null;
            object.pingResponse = null;
            object.updateUserSettingResponse = null;
            object.getUserSettingsResponse = null;
            object.getSharingSettingsResponse = null;
            object.updateSharingSettingsResponse = null;
            object.reviewSnippetsResponse = null;
            object.documentSharingStateResponse = null;
            object.moduleDeliveryResponse = null;
            object.testingProgramResponse = null;
            object.reviewSummaryResponse = null;
        }
        if (message.listResponse != null && message.hasOwnProperty("listResponse"))
            object.listResponse = $root.ListResponse.toObject(message.listResponse, options);
        if (message.detailsResponse != null && message.hasOwnProperty("detailsResponse"))
            object.detailsResponse = $root.DetailsResponse.toObject(message.detailsResponse, options);
        if (message.reviewResponse != null && message.hasOwnProperty("reviewResponse"))
            object.reviewResponse = $root.ReviewResponse.toObject(message.reviewResponse, options);
        if (message.buyResponse != null && message.hasOwnProperty("buyResponse"))
            object.buyResponse = $root.BuyResponse.toObject(message.buyResponse, options);
        if (message.searchResponse != null && message.hasOwnProperty("searchResponse"))
            object.searchResponse = $root.SearchResponse.toObject(message.searchResponse, options);
        if (message.tocResponse != null && message.hasOwnProperty("tocResponse"))
            object.tocResponse = $root.TocResponse.toObject(message.tocResponse, options);
        if (message.browseResponse != null && message.hasOwnProperty("browseResponse"))
            object.browseResponse = $root.BrowseResponse.toObject(message.browseResponse, options);
        if (message.purchaseStatusResponse != null && message.hasOwnProperty("purchaseStatusResponse"))
            object.purchaseStatusResponse = $root.PurchaseStatusResponse.toObject(message.purchaseStatusResponse, options);
        if (message.logResponse != null && message.hasOwnProperty("logResponse"))
            object.logResponse = message.logResponse;
        if (message.flagContentResponse != null && message.hasOwnProperty("flagContentResponse"))
            object.flagContentResponse = message.flagContentResponse;
        if (message.bulkDetailsResponse != null && message.hasOwnProperty("bulkDetailsResponse"))
            object.bulkDetailsResponse = $root.BulkDetailsResponse.toObject(message.bulkDetailsResponse, options);
        if (message.deliveryResponse != null && message.hasOwnProperty("deliveryResponse"))
            object.deliveryResponse = $root.DeliveryResponse.toObject(message.deliveryResponse, options);
        if (message.acceptTosResponse != null && message.hasOwnProperty("acceptTosResponse"))
            object.acceptTosResponse = $root.AcceptTosResponse.toObject(message.acceptTosResponse, options);
        if (message.checkPromoOfferResponse != null && message.hasOwnProperty("checkPromoOfferResponse"))
            object.checkPromoOfferResponse = $root.CheckPromoOfferResponse.toObject(message.checkPromoOfferResponse, options);
        if (message.instrumentSetupInfoResponse != null && message.hasOwnProperty("instrumentSetupInfoResponse"))
            object.instrumentSetupInfoResponse = $root.InstrumentSetupInfoResponse.toObject(message.instrumentSetupInfoResponse, options);
        if (message.androidCheckinResponse != null && message.hasOwnProperty("androidCheckinResponse"))
            object.androidCheckinResponse = $root.AndroidCheckinResponse.toObject(message.androidCheckinResponse, options);
        if (message.uploadDeviceConfigResponse != null && message.hasOwnProperty("uploadDeviceConfigResponse"))
            object.uploadDeviceConfigResponse = $root.UploadDeviceConfigResponse.toObject(message.uploadDeviceConfigResponse, options);
        if (message.consumePurchaseResponse != null && message.hasOwnProperty("consumePurchaseResponse"))
            object.consumePurchaseResponse = $root.ConsumePurchaseResponse.toObject(message.consumePurchaseResponse, options);
        if (message.billingProfileResponse != null && message.hasOwnProperty("billingProfileResponse"))
            object.billingProfileResponse = $root.BillingProfileResponse.toObject(message.billingProfileResponse, options);
        if (message.debugSettingsResponse != null && message.hasOwnProperty("debugSettingsResponse"))
            object.debugSettingsResponse = $root.DebugSettingsResponse.toObject(message.debugSettingsResponse, options);
        if (message.checkIabPromoResponse != null && message.hasOwnProperty("checkIabPromoResponse"))
            object.checkIabPromoResponse = $root.CheckIabPromoResponse.toObject(message.checkIabPromoResponse, options);
        if (message.userActivitySettingsResponse != null && message.hasOwnProperty("userActivitySettingsResponse"))
            object.userActivitySettingsResponse = $root.UserActivitySettingsResponse.toObject(message.userActivitySettingsResponse, options);
        if (message.recordUserActivityResponse != null && message.hasOwnProperty("recordUserActivityResponse"))
            object.recordUserActivityResponse = $root.RecordUserActivityResponse.toObject(message.recordUserActivityResponse, options);
        if (message.redeemCodeResponse != null && message.hasOwnProperty("redeemCodeResponse"))
            object.redeemCodeResponse = $root.RedeemCodeResponse.toObject(message.redeemCodeResponse, options);
        if (message.selfUpdateResponse != null && message.hasOwnProperty("selfUpdateResponse"))
            object.selfUpdateResponse = $root.SelfUpdateResponse.toObject(message.selfUpdateResponse, options);
        if (message.searchSuggestResponse != null && message.hasOwnProperty("searchSuggestResponse"))
            object.searchSuggestResponse = $root.SearchSuggestResponse.toObject(message.searchSuggestResponse, options);
        if (message.getInitialInstrumentFlowStateResponse != null && message.hasOwnProperty("getInitialInstrumentFlowStateResponse"))
            object.getInitialInstrumentFlowStateResponse = $root.GetInitialInstrumentFlowStateResponse.toObject(message.getInitialInstrumentFlowStateResponse, options);
        if (message.createInstrumentResponse != null && message.hasOwnProperty("createInstrumentResponse"))
            object.createInstrumentResponse = $root.CreateInstrumentResponse.toObject(message.createInstrumentResponse, options);
        if (message.challengeResponse != null && message.hasOwnProperty("challengeResponse"))
            object.challengeResponse = $root.ChallengeResponse.toObject(message.challengeResponse, options);
        if (message.backupDeviceChoicesResponse != null && message.hasOwnProperty("backupDeviceChoicesResponse"))
            object.backupDeviceChoicesResponse = $root.BackDeviceChoicesResponse.toObject(message.backupDeviceChoicesResponse, options);
        if (message.backupDocumentChoicesResponse != null && message.hasOwnProperty("backupDocumentChoicesResponse"))
            object.backupDocumentChoicesResponse = $root.BackupDocumentChoicesResponse.toObject(message.backupDocumentChoicesResponse, options);
        if (message.earlyUpdateResponse != null && message.hasOwnProperty("earlyUpdateResponse"))
            object.earlyUpdateResponse = $root.EarlyUpdateResponse.toObject(message.earlyUpdateResponse, options);
        if (message.preloadsResponse != null && message.hasOwnProperty("preloadsResponse"))
            object.preloadsResponse = $root.PreloadsResponse.toObject(message.preloadsResponse, options);
        if (message.myAccountsResponse != null && message.hasOwnProperty("myAccountsResponse"))
            object.myAccountsResponse = $root.MyAccountsResponse.toObject(message.myAccountsResponse, options);
        if (message.contentFilterResponse != null && message.hasOwnProperty("contentFilterResponse"))
            object.contentFilterResponse = $root.ContentFilterResponse.toObject(message.contentFilterResponse, options);
        if (message.experimentsResponse != null && message.hasOwnProperty("experimentsResponse"))
            object.experimentsResponse = $root.ExperimentsResponse.toObject(message.experimentsResponse, options);
        if (message.surveyResponse != null && message.hasOwnProperty("surveyResponse"))
            object.surveyResponse = $root.SurveyResponse.toObject(message.surveyResponse, options);
        if (message.pingResponse != null && message.hasOwnProperty("pingResponse"))
            object.pingResponse = $root.PingResponse.toObject(message.pingResponse, options);
        if (message.updateUserSettingResponse != null && message.hasOwnProperty("updateUserSettingResponse"))
            object.updateUserSettingResponse = $root.UpdateUserSettingResponse.toObject(message.updateUserSettingResponse, options);
        if (message.getUserSettingsResponse != null && message.hasOwnProperty("getUserSettingsResponse"))
            object.getUserSettingsResponse = $root.GetUserSettingsResponse.toObject(message.getUserSettingsResponse, options);
        if (message.getSharingSettingsResponse != null && message.hasOwnProperty("getSharingSettingsResponse"))
            object.getSharingSettingsResponse = $root.GetSharingSettingsResponse.toObject(message.getSharingSettingsResponse, options);
        if (message.updateSharingSettingsResponse != null && message.hasOwnProperty("updateSharingSettingsResponse"))
            object.updateSharingSettingsResponse = $root.UpdateSharingSettingsResponse.toObject(message.updateSharingSettingsResponse, options);
        if (message.reviewSnippetsResponse != null && message.hasOwnProperty("reviewSnippetsResponse"))
            object.reviewSnippetsResponse = $root.ReviewSnippetsResponse.toObject(message.reviewSnippetsResponse, options);
        if (message.documentSharingStateResponse != null && message.hasOwnProperty("documentSharingStateResponse"))
            object.documentSharingStateResponse = $root.DocumentSharingStateResponse.toObject(message.documentSharingStateResponse, options);
        if (message.moduleDeliveryResponse != null && message.hasOwnProperty("moduleDeliveryResponse"))
            object.moduleDeliveryResponse = $root.ModuleDeliveryResponse.toObject(message.moduleDeliveryResponse, options);
        if (message.testingProgramResponse != null && message.hasOwnProperty("testingProgramResponse"))
            object.testingProgramResponse = $root.TestingProgramResponse.toObject(message.testingProgramResponse, options);
        if (message.reviewSummaryResponse != null && message.hasOwnProperty("reviewSummaryResponse"))
            object.reviewSummaryResponse = $root.ReviewResponse.toObject(message.reviewSummaryResponse, options);
        return object;
    };

    /**
     * Converts this Payload to JSON.
     * @function toJSON
     * @memberof Payload
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    Payload.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return Payload;
})();

$root.CheckIabPromoResponse = (function() {

    /**
     * Properties of a CheckIabPromoResponse.
     * @exports ICheckIabPromoResponse
     * @interface ICheckIabPromoResponse
     */

    /**
     * Constructs a new CheckIabPromoResponse.
     * @exports CheckIabPromoResponse
     * @classdesc Represents a CheckIabPromoResponse.
     * @implements ICheckIabPromoResponse
     * @constructor
     * @param {ICheckIabPromoResponse=} [properties] Properties to set
     */
    function CheckIabPromoResponse(properties) {
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * Creates a new CheckIabPromoResponse instance using the specified properties.
     * @function create
     * @memberof CheckIabPromoResponse
     * @static
     * @param {ICheckIabPromoResponse=} [properties] Properties to set
     * @returns {CheckIabPromoResponse} CheckIabPromoResponse instance
     */
    CheckIabPromoResponse.create = function create(properties) {
        return new CheckIabPromoResponse(properties);
    };

    /**
     * Encodes the specified CheckIabPromoResponse message. Does not implicitly {@link CheckIabPromoResponse.verify|verify} messages.
     * @function encode
     * @memberof CheckIabPromoResponse
     * @static
     * @param {ICheckIabPromoResponse} message CheckIabPromoResponse message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    CheckIabPromoResponse.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        return writer;
    };

    /**
     * Encodes the specified CheckIabPromoResponse message, length delimited. Does not implicitly {@link CheckIabPromoResponse.verify|verify} messages.
     * @function encodeDelimited
     * @memberof CheckIabPromoResponse
     * @static
     * @param {ICheckIabPromoResponse} message CheckIabPromoResponse message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    CheckIabPromoResponse.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a CheckIabPromoResponse message from the specified reader or buffer.
     * @function decode
     * @memberof CheckIabPromoResponse
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CheckIabPromoResponse} CheckIabPromoResponse
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CheckIabPromoResponse.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CheckIabPromoResponse();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a CheckIabPromoResponse message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof CheckIabPromoResponse
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {CheckIabPromoResponse} CheckIabPromoResponse
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CheckIabPromoResponse.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a CheckIabPromoResponse message.
     * @function verify
     * @memberof CheckIabPromoResponse
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    CheckIabPromoResponse.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        return null;
    };

    /**
     * Creates a CheckIabPromoResponse message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof CheckIabPromoResponse
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {CheckIabPromoResponse} CheckIabPromoResponse
     */
    CheckIabPromoResponse.fromObject = function fromObject(object) {
        if (object instanceof $root.CheckIabPromoResponse)
            return object;
        return new $root.CheckIabPromoResponse();
    };

    /**
     * Creates a plain object from a CheckIabPromoResponse message. Also converts values to other types if specified.
     * @function toObject
     * @memberof CheckIabPromoResponse
     * @static
     * @param {CheckIabPromoResponse} message CheckIabPromoResponse
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    CheckIabPromoResponse.toObject = function toObject() {
        return {};
    };

    /**
     * Converts this CheckIabPromoResponse to JSON.
     * @function toJSON
     * @memberof CheckIabPromoResponse
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    CheckIabPromoResponse.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return CheckIabPromoResponse;
})();

$root.UserActivitySettingsResponse = (function() {

    /**
     * Properties of a UserActivitySettingsResponse.
     * @exports IUserActivitySettingsResponse
     * @interface IUserActivitySettingsResponse
     */

    /**
     * Constructs a new UserActivitySettingsResponse.
     * @exports UserActivitySettingsResponse
     * @classdesc Represents a UserActivitySettingsResponse.
     * @implements IUserActivitySettingsResponse
     * @constructor
     * @param {IUserActivitySettingsResponse=} [properties] Properties to set
     */
    function UserActivitySettingsResponse(properties) {
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * Creates a new UserActivitySettingsResponse instance using the specified properties.
     * @function create
     * @memberof UserActivitySettingsResponse
     * @static
     * @param {IUserActivitySettingsResponse=} [properties] Properties to set
     * @returns {UserActivitySettingsResponse} UserActivitySettingsResponse instance
     */
    UserActivitySettingsResponse.create = function create(properties) {
        return new UserActivitySettingsResponse(properties);
    };

    /**
     * Encodes the specified UserActivitySettingsResponse message. Does not implicitly {@link UserActivitySettingsResponse.verify|verify} messages.
     * @function encode
     * @memberof UserActivitySettingsResponse
     * @static
     * @param {IUserActivitySettingsResponse} message UserActivitySettingsResponse message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    UserActivitySettingsResponse.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        return writer;
    };

    /**
     * Encodes the specified UserActivitySettingsResponse message, length delimited. Does not implicitly {@link UserActivitySettingsResponse.verify|verify} messages.
     * @function encodeDelimited
     * @memberof UserActivitySettingsResponse
     * @static
     * @param {IUserActivitySettingsResponse} message UserActivitySettingsResponse message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    UserActivitySettingsResponse.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a UserActivitySettingsResponse message from the specified reader or buffer.
     * @function decode
     * @memberof UserActivitySettingsResponse
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {UserActivitySettingsResponse} UserActivitySettingsResponse
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    UserActivitySettingsResponse.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.UserActivitySettingsResponse();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a UserActivitySettingsResponse message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof UserActivitySettingsResponse
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {UserActivitySettingsResponse} UserActivitySettingsResponse
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    UserActivitySettingsResponse.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a UserActivitySettingsResponse message.
     * @function verify
     * @memberof UserActivitySettingsResponse
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    UserActivitySettingsResponse.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        return null;
    };

    /**
     * Creates a UserActivitySettingsResponse message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof UserActivitySettingsResponse
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {UserActivitySettingsResponse} UserActivitySettingsResponse
     */
    UserActivitySettingsResponse.fromObject = function fromObject(object) {
        if (object instanceof $root.UserActivitySettingsResponse)
            return object;
        return new $root.UserActivitySettingsResponse();
    };

    /**
     * Creates a plain object from a UserActivitySettingsResponse message. Also converts values to other types if specified.
     * @function toObject
     * @memberof UserActivitySettingsResponse
     * @static
     * @param {UserActivitySettingsResponse} message UserActivitySettingsResponse
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    UserActivitySettingsResponse.toObject = function toObject() {
        return {};
    };

    /**
     * Converts this UserActivitySettingsResponse to JSON.
     * @function toJSON
     * @memberof UserActivitySettingsResponse
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    UserActivitySettingsResponse.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return UserActivitySettingsResponse;
})();

$root.RecordUserActivityResponse = (function() {

    /**
     * Properties of a RecordUserActivityResponse.
     * @exports IRecordUserActivityResponse
     * @interface IRecordUserActivityResponse
     */

    /**
     * Constructs a new RecordUserActivityResponse.
     * @exports RecordUserActivityResponse
     * @classdesc Represents a RecordUserActivityResponse.
     * @implements IRecordUserActivityResponse
     * @constructor
     * @param {IRecordUserActivityResponse=} [properties] Properties to set
     */
    function RecordUserActivityResponse(properties) {
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * Creates a new RecordUserActivityResponse instance using the specified properties.
     * @function create
     * @memberof RecordUserActivityResponse
     * @static
     * @param {IRecordUserActivityResponse=} [properties] Properties to set
     * @returns {RecordUserActivityResponse} RecordUserActivityResponse instance
     */
    RecordUserActivityResponse.create = function create(properties) {
        return new RecordUserActivityResponse(properties);
    };

    /**
     * Encodes the specified RecordUserActivityResponse message. Does not implicitly {@link RecordUserActivityResponse.verify|verify} messages.
     * @function encode
     * @memberof RecordUserActivityResponse
     * @static
     * @param {IRecordUserActivityResponse} message RecordUserActivityResponse message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    RecordUserActivityResponse.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        return writer;
    };

    /**
     * Encodes the specified RecordUserActivityResponse message, length delimited. Does not implicitly {@link RecordUserActivityResponse.verify|verify} messages.
     * @function encodeDelimited
     * @memberof RecordUserActivityResponse
     * @static
     * @param {IRecordUserActivityResponse} message RecordUserActivityResponse message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    RecordUserActivityResponse.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a RecordUserActivityResponse message from the specified reader or buffer.
     * @function decode
     * @memberof RecordUserActivityResponse
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {RecordUserActivityResponse} RecordUserActivityResponse
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    RecordUserActivityResponse.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.RecordUserActivityResponse();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a RecordUserActivityResponse message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof RecordUserActivityResponse
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {RecordUserActivityResponse} RecordUserActivityResponse
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    RecordUserActivityResponse.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a RecordUserActivityResponse message.
     * @function verify
     * @memberof RecordUserActivityResponse
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    RecordUserActivityResponse.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        return null;
    };

    /**
     * Creates a RecordUserActivityResponse message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof RecordUserActivityResponse
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {RecordUserActivityResponse} RecordUserActivityResponse
     */
    RecordUserActivityResponse.fromObject = function fromObject(object) {
        if (object instanceof $root.RecordUserActivityResponse)
            return object;
        return new $root.RecordUserActivityResponse();
    };

    /**
     * Creates a plain object from a RecordUserActivityResponse message. Also converts values to other types if specified.
     * @function toObject
     * @memberof RecordUserActivityResponse
     * @static
     * @param {RecordUserActivityResponse} message RecordUserActivityResponse
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    RecordUserActivityResponse.toObject = function toObject() {
        return {};
    };

    /**
     * Converts this RecordUserActivityResponse to JSON.
     * @function toJSON
     * @memberof RecordUserActivityResponse
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    RecordUserActivityResponse.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return RecordUserActivityResponse;
})();

$root.RedeemCodeResponse = (function() {

    /**
     * Properties of a RedeemCodeResponse.
     * @exports IRedeemCodeResponse
     * @interface IRedeemCodeResponse
     */

    /**
     * Constructs a new RedeemCodeResponse.
     * @exports RedeemCodeResponse
     * @classdesc Represents a RedeemCodeResponse.
     * @implements IRedeemCodeResponse
     * @constructor
     * @param {IRedeemCodeResponse=} [properties] Properties to set
     */
    function RedeemCodeResponse(properties) {
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * Creates a new RedeemCodeResponse instance using the specified properties.
     * @function create
     * @memberof RedeemCodeResponse
     * @static
     * @param {IRedeemCodeResponse=} [properties] Properties to set
     * @returns {RedeemCodeResponse} RedeemCodeResponse instance
     */
    RedeemCodeResponse.create = function create(properties) {
        return new RedeemCodeResponse(properties);
    };

    /**
     * Encodes the specified RedeemCodeResponse message. Does not implicitly {@link RedeemCodeResponse.verify|verify} messages.
     * @function encode
     * @memberof RedeemCodeResponse
     * @static
     * @param {IRedeemCodeResponse} message RedeemCodeResponse message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    RedeemCodeResponse.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        return writer;
    };

    /**
     * Encodes the specified RedeemCodeResponse message, length delimited. Does not implicitly {@link RedeemCodeResponse.verify|verify} messages.
     * @function encodeDelimited
     * @memberof RedeemCodeResponse
     * @static
     * @param {IRedeemCodeResponse} message RedeemCodeResponse message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    RedeemCodeResponse.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a RedeemCodeResponse message from the specified reader or buffer.
     * @function decode
     * @memberof RedeemCodeResponse
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {RedeemCodeResponse} RedeemCodeResponse
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    RedeemCodeResponse.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.RedeemCodeResponse();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a RedeemCodeResponse message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof RedeemCodeResponse
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {RedeemCodeResponse} RedeemCodeResponse
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    RedeemCodeResponse.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a RedeemCodeResponse message.
     * @function verify
     * @memberof RedeemCodeResponse
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    RedeemCodeResponse.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        return null;
    };

    /**
     * Creates a RedeemCodeResponse message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof RedeemCodeResponse
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {RedeemCodeResponse} RedeemCodeResponse
     */
    RedeemCodeResponse.fromObject = function fromObject(object) {
        if (object instanceof $root.RedeemCodeResponse)
            return object;
        return new $root.RedeemCodeResponse();
    };

    /**
     * Creates a plain object from a RedeemCodeResponse message. Also converts values to other types if specified.
     * @function toObject
     * @memberof RedeemCodeResponse
     * @static
     * @param {RedeemCodeResponse} message RedeemCodeResponse
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    RedeemCodeResponse.toObject = function toObject() {
        return {};
    };

    /**
     * Converts this RedeemCodeResponse to JSON.
     * @function toJSON
     * @memberof RedeemCodeResponse
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    RedeemCodeResponse.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return RedeemCodeResponse;
})();

$root.SelfUpdateResponse = (function() {

    /**
     * Properties of a SelfUpdateResponse.
     * @exports ISelfUpdateResponse
     * @interface ISelfUpdateResponse
     */

    /**
     * Constructs a new SelfUpdateResponse.
     * @exports SelfUpdateResponse
     * @classdesc Represents a SelfUpdateResponse.
     * @implements ISelfUpdateResponse
     * @constructor
     * @param {ISelfUpdateResponse=} [properties] Properties to set
     */
    function SelfUpdateResponse(properties) {
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * Creates a new SelfUpdateResponse instance using the specified properties.
     * @function create
     * @memberof SelfUpdateResponse
     * @static
     * @param {ISelfUpdateResponse=} [properties] Properties to set
     * @returns {SelfUpdateResponse} SelfUpdateResponse instance
     */
    SelfUpdateResponse.create = function create(properties) {
        return new SelfUpdateResponse(properties);
    };

    /**
     * Encodes the specified SelfUpdateResponse message. Does not implicitly {@link SelfUpdateResponse.verify|verify} messages.
     * @function encode
     * @memberof SelfUpdateResponse
     * @static
     * @param {ISelfUpdateResponse} message SelfUpdateResponse message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    SelfUpdateResponse.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        return writer;
    };

    /**
     * Encodes the specified SelfUpdateResponse message, length delimited. Does not implicitly {@link SelfUpdateResponse.verify|verify} messages.
     * @function encodeDelimited
     * @memberof SelfUpdateResponse
     * @static
     * @param {ISelfUpdateResponse} message SelfUpdateResponse message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    SelfUpdateResponse.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a SelfUpdateResponse message from the specified reader or buffer.
     * @function decode
     * @memberof SelfUpdateResponse
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {SelfUpdateResponse} SelfUpdateResponse
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    SelfUpdateResponse.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.SelfUpdateResponse();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a SelfUpdateResponse message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof SelfUpdateResponse
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {SelfUpdateResponse} SelfUpdateResponse
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    SelfUpdateResponse.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a SelfUpdateResponse message.
     * @function verify
     * @memberof SelfUpdateResponse
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    SelfUpdateResponse.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        return null;
    };

    /**
     * Creates a SelfUpdateResponse message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof SelfUpdateResponse
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {SelfUpdateResponse} SelfUpdateResponse
     */
    SelfUpdateResponse.fromObject = function fromObject(object) {
        if (object instanceof $root.SelfUpdateResponse)
            return object;
        return new $root.SelfUpdateResponse();
    };

    /**
     * Creates a plain object from a SelfUpdateResponse message. Also converts values to other types if specified.
     * @function toObject
     * @memberof SelfUpdateResponse
     * @static
     * @param {SelfUpdateResponse} message SelfUpdateResponse
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    SelfUpdateResponse.toObject = function toObject() {
        return {};
    };

    /**
     * Converts this SelfUpdateResponse to JSON.
     * @function toJSON
     * @memberof SelfUpdateResponse
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    SelfUpdateResponse.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return SelfUpdateResponse;
})();

$root.GetInitialInstrumentFlowStateResponse = (function() {

    /**
     * Properties of a GetInitialInstrumentFlowStateResponse.
     * @exports IGetInitialInstrumentFlowStateResponse
     * @interface IGetInitialInstrumentFlowStateResponse
     */

    /**
     * Constructs a new GetInitialInstrumentFlowStateResponse.
     * @exports GetInitialInstrumentFlowStateResponse
     * @classdesc Represents a GetInitialInstrumentFlowStateResponse.
     * @implements IGetInitialInstrumentFlowStateResponse
     * @constructor
     * @param {IGetInitialInstrumentFlowStateResponse=} [properties] Properties to set
     */
    function GetInitialInstrumentFlowStateResponse(properties) {
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * Creates a new GetInitialInstrumentFlowStateResponse instance using the specified properties.
     * @function create
     * @memberof GetInitialInstrumentFlowStateResponse
     * @static
     * @param {IGetInitialInstrumentFlowStateResponse=} [properties] Properties to set
     * @returns {GetInitialInstrumentFlowStateResponse} GetInitialInstrumentFlowStateResponse instance
     */
    GetInitialInstrumentFlowStateResponse.create = function create(properties) {
        return new GetInitialInstrumentFlowStateResponse(properties);
    };

    /**
     * Encodes the specified GetInitialInstrumentFlowStateResponse message. Does not implicitly {@link GetInitialInstrumentFlowStateResponse.verify|verify} messages.
     * @function encode
     * @memberof GetInitialInstrumentFlowStateResponse
     * @static
     * @param {IGetInitialInstrumentFlowStateResponse} message GetInitialInstrumentFlowStateResponse message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    GetInitialInstrumentFlowStateResponse.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        return writer;
    };

    /**
     * Encodes the specified GetInitialInstrumentFlowStateResponse message, length delimited. Does not implicitly {@link GetInitialInstrumentFlowStateResponse.verify|verify} messages.
     * @function encodeDelimited
     * @memberof GetInitialInstrumentFlowStateResponse
     * @static
     * @param {IGetInitialInstrumentFlowStateResponse} message GetInitialInstrumentFlowStateResponse message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    GetInitialInstrumentFlowStateResponse.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a GetInitialInstrumentFlowStateResponse message from the specified reader or buffer.
     * @function decode
     * @memberof GetInitialInstrumentFlowStateResponse
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {GetInitialInstrumentFlowStateResponse} GetInitialInstrumentFlowStateResponse
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    GetInitialInstrumentFlowStateResponse.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.GetInitialInstrumentFlowStateResponse();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a GetInitialInstrumentFlowStateResponse message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof GetInitialInstrumentFlowStateResponse
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {GetInitialInstrumentFlowStateResponse} GetInitialInstrumentFlowStateResponse
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    GetInitialInstrumentFlowStateResponse.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a GetInitialInstrumentFlowStateResponse message.
     * @function verify
     * @memberof GetInitialInstrumentFlowStateResponse
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    GetInitialInstrumentFlowStateResponse.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        return null;
    };

    /**
     * Creates a GetInitialInstrumentFlowStateResponse message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof GetInitialInstrumentFlowStateResponse
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {GetInitialInstrumentFlowStateResponse} GetInitialInstrumentFlowStateResponse
     */
    GetInitialInstrumentFlowStateResponse.fromObject = function fromObject(object) {
        if (object instanceof $root.GetInitialInstrumentFlowStateResponse)
            return object;
        return new $root.GetInitialInstrumentFlowStateResponse();
    };

    /**
     * Creates a plain object from a GetInitialInstrumentFlowStateResponse message. Also converts values to other types if specified.
     * @function toObject
     * @memberof GetInitialInstrumentFlowStateResponse
     * @static
     * @param {GetInitialInstrumentFlowStateResponse} message GetInitialInstrumentFlowStateResponse
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    GetInitialInstrumentFlowStateResponse.toObject = function toObject() {
        return {};
    };

    /**
     * Converts this GetInitialInstrumentFlowStateResponse to JSON.
     * @function toJSON
     * @memberof GetInitialInstrumentFlowStateResponse
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    GetInitialInstrumentFlowStateResponse.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return GetInitialInstrumentFlowStateResponse;
})();

$root.CreateInstrumentResponse = (function() {

    /**
     * Properties of a CreateInstrumentResponse.
     * @exports ICreateInstrumentResponse
     * @interface ICreateInstrumentResponse
     */

    /**
     * Constructs a new CreateInstrumentResponse.
     * @exports CreateInstrumentResponse
     * @classdesc Represents a CreateInstrumentResponse.
     * @implements ICreateInstrumentResponse
     * @constructor
     * @param {ICreateInstrumentResponse=} [properties] Properties to set
     */
    function CreateInstrumentResponse(properties) {
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * Creates a new CreateInstrumentResponse instance using the specified properties.
     * @function create
     * @memberof CreateInstrumentResponse
     * @static
     * @param {ICreateInstrumentResponse=} [properties] Properties to set
     * @returns {CreateInstrumentResponse} CreateInstrumentResponse instance
     */
    CreateInstrumentResponse.create = function create(properties) {
        return new CreateInstrumentResponse(properties);
    };

    /**
     * Encodes the specified CreateInstrumentResponse message. Does not implicitly {@link CreateInstrumentResponse.verify|verify} messages.
     * @function encode
     * @memberof CreateInstrumentResponse
     * @static
     * @param {ICreateInstrumentResponse} message CreateInstrumentResponse message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    CreateInstrumentResponse.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        return writer;
    };

    /**
     * Encodes the specified CreateInstrumentResponse message, length delimited. Does not implicitly {@link CreateInstrumentResponse.verify|verify} messages.
     * @function encodeDelimited
     * @memberof CreateInstrumentResponse
     * @static
     * @param {ICreateInstrumentResponse} message CreateInstrumentResponse message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    CreateInstrumentResponse.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a CreateInstrumentResponse message from the specified reader or buffer.
     * @function decode
     * @memberof CreateInstrumentResponse
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CreateInstrumentResponse} CreateInstrumentResponse
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CreateInstrumentResponse.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CreateInstrumentResponse();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a CreateInstrumentResponse message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof CreateInstrumentResponse
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {CreateInstrumentResponse} CreateInstrumentResponse
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CreateInstrumentResponse.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a CreateInstrumentResponse message.
     * @function verify
     * @memberof CreateInstrumentResponse
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    CreateInstrumentResponse.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        return null;
    };

    /**
     * Creates a CreateInstrumentResponse message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof CreateInstrumentResponse
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {CreateInstrumentResponse} CreateInstrumentResponse
     */
    CreateInstrumentResponse.fromObject = function fromObject(object) {
        if (object instanceof $root.CreateInstrumentResponse)
            return object;
        return new $root.CreateInstrumentResponse();
    };

    /**
     * Creates a plain object from a CreateInstrumentResponse message. Also converts values to other types if specified.
     * @function toObject
     * @memberof CreateInstrumentResponse
     * @static
     * @param {CreateInstrumentResponse} message CreateInstrumentResponse
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    CreateInstrumentResponse.toObject = function toObject() {
        return {};
    };

    /**
     * Converts this CreateInstrumentResponse to JSON.
     * @function toJSON
     * @memberof CreateInstrumentResponse
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    CreateInstrumentResponse.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return CreateInstrumentResponse;
})();

$root.ChallengeResponse = (function() {

    /**
     * Properties of a ChallengeResponse.
     * @exports IChallengeResponse
     * @interface IChallengeResponse
     */

    /**
     * Constructs a new ChallengeResponse.
     * @exports ChallengeResponse
     * @classdesc Represents a ChallengeResponse.
     * @implements IChallengeResponse
     * @constructor
     * @param {IChallengeResponse=} [properties] Properties to set
     */
    function ChallengeResponse(properties) {
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * Creates a new ChallengeResponse instance using the specified properties.
     * @function create
     * @memberof ChallengeResponse
     * @static
     * @param {IChallengeResponse=} [properties] Properties to set
     * @returns {ChallengeResponse} ChallengeResponse instance
     */
    ChallengeResponse.create = function create(properties) {
        return new ChallengeResponse(properties);
    };

    /**
     * Encodes the specified ChallengeResponse message. Does not implicitly {@link ChallengeResponse.verify|verify} messages.
     * @function encode
     * @memberof ChallengeResponse
     * @static
     * @param {IChallengeResponse} message ChallengeResponse message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    ChallengeResponse.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        return writer;
    };

    /**
     * Encodes the specified ChallengeResponse message, length delimited. Does not implicitly {@link ChallengeResponse.verify|verify} messages.
     * @function encodeDelimited
     * @memberof ChallengeResponse
     * @static
     * @param {IChallengeResponse} message ChallengeResponse message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    ChallengeResponse.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a ChallengeResponse message from the specified reader or buffer.
     * @function decode
     * @memberof ChallengeResponse
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {ChallengeResponse} ChallengeResponse
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    ChallengeResponse.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ChallengeResponse();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a ChallengeResponse message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof ChallengeResponse
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {ChallengeResponse} ChallengeResponse
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    ChallengeResponse.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a ChallengeResponse message.
     * @function verify
     * @memberof ChallengeResponse
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    ChallengeResponse.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        return null;
    };

    /**
     * Creates a ChallengeResponse message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof ChallengeResponse
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {ChallengeResponse} ChallengeResponse
     */
    ChallengeResponse.fromObject = function fromObject(object) {
        if (object instanceof $root.ChallengeResponse)
            return object;
        return new $root.ChallengeResponse();
    };

    /**
     * Creates a plain object from a ChallengeResponse message. Also converts values to other types if specified.
     * @function toObject
     * @memberof ChallengeResponse
     * @static
     * @param {ChallengeResponse} message ChallengeResponse
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    ChallengeResponse.toObject = function toObject() {
        return {};
    };

    /**
     * Converts this ChallengeResponse to JSON.
     * @function toJSON
     * @memberof ChallengeResponse
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    ChallengeResponse.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return ChallengeResponse;
})();

$root.BackDeviceChoicesResponse = (function() {

    /**
     * Properties of a BackDeviceChoicesResponse.
     * @exports IBackDeviceChoicesResponse
     * @interface IBackDeviceChoicesResponse
     */

    /**
     * Constructs a new BackDeviceChoicesResponse.
     * @exports BackDeviceChoicesResponse
     * @classdesc Represents a BackDeviceChoicesResponse.
     * @implements IBackDeviceChoicesResponse
     * @constructor
     * @param {IBackDeviceChoicesResponse=} [properties] Properties to set
     */
    function BackDeviceChoicesResponse(properties) {
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * Creates a new BackDeviceChoicesResponse instance using the specified properties.
     * @function create
     * @memberof BackDeviceChoicesResponse
     * @static
     * @param {IBackDeviceChoicesResponse=} [properties] Properties to set
     * @returns {BackDeviceChoicesResponse} BackDeviceChoicesResponse instance
     */
    BackDeviceChoicesResponse.create = function create(properties) {
        return new BackDeviceChoicesResponse(properties);
    };

    /**
     * Encodes the specified BackDeviceChoicesResponse message. Does not implicitly {@link BackDeviceChoicesResponse.verify|verify} messages.
     * @function encode
     * @memberof BackDeviceChoicesResponse
     * @static
     * @param {IBackDeviceChoicesResponse} message BackDeviceChoicesResponse message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    BackDeviceChoicesResponse.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        return writer;
    };

    /**
     * Encodes the specified BackDeviceChoicesResponse message, length delimited. Does not implicitly {@link BackDeviceChoicesResponse.verify|verify} messages.
     * @function encodeDelimited
     * @memberof BackDeviceChoicesResponse
     * @static
     * @param {IBackDeviceChoicesResponse} message BackDeviceChoicesResponse message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    BackDeviceChoicesResponse.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a BackDeviceChoicesResponse message from the specified reader or buffer.
     * @function decode
     * @memberof BackDeviceChoicesResponse
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {BackDeviceChoicesResponse} BackDeviceChoicesResponse
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    BackDeviceChoicesResponse.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.BackDeviceChoicesResponse();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a BackDeviceChoicesResponse message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof BackDeviceChoicesResponse
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {BackDeviceChoicesResponse} BackDeviceChoicesResponse
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    BackDeviceChoicesResponse.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a BackDeviceChoicesResponse message.
     * @function verify
     * @memberof BackDeviceChoicesResponse
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    BackDeviceChoicesResponse.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        return null;
    };

    /**
     * Creates a BackDeviceChoicesResponse message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof BackDeviceChoicesResponse
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {BackDeviceChoicesResponse} BackDeviceChoicesResponse
     */
    BackDeviceChoicesResponse.fromObject = function fromObject(object) {
        if (object instanceof $root.BackDeviceChoicesResponse)
            return object;
        return new $root.BackDeviceChoicesResponse();
    };

    /**
     * Creates a plain object from a BackDeviceChoicesResponse message. Also converts values to other types if specified.
     * @function toObject
     * @memberof BackDeviceChoicesResponse
     * @static
     * @param {BackDeviceChoicesResponse} message BackDeviceChoicesResponse
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    BackDeviceChoicesResponse.toObject = function toObject() {
        return {};
    };

    /**
     * Converts this BackDeviceChoicesResponse to JSON.
     * @function toJSON
     * @memberof BackDeviceChoicesResponse
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    BackDeviceChoicesResponse.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return BackDeviceChoicesResponse;
})();

$root.BackupDocumentChoicesResponse = (function() {

    /**
     * Properties of a BackupDocumentChoicesResponse.
     * @exports IBackupDocumentChoicesResponse
     * @interface IBackupDocumentChoicesResponse
     */

    /**
     * Constructs a new BackupDocumentChoicesResponse.
     * @exports BackupDocumentChoicesResponse
     * @classdesc Represents a BackupDocumentChoicesResponse.
     * @implements IBackupDocumentChoicesResponse
     * @constructor
     * @param {IBackupDocumentChoicesResponse=} [properties] Properties to set
     */
    function BackupDocumentChoicesResponse(properties) {
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * Creates a new BackupDocumentChoicesResponse instance using the specified properties.
     * @function create
     * @memberof BackupDocumentChoicesResponse
     * @static
     * @param {IBackupDocumentChoicesResponse=} [properties] Properties to set
     * @returns {BackupDocumentChoicesResponse} BackupDocumentChoicesResponse instance
     */
    BackupDocumentChoicesResponse.create = function create(properties) {
        return new BackupDocumentChoicesResponse(properties);
    };

    /**
     * Encodes the specified BackupDocumentChoicesResponse message. Does not implicitly {@link BackupDocumentChoicesResponse.verify|verify} messages.
     * @function encode
     * @memberof BackupDocumentChoicesResponse
     * @static
     * @param {IBackupDocumentChoicesResponse} message BackupDocumentChoicesResponse message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    BackupDocumentChoicesResponse.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        return writer;
    };

    /**
     * Encodes the specified BackupDocumentChoicesResponse message, length delimited. Does not implicitly {@link BackupDocumentChoicesResponse.verify|verify} messages.
     * @function encodeDelimited
     * @memberof BackupDocumentChoicesResponse
     * @static
     * @param {IBackupDocumentChoicesResponse} message BackupDocumentChoicesResponse message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    BackupDocumentChoicesResponse.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a BackupDocumentChoicesResponse message from the specified reader or buffer.
     * @function decode
     * @memberof BackupDocumentChoicesResponse
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {BackupDocumentChoicesResponse} BackupDocumentChoicesResponse
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    BackupDocumentChoicesResponse.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.BackupDocumentChoicesResponse();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a BackupDocumentChoicesResponse message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof BackupDocumentChoicesResponse
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {BackupDocumentChoicesResponse} BackupDocumentChoicesResponse
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    BackupDocumentChoicesResponse.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a BackupDocumentChoicesResponse message.
     * @function verify
     * @memberof BackupDocumentChoicesResponse
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    BackupDocumentChoicesResponse.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        return null;
    };

    /**
     * Creates a BackupDocumentChoicesResponse message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof BackupDocumentChoicesResponse
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {BackupDocumentChoicesResponse} BackupDocumentChoicesResponse
     */
    BackupDocumentChoicesResponse.fromObject = function fromObject(object) {
        if (object instanceof $root.BackupDocumentChoicesResponse)
            return object;
        return new $root.BackupDocumentChoicesResponse();
    };

    /**
     * Creates a plain object from a BackupDocumentChoicesResponse message. Also converts values to other types if specified.
     * @function toObject
     * @memberof BackupDocumentChoicesResponse
     * @static
     * @param {BackupDocumentChoicesResponse} message BackupDocumentChoicesResponse
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    BackupDocumentChoicesResponse.toObject = function toObject() {
        return {};
    };

    /**
     * Converts this BackupDocumentChoicesResponse to JSON.
     * @function toJSON
     * @memberof BackupDocumentChoicesResponse
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    BackupDocumentChoicesResponse.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return BackupDocumentChoicesResponse;
})();

$root.EarlyUpdateResponse = (function() {

    /**
     * Properties of an EarlyUpdateResponse.
     * @exports IEarlyUpdateResponse
     * @interface IEarlyUpdateResponse
     */

    /**
     * Constructs a new EarlyUpdateResponse.
     * @exports EarlyUpdateResponse
     * @classdesc Represents an EarlyUpdateResponse.
     * @implements IEarlyUpdateResponse
     * @constructor
     * @param {IEarlyUpdateResponse=} [properties] Properties to set
     */
    function EarlyUpdateResponse(properties) {
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * Creates a new EarlyUpdateResponse instance using the specified properties.
     * @function create
     * @memberof EarlyUpdateResponse
     * @static
     * @param {IEarlyUpdateResponse=} [properties] Properties to set
     * @returns {EarlyUpdateResponse} EarlyUpdateResponse instance
     */
    EarlyUpdateResponse.create = function create(properties) {
        return new EarlyUpdateResponse(properties);
    };

    /**
     * Encodes the specified EarlyUpdateResponse message. Does not implicitly {@link EarlyUpdateResponse.verify|verify} messages.
     * @function encode
     * @memberof EarlyUpdateResponse
     * @static
     * @param {IEarlyUpdateResponse} message EarlyUpdateResponse message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    EarlyUpdateResponse.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        return writer;
    };

    /**
     * Encodes the specified EarlyUpdateResponse message, length delimited. Does not implicitly {@link EarlyUpdateResponse.verify|verify} messages.
     * @function encodeDelimited
     * @memberof EarlyUpdateResponse
     * @static
     * @param {IEarlyUpdateResponse} message EarlyUpdateResponse message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    EarlyUpdateResponse.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes an EarlyUpdateResponse message from the specified reader or buffer.
     * @function decode
     * @memberof EarlyUpdateResponse
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {EarlyUpdateResponse} EarlyUpdateResponse
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    EarlyUpdateResponse.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.EarlyUpdateResponse();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes an EarlyUpdateResponse message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof EarlyUpdateResponse
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {EarlyUpdateResponse} EarlyUpdateResponse
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    EarlyUpdateResponse.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies an EarlyUpdateResponse message.
     * @function verify
     * @memberof EarlyUpdateResponse
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    EarlyUpdateResponse.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        return null;
    };

    /**
     * Creates an EarlyUpdateResponse message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof EarlyUpdateResponse
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {EarlyUpdateResponse} EarlyUpdateResponse
     */
    EarlyUpdateResponse.fromObject = function fromObject(object) {
        if (object instanceof $root.EarlyUpdateResponse)
            return object;
        return new $root.EarlyUpdateResponse();
    };

    /**
     * Creates a plain object from an EarlyUpdateResponse message. Also converts values to other types if specified.
     * @function toObject
     * @memberof EarlyUpdateResponse
     * @static
     * @param {EarlyUpdateResponse} message EarlyUpdateResponse
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    EarlyUpdateResponse.toObject = function toObject() {
        return {};
    };

    /**
     * Converts this EarlyUpdateResponse to JSON.
     * @function toJSON
     * @memberof EarlyUpdateResponse
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    EarlyUpdateResponse.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return EarlyUpdateResponse;
})();

$root.PreloadsResponse = (function() {

    /**
     * Properties of a PreloadsResponse.
     * @exports IPreloadsResponse
     * @interface IPreloadsResponse
     * @property {PreloadsResponse.IPreload|null} [configPreload] PreloadsResponse configPreload
     * @property {Array.<PreloadsResponse.IPreload>|null} [appPreload] PreloadsResponse appPreload
     */

    /**
     * Constructs a new PreloadsResponse.
     * @exports PreloadsResponse
     * @classdesc Represents a PreloadsResponse.
     * @implements IPreloadsResponse
     * @constructor
     * @param {IPreloadsResponse=} [properties] Properties to set
     */
    function PreloadsResponse(properties) {
        this.appPreload = [];
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * PreloadsResponse configPreload.
     * @member {PreloadsResponse.IPreload|null|undefined} configPreload
     * @memberof PreloadsResponse
     * @instance
     */
    PreloadsResponse.prototype.configPreload = null;

    /**
     * PreloadsResponse appPreload.
     * @member {Array.<PreloadsResponse.IPreload>} appPreload
     * @memberof PreloadsResponse
     * @instance
     */
    PreloadsResponse.prototype.appPreload = $util.emptyArray;

    /**
     * Creates a new PreloadsResponse instance using the specified properties.
     * @function create
     * @memberof PreloadsResponse
     * @static
     * @param {IPreloadsResponse=} [properties] Properties to set
     * @returns {PreloadsResponse} PreloadsResponse instance
     */
    PreloadsResponse.create = function create(properties) {
        return new PreloadsResponse(properties);
    };

    /**
     * Encodes the specified PreloadsResponse message. Does not implicitly {@link PreloadsResponse.verify|verify} messages.
     * @function encode
     * @memberof PreloadsResponse
     * @static
     * @param {IPreloadsResponse} message PreloadsResponse message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    PreloadsResponse.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.configPreload != null && Object.hasOwnProperty.call(message, "configPreload"))
            $root.PreloadsResponse.Preload.encode(message.configPreload, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
        if (message.appPreload != null && message.appPreload.length)
            for (var i = 0; i < message.appPreload.length; ++i)
                $root.PreloadsResponse.Preload.encode(message.appPreload[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
        return writer;
    };

    /**
     * Encodes the specified PreloadsResponse message, length delimited. Does not implicitly {@link PreloadsResponse.verify|verify} messages.
     * @function encodeDelimited
     * @memberof PreloadsResponse
     * @static
     * @param {IPreloadsResponse} message PreloadsResponse message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    PreloadsResponse.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a PreloadsResponse message from the specified reader or buffer.
     * @function decode
     * @memberof PreloadsResponse
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {PreloadsResponse} PreloadsResponse
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    PreloadsResponse.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.PreloadsResponse();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.configPreload = $root.PreloadsResponse.Preload.decode(reader, reader.uint32());
                break;
            case 2:
                if (!(message.appPreload && message.appPreload.length))
                    message.appPreload = [];
                message.appPreload.push($root.PreloadsResponse.Preload.decode(reader, reader.uint32()));
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a PreloadsResponse message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof PreloadsResponse
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {PreloadsResponse} PreloadsResponse
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    PreloadsResponse.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a PreloadsResponse message.
     * @function verify
     * @memberof PreloadsResponse
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    PreloadsResponse.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.configPreload != null && message.hasOwnProperty("configPreload")) {
            var error = $root.PreloadsResponse.Preload.verify(message.configPreload);
            if (error)
                return "configPreload." + error;
        }
        if (message.appPreload != null && message.hasOwnProperty("appPreload")) {
            if (!Array.isArray(message.appPreload))
                return "appPreload: array expected";
            for (var i = 0; i < message.appPreload.length; ++i) {
                var error = $root.PreloadsResponse.Preload.verify(message.appPreload[i]);
                if (error)
                    return "appPreload." + error;
            }
        }
        return null;
    };

    /**
     * Creates a PreloadsResponse message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof PreloadsResponse
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {PreloadsResponse} PreloadsResponse
     */
    PreloadsResponse.fromObject = function fromObject(object) {
        if (object instanceof $root.PreloadsResponse)
            return object;
        var message = new $root.PreloadsResponse();
        if (object.configPreload != null) {
            if (typeof object.configPreload !== "object")
                throw TypeError(".PreloadsResponse.configPreload: object expected");
            message.configPreload = $root.PreloadsResponse.Preload.fromObject(object.configPreload);
        }
        if (object.appPreload) {
            if (!Array.isArray(object.appPreload))
                throw TypeError(".PreloadsResponse.appPreload: array expected");
            message.appPreload = [];
            for (var i = 0; i < object.appPreload.length; ++i) {
                if (typeof object.appPreload[i] !== "object")
                    throw TypeError(".PreloadsResponse.appPreload: object expected");
                message.appPreload[i] = $root.PreloadsResponse.Preload.fromObject(object.appPreload[i]);
            }
        }
        return message;
    };

    /**
     * Creates a plain object from a PreloadsResponse message. Also converts values to other types if specified.
     * @function toObject
     * @memberof PreloadsResponse
     * @static
     * @param {PreloadsResponse} message PreloadsResponse
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    PreloadsResponse.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        var object = {};
        if (options.arrays || options.defaults)
            object.appPreload = [];
        if (options.defaults)
            object.configPreload = null;
        if (message.configPreload != null && message.hasOwnProperty("configPreload"))
            object.configPreload = $root.PreloadsResponse.Preload.toObject(message.configPreload, options);
        if (message.appPreload && message.appPreload.length) {
            object.appPreload = [];
            for (var j = 0; j < message.appPreload.length; ++j)
                object.appPreload[j] = $root.PreloadsResponse.Preload.toObject(message.appPreload[j], options);
        }
        return object;
    };

    /**
     * Converts this PreloadsResponse to JSON.
     * @function toJSON
     * @memberof PreloadsResponse
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    PreloadsResponse.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    PreloadsResponse.Preload = (function() {

        /**
         * Properties of a Preload.
         * @memberof PreloadsResponse
         * @interface IPreload
         * @property {IDocId|null} [DocId] Preload DocId
         * @property {number|null} [versionCode] Preload versionCode
         * @property {string|null} [title] Preload title
         * @property {IImage|null} [icon] Preload icon
         * @property {string|null} [deliveryToken] Preload deliveryToken
         * @property {number|null} [installLocation] Preload installLocation
         * @property {number|Long|null} [size] Preload size
         */

        /**
         * Constructs a new Preload.
         * @memberof PreloadsResponse
         * @classdesc Represents a Preload.
         * @implements IPreload
         * @constructor
         * @param {PreloadsResponse.IPreload=} [properties] Properties to set
         */
        function Preload(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Preload DocId.
         * @member {IDocId|null|undefined} DocId
         * @memberof PreloadsResponse.Preload
         * @instance
         */
        Preload.prototype.DocId = null;

        /**
         * Preload versionCode.
         * @member {number} versionCode
         * @memberof PreloadsResponse.Preload
         * @instance
         */
        Preload.prototype.versionCode = 0;

        /**
         * Preload title.
         * @member {string} title
         * @memberof PreloadsResponse.Preload
         * @instance
         */
        Preload.prototype.title = "";

        /**
         * Preload icon.
         * @member {IImage|null|undefined} icon
         * @memberof PreloadsResponse.Preload
         * @instance
         */
        Preload.prototype.icon = null;

        /**
         * Preload deliveryToken.
         * @member {string} deliveryToken
         * @memberof PreloadsResponse.Preload
         * @instance
         */
        Preload.prototype.deliveryToken = "";

        /**
         * Preload installLocation.
         * @member {number} installLocation
         * @memberof PreloadsResponse.Preload
         * @instance
         */
        Preload.prototype.installLocation = 0;

        /**
         * Preload size.
         * @member {number|Long} size
         * @memberof PreloadsResponse.Preload
         * @instance
         */
        Preload.prototype.size = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Creates a new Preload instance using the specified properties.
         * @function create
         * @memberof PreloadsResponse.Preload
         * @static
         * @param {PreloadsResponse.IPreload=} [properties] Properties to set
         * @returns {PreloadsResponse.Preload} Preload instance
         */
        Preload.create = function create(properties) {
            return new Preload(properties);
        };

        /**
         * Encodes the specified Preload message. Does not implicitly {@link PreloadsResponse.Preload.verify|verify} messages.
         * @function encode
         * @memberof PreloadsResponse.Preload
         * @static
         * @param {PreloadsResponse.IPreload} message Preload message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Preload.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.DocId != null && Object.hasOwnProperty.call(message, "DocId"))
                $root.DocId.encode(message.DocId, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.versionCode != null && Object.hasOwnProperty.call(message, "versionCode"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.versionCode);
            if (message.title != null && Object.hasOwnProperty.call(message, "title"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.title);
            if (message.icon != null && Object.hasOwnProperty.call(message, "icon"))
                $root.Image.encode(message.icon, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            if (message.deliveryToken != null && Object.hasOwnProperty.call(message, "deliveryToken"))
                writer.uint32(/* id 5, wireType 2 =*/42).string(message.deliveryToken);
            if (message.installLocation != null && Object.hasOwnProperty.call(message, "installLocation"))
                writer.uint32(/* id 6, wireType 0 =*/48).int32(message.installLocation);
            if (message.size != null && Object.hasOwnProperty.call(message, "size"))
                writer.uint32(/* id 7, wireType 0 =*/56).int64(message.size);
            return writer;
        };

        /**
         * Encodes the specified Preload message, length delimited. Does not implicitly {@link PreloadsResponse.Preload.verify|verify} messages.
         * @function encodeDelimited
         * @memberof PreloadsResponse.Preload
         * @static
         * @param {PreloadsResponse.IPreload} message Preload message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Preload.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Preload message from the specified reader or buffer.
         * @function decode
         * @memberof PreloadsResponse.Preload
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {PreloadsResponse.Preload} Preload
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Preload.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.PreloadsResponse.Preload();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.DocId = $root.DocId.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.versionCode = reader.int32();
                    break;
                case 3:
                    message.title = reader.string();
                    break;
                case 4:
                    message.icon = $root.Image.decode(reader, reader.uint32());
                    break;
                case 5:
                    message.deliveryToken = reader.string();
                    break;
                case 6:
                    message.installLocation = reader.int32();
                    break;
                case 7:
                    message.size = reader.int64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a Preload message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof PreloadsResponse.Preload
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {PreloadsResponse.Preload} Preload
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Preload.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Preload message.
         * @function verify
         * @memberof PreloadsResponse.Preload
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Preload.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.DocId != null && message.hasOwnProperty("DocId")) {
                var error = $root.DocId.verify(message.DocId);
                if (error)
                    return "DocId." + error;
            }
            if (message.versionCode != null && message.hasOwnProperty("versionCode"))
                if (!$util.isInteger(message.versionCode))
                    return "versionCode: integer expected";
            if (message.title != null && message.hasOwnProperty("title"))
                if (!$util.isString(message.title))
                    return "title: string expected";
            if (message.icon != null && message.hasOwnProperty("icon")) {
                var error = $root.Image.verify(message.icon);
                if (error)
                    return "icon." + error;
            }
            if (message.deliveryToken != null && message.hasOwnProperty("deliveryToken"))
                if (!$util.isString(message.deliveryToken))
                    return "deliveryToken: string expected";
            if (message.installLocation != null && message.hasOwnProperty("installLocation"))
                if (!$util.isInteger(message.installLocation))
                    return "installLocation: integer expected";
            if (message.size != null && message.hasOwnProperty("size"))
                if (!$util.isInteger(message.size) && !(message.size && $util.isInteger(message.size.low) && $util.isInteger(message.size.high)))
                    return "size: integer|Long expected";
            return null;
        };

        /**
         * Creates a Preload message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof PreloadsResponse.Preload
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {PreloadsResponse.Preload} Preload
         */
        Preload.fromObject = function fromObject(object) {
            if (object instanceof $root.PreloadsResponse.Preload)
                return object;
            var message = new $root.PreloadsResponse.Preload();
            if (object.DocId != null) {
                if (typeof object.DocId !== "object")
                    throw TypeError(".PreloadsResponse.Preload.DocId: object expected");
                message.DocId = $root.DocId.fromObject(object.DocId);
            }
            if (object.versionCode != null)
                message.versionCode = object.versionCode | 0;
            if (object.title != null)
                message.title = String(object.title);
            if (object.icon != null) {
                if (typeof object.icon !== "object")
                    throw TypeError(".PreloadsResponse.Preload.icon: object expected");
                message.icon = $root.Image.fromObject(object.icon);
            }
            if (object.deliveryToken != null)
                message.deliveryToken = String(object.deliveryToken);
            if (object.installLocation != null)
                message.installLocation = object.installLocation | 0;
            if (object.size != null)
                if ($util.Long)
                    (message.size = $util.Long.fromValue(object.size)).unsigned = false;
                else if (typeof object.size === "string")
                    message.size = parseInt(object.size, 10);
                else if (typeof object.size === "number")
                    message.size = object.size;
                else if (typeof object.size === "object")
                    message.size = new $util.LongBits(object.size.low >>> 0, object.size.high >>> 0).toNumber();
            return message;
        };

        /**
         * Creates a plain object from a Preload message. Also converts values to other types if specified.
         * @function toObject
         * @memberof PreloadsResponse.Preload
         * @static
         * @param {PreloadsResponse.Preload} message Preload
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Preload.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.DocId = null;
                object.versionCode = 0;
                object.title = "";
                object.icon = null;
                object.deliveryToken = "";
                object.installLocation = 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.size = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.size = options.longs === String ? "0" : 0;
            }
            if (message.DocId != null && message.hasOwnProperty("DocId"))
                object.DocId = $root.DocId.toObject(message.DocId, options);
            if (message.versionCode != null && message.hasOwnProperty("versionCode"))
                object.versionCode = message.versionCode;
            if (message.title != null && message.hasOwnProperty("title"))
                object.title = message.title;
            if (message.icon != null && message.hasOwnProperty("icon"))
                object.icon = $root.Image.toObject(message.icon, options);
            if (message.deliveryToken != null && message.hasOwnProperty("deliveryToken"))
                object.deliveryToken = message.deliveryToken;
            if (message.installLocation != null && message.hasOwnProperty("installLocation"))
                object.installLocation = message.installLocation;
            if (message.size != null && message.hasOwnProperty("size"))
                if (typeof message.size === "number")
                    object.size = options.longs === String ? String(message.size) : message.size;
                else
                    object.size = options.longs === String ? $util.Long.prototype.toString.call(message.size) : options.longs === Number ? new $util.LongBits(message.size.low >>> 0, message.size.high >>> 0).toNumber() : message.size;
            return object;
        };

        /**
         * Converts this Preload to JSON.
         * @function toJSON
         * @memberof PreloadsResponse.Preload
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Preload.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Preload;
    })();

    return PreloadsResponse;
})();

$root.MyAccountsResponse = (function() {

    /**
     * Properties of a MyAccountsResponse.
     * @exports IMyAccountsResponse
     * @interface IMyAccountsResponse
     */

    /**
     * Constructs a new MyAccountsResponse.
     * @exports MyAccountsResponse
     * @classdesc Represents a MyAccountsResponse.
     * @implements IMyAccountsResponse
     * @constructor
     * @param {IMyAccountsResponse=} [properties] Properties to set
     */
    function MyAccountsResponse(properties) {
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * Creates a new MyAccountsResponse instance using the specified properties.
     * @function create
     * @memberof MyAccountsResponse
     * @static
     * @param {IMyAccountsResponse=} [properties] Properties to set
     * @returns {MyAccountsResponse} MyAccountsResponse instance
     */
    MyAccountsResponse.create = function create(properties) {
        return new MyAccountsResponse(properties);
    };

    /**
     * Encodes the specified MyAccountsResponse message. Does not implicitly {@link MyAccountsResponse.verify|verify} messages.
     * @function encode
     * @memberof MyAccountsResponse
     * @static
     * @param {IMyAccountsResponse} message MyAccountsResponse message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    MyAccountsResponse.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        return writer;
    };

    /**
     * Encodes the specified MyAccountsResponse message, length delimited. Does not implicitly {@link MyAccountsResponse.verify|verify} messages.
     * @function encodeDelimited
     * @memberof MyAccountsResponse
     * @static
     * @param {IMyAccountsResponse} message MyAccountsResponse message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    MyAccountsResponse.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a MyAccountsResponse message from the specified reader or buffer.
     * @function decode
     * @memberof MyAccountsResponse
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {MyAccountsResponse} MyAccountsResponse
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    MyAccountsResponse.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.MyAccountsResponse();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a MyAccountsResponse message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof MyAccountsResponse
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {MyAccountsResponse} MyAccountsResponse
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    MyAccountsResponse.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a MyAccountsResponse message.
     * @function verify
     * @memberof MyAccountsResponse
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    MyAccountsResponse.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        return null;
    };

    /**
     * Creates a MyAccountsResponse message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof MyAccountsResponse
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {MyAccountsResponse} MyAccountsResponse
     */
    MyAccountsResponse.fromObject = function fromObject(object) {
        if (object instanceof $root.MyAccountsResponse)
            return object;
        return new $root.MyAccountsResponse();
    };

    /**
     * Creates a plain object from a MyAccountsResponse message. Also converts values to other types if specified.
     * @function toObject
     * @memberof MyAccountsResponse
     * @static
     * @param {MyAccountsResponse} message MyAccountsResponse
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    MyAccountsResponse.toObject = function toObject() {
        return {};
    };

    /**
     * Converts this MyAccountsResponse to JSON.
     * @function toJSON
     * @memberof MyAccountsResponse
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    MyAccountsResponse.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return MyAccountsResponse;
})();

$root.ContentFilterResponse = (function() {

    /**
     * Properties of a ContentFilterResponse.
     * @exports IContentFilterResponse
     * @interface IContentFilterResponse
     */

    /**
     * Constructs a new ContentFilterResponse.
     * @exports ContentFilterResponse
     * @classdesc Represents a ContentFilterResponse.
     * @implements IContentFilterResponse
     * @constructor
     * @param {IContentFilterResponse=} [properties] Properties to set
     */
    function ContentFilterResponse(properties) {
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * Creates a new ContentFilterResponse instance using the specified properties.
     * @function create
     * @memberof ContentFilterResponse
     * @static
     * @param {IContentFilterResponse=} [properties] Properties to set
     * @returns {ContentFilterResponse} ContentFilterResponse instance
     */
    ContentFilterResponse.create = function create(properties) {
        return new ContentFilterResponse(properties);
    };

    /**
     * Encodes the specified ContentFilterResponse message. Does not implicitly {@link ContentFilterResponse.verify|verify} messages.
     * @function encode
     * @memberof ContentFilterResponse
     * @static
     * @param {IContentFilterResponse} message ContentFilterResponse message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    ContentFilterResponse.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        return writer;
    };

    /**
     * Encodes the specified ContentFilterResponse message, length delimited. Does not implicitly {@link ContentFilterResponse.verify|verify} messages.
     * @function encodeDelimited
     * @memberof ContentFilterResponse
     * @static
     * @param {IContentFilterResponse} message ContentFilterResponse message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    ContentFilterResponse.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a ContentFilterResponse message from the specified reader or buffer.
     * @function decode
     * @memberof ContentFilterResponse
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {ContentFilterResponse} ContentFilterResponse
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    ContentFilterResponse.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ContentFilterResponse();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a ContentFilterResponse message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof ContentFilterResponse
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {ContentFilterResponse} ContentFilterResponse
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    ContentFilterResponse.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a ContentFilterResponse message.
     * @function verify
     * @memberof ContentFilterResponse
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    ContentFilterResponse.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        return null;
    };

    /**
     * Creates a ContentFilterResponse message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof ContentFilterResponse
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {ContentFilterResponse} ContentFilterResponse
     */
    ContentFilterResponse.fromObject = function fromObject(object) {
        if (object instanceof $root.ContentFilterResponse)
            return object;
        return new $root.ContentFilterResponse();
    };

    /**
     * Creates a plain object from a ContentFilterResponse message. Also converts values to other types if specified.
     * @function toObject
     * @memberof ContentFilterResponse
     * @static
     * @param {ContentFilterResponse} message ContentFilterResponse
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    ContentFilterResponse.toObject = function toObject() {
        return {};
    };

    /**
     * Converts this ContentFilterResponse to JSON.
     * @function toJSON
     * @memberof ContentFilterResponse
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    ContentFilterResponse.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return ContentFilterResponse;
})();

$root.ExperimentsResponse = (function() {

    /**
     * Properties of an ExperimentsResponse.
     * @exports IExperimentsResponse
     * @interface IExperimentsResponse
     */

    /**
     * Constructs a new ExperimentsResponse.
     * @exports ExperimentsResponse
     * @classdesc Represents an ExperimentsResponse.
     * @implements IExperimentsResponse
     * @constructor
     * @param {IExperimentsResponse=} [properties] Properties to set
     */
    function ExperimentsResponse(properties) {
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * Creates a new ExperimentsResponse instance using the specified properties.
     * @function create
     * @memberof ExperimentsResponse
     * @static
     * @param {IExperimentsResponse=} [properties] Properties to set
     * @returns {ExperimentsResponse} ExperimentsResponse instance
     */
    ExperimentsResponse.create = function create(properties) {
        return new ExperimentsResponse(properties);
    };

    /**
     * Encodes the specified ExperimentsResponse message. Does not implicitly {@link ExperimentsResponse.verify|verify} messages.
     * @function encode
     * @memberof ExperimentsResponse
     * @static
     * @param {IExperimentsResponse} message ExperimentsResponse message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    ExperimentsResponse.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        return writer;
    };

    /**
     * Encodes the specified ExperimentsResponse message, length delimited. Does not implicitly {@link ExperimentsResponse.verify|verify} messages.
     * @function encodeDelimited
     * @memberof ExperimentsResponse
     * @static
     * @param {IExperimentsResponse} message ExperimentsResponse message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    ExperimentsResponse.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes an ExperimentsResponse message from the specified reader or buffer.
     * @function decode
     * @memberof ExperimentsResponse
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {ExperimentsResponse} ExperimentsResponse
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    ExperimentsResponse.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ExperimentsResponse();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes an ExperimentsResponse message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof ExperimentsResponse
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {ExperimentsResponse} ExperimentsResponse
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    ExperimentsResponse.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies an ExperimentsResponse message.
     * @function verify
     * @memberof ExperimentsResponse
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    ExperimentsResponse.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        return null;
    };

    /**
     * Creates an ExperimentsResponse message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof ExperimentsResponse
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {ExperimentsResponse} ExperimentsResponse
     */
    ExperimentsResponse.fromObject = function fromObject(object) {
        if (object instanceof $root.ExperimentsResponse)
            return object;
        return new $root.ExperimentsResponse();
    };

    /**
     * Creates a plain object from an ExperimentsResponse message. Also converts values to other types if specified.
     * @function toObject
     * @memberof ExperimentsResponse
     * @static
     * @param {ExperimentsResponse} message ExperimentsResponse
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    ExperimentsResponse.toObject = function toObject() {
        return {};
    };

    /**
     * Converts this ExperimentsResponse to JSON.
     * @function toJSON
     * @memberof ExperimentsResponse
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    ExperimentsResponse.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return ExperimentsResponse;
})();

$root.SurveyResponse = (function() {

    /**
     * Properties of a SurveyResponse.
     * @exports ISurveyResponse
     * @interface ISurveyResponse
     */

    /**
     * Constructs a new SurveyResponse.
     * @exports SurveyResponse
     * @classdesc Represents a SurveyResponse.
     * @implements ISurveyResponse
     * @constructor
     * @param {ISurveyResponse=} [properties] Properties to set
     */
    function SurveyResponse(properties) {
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * Creates a new SurveyResponse instance using the specified properties.
     * @function create
     * @memberof SurveyResponse
     * @static
     * @param {ISurveyResponse=} [properties] Properties to set
     * @returns {SurveyResponse} SurveyResponse instance
     */
    SurveyResponse.create = function create(properties) {
        return new SurveyResponse(properties);
    };

    /**
     * Encodes the specified SurveyResponse message. Does not implicitly {@link SurveyResponse.verify|verify} messages.
     * @function encode
     * @memberof SurveyResponse
     * @static
     * @param {ISurveyResponse} message SurveyResponse message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    SurveyResponse.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        return writer;
    };

    /**
     * Encodes the specified SurveyResponse message, length delimited. Does not implicitly {@link SurveyResponse.verify|verify} messages.
     * @function encodeDelimited
     * @memberof SurveyResponse
     * @static
     * @param {ISurveyResponse} message SurveyResponse message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    SurveyResponse.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a SurveyResponse message from the specified reader or buffer.
     * @function decode
     * @memberof SurveyResponse
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {SurveyResponse} SurveyResponse
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    SurveyResponse.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.SurveyResponse();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a SurveyResponse message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof SurveyResponse
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {SurveyResponse} SurveyResponse
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    SurveyResponse.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a SurveyResponse message.
     * @function verify
     * @memberof SurveyResponse
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    SurveyResponse.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        return null;
    };

    /**
     * Creates a SurveyResponse message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof SurveyResponse
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {SurveyResponse} SurveyResponse
     */
    SurveyResponse.fromObject = function fromObject(object) {
        if (object instanceof $root.SurveyResponse)
            return object;
        return new $root.SurveyResponse();
    };

    /**
     * Creates a plain object from a SurveyResponse message. Also converts values to other types if specified.
     * @function toObject
     * @memberof SurveyResponse
     * @static
     * @param {SurveyResponse} message SurveyResponse
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    SurveyResponse.toObject = function toObject() {
        return {};
    };

    /**
     * Converts this SurveyResponse to JSON.
     * @function toJSON
     * @memberof SurveyResponse
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    SurveyResponse.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return SurveyResponse;
})();

$root.PingResponse = (function() {

    /**
     * Properties of a PingResponse.
     * @exports IPingResponse
     * @interface IPingResponse
     */

    /**
     * Constructs a new PingResponse.
     * @exports PingResponse
     * @classdesc Represents a PingResponse.
     * @implements IPingResponse
     * @constructor
     * @param {IPingResponse=} [properties] Properties to set
     */
    function PingResponse(properties) {
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * Creates a new PingResponse instance using the specified properties.
     * @function create
     * @memberof PingResponse
     * @static
     * @param {IPingResponse=} [properties] Properties to set
     * @returns {PingResponse} PingResponse instance
     */
    PingResponse.create = function create(properties) {
        return new PingResponse(properties);
    };

    /**
     * Encodes the specified PingResponse message. Does not implicitly {@link PingResponse.verify|verify} messages.
     * @function encode
     * @memberof PingResponse
     * @static
     * @param {IPingResponse} message PingResponse message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    PingResponse.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        return writer;
    };

    /**
     * Encodes the specified PingResponse message, length delimited. Does not implicitly {@link PingResponse.verify|verify} messages.
     * @function encodeDelimited
     * @memberof PingResponse
     * @static
     * @param {IPingResponse} message PingResponse message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    PingResponse.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a PingResponse message from the specified reader or buffer.
     * @function decode
     * @memberof PingResponse
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {PingResponse} PingResponse
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    PingResponse.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.PingResponse();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a PingResponse message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof PingResponse
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {PingResponse} PingResponse
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    PingResponse.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a PingResponse message.
     * @function verify
     * @memberof PingResponse
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    PingResponse.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        return null;
    };

    /**
     * Creates a PingResponse message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof PingResponse
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {PingResponse} PingResponse
     */
    PingResponse.fromObject = function fromObject(object) {
        if (object instanceof $root.PingResponse)
            return object;
        return new $root.PingResponse();
    };

    /**
     * Creates a plain object from a PingResponse message. Also converts values to other types if specified.
     * @function toObject
     * @memberof PingResponse
     * @static
     * @param {PingResponse} message PingResponse
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    PingResponse.toObject = function toObject() {
        return {};
    };

    /**
     * Converts this PingResponse to JSON.
     * @function toJSON
     * @memberof PingResponse
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    PingResponse.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return PingResponse;
})();

$root.UpdateUserSettingResponse = (function() {

    /**
     * Properties of an UpdateUserSettingResponse.
     * @exports IUpdateUserSettingResponse
     * @interface IUpdateUserSettingResponse
     */

    /**
     * Constructs a new UpdateUserSettingResponse.
     * @exports UpdateUserSettingResponse
     * @classdesc Represents an UpdateUserSettingResponse.
     * @implements IUpdateUserSettingResponse
     * @constructor
     * @param {IUpdateUserSettingResponse=} [properties] Properties to set
     */
    function UpdateUserSettingResponse(properties) {
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * Creates a new UpdateUserSettingResponse instance using the specified properties.
     * @function create
     * @memberof UpdateUserSettingResponse
     * @static
     * @param {IUpdateUserSettingResponse=} [properties] Properties to set
     * @returns {UpdateUserSettingResponse} UpdateUserSettingResponse instance
     */
    UpdateUserSettingResponse.create = function create(properties) {
        return new UpdateUserSettingResponse(properties);
    };

    /**
     * Encodes the specified UpdateUserSettingResponse message. Does not implicitly {@link UpdateUserSettingResponse.verify|verify} messages.
     * @function encode
     * @memberof UpdateUserSettingResponse
     * @static
     * @param {IUpdateUserSettingResponse} message UpdateUserSettingResponse message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    UpdateUserSettingResponse.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        return writer;
    };

    /**
     * Encodes the specified UpdateUserSettingResponse message, length delimited. Does not implicitly {@link UpdateUserSettingResponse.verify|verify} messages.
     * @function encodeDelimited
     * @memberof UpdateUserSettingResponse
     * @static
     * @param {IUpdateUserSettingResponse} message UpdateUserSettingResponse message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    UpdateUserSettingResponse.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes an UpdateUserSettingResponse message from the specified reader or buffer.
     * @function decode
     * @memberof UpdateUserSettingResponse
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {UpdateUserSettingResponse} UpdateUserSettingResponse
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    UpdateUserSettingResponse.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.UpdateUserSettingResponse();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes an UpdateUserSettingResponse message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof UpdateUserSettingResponse
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {UpdateUserSettingResponse} UpdateUserSettingResponse
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    UpdateUserSettingResponse.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies an UpdateUserSettingResponse message.
     * @function verify
     * @memberof UpdateUserSettingResponse
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    UpdateUserSettingResponse.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        return null;
    };

    /**
     * Creates an UpdateUserSettingResponse message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof UpdateUserSettingResponse
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {UpdateUserSettingResponse} UpdateUserSettingResponse
     */
    UpdateUserSettingResponse.fromObject = function fromObject(object) {
        if (object instanceof $root.UpdateUserSettingResponse)
            return object;
        return new $root.UpdateUserSettingResponse();
    };

    /**
     * Creates a plain object from an UpdateUserSettingResponse message. Also converts values to other types if specified.
     * @function toObject
     * @memberof UpdateUserSettingResponse
     * @static
     * @param {UpdateUserSettingResponse} message UpdateUserSettingResponse
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    UpdateUserSettingResponse.toObject = function toObject() {
        return {};
    };

    /**
     * Converts this UpdateUserSettingResponse to JSON.
     * @function toJSON
     * @memberof UpdateUserSettingResponse
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    UpdateUserSettingResponse.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return UpdateUserSettingResponse;
})();

$root.GetUserSettingsResponse = (function() {

    /**
     * Properties of a GetUserSettingsResponse.
     * @exports IGetUserSettingsResponse
     * @interface IGetUserSettingsResponse
     */

    /**
     * Constructs a new GetUserSettingsResponse.
     * @exports GetUserSettingsResponse
     * @classdesc Represents a GetUserSettingsResponse.
     * @implements IGetUserSettingsResponse
     * @constructor
     * @param {IGetUserSettingsResponse=} [properties] Properties to set
     */
    function GetUserSettingsResponse(properties) {
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * Creates a new GetUserSettingsResponse instance using the specified properties.
     * @function create
     * @memberof GetUserSettingsResponse
     * @static
     * @param {IGetUserSettingsResponse=} [properties] Properties to set
     * @returns {GetUserSettingsResponse} GetUserSettingsResponse instance
     */
    GetUserSettingsResponse.create = function create(properties) {
        return new GetUserSettingsResponse(properties);
    };

    /**
     * Encodes the specified GetUserSettingsResponse message. Does not implicitly {@link GetUserSettingsResponse.verify|verify} messages.
     * @function encode
     * @memberof GetUserSettingsResponse
     * @static
     * @param {IGetUserSettingsResponse} message GetUserSettingsResponse message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    GetUserSettingsResponse.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        return writer;
    };

    /**
     * Encodes the specified GetUserSettingsResponse message, length delimited. Does not implicitly {@link GetUserSettingsResponse.verify|verify} messages.
     * @function encodeDelimited
     * @memberof GetUserSettingsResponse
     * @static
     * @param {IGetUserSettingsResponse} message GetUserSettingsResponse message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    GetUserSettingsResponse.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a GetUserSettingsResponse message from the specified reader or buffer.
     * @function decode
     * @memberof GetUserSettingsResponse
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {GetUserSettingsResponse} GetUserSettingsResponse
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    GetUserSettingsResponse.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.GetUserSettingsResponse();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a GetUserSettingsResponse message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof GetUserSettingsResponse
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {GetUserSettingsResponse} GetUserSettingsResponse
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    GetUserSettingsResponse.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a GetUserSettingsResponse message.
     * @function verify
     * @memberof GetUserSettingsResponse
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    GetUserSettingsResponse.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        return null;
    };

    /**
     * Creates a GetUserSettingsResponse message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof GetUserSettingsResponse
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {GetUserSettingsResponse} GetUserSettingsResponse
     */
    GetUserSettingsResponse.fromObject = function fromObject(object) {
        if (object instanceof $root.GetUserSettingsResponse)
            return object;
        return new $root.GetUserSettingsResponse();
    };

    /**
     * Creates a plain object from a GetUserSettingsResponse message. Also converts values to other types if specified.
     * @function toObject
     * @memberof GetUserSettingsResponse
     * @static
     * @param {GetUserSettingsResponse} message GetUserSettingsResponse
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    GetUserSettingsResponse.toObject = function toObject() {
        return {};
    };

    /**
     * Converts this GetUserSettingsResponse to JSON.
     * @function toJSON
     * @memberof GetUserSettingsResponse
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    GetUserSettingsResponse.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return GetUserSettingsResponse;
})();

$root.GetSharingSettingsResponse = (function() {

    /**
     * Properties of a GetSharingSettingsResponse.
     * @exports IGetSharingSettingsResponse
     * @interface IGetSharingSettingsResponse
     */

    /**
     * Constructs a new GetSharingSettingsResponse.
     * @exports GetSharingSettingsResponse
     * @classdesc Represents a GetSharingSettingsResponse.
     * @implements IGetSharingSettingsResponse
     * @constructor
     * @param {IGetSharingSettingsResponse=} [properties] Properties to set
     */
    function GetSharingSettingsResponse(properties) {
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * Creates a new GetSharingSettingsResponse instance using the specified properties.
     * @function create
     * @memberof GetSharingSettingsResponse
     * @static
     * @param {IGetSharingSettingsResponse=} [properties] Properties to set
     * @returns {GetSharingSettingsResponse} GetSharingSettingsResponse instance
     */
    GetSharingSettingsResponse.create = function create(properties) {
        return new GetSharingSettingsResponse(properties);
    };

    /**
     * Encodes the specified GetSharingSettingsResponse message. Does not implicitly {@link GetSharingSettingsResponse.verify|verify} messages.
     * @function encode
     * @memberof GetSharingSettingsResponse
     * @static
     * @param {IGetSharingSettingsResponse} message GetSharingSettingsResponse message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    GetSharingSettingsResponse.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        return writer;
    };

    /**
     * Encodes the specified GetSharingSettingsResponse message, length delimited. Does not implicitly {@link GetSharingSettingsResponse.verify|verify} messages.
     * @function encodeDelimited
     * @memberof GetSharingSettingsResponse
     * @static
     * @param {IGetSharingSettingsResponse} message GetSharingSettingsResponse message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    GetSharingSettingsResponse.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a GetSharingSettingsResponse message from the specified reader or buffer.
     * @function decode
     * @memberof GetSharingSettingsResponse
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {GetSharingSettingsResponse} GetSharingSettingsResponse
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    GetSharingSettingsResponse.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.GetSharingSettingsResponse();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a GetSharingSettingsResponse message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof GetSharingSettingsResponse
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {GetSharingSettingsResponse} GetSharingSettingsResponse
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    GetSharingSettingsResponse.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a GetSharingSettingsResponse message.
     * @function verify
     * @memberof GetSharingSettingsResponse
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    GetSharingSettingsResponse.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        return null;
    };

    /**
     * Creates a GetSharingSettingsResponse message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof GetSharingSettingsResponse
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {GetSharingSettingsResponse} GetSharingSettingsResponse
     */
    GetSharingSettingsResponse.fromObject = function fromObject(object) {
        if (object instanceof $root.GetSharingSettingsResponse)
            return object;
        return new $root.GetSharingSettingsResponse();
    };

    /**
     * Creates a plain object from a GetSharingSettingsResponse message. Also converts values to other types if specified.
     * @function toObject
     * @memberof GetSharingSettingsResponse
     * @static
     * @param {GetSharingSettingsResponse} message GetSharingSettingsResponse
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    GetSharingSettingsResponse.toObject = function toObject() {
        return {};
    };

    /**
     * Converts this GetSharingSettingsResponse to JSON.
     * @function toJSON
     * @memberof GetSharingSettingsResponse
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    GetSharingSettingsResponse.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return GetSharingSettingsResponse;
})();

$root.UpdateSharingSettingsResponse = (function() {

    /**
     * Properties of an UpdateSharingSettingsResponse.
     * @exports IUpdateSharingSettingsResponse
     * @interface IUpdateSharingSettingsResponse
     */

    /**
     * Constructs a new UpdateSharingSettingsResponse.
     * @exports UpdateSharingSettingsResponse
     * @classdesc Represents an UpdateSharingSettingsResponse.
     * @implements IUpdateSharingSettingsResponse
     * @constructor
     * @param {IUpdateSharingSettingsResponse=} [properties] Properties to set
     */
    function UpdateSharingSettingsResponse(properties) {
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * Creates a new UpdateSharingSettingsResponse instance using the specified properties.
     * @function create
     * @memberof UpdateSharingSettingsResponse
     * @static
     * @param {IUpdateSharingSettingsResponse=} [properties] Properties to set
     * @returns {UpdateSharingSettingsResponse} UpdateSharingSettingsResponse instance
     */
    UpdateSharingSettingsResponse.create = function create(properties) {
        return new UpdateSharingSettingsResponse(properties);
    };

    /**
     * Encodes the specified UpdateSharingSettingsResponse message. Does not implicitly {@link UpdateSharingSettingsResponse.verify|verify} messages.
     * @function encode
     * @memberof UpdateSharingSettingsResponse
     * @static
     * @param {IUpdateSharingSettingsResponse} message UpdateSharingSettingsResponse message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    UpdateSharingSettingsResponse.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        return writer;
    };

    /**
     * Encodes the specified UpdateSharingSettingsResponse message, length delimited. Does not implicitly {@link UpdateSharingSettingsResponse.verify|verify} messages.
     * @function encodeDelimited
     * @memberof UpdateSharingSettingsResponse
     * @static
     * @param {IUpdateSharingSettingsResponse} message UpdateSharingSettingsResponse message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    UpdateSharingSettingsResponse.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes an UpdateSharingSettingsResponse message from the specified reader or buffer.
     * @function decode
     * @memberof UpdateSharingSettingsResponse
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {UpdateSharingSettingsResponse} UpdateSharingSettingsResponse
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    UpdateSharingSettingsResponse.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.UpdateSharingSettingsResponse();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes an UpdateSharingSettingsResponse message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof UpdateSharingSettingsResponse
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {UpdateSharingSettingsResponse} UpdateSharingSettingsResponse
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    UpdateSharingSettingsResponse.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies an UpdateSharingSettingsResponse message.
     * @function verify
     * @memberof UpdateSharingSettingsResponse
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    UpdateSharingSettingsResponse.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        return null;
    };

    /**
     * Creates an UpdateSharingSettingsResponse message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof UpdateSharingSettingsResponse
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {UpdateSharingSettingsResponse} UpdateSharingSettingsResponse
     */
    UpdateSharingSettingsResponse.fromObject = function fromObject(object) {
        if (object instanceof $root.UpdateSharingSettingsResponse)
            return object;
        return new $root.UpdateSharingSettingsResponse();
    };

    /**
     * Creates a plain object from an UpdateSharingSettingsResponse message. Also converts values to other types if specified.
     * @function toObject
     * @memberof UpdateSharingSettingsResponse
     * @static
     * @param {UpdateSharingSettingsResponse} message UpdateSharingSettingsResponse
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    UpdateSharingSettingsResponse.toObject = function toObject() {
        return {};
    };

    /**
     * Converts this UpdateSharingSettingsResponse to JSON.
     * @function toJSON
     * @memberof UpdateSharingSettingsResponse
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    UpdateSharingSettingsResponse.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return UpdateSharingSettingsResponse;
})();

$root.ReviewSnippetsResponse = (function() {

    /**
     * Properties of a ReviewSnippetsResponse.
     * @exports IReviewSnippetsResponse
     * @interface IReviewSnippetsResponse
     */

    /**
     * Constructs a new ReviewSnippetsResponse.
     * @exports ReviewSnippetsResponse
     * @classdesc Represents a ReviewSnippetsResponse.
     * @implements IReviewSnippetsResponse
     * @constructor
     * @param {IReviewSnippetsResponse=} [properties] Properties to set
     */
    function ReviewSnippetsResponse(properties) {
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * Creates a new ReviewSnippetsResponse instance using the specified properties.
     * @function create
     * @memberof ReviewSnippetsResponse
     * @static
     * @param {IReviewSnippetsResponse=} [properties] Properties to set
     * @returns {ReviewSnippetsResponse} ReviewSnippetsResponse instance
     */
    ReviewSnippetsResponse.create = function create(properties) {
        return new ReviewSnippetsResponse(properties);
    };

    /**
     * Encodes the specified ReviewSnippetsResponse message. Does not implicitly {@link ReviewSnippetsResponse.verify|verify} messages.
     * @function encode
     * @memberof ReviewSnippetsResponse
     * @static
     * @param {IReviewSnippetsResponse} message ReviewSnippetsResponse message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    ReviewSnippetsResponse.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        return writer;
    };

    /**
     * Encodes the specified ReviewSnippetsResponse message, length delimited. Does not implicitly {@link ReviewSnippetsResponse.verify|verify} messages.
     * @function encodeDelimited
     * @memberof ReviewSnippetsResponse
     * @static
     * @param {IReviewSnippetsResponse} message ReviewSnippetsResponse message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    ReviewSnippetsResponse.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a ReviewSnippetsResponse message from the specified reader or buffer.
     * @function decode
     * @memberof ReviewSnippetsResponse
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {ReviewSnippetsResponse} ReviewSnippetsResponse
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    ReviewSnippetsResponse.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ReviewSnippetsResponse();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a ReviewSnippetsResponse message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof ReviewSnippetsResponse
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {ReviewSnippetsResponse} ReviewSnippetsResponse
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    ReviewSnippetsResponse.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a ReviewSnippetsResponse message.
     * @function verify
     * @memberof ReviewSnippetsResponse
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    ReviewSnippetsResponse.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        return null;
    };

    /**
     * Creates a ReviewSnippetsResponse message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof ReviewSnippetsResponse
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {ReviewSnippetsResponse} ReviewSnippetsResponse
     */
    ReviewSnippetsResponse.fromObject = function fromObject(object) {
        if (object instanceof $root.ReviewSnippetsResponse)
            return object;
        return new $root.ReviewSnippetsResponse();
    };

    /**
     * Creates a plain object from a ReviewSnippetsResponse message. Also converts values to other types if specified.
     * @function toObject
     * @memberof ReviewSnippetsResponse
     * @static
     * @param {ReviewSnippetsResponse} message ReviewSnippetsResponse
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    ReviewSnippetsResponse.toObject = function toObject() {
        return {};
    };

    /**
     * Converts this ReviewSnippetsResponse to JSON.
     * @function toJSON
     * @memberof ReviewSnippetsResponse
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    ReviewSnippetsResponse.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return ReviewSnippetsResponse;
})();

$root.DocumentSharingStateResponse = (function() {

    /**
     * Properties of a DocumentSharingStateResponse.
     * @exports IDocumentSharingStateResponse
     * @interface IDocumentSharingStateResponse
     */

    /**
     * Constructs a new DocumentSharingStateResponse.
     * @exports DocumentSharingStateResponse
     * @classdesc Represents a DocumentSharingStateResponse.
     * @implements IDocumentSharingStateResponse
     * @constructor
     * @param {IDocumentSharingStateResponse=} [properties] Properties to set
     */
    function DocumentSharingStateResponse(properties) {
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * Creates a new DocumentSharingStateResponse instance using the specified properties.
     * @function create
     * @memberof DocumentSharingStateResponse
     * @static
     * @param {IDocumentSharingStateResponse=} [properties] Properties to set
     * @returns {DocumentSharingStateResponse} DocumentSharingStateResponse instance
     */
    DocumentSharingStateResponse.create = function create(properties) {
        return new DocumentSharingStateResponse(properties);
    };

    /**
     * Encodes the specified DocumentSharingStateResponse message. Does not implicitly {@link DocumentSharingStateResponse.verify|verify} messages.
     * @function encode
     * @memberof DocumentSharingStateResponse
     * @static
     * @param {IDocumentSharingStateResponse} message DocumentSharingStateResponse message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    DocumentSharingStateResponse.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        return writer;
    };

    /**
     * Encodes the specified DocumentSharingStateResponse message, length delimited. Does not implicitly {@link DocumentSharingStateResponse.verify|verify} messages.
     * @function encodeDelimited
     * @memberof DocumentSharingStateResponse
     * @static
     * @param {IDocumentSharingStateResponse} message DocumentSharingStateResponse message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    DocumentSharingStateResponse.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a DocumentSharingStateResponse message from the specified reader or buffer.
     * @function decode
     * @memberof DocumentSharingStateResponse
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {DocumentSharingStateResponse} DocumentSharingStateResponse
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    DocumentSharingStateResponse.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.DocumentSharingStateResponse();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a DocumentSharingStateResponse message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof DocumentSharingStateResponse
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {DocumentSharingStateResponse} DocumentSharingStateResponse
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    DocumentSharingStateResponse.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a DocumentSharingStateResponse message.
     * @function verify
     * @memberof DocumentSharingStateResponse
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    DocumentSharingStateResponse.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        return null;
    };

    /**
     * Creates a DocumentSharingStateResponse message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof DocumentSharingStateResponse
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {DocumentSharingStateResponse} DocumentSharingStateResponse
     */
    DocumentSharingStateResponse.fromObject = function fromObject(object) {
        if (object instanceof $root.DocumentSharingStateResponse)
            return object;
        return new $root.DocumentSharingStateResponse();
    };

    /**
     * Creates a plain object from a DocumentSharingStateResponse message. Also converts values to other types if specified.
     * @function toObject
     * @memberof DocumentSharingStateResponse
     * @static
     * @param {DocumentSharingStateResponse} message DocumentSharingStateResponse
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    DocumentSharingStateResponse.toObject = function toObject() {
        return {};
    };

    /**
     * Converts this DocumentSharingStateResponse to JSON.
     * @function toJSON
     * @memberof DocumentSharingStateResponse
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    DocumentSharingStateResponse.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return DocumentSharingStateResponse;
})();

$root.ModuleDeliveryResponse = (function() {

    /**
     * Properties of a ModuleDeliveryResponse.
     * @exports IModuleDeliveryResponse
     * @interface IModuleDeliveryResponse
     */

    /**
     * Constructs a new ModuleDeliveryResponse.
     * @exports ModuleDeliveryResponse
     * @classdesc Represents a ModuleDeliveryResponse.
     * @implements IModuleDeliveryResponse
     * @constructor
     * @param {IModuleDeliveryResponse=} [properties] Properties to set
     */
    function ModuleDeliveryResponse(properties) {
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * Creates a new ModuleDeliveryResponse instance using the specified properties.
     * @function create
     * @memberof ModuleDeliveryResponse
     * @static
     * @param {IModuleDeliveryResponse=} [properties] Properties to set
     * @returns {ModuleDeliveryResponse} ModuleDeliveryResponse instance
     */
    ModuleDeliveryResponse.create = function create(properties) {
        return new ModuleDeliveryResponse(properties);
    };

    /**
     * Encodes the specified ModuleDeliveryResponse message. Does not implicitly {@link ModuleDeliveryResponse.verify|verify} messages.
     * @function encode
     * @memberof ModuleDeliveryResponse
     * @static
     * @param {IModuleDeliveryResponse} message ModuleDeliveryResponse message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    ModuleDeliveryResponse.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        return writer;
    };

    /**
     * Encodes the specified ModuleDeliveryResponse message, length delimited. Does not implicitly {@link ModuleDeliveryResponse.verify|verify} messages.
     * @function encodeDelimited
     * @memberof ModuleDeliveryResponse
     * @static
     * @param {IModuleDeliveryResponse} message ModuleDeliveryResponse message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    ModuleDeliveryResponse.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a ModuleDeliveryResponse message from the specified reader or buffer.
     * @function decode
     * @memberof ModuleDeliveryResponse
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {ModuleDeliveryResponse} ModuleDeliveryResponse
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    ModuleDeliveryResponse.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ModuleDeliveryResponse();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a ModuleDeliveryResponse message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof ModuleDeliveryResponse
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {ModuleDeliveryResponse} ModuleDeliveryResponse
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    ModuleDeliveryResponse.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a ModuleDeliveryResponse message.
     * @function verify
     * @memberof ModuleDeliveryResponse
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    ModuleDeliveryResponse.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        return null;
    };

    /**
     * Creates a ModuleDeliveryResponse message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof ModuleDeliveryResponse
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {ModuleDeliveryResponse} ModuleDeliveryResponse
     */
    ModuleDeliveryResponse.fromObject = function fromObject(object) {
        if (object instanceof $root.ModuleDeliveryResponse)
            return object;
        return new $root.ModuleDeliveryResponse();
    };

    /**
     * Creates a plain object from a ModuleDeliveryResponse message. Also converts values to other types if specified.
     * @function toObject
     * @memberof ModuleDeliveryResponse
     * @static
     * @param {ModuleDeliveryResponse} message ModuleDeliveryResponse
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    ModuleDeliveryResponse.toObject = function toObject() {
        return {};
    };

    /**
     * Converts this ModuleDeliveryResponse to JSON.
     * @function toJSON
     * @memberof ModuleDeliveryResponse
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    ModuleDeliveryResponse.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return ModuleDeliveryResponse;
})();

$root.PreFetch = (function() {

    /**
     * Properties of a PreFetch.
     * @exports IPreFetch
     * @interface IPreFetch
     * @property {string|null} [url] PreFetch url
     * @property {IResponseWrapper|null} [response] PreFetch response
     * @property {string|null} [etag] PreFetch etag
     * @property {number|Long|null} [ttl] PreFetch ttl
     * @property {number|Long|null} [softTtl] PreFetch softTtl
     */

    /**
     * Constructs a new PreFetch.
     * @exports PreFetch
     * @classdesc Represents a PreFetch.
     * @implements IPreFetch
     * @constructor
     * @param {IPreFetch=} [properties] Properties to set
     */
    function PreFetch(properties) {
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * PreFetch url.
     * @member {string} url
     * @memberof PreFetch
     * @instance
     */
    PreFetch.prototype.url = "";

    /**
     * PreFetch response.
     * @member {IResponseWrapper|null|undefined} response
     * @memberof PreFetch
     * @instance
     */
    PreFetch.prototype.response = null;

    /**
     * PreFetch etag.
     * @member {string} etag
     * @memberof PreFetch
     * @instance
     */
    PreFetch.prototype.etag = "";

    /**
     * PreFetch ttl.
     * @member {number|Long} ttl
     * @memberof PreFetch
     * @instance
     */
    PreFetch.prototype.ttl = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

    /**
     * PreFetch softTtl.
     * @member {number|Long} softTtl
     * @memberof PreFetch
     * @instance
     */
    PreFetch.prototype.softTtl = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

    /**
     * Creates a new PreFetch instance using the specified properties.
     * @function create
     * @memberof PreFetch
     * @static
     * @param {IPreFetch=} [properties] Properties to set
     * @returns {PreFetch} PreFetch instance
     */
    PreFetch.create = function create(properties) {
        return new PreFetch(properties);
    };

    /**
     * Encodes the specified PreFetch message. Does not implicitly {@link PreFetch.verify|verify} messages.
     * @function encode
     * @memberof PreFetch
     * @static
     * @param {IPreFetch} message PreFetch message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    PreFetch.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.url != null && Object.hasOwnProperty.call(message, "url"))
            writer.uint32(/* id 1, wireType 2 =*/10).string(message.url);
        if (message.response != null && Object.hasOwnProperty.call(message, "response"))
            $root.ResponseWrapper.encode(message.response, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
        if (message.etag != null && Object.hasOwnProperty.call(message, "etag"))
            writer.uint32(/* id 3, wireType 2 =*/26).string(message.etag);
        if (message.ttl != null && Object.hasOwnProperty.call(message, "ttl"))
            writer.uint32(/* id 4, wireType 0 =*/32).int64(message.ttl);
        if (message.softTtl != null && Object.hasOwnProperty.call(message, "softTtl"))
            writer.uint32(/* id 5, wireType 0 =*/40).int64(message.softTtl);
        return writer;
    };

    /**
     * Encodes the specified PreFetch message, length delimited. Does not implicitly {@link PreFetch.verify|verify} messages.
     * @function encodeDelimited
     * @memberof PreFetch
     * @static
     * @param {IPreFetch} message PreFetch message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    PreFetch.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a PreFetch message from the specified reader or buffer.
     * @function decode
     * @memberof PreFetch
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {PreFetch} PreFetch
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    PreFetch.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.PreFetch();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.url = reader.string();
                break;
            case 2:
                message.response = $root.ResponseWrapper.decode(reader, reader.uint32());
                break;
            case 3:
                message.etag = reader.string();
                break;
            case 4:
                message.ttl = reader.int64();
                break;
            case 5:
                message.softTtl = reader.int64();
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a PreFetch message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof PreFetch
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {PreFetch} PreFetch
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    PreFetch.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a PreFetch message.
     * @function verify
     * @memberof PreFetch
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    PreFetch.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.url != null && message.hasOwnProperty("url"))
            if (!$util.isString(message.url))
                return "url: string expected";
        if (message.response != null && message.hasOwnProperty("response")) {
            var error = $root.ResponseWrapper.verify(message.response);
            if (error)
                return "response." + error;
        }
        if (message.etag != null && message.hasOwnProperty("etag"))
            if (!$util.isString(message.etag))
                return "etag: string expected";
        if (message.ttl != null && message.hasOwnProperty("ttl"))
            if (!$util.isInteger(message.ttl) && !(message.ttl && $util.isInteger(message.ttl.low) && $util.isInteger(message.ttl.high)))
                return "ttl: integer|Long expected";
        if (message.softTtl != null && message.hasOwnProperty("softTtl"))
            if (!$util.isInteger(message.softTtl) && !(message.softTtl && $util.isInteger(message.softTtl.low) && $util.isInteger(message.softTtl.high)))
                return "softTtl: integer|Long expected";
        return null;
    };

    /**
     * Creates a PreFetch message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof PreFetch
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {PreFetch} PreFetch
     */
    PreFetch.fromObject = function fromObject(object) {
        if (object instanceof $root.PreFetch)
            return object;
        var message = new $root.PreFetch();
        if (object.url != null)
            message.url = String(object.url);
        if (object.response != null) {
            if (typeof object.response !== "object")
                throw TypeError(".PreFetch.response: object expected");
            message.response = $root.ResponseWrapper.fromObject(object.response);
        }
        if (object.etag != null)
            message.etag = String(object.etag);
        if (object.ttl != null)
            if ($util.Long)
                (message.ttl = $util.Long.fromValue(object.ttl)).unsigned = false;
            else if (typeof object.ttl === "string")
                message.ttl = parseInt(object.ttl, 10);
            else if (typeof object.ttl === "number")
                message.ttl = object.ttl;
            else if (typeof object.ttl === "object")
                message.ttl = new $util.LongBits(object.ttl.low >>> 0, object.ttl.high >>> 0).toNumber();
        if (object.softTtl != null)
            if ($util.Long)
                (message.softTtl = $util.Long.fromValue(object.softTtl)).unsigned = false;
            else if (typeof object.softTtl === "string")
                message.softTtl = parseInt(object.softTtl, 10);
            else if (typeof object.softTtl === "number")
                message.softTtl = object.softTtl;
            else if (typeof object.softTtl === "object")
                message.softTtl = new $util.LongBits(object.softTtl.low >>> 0, object.softTtl.high >>> 0).toNumber();
        return message;
    };

    /**
     * Creates a plain object from a PreFetch message. Also converts values to other types if specified.
     * @function toObject
     * @memberof PreFetch
     * @static
     * @param {PreFetch} message PreFetch
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    PreFetch.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        var object = {};
        if (options.defaults) {
            object.url = "";
            object.response = null;
            object.etag = "";
            if ($util.Long) {
                var long = new $util.Long(0, 0, false);
                object.ttl = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
            } else
                object.ttl = options.longs === String ? "0" : 0;
            if ($util.Long) {
                var long = new $util.Long(0, 0, false);
                object.softTtl = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
            } else
                object.softTtl = options.longs === String ? "0" : 0;
        }
        if (message.url != null && message.hasOwnProperty("url"))
            object.url = message.url;
        if (message.response != null && message.hasOwnProperty("response"))
            object.response = $root.ResponseWrapper.toObject(message.response, options);
        if (message.etag != null && message.hasOwnProperty("etag"))
            object.etag = message.etag;
        if (message.ttl != null && message.hasOwnProperty("ttl"))
            if (typeof message.ttl === "number")
                object.ttl = options.longs === String ? String(message.ttl) : message.ttl;
            else
                object.ttl = options.longs === String ? $util.Long.prototype.toString.call(message.ttl) : options.longs === Number ? new $util.LongBits(message.ttl.low >>> 0, message.ttl.high >>> 0).toNumber() : message.ttl;
        if (message.softTtl != null && message.hasOwnProperty("softTtl"))
            if (typeof message.softTtl === "number")
                object.softTtl = options.longs === String ? String(message.softTtl) : message.softTtl;
            else
                object.softTtl = options.longs === String ? $util.Long.prototype.toString.call(message.softTtl) : options.longs === Number ? new $util.LongBits(message.softTtl.low >>> 0, message.softTtl.high >>> 0).toNumber() : message.softTtl;
        return object;
    };

    /**
     * Converts this PreFetch to JSON.
     * @function toJSON
     * @memberof PreFetch
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    PreFetch.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return PreFetch;
})();

$root.ServerMetadata = (function() {

    /**
     * Properties of a ServerMetadata.
     * @exports IServerMetadata
     * @interface IServerMetadata
     * @property {number|Long|null} [latencyMillis] ServerMetadata latencyMillis
     */

    /**
     * Constructs a new ServerMetadata.
     * @exports ServerMetadata
     * @classdesc Represents a ServerMetadata.
     * @implements IServerMetadata
     * @constructor
     * @param {IServerMetadata=} [properties] Properties to set
     */
    function ServerMetadata(properties) {
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * ServerMetadata latencyMillis.
     * @member {number|Long} latencyMillis
     * @memberof ServerMetadata
     * @instance
     */
    ServerMetadata.prototype.latencyMillis = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

    /**
     * Creates a new ServerMetadata instance using the specified properties.
     * @function create
     * @memberof ServerMetadata
     * @static
     * @param {IServerMetadata=} [properties] Properties to set
     * @returns {ServerMetadata} ServerMetadata instance
     */
    ServerMetadata.create = function create(properties) {
        return new ServerMetadata(properties);
    };

    /**
     * Encodes the specified ServerMetadata message. Does not implicitly {@link ServerMetadata.verify|verify} messages.
     * @function encode
     * @memberof ServerMetadata
     * @static
     * @param {IServerMetadata} message ServerMetadata message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    ServerMetadata.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.latencyMillis != null && Object.hasOwnProperty.call(message, "latencyMillis"))
            writer.uint32(/* id 1, wireType 0 =*/8).int64(message.latencyMillis);
        return writer;
    };

    /**
     * Encodes the specified ServerMetadata message, length delimited. Does not implicitly {@link ServerMetadata.verify|verify} messages.
     * @function encodeDelimited
     * @memberof ServerMetadata
     * @static
     * @param {IServerMetadata} message ServerMetadata message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    ServerMetadata.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a ServerMetadata message from the specified reader or buffer.
     * @function decode
     * @memberof ServerMetadata
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {ServerMetadata} ServerMetadata
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    ServerMetadata.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ServerMetadata();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.latencyMillis = reader.int64();
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a ServerMetadata message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof ServerMetadata
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {ServerMetadata} ServerMetadata
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    ServerMetadata.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a ServerMetadata message.
     * @function verify
     * @memberof ServerMetadata
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    ServerMetadata.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.latencyMillis != null && message.hasOwnProperty("latencyMillis"))
            if (!$util.isInteger(message.latencyMillis) && !(message.latencyMillis && $util.isInteger(message.latencyMillis.low) && $util.isInteger(message.latencyMillis.high)))
                return "latencyMillis: integer|Long expected";
        return null;
    };

    /**
     * Creates a ServerMetadata message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof ServerMetadata
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {ServerMetadata} ServerMetadata
     */
    ServerMetadata.fromObject = function fromObject(object) {
        if (object instanceof $root.ServerMetadata)
            return object;
        var message = new $root.ServerMetadata();
        if (object.latencyMillis != null)
            if ($util.Long)
                (message.latencyMillis = $util.Long.fromValue(object.latencyMillis)).unsigned = false;
            else if (typeof object.latencyMillis === "string")
                message.latencyMillis = parseInt(object.latencyMillis, 10);
            else if (typeof object.latencyMillis === "number")
                message.latencyMillis = object.latencyMillis;
            else if (typeof object.latencyMillis === "object")
                message.latencyMillis = new $util.LongBits(object.latencyMillis.low >>> 0, object.latencyMillis.high >>> 0).toNumber();
        return message;
    };

    /**
     * Creates a plain object from a ServerMetadata message. Also converts values to other types if specified.
     * @function toObject
     * @memberof ServerMetadata
     * @static
     * @param {ServerMetadata} message ServerMetadata
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    ServerMetadata.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        var object = {};
        if (options.defaults)
            if ($util.Long) {
                var long = new $util.Long(0, 0, false);
                object.latencyMillis = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
            } else
                object.latencyMillis = options.longs === String ? "0" : 0;
        if (message.latencyMillis != null && message.hasOwnProperty("latencyMillis"))
            if (typeof message.latencyMillis === "number")
                object.latencyMillis = options.longs === String ? String(message.latencyMillis) : message.latencyMillis;
            else
                object.latencyMillis = options.longs === String ? $util.Long.prototype.toString.call(message.latencyMillis) : options.longs === Number ? new $util.LongBits(message.latencyMillis.low >>> 0, message.latencyMillis.high >>> 0).toNumber() : message.latencyMillis;
        return object;
    };

    /**
     * Converts this ServerMetadata to JSON.
     * @function toJSON
     * @memberof ServerMetadata
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    ServerMetadata.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return ServerMetadata;
})();

$root.Targets = (function() {

    /**
     * Properties of a Targets.
     * @exports ITargets
     * @interface ITargets
     * @property {Array.<number|Long>|null} [targetId] Targets targetId
     * @property {Uint8Array|null} [signature] Targets signature
     */

    /**
     * Constructs a new Targets.
     * @exports Targets
     * @classdesc Represents a Targets.
     * @implements ITargets
     * @constructor
     * @param {ITargets=} [properties] Properties to set
     */
    function Targets(properties) {
        this.targetId = [];
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * Targets targetId.
     * @member {Array.<number|Long>} targetId
     * @memberof Targets
     * @instance
     */
    Targets.prototype.targetId = $util.emptyArray;

    /**
     * Targets signature.
     * @member {Uint8Array} signature
     * @memberof Targets
     * @instance
     */
    Targets.prototype.signature = $util.newBuffer([]);

    /**
     * Creates a new Targets instance using the specified properties.
     * @function create
     * @memberof Targets
     * @static
     * @param {ITargets=} [properties] Properties to set
     * @returns {Targets} Targets instance
     */
    Targets.create = function create(properties) {
        return new Targets(properties);
    };

    /**
     * Encodes the specified Targets message. Does not implicitly {@link Targets.verify|verify} messages.
     * @function encode
     * @memberof Targets
     * @static
     * @param {ITargets} message Targets message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    Targets.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.targetId != null && message.targetId.length)
            for (var i = 0; i < message.targetId.length; ++i)
                writer.uint32(/* id 1, wireType 0 =*/8).int64(message.targetId[i]);
        if (message.signature != null && Object.hasOwnProperty.call(message, "signature"))
            writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.signature);
        return writer;
    };

    /**
     * Encodes the specified Targets message, length delimited. Does not implicitly {@link Targets.verify|verify} messages.
     * @function encodeDelimited
     * @memberof Targets
     * @static
     * @param {ITargets} message Targets message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    Targets.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a Targets message from the specified reader or buffer.
     * @function decode
     * @memberof Targets
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {Targets} Targets
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    Targets.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Targets();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                if (!(message.targetId && message.targetId.length))
                    message.targetId = [];
                if ((tag & 7) === 2) {
                    var end2 = reader.uint32() + reader.pos;
                    while (reader.pos < end2)
                        message.targetId.push(reader.int64());
                } else
                    message.targetId.push(reader.int64());
                break;
            case 2:
                message.signature = reader.bytes();
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a Targets message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof Targets
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {Targets} Targets
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    Targets.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a Targets message.
     * @function verify
     * @memberof Targets
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    Targets.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.targetId != null && message.hasOwnProperty("targetId")) {
            if (!Array.isArray(message.targetId))
                return "targetId: array expected";
            for (var i = 0; i < message.targetId.length; ++i)
                if (!$util.isInteger(message.targetId[i]) && !(message.targetId[i] && $util.isInteger(message.targetId[i].low) && $util.isInteger(message.targetId[i].high)))
                    return "targetId: integer|Long[] expected";
        }
        if (message.signature != null && message.hasOwnProperty("signature"))
            if (!(message.signature && typeof message.signature.length === "number" || $util.isString(message.signature)))
                return "signature: buffer expected";
        return null;
    };

    /**
     * Creates a Targets message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof Targets
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {Targets} Targets
     */
    Targets.fromObject = function fromObject(object) {
        if (object instanceof $root.Targets)
            return object;
        var message = new $root.Targets();
        if (object.targetId) {
            if (!Array.isArray(object.targetId))
                throw TypeError(".Targets.targetId: array expected");
            message.targetId = [];
            for (var i = 0; i < object.targetId.length; ++i)
                if ($util.Long)
                    (message.targetId[i] = $util.Long.fromValue(object.targetId[i])).unsigned = false;
                else if (typeof object.targetId[i] === "string")
                    message.targetId[i] = parseInt(object.targetId[i], 10);
                else if (typeof object.targetId[i] === "number")
                    message.targetId[i] = object.targetId[i];
                else if (typeof object.targetId[i] === "object")
                    message.targetId[i] = new $util.LongBits(object.targetId[i].low >>> 0, object.targetId[i].high >>> 0).toNumber();
        }
        if (object.signature != null)
            if (typeof object.signature === "string")
                $util.base64.decode(object.signature, message.signature = $util.newBuffer($util.base64.length(object.signature)), 0);
            else if (object.signature.length)
                message.signature = object.signature;
        return message;
    };

    /**
     * Creates a plain object from a Targets message. Also converts values to other types if specified.
     * @function toObject
     * @memberof Targets
     * @static
     * @param {Targets} message Targets
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    Targets.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        var object = {};
        if (options.arrays || options.defaults)
            object.targetId = [];
        if (options.defaults)
            if (options.bytes === String)
                object.signature = "";
            else {
                object.signature = [];
                if (options.bytes !== Array)
                    object.signature = $util.newBuffer(object.signature);
            }
        if (message.targetId && message.targetId.length) {
            object.targetId = [];
            for (var j = 0; j < message.targetId.length; ++j)
                if (typeof message.targetId[j] === "number")
                    object.targetId[j] = options.longs === String ? String(message.targetId[j]) : message.targetId[j];
                else
                    object.targetId[j] = options.longs === String ? $util.Long.prototype.toString.call(message.targetId[j]) : options.longs === Number ? new $util.LongBits(message.targetId[j].low >>> 0, message.targetId[j].high >>> 0).toNumber() : message.targetId[j];
        }
        if (message.signature != null && message.hasOwnProperty("signature"))
            object.signature = options.bytes === String ? $util.base64.encode(message.signature, 0, message.signature.length) : options.bytes === Array ? Array.prototype.slice.call(message.signature) : message.signature;
        return object;
    };

    /**
     * Converts this Targets to JSON.
     * @function toJSON
     * @memberof Targets
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    Targets.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return Targets;
})();

$root.ServerCookie = (function() {

    /**
     * Properties of a ServerCookie.
     * @exports IServerCookie
     * @interface IServerCookie
     * @property {number|null} [type] ServerCookie type
     * @property {Uint8Array|null} [token] ServerCookie token
     */

    /**
     * Constructs a new ServerCookie.
     * @exports ServerCookie
     * @classdesc Represents a ServerCookie.
     * @implements IServerCookie
     * @constructor
     * @param {IServerCookie=} [properties] Properties to set
     */
    function ServerCookie(properties) {
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * ServerCookie type.
     * @member {number} type
     * @memberof ServerCookie
     * @instance
     */
    ServerCookie.prototype.type = 0;

    /**
     * ServerCookie token.
     * @member {Uint8Array} token
     * @memberof ServerCookie
     * @instance
     */
    ServerCookie.prototype.token = $util.newBuffer([]);

    /**
     * Creates a new ServerCookie instance using the specified properties.
     * @function create
     * @memberof ServerCookie
     * @static
     * @param {IServerCookie=} [properties] Properties to set
     * @returns {ServerCookie} ServerCookie instance
     */
    ServerCookie.create = function create(properties) {
        return new ServerCookie(properties);
    };

    /**
     * Encodes the specified ServerCookie message. Does not implicitly {@link ServerCookie.verify|verify} messages.
     * @function encode
     * @memberof ServerCookie
     * @static
     * @param {IServerCookie} message ServerCookie message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    ServerCookie.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.type != null && Object.hasOwnProperty.call(message, "type"))
            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.type);
        if (message.token != null && Object.hasOwnProperty.call(message, "token"))
            writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.token);
        return writer;
    };

    /**
     * Encodes the specified ServerCookie message, length delimited. Does not implicitly {@link ServerCookie.verify|verify} messages.
     * @function encodeDelimited
     * @memberof ServerCookie
     * @static
     * @param {IServerCookie} message ServerCookie message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    ServerCookie.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a ServerCookie message from the specified reader or buffer.
     * @function decode
     * @memberof ServerCookie
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {ServerCookie} ServerCookie
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    ServerCookie.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ServerCookie();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.type = reader.int32();
                break;
            case 2:
                message.token = reader.bytes();
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a ServerCookie message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof ServerCookie
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {ServerCookie} ServerCookie
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    ServerCookie.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a ServerCookie message.
     * @function verify
     * @memberof ServerCookie
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    ServerCookie.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.type != null && message.hasOwnProperty("type"))
            if (!$util.isInteger(message.type))
                return "type: integer expected";
        if (message.token != null && message.hasOwnProperty("token"))
            if (!(message.token && typeof message.token.length === "number" || $util.isString(message.token)))
                return "token: buffer expected";
        return null;
    };

    /**
     * Creates a ServerCookie message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof ServerCookie
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {ServerCookie} ServerCookie
     */
    ServerCookie.fromObject = function fromObject(object) {
        if (object instanceof $root.ServerCookie)
            return object;
        var message = new $root.ServerCookie();
        if (object.type != null)
            message.type = object.type | 0;
        if (object.token != null)
            if (typeof object.token === "string")
                $util.base64.decode(object.token, message.token = $util.newBuffer($util.base64.length(object.token)), 0);
            else if (object.token.length)
                message.token = object.token;
        return message;
    };

    /**
     * Creates a plain object from a ServerCookie message. Also converts values to other types if specified.
     * @function toObject
     * @memberof ServerCookie
     * @static
     * @param {ServerCookie} message ServerCookie
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    ServerCookie.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        var object = {};
        if (options.defaults) {
            object.type = 0;
            if (options.bytes === String)
                object.token = "";
            else {
                object.token = [];
                if (options.bytes !== Array)
                    object.token = $util.newBuffer(object.token);
            }
        }
        if (message.type != null && message.hasOwnProperty("type"))
            object.type = message.type;
        if (message.token != null && message.hasOwnProperty("token"))
            object.token = options.bytes === String ? $util.base64.encode(message.token, 0, message.token.length) : options.bytes === Array ? Array.prototype.slice.call(message.token) : message.token;
        return object;
    };

    /**
     * Converts this ServerCookie to JSON.
     * @function toJSON
     * @memberof ServerCookie
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    ServerCookie.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return ServerCookie;
})();

$root.ServerCookies = (function() {

    /**
     * Properties of a ServerCookies.
     * @exports IServerCookies
     * @interface IServerCookies
     * @property {Array.<IServerCookie>|null} [serverCookie] ServerCookies serverCookie
     */

    /**
     * Constructs a new ServerCookies.
     * @exports ServerCookies
     * @classdesc Represents a ServerCookies.
     * @implements IServerCookies
     * @constructor
     * @param {IServerCookies=} [properties] Properties to set
     */
    function ServerCookies(properties) {
        this.serverCookie = [];
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * ServerCookies serverCookie.
     * @member {Array.<IServerCookie>} serverCookie
     * @memberof ServerCookies
     * @instance
     */
    ServerCookies.prototype.serverCookie = $util.emptyArray;

    /**
     * Creates a new ServerCookies instance using the specified properties.
     * @function create
     * @memberof ServerCookies
     * @static
     * @param {IServerCookies=} [properties] Properties to set
     * @returns {ServerCookies} ServerCookies instance
     */
    ServerCookies.create = function create(properties) {
        return new ServerCookies(properties);
    };

    /**
     * Encodes the specified ServerCookies message. Does not implicitly {@link ServerCookies.verify|verify} messages.
     * @function encode
     * @memberof ServerCookies
     * @static
     * @param {IServerCookies} message ServerCookies message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    ServerCookies.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.serverCookie != null && message.serverCookie.length)
            for (var i = 0; i < message.serverCookie.length; ++i)
                $root.ServerCookie.encode(message.serverCookie[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
        return writer;
    };

    /**
     * Encodes the specified ServerCookies message, length delimited. Does not implicitly {@link ServerCookies.verify|verify} messages.
     * @function encodeDelimited
     * @memberof ServerCookies
     * @static
     * @param {IServerCookies} message ServerCookies message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    ServerCookies.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a ServerCookies message from the specified reader or buffer.
     * @function decode
     * @memberof ServerCookies
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {ServerCookies} ServerCookies
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    ServerCookies.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ServerCookies();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                if (!(message.serverCookie && message.serverCookie.length))
                    message.serverCookie = [];
                message.serverCookie.push($root.ServerCookie.decode(reader, reader.uint32()));
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a ServerCookies message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof ServerCookies
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {ServerCookies} ServerCookies
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    ServerCookies.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a ServerCookies message.
     * @function verify
     * @memberof ServerCookies
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    ServerCookies.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.serverCookie != null && message.hasOwnProperty("serverCookie")) {
            if (!Array.isArray(message.serverCookie))
                return "serverCookie: array expected";
            for (var i = 0; i < message.serverCookie.length; ++i) {
                var error = $root.ServerCookie.verify(message.serverCookie[i]);
                if (error)
                    return "serverCookie." + error;
            }
        }
        return null;
    };

    /**
     * Creates a ServerCookies message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof ServerCookies
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {ServerCookies} ServerCookies
     */
    ServerCookies.fromObject = function fromObject(object) {
        if (object instanceof $root.ServerCookies)
            return object;
        var message = new $root.ServerCookies();
        if (object.serverCookie) {
            if (!Array.isArray(object.serverCookie))
                throw TypeError(".ServerCookies.serverCookie: array expected");
            message.serverCookie = [];
            for (var i = 0; i < object.serverCookie.length; ++i) {
                if (typeof object.serverCookie[i] !== "object")
                    throw TypeError(".ServerCookies.serverCookie: object expected");
                message.serverCookie[i] = $root.ServerCookie.fromObject(object.serverCookie[i]);
            }
        }
        return message;
    };

    /**
     * Creates a plain object from a ServerCookies message. Also converts values to other types if specified.
     * @function toObject
     * @memberof ServerCookies
     * @static
     * @param {ServerCookies} message ServerCookies
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    ServerCookies.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        var object = {};
        if (options.arrays || options.defaults)
            object.serverCookie = [];
        if (message.serverCookie && message.serverCookie.length) {
            object.serverCookie = [];
            for (var j = 0; j < message.serverCookie.length; ++j)
                object.serverCookie[j] = $root.ServerCookie.toObject(message.serverCookie[j], options);
        }
        return object;
    };

    /**
     * Converts this ServerCookies to JSON.
     * @function toJSON
     * @memberof ServerCookies
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    ServerCookies.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return ServerCookies;
})();

$root.ResponseWrapper = (function() {

    /**
     * Properties of a ResponseWrapper.
     * @exports IResponseWrapper
     * @interface IResponseWrapper
     * @property {IPayload|null} [payload] ResponseWrapper payload
     * @property {IServerCommands|null} [commands] ResponseWrapper commands
     * @property {Array.<IPreFetch>|null} [preFetch] ResponseWrapper preFetch
     * @property {Array.<INotification>|null} [notification] ResponseWrapper notification
     * @property {IServerMetadata|null} [serverMetadata] ResponseWrapper serverMetadata
     * @property {ITargets|null} [targets] ResponseWrapper targets
     * @property {IServerCookies|null} [serverCookies] ResponseWrapper serverCookies
     * @property {Uint8Array|null} [serverLogsCookie] ResponseWrapper serverLogsCookie
     */

    /**
     * Constructs a new ResponseWrapper.
     * @exports ResponseWrapper
     * @classdesc Represents a ResponseWrapper.
     * @implements IResponseWrapper
     * @constructor
     * @param {IResponseWrapper=} [properties] Properties to set
     */
    function ResponseWrapper(properties) {
        this.preFetch = [];
        this.notification = [];
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * ResponseWrapper payload.
     * @member {IPayload|null|undefined} payload
     * @memberof ResponseWrapper
     * @instance
     */
    ResponseWrapper.prototype.payload = null;

    /**
     * ResponseWrapper commands.
     * @member {IServerCommands|null|undefined} commands
     * @memberof ResponseWrapper
     * @instance
     */
    ResponseWrapper.prototype.commands = null;

    /**
     * ResponseWrapper preFetch.
     * @member {Array.<IPreFetch>} preFetch
     * @memberof ResponseWrapper
     * @instance
     */
    ResponseWrapper.prototype.preFetch = $util.emptyArray;

    /**
     * ResponseWrapper notification.
     * @member {Array.<INotification>} notification
     * @memberof ResponseWrapper
     * @instance
     */
    ResponseWrapper.prototype.notification = $util.emptyArray;

    /**
     * ResponseWrapper serverMetadata.
     * @member {IServerMetadata|null|undefined} serverMetadata
     * @memberof ResponseWrapper
     * @instance
     */
    ResponseWrapper.prototype.serverMetadata = null;

    /**
     * ResponseWrapper targets.
     * @member {ITargets|null|undefined} targets
     * @memberof ResponseWrapper
     * @instance
     */
    ResponseWrapper.prototype.targets = null;

    /**
     * ResponseWrapper serverCookies.
     * @member {IServerCookies|null|undefined} serverCookies
     * @memberof ResponseWrapper
     * @instance
     */
    ResponseWrapper.prototype.serverCookies = null;

    /**
     * ResponseWrapper serverLogsCookie.
     * @member {Uint8Array} serverLogsCookie
     * @memberof ResponseWrapper
     * @instance
     */
    ResponseWrapper.prototype.serverLogsCookie = $util.newBuffer([]);

    /**
     * Creates a new ResponseWrapper instance using the specified properties.
     * @function create
     * @memberof ResponseWrapper
     * @static
     * @param {IResponseWrapper=} [properties] Properties to set
     * @returns {ResponseWrapper} ResponseWrapper instance
     */
    ResponseWrapper.create = function create(properties) {
        return new ResponseWrapper(properties);
    };

    /**
     * Encodes the specified ResponseWrapper message. Does not implicitly {@link ResponseWrapper.verify|verify} messages.
     * @function encode
     * @memberof ResponseWrapper
     * @static
     * @param {IResponseWrapper} message ResponseWrapper message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    ResponseWrapper.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.payload != null && Object.hasOwnProperty.call(message, "payload"))
            $root.Payload.encode(message.payload, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
        if (message.commands != null && Object.hasOwnProperty.call(message, "commands"))
            $root.ServerCommands.encode(message.commands, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
        if (message.preFetch != null && message.preFetch.length)
            for (var i = 0; i < message.preFetch.length; ++i)
                $root.PreFetch.encode(message.preFetch[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
        if (message.notification != null && message.notification.length)
            for (var i = 0; i < message.notification.length; ++i)
                $root.Notification.encode(message.notification[i], writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
        if (message.serverMetadata != null && Object.hasOwnProperty.call(message, "serverMetadata"))
            $root.ServerMetadata.encode(message.serverMetadata, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
        if (message.targets != null && Object.hasOwnProperty.call(message, "targets"))
            $root.Targets.encode(message.targets, writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
        if (message.serverCookies != null && Object.hasOwnProperty.call(message, "serverCookies"))
            $root.ServerCookies.encode(message.serverCookies, writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
        if (message.serverLogsCookie != null && Object.hasOwnProperty.call(message, "serverLogsCookie"))
            writer.uint32(/* id 9, wireType 2 =*/74).bytes(message.serverLogsCookie);
        return writer;
    };

    /**
     * Encodes the specified ResponseWrapper message, length delimited. Does not implicitly {@link ResponseWrapper.verify|verify} messages.
     * @function encodeDelimited
     * @memberof ResponseWrapper
     * @static
     * @param {IResponseWrapper} message ResponseWrapper message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    ResponseWrapper.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a ResponseWrapper message from the specified reader or buffer.
     * @function decode
     * @memberof ResponseWrapper
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {ResponseWrapper} ResponseWrapper
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    ResponseWrapper.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ResponseWrapper();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.payload = $root.Payload.decode(reader, reader.uint32());
                break;
            case 2:
                message.commands = $root.ServerCommands.decode(reader, reader.uint32());
                break;
            case 3:
                if (!(message.preFetch && message.preFetch.length))
                    message.preFetch = [];
                message.preFetch.push($root.PreFetch.decode(reader, reader.uint32()));
                break;
            case 4:
                if (!(message.notification && message.notification.length))
                    message.notification = [];
                message.notification.push($root.Notification.decode(reader, reader.uint32()));
                break;
            case 5:
                message.serverMetadata = $root.ServerMetadata.decode(reader, reader.uint32());
                break;
            case 6:
                message.targets = $root.Targets.decode(reader, reader.uint32());
                break;
            case 7:
                message.serverCookies = $root.ServerCookies.decode(reader, reader.uint32());
                break;
            case 9:
                message.serverLogsCookie = reader.bytes();
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a ResponseWrapper message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof ResponseWrapper
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {ResponseWrapper} ResponseWrapper
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    ResponseWrapper.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a ResponseWrapper message.
     * @function verify
     * @memberof ResponseWrapper
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    ResponseWrapper.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.payload != null && message.hasOwnProperty("payload")) {
            var error = $root.Payload.verify(message.payload);
            if (error)
                return "payload." + error;
        }
        if (message.commands != null && message.hasOwnProperty("commands")) {
            var error = $root.ServerCommands.verify(message.commands);
            if (error)
                return "commands." + error;
        }
        if (message.preFetch != null && message.hasOwnProperty("preFetch")) {
            if (!Array.isArray(message.preFetch))
                return "preFetch: array expected";
            for (var i = 0; i < message.preFetch.length; ++i) {
                var error = $root.PreFetch.verify(message.preFetch[i]);
                if (error)
                    return "preFetch." + error;
            }
        }
        if (message.notification != null && message.hasOwnProperty("notification")) {
            if (!Array.isArray(message.notification))
                return "notification: array expected";
            for (var i = 0; i < message.notification.length; ++i) {
                var error = $root.Notification.verify(message.notification[i]);
                if (error)
                    return "notification." + error;
            }
        }
        if (message.serverMetadata != null && message.hasOwnProperty("serverMetadata")) {
            var error = $root.ServerMetadata.verify(message.serverMetadata);
            if (error)
                return "serverMetadata." + error;
        }
        if (message.targets != null && message.hasOwnProperty("targets")) {
            var error = $root.Targets.verify(message.targets);
            if (error)
                return "targets." + error;
        }
        if (message.serverCookies != null && message.hasOwnProperty("serverCookies")) {
            var error = $root.ServerCookies.verify(message.serverCookies);
            if (error)
                return "serverCookies." + error;
        }
        if (message.serverLogsCookie != null && message.hasOwnProperty("serverLogsCookie"))
            if (!(message.serverLogsCookie && typeof message.serverLogsCookie.length === "number" || $util.isString(message.serverLogsCookie)))
                return "serverLogsCookie: buffer expected";
        return null;
    };

    /**
     * Creates a ResponseWrapper message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof ResponseWrapper
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {ResponseWrapper} ResponseWrapper
     */
    ResponseWrapper.fromObject = function fromObject(object) {
        if (object instanceof $root.ResponseWrapper)
            return object;
        var message = new $root.ResponseWrapper();
        if (object.payload != null) {
            if (typeof object.payload !== "object")
                throw TypeError(".ResponseWrapper.payload: object expected");
            message.payload = $root.Payload.fromObject(object.payload);
        }
        if (object.commands != null) {
            if (typeof object.commands !== "object")
                throw TypeError(".ResponseWrapper.commands: object expected");
            message.commands = $root.ServerCommands.fromObject(object.commands);
        }
        if (object.preFetch) {
            if (!Array.isArray(object.preFetch))
                throw TypeError(".ResponseWrapper.preFetch: array expected");
            message.preFetch = [];
            for (var i = 0; i < object.preFetch.length; ++i) {
                if (typeof object.preFetch[i] !== "object")
                    throw TypeError(".ResponseWrapper.preFetch: object expected");
                message.preFetch[i] = $root.PreFetch.fromObject(object.preFetch[i]);
            }
        }
        if (object.notification) {
            if (!Array.isArray(object.notification))
                throw TypeError(".ResponseWrapper.notification: array expected");
            message.notification = [];
            for (var i = 0; i < object.notification.length; ++i) {
                if (typeof object.notification[i] !== "object")
                    throw TypeError(".ResponseWrapper.notification: object expected");
                message.notification[i] = $root.Notification.fromObject(object.notification[i]);
            }
        }
        if (object.serverMetadata != null) {
            if (typeof object.serverMetadata !== "object")
                throw TypeError(".ResponseWrapper.serverMetadata: object expected");
            message.serverMetadata = $root.ServerMetadata.fromObject(object.serverMetadata);
        }
        if (object.targets != null) {
            if (typeof object.targets !== "object")
                throw TypeError(".ResponseWrapper.targets: object expected");
            message.targets = $root.Targets.fromObject(object.targets);
        }
        if (object.serverCookies != null) {
            if (typeof object.serverCookies !== "object")
                throw TypeError(".ResponseWrapper.serverCookies: object expected");
            message.serverCookies = $root.ServerCookies.fromObject(object.serverCookies);
        }
        if (object.serverLogsCookie != null)
            if (typeof object.serverLogsCookie === "string")
                $util.base64.decode(object.serverLogsCookie, message.serverLogsCookie = $util.newBuffer($util.base64.length(object.serverLogsCookie)), 0);
            else if (object.serverLogsCookie.length)
                message.serverLogsCookie = object.serverLogsCookie;
        return message;
    };

    /**
     * Creates a plain object from a ResponseWrapper message. Also converts values to other types if specified.
     * @function toObject
     * @memberof ResponseWrapper
     * @static
     * @param {ResponseWrapper} message ResponseWrapper
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    ResponseWrapper.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        var object = {};
        if (options.arrays || options.defaults) {
            object.preFetch = [];
            object.notification = [];
        }
        if (options.defaults) {
            object.payload = null;
            object.commands = null;
            object.serverMetadata = null;
            object.targets = null;
            object.serverCookies = null;
            if (options.bytes === String)
                object.serverLogsCookie = "";
            else {
                object.serverLogsCookie = [];
                if (options.bytes !== Array)
                    object.serverLogsCookie = $util.newBuffer(object.serverLogsCookie);
            }
        }
        if (message.payload != null && message.hasOwnProperty("payload"))
            object.payload = $root.Payload.toObject(message.payload, options);
        if (message.commands != null && message.hasOwnProperty("commands"))
            object.commands = $root.ServerCommands.toObject(message.commands, options);
        if (message.preFetch && message.preFetch.length) {
            object.preFetch = [];
            for (var j = 0; j < message.preFetch.length; ++j)
                object.preFetch[j] = $root.PreFetch.toObject(message.preFetch[j], options);
        }
        if (message.notification && message.notification.length) {
            object.notification = [];
            for (var j = 0; j < message.notification.length; ++j)
                object.notification[j] = $root.Notification.toObject(message.notification[j], options);
        }
        if (message.serverMetadata != null && message.hasOwnProperty("serverMetadata"))
            object.serverMetadata = $root.ServerMetadata.toObject(message.serverMetadata, options);
        if (message.targets != null && message.hasOwnProperty("targets"))
            object.targets = $root.Targets.toObject(message.targets, options);
        if (message.serverCookies != null && message.hasOwnProperty("serverCookies"))
            object.serverCookies = $root.ServerCookies.toObject(message.serverCookies, options);
        if (message.serverLogsCookie != null && message.hasOwnProperty("serverLogsCookie"))
            object.serverLogsCookie = options.bytes === String ? $util.base64.encode(message.serverLogsCookie, 0, message.serverLogsCookie.length) : options.bytes === Array ? Array.prototype.slice.call(message.serverLogsCookie) : message.serverLogsCookie;
        return object;
    };

    /**
     * Converts this ResponseWrapper to JSON.
     * @function toJSON
     * @memberof ResponseWrapper
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    ResponseWrapper.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return ResponseWrapper;
})();

$root.ResponseWrapperApi = (function() {

    /**
     * Properties of a ResponseWrapperApi.
     * @exports IResponseWrapperApi
     * @interface IResponseWrapperApi
     * @property {IPayloadApi|null} [payload] ResponseWrapperApi payload
     */

    /**
     * Constructs a new ResponseWrapperApi.
     * @exports ResponseWrapperApi
     * @classdesc Represents a ResponseWrapperApi.
     * @implements IResponseWrapperApi
     * @constructor
     * @param {IResponseWrapperApi=} [properties] Properties to set
     */
    function ResponseWrapperApi(properties) {
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * ResponseWrapperApi payload.
     * @member {IPayloadApi|null|undefined} payload
     * @memberof ResponseWrapperApi
     * @instance
     */
    ResponseWrapperApi.prototype.payload = null;

    /**
     * Creates a new ResponseWrapperApi instance using the specified properties.
     * @function create
     * @memberof ResponseWrapperApi
     * @static
     * @param {IResponseWrapperApi=} [properties] Properties to set
     * @returns {ResponseWrapperApi} ResponseWrapperApi instance
     */
    ResponseWrapperApi.create = function create(properties) {
        return new ResponseWrapperApi(properties);
    };

    /**
     * Encodes the specified ResponseWrapperApi message. Does not implicitly {@link ResponseWrapperApi.verify|verify} messages.
     * @function encode
     * @memberof ResponseWrapperApi
     * @static
     * @param {IResponseWrapperApi} message ResponseWrapperApi message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    ResponseWrapperApi.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.payload != null && Object.hasOwnProperty.call(message, "payload"))
            $root.PayloadApi.encode(message.payload, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
        return writer;
    };

    /**
     * Encodes the specified ResponseWrapperApi message, length delimited. Does not implicitly {@link ResponseWrapperApi.verify|verify} messages.
     * @function encodeDelimited
     * @memberof ResponseWrapperApi
     * @static
     * @param {IResponseWrapperApi} message ResponseWrapperApi message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    ResponseWrapperApi.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a ResponseWrapperApi message from the specified reader or buffer.
     * @function decode
     * @memberof ResponseWrapperApi
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {ResponseWrapperApi} ResponseWrapperApi
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    ResponseWrapperApi.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ResponseWrapperApi();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.payload = $root.PayloadApi.decode(reader, reader.uint32());
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a ResponseWrapperApi message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof ResponseWrapperApi
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {ResponseWrapperApi} ResponseWrapperApi
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    ResponseWrapperApi.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a ResponseWrapperApi message.
     * @function verify
     * @memberof ResponseWrapperApi
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    ResponseWrapperApi.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.payload != null && message.hasOwnProperty("payload")) {
            var error = $root.PayloadApi.verify(message.payload);
            if (error)
                return "payload." + error;
        }
        return null;
    };

    /**
     * Creates a ResponseWrapperApi message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof ResponseWrapperApi
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {ResponseWrapperApi} ResponseWrapperApi
     */
    ResponseWrapperApi.fromObject = function fromObject(object) {
        if (object instanceof $root.ResponseWrapperApi)
            return object;
        var message = new $root.ResponseWrapperApi();
        if (object.payload != null) {
            if (typeof object.payload !== "object")
                throw TypeError(".ResponseWrapperApi.payload: object expected");
            message.payload = $root.PayloadApi.fromObject(object.payload);
        }
        return message;
    };

    /**
     * Creates a plain object from a ResponseWrapperApi message. Also converts values to other types if specified.
     * @function toObject
     * @memberof ResponseWrapperApi
     * @static
     * @param {ResponseWrapperApi} message ResponseWrapperApi
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    ResponseWrapperApi.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        var object = {};
        if (options.defaults)
            object.payload = null;
        if (message.payload != null && message.hasOwnProperty("payload"))
            object.payload = $root.PayloadApi.toObject(message.payload, options);
        return object;
    };

    /**
     * Converts this ResponseWrapperApi to JSON.
     * @function toJSON
     * @memberof ResponseWrapperApi
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    ResponseWrapperApi.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return ResponseWrapperApi;
})();

$root.PayloadApi = (function() {

    /**
     * Properties of a PayloadApi.
     * @exports IPayloadApi
     * @interface IPayloadApi
     * @property {IUserProfileResponse|null} [userProfileResponse] PayloadApi userProfileResponse
     */

    /**
     * Constructs a new PayloadApi.
     * @exports PayloadApi
     * @classdesc Represents a PayloadApi.
     * @implements IPayloadApi
     * @constructor
     * @param {IPayloadApi=} [properties] Properties to set
     */
    function PayloadApi(properties) {
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * PayloadApi userProfileResponse.
     * @member {IUserProfileResponse|null|undefined} userProfileResponse
     * @memberof PayloadApi
     * @instance
     */
    PayloadApi.prototype.userProfileResponse = null;

    /**
     * Creates a new PayloadApi instance using the specified properties.
     * @function create
     * @memberof PayloadApi
     * @static
     * @param {IPayloadApi=} [properties] Properties to set
     * @returns {PayloadApi} PayloadApi instance
     */
    PayloadApi.create = function create(properties) {
        return new PayloadApi(properties);
    };

    /**
     * Encodes the specified PayloadApi message. Does not implicitly {@link PayloadApi.verify|verify} messages.
     * @function encode
     * @memberof PayloadApi
     * @static
     * @param {IPayloadApi} message PayloadApi message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    PayloadApi.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.userProfileResponse != null && Object.hasOwnProperty.call(message, "userProfileResponse"))
            $root.UserProfileResponse.encode(message.userProfileResponse, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
        return writer;
    };

    /**
     * Encodes the specified PayloadApi message, length delimited. Does not implicitly {@link PayloadApi.verify|verify} messages.
     * @function encodeDelimited
     * @memberof PayloadApi
     * @static
     * @param {IPayloadApi} message PayloadApi message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    PayloadApi.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a PayloadApi message from the specified reader or buffer.
     * @function decode
     * @memberof PayloadApi
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {PayloadApi} PayloadApi
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    PayloadApi.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.PayloadApi();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            case 5:
                message.userProfileResponse = $root.UserProfileResponse.decode(reader, reader.uint32());
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a PayloadApi message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof PayloadApi
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {PayloadApi} PayloadApi
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    PayloadApi.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a PayloadApi message.
     * @function verify
     * @memberof PayloadApi
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    PayloadApi.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.userProfileResponse != null && message.hasOwnProperty("userProfileResponse")) {
            var error = $root.UserProfileResponse.verify(message.userProfileResponse);
            if (error)
                return "userProfileResponse." + error;
        }
        return null;
    };

    /**
     * Creates a PayloadApi message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof PayloadApi
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {PayloadApi} PayloadApi
     */
    PayloadApi.fromObject = function fromObject(object) {
        if (object instanceof $root.PayloadApi)
            return object;
        var message = new $root.PayloadApi();
        if (object.userProfileResponse != null) {
            if (typeof object.userProfileResponse !== "object")
                throw TypeError(".PayloadApi.userProfileResponse: object expected");
            message.userProfileResponse = $root.UserProfileResponse.fromObject(object.userProfileResponse);
        }
        return message;
    };

    /**
     * Creates a plain object from a PayloadApi message. Also converts values to other types if specified.
     * @function toObject
     * @memberof PayloadApi
     * @static
     * @param {PayloadApi} message PayloadApi
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    PayloadApi.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        var object = {};
        if (options.defaults)
            object.userProfileResponse = null;
        if (message.userProfileResponse != null && message.hasOwnProperty("userProfileResponse"))
            object.userProfileResponse = $root.UserProfileResponse.toObject(message.userProfileResponse, options);
        return object;
    };

    /**
     * Converts this PayloadApi to JSON.
     * @function toJSON
     * @memberof PayloadApi
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    PayloadApi.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return PayloadApi;
})();

$root.UserProfileResponse = (function() {

    /**
     * Properties of a UserProfileResponse.
     * @exports IUserProfileResponse
     * @interface IUserProfileResponse
     * @property {IUserProfile|null} [userProfile] UserProfileResponse userProfile
     */

    /**
     * Constructs a new UserProfileResponse.
     * @exports UserProfileResponse
     * @classdesc Represents a UserProfileResponse.
     * @implements IUserProfileResponse
     * @constructor
     * @param {IUserProfileResponse=} [properties] Properties to set
     */
    function UserProfileResponse(properties) {
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * UserProfileResponse userProfile.
     * @member {IUserProfile|null|undefined} userProfile
     * @memberof UserProfileResponse
     * @instance
     */
    UserProfileResponse.prototype.userProfile = null;

    /**
     * Creates a new UserProfileResponse instance using the specified properties.
     * @function create
     * @memberof UserProfileResponse
     * @static
     * @param {IUserProfileResponse=} [properties] Properties to set
     * @returns {UserProfileResponse} UserProfileResponse instance
     */
    UserProfileResponse.create = function create(properties) {
        return new UserProfileResponse(properties);
    };

    /**
     * Encodes the specified UserProfileResponse message. Does not implicitly {@link UserProfileResponse.verify|verify} messages.
     * @function encode
     * @memberof UserProfileResponse
     * @static
     * @param {IUserProfileResponse} message UserProfileResponse message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    UserProfileResponse.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.userProfile != null && Object.hasOwnProperty.call(message, "userProfile"))
            $root.UserProfile.encode(message.userProfile, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
        return writer;
    };

    /**
     * Encodes the specified UserProfileResponse message, length delimited. Does not implicitly {@link UserProfileResponse.verify|verify} messages.
     * @function encodeDelimited
     * @memberof UserProfileResponse
     * @static
     * @param {IUserProfileResponse} message UserProfileResponse message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    UserProfileResponse.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a UserProfileResponse message from the specified reader or buffer.
     * @function decode
     * @memberof UserProfileResponse
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {UserProfileResponse} UserProfileResponse
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    UserProfileResponse.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.UserProfileResponse();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.userProfile = $root.UserProfile.decode(reader, reader.uint32());
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a UserProfileResponse message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof UserProfileResponse
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {UserProfileResponse} UserProfileResponse
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    UserProfileResponse.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a UserProfileResponse message.
     * @function verify
     * @memberof UserProfileResponse
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    UserProfileResponse.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.userProfile != null && message.hasOwnProperty("userProfile")) {
            var error = $root.UserProfile.verify(message.userProfile);
            if (error)
                return "userProfile." + error;
        }
        return null;
    };

    /**
     * Creates a UserProfileResponse message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof UserProfileResponse
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {UserProfileResponse} UserProfileResponse
     */
    UserProfileResponse.fromObject = function fromObject(object) {
        if (object instanceof $root.UserProfileResponse)
            return object;
        var message = new $root.UserProfileResponse();
        if (object.userProfile != null) {
            if (typeof object.userProfile !== "object")
                throw TypeError(".UserProfileResponse.userProfile: object expected");
            message.userProfile = $root.UserProfile.fromObject(object.userProfile);
        }
        return message;
    };

    /**
     * Creates a plain object from a UserProfileResponse message. Also converts values to other types if specified.
     * @function toObject
     * @memberof UserProfileResponse
     * @static
     * @param {UserProfileResponse} message UserProfileResponse
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    UserProfileResponse.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        var object = {};
        if (options.defaults)
            object.userProfile = null;
        if (message.userProfile != null && message.hasOwnProperty("userProfile"))
            object.userProfile = $root.UserProfile.toObject(message.userProfile, options);
        return object;
    };

    /**
     * Converts this UserProfileResponse to JSON.
     * @function toJSON
     * @memberof UserProfileResponse
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    UserProfileResponse.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return UserProfileResponse;
})();

$root.ServerCommands = (function() {

    /**
     * Properties of a ServerCommands.
     * @exports IServerCommands
     * @interface IServerCommands
     * @property {boolean|null} [clearCache] ServerCommands clearCache
     * @property {string|null} [displayErrorMessage] ServerCommands displayErrorMessage
     * @property {string|null} [logErrorStacktrace] ServerCommands logErrorStacktrace
     */

    /**
     * Constructs a new ServerCommands.
     * @exports ServerCommands
     * @classdesc Represents a ServerCommands.
     * @implements IServerCommands
     * @constructor
     * @param {IServerCommands=} [properties] Properties to set
     */
    function ServerCommands(properties) {
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * ServerCommands clearCache.
     * @member {boolean} clearCache
     * @memberof ServerCommands
     * @instance
     */
    ServerCommands.prototype.clearCache = false;

    /**
     * ServerCommands displayErrorMessage.
     * @member {string} displayErrorMessage
     * @memberof ServerCommands
     * @instance
     */
    ServerCommands.prototype.displayErrorMessage = "";

    /**
     * ServerCommands logErrorStacktrace.
     * @member {string} logErrorStacktrace
     * @memberof ServerCommands
     * @instance
     */
    ServerCommands.prototype.logErrorStacktrace = "";

    /**
     * Creates a new ServerCommands instance using the specified properties.
     * @function create
     * @memberof ServerCommands
     * @static
     * @param {IServerCommands=} [properties] Properties to set
     * @returns {ServerCommands} ServerCommands instance
     */
    ServerCommands.create = function create(properties) {
        return new ServerCommands(properties);
    };

    /**
     * Encodes the specified ServerCommands message. Does not implicitly {@link ServerCommands.verify|verify} messages.
     * @function encode
     * @memberof ServerCommands
     * @static
     * @param {IServerCommands} message ServerCommands message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    ServerCommands.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.clearCache != null && Object.hasOwnProperty.call(message, "clearCache"))
            writer.uint32(/* id 1, wireType 0 =*/8).bool(message.clearCache);
        if (message.displayErrorMessage != null && Object.hasOwnProperty.call(message, "displayErrorMessage"))
            writer.uint32(/* id 2, wireType 2 =*/18).string(message.displayErrorMessage);
        if (message.logErrorStacktrace != null && Object.hasOwnProperty.call(message, "logErrorStacktrace"))
            writer.uint32(/* id 3, wireType 2 =*/26).string(message.logErrorStacktrace);
        return writer;
    };

    /**
     * Encodes the specified ServerCommands message, length delimited. Does not implicitly {@link ServerCommands.verify|verify} messages.
     * @function encodeDelimited
     * @memberof ServerCommands
     * @static
     * @param {IServerCommands} message ServerCommands message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    ServerCommands.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a ServerCommands message from the specified reader or buffer.
     * @function decode
     * @memberof ServerCommands
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {ServerCommands} ServerCommands
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    ServerCommands.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ServerCommands();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.clearCache = reader.bool();
                break;
            case 2:
                message.displayErrorMessage = reader.string();
                break;
            case 3:
                message.logErrorStacktrace = reader.string();
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a ServerCommands message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof ServerCommands
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {ServerCommands} ServerCommands
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    ServerCommands.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a ServerCommands message.
     * @function verify
     * @memberof ServerCommands
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    ServerCommands.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.clearCache != null && message.hasOwnProperty("clearCache"))
            if (typeof message.clearCache !== "boolean")
                return "clearCache: boolean expected";
        if (message.displayErrorMessage != null && message.hasOwnProperty("displayErrorMessage"))
            if (!$util.isString(message.displayErrorMessage))
                return "displayErrorMessage: string expected";
        if (message.logErrorStacktrace != null && message.hasOwnProperty("logErrorStacktrace"))
            if (!$util.isString(message.logErrorStacktrace))
                return "logErrorStacktrace: string expected";
        return null;
    };

    /**
     * Creates a ServerCommands message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof ServerCommands
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {ServerCommands} ServerCommands
     */
    ServerCommands.fromObject = function fromObject(object) {
        if (object instanceof $root.ServerCommands)
            return object;
        var message = new $root.ServerCommands();
        if (object.clearCache != null)
            message.clearCache = Boolean(object.clearCache);
        if (object.displayErrorMessage != null)
            message.displayErrorMessage = String(object.displayErrorMessage);
        if (object.logErrorStacktrace != null)
            message.logErrorStacktrace = String(object.logErrorStacktrace);
        return message;
    };

    /**
     * Creates a plain object from a ServerCommands message. Also converts values to other types if specified.
     * @function toObject
     * @memberof ServerCommands
     * @static
     * @param {ServerCommands} message ServerCommands
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    ServerCommands.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        var object = {};
        if (options.defaults) {
            object.clearCache = false;
            object.displayErrorMessage = "";
            object.logErrorStacktrace = "";
        }
        if (message.clearCache != null && message.hasOwnProperty("clearCache"))
            object.clearCache = message.clearCache;
        if (message.displayErrorMessage != null && message.hasOwnProperty("displayErrorMessage"))
            object.displayErrorMessage = message.displayErrorMessage;
        if (message.logErrorStacktrace != null && message.hasOwnProperty("logErrorStacktrace"))
            object.logErrorStacktrace = message.logErrorStacktrace;
        return object;
    };

    /**
     * Converts this ServerCommands to JSON.
     * @function toJSON
     * @memberof ServerCommands
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    ServerCommands.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return ServerCommands;
})();

$root.GetReviewsResponse = (function() {

    /**
     * Properties of a GetReviewsResponse.
     * @exports IGetReviewsResponse
     * @interface IGetReviewsResponse
     * @property {Array.<IReview>|null} [review] GetReviewsResponse review
     * @property {number|Long|null} [matchingCount] GetReviewsResponse matchingCount
     */

    /**
     * Constructs a new GetReviewsResponse.
     * @exports GetReviewsResponse
     * @classdesc Represents a GetReviewsResponse.
     * @implements IGetReviewsResponse
     * @constructor
     * @param {IGetReviewsResponse=} [properties] Properties to set
     */
    function GetReviewsResponse(properties) {
        this.review = [];
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * GetReviewsResponse review.
     * @member {Array.<IReview>} review
     * @memberof GetReviewsResponse
     * @instance
     */
    GetReviewsResponse.prototype.review = $util.emptyArray;

    /**
     * GetReviewsResponse matchingCount.
     * @member {number|Long} matchingCount
     * @memberof GetReviewsResponse
     * @instance
     */
    GetReviewsResponse.prototype.matchingCount = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

    /**
     * Creates a new GetReviewsResponse instance using the specified properties.
     * @function create
     * @memberof GetReviewsResponse
     * @static
     * @param {IGetReviewsResponse=} [properties] Properties to set
     * @returns {GetReviewsResponse} GetReviewsResponse instance
     */
    GetReviewsResponse.create = function create(properties) {
        return new GetReviewsResponse(properties);
    };

    /**
     * Encodes the specified GetReviewsResponse message. Does not implicitly {@link GetReviewsResponse.verify|verify} messages.
     * @function encode
     * @memberof GetReviewsResponse
     * @static
     * @param {IGetReviewsResponse} message GetReviewsResponse message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    GetReviewsResponse.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.review != null && message.review.length)
            for (var i = 0; i < message.review.length; ++i)
                $root.Review.encode(message.review[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
        if (message.matchingCount != null && Object.hasOwnProperty.call(message, "matchingCount"))
            writer.uint32(/* id 2, wireType 0 =*/16).int64(message.matchingCount);
        return writer;
    };

    /**
     * Encodes the specified GetReviewsResponse message, length delimited. Does not implicitly {@link GetReviewsResponse.verify|verify} messages.
     * @function encodeDelimited
     * @memberof GetReviewsResponse
     * @static
     * @param {IGetReviewsResponse} message GetReviewsResponse message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    GetReviewsResponse.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a GetReviewsResponse message from the specified reader or buffer.
     * @function decode
     * @memberof GetReviewsResponse
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {GetReviewsResponse} GetReviewsResponse
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    GetReviewsResponse.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.GetReviewsResponse();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                if (!(message.review && message.review.length))
                    message.review = [];
                message.review.push($root.Review.decode(reader, reader.uint32()));
                break;
            case 2:
                message.matchingCount = reader.int64();
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a GetReviewsResponse message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof GetReviewsResponse
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {GetReviewsResponse} GetReviewsResponse
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    GetReviewsResponse.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a GetReviewsResponse message.
     * @function verify
     * @memberof GetReviewsResponse
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    GetReviewsResponse.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.review != null && message.hasOwnProperty("review")) {
            if (!Array.isArray(message.review))
                return "review: array expected";
            for (var i = 0; i < message.review.length; ++i) {
                var error = $root.Review.verify(message.review[i]);
                if (error)
                    return "review." + error;
            }
        }
        if (message.matchingCount != null && message.hasOwnProperty("matchingCount"))
            if (!$util.isInteger(message.matchingCount) && !(message.matchingCount && $util.isInteger(message.matchingCount.low) && $util.isInteger(message.matchingCount.high)))
                return "matchingCount: integer|Long expected";
        return null;
    };

    /**
     * Creates a GetReviewsResponse message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof GetReviewsResponse
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {GetReviewsResponse} GetReviewsResponse
     */
    GetReviewsResponse.fromObject = function fromObject(object) {
        if (object instanceof $root.GetReviewsResponse)
            return object;
        var message = new $root.GetReviewsResponse();
        if (object.review) {
            if (!Array.isArray(object.review))
                throw TypeError(".GetReviewsResponse.review: array expected");
            message.review = [];
            for (var i = 0; i < object.review.length; ++i) {
                if (typeof object.review[i] !== "object")
                    throw TypeError(".GetReviewsResponse.review: object expected");
                message.review[i] = $root.Review.fromObject(object.review[i]);
            }
        }
        if (object.matchingCount != null)
            if ($util.Long)
                (message.matchingCount = $util.Long.fromValue(object.matchingCount)).unsigned = false;
            else if (typeof object.matchingCount === "string")
                message.matchingCount = parseInt(object.matchingCount, 10);
            else if (typeof object.matchingCount === "number")
                message.matchingCount = object.matchingCount;
            else if (typeof object.matchingCount === "object")
                message.matchingCount = new $util.LongBits(object.matchingCount.low >>> 0, object.matchingCount.high >>> 0).toNumber();
        return message;
    };

    /**
     * Creates a plain object from a GetReviewsResponse message. Also converts values to other types if specified.
     * @function toObject
     * @memberof GetReviewsResponse
     * @static
     * @param {GetReviewsResponse} message GetReviewsResponse
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    GetReviewsResponse.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        var object = {};
        if (options.arrays || options.defaults)
            object.review = [];
        if (options.defaults)
            if ($util.Long) {
                var long = new $util.Long(0, 0, false);
                object.matchingCount = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
            } else
                object.matchingCount = options.longs === String ? "0" : 0;
        if (message.review && message.review.length) {
            object.review = [];
            for (var j = 0; j < message.review.length; ++j)
                object.review[j] = $root.Review.toObject(message.review[j], options);
        }
        if (message.matchingCount != null && message.hasOwnProperty("matchingCount"))
            if (typeof message.matchingCount === "number")
                object.matchingCount = options.longs === String ? String(message.matchingCount) : message.matchingCount;
            else
                object.matchingCount = options.longs === String ? $util.Long.prototype.toString.call(message.matchingCount) : options.longs === Number ? new $util.LongBits(message.matchingCount.low >>> 0, message.matchingCount.high >>> 0).toNumber() : message.matchingCount;
        return object;
    };

    /**
     * Converts this GetReviewsResponse to JSON.
     * @function toJSON
     * @memberof GetReviewsResponse
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    GetReviewsResponse.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return GetReviewsResponse;
})();

$root.Review = (function() {

    /**
     * Properties of a Review.
     * @exports IReview
     * @interface IReview
     * @property {string|null} [authorName] Review authorName
     * @property {string|null} [url] Review url
     * @property {string|null} [source] Review source
     * @property {string|null} [version] Review version
     * @property {number|Long|null} [timestamp] Review timestamp
     * @property {number|null} [starRating] Review starRating
     * @property {string|null} [title] Review title
     * @property {string|null} [comment] Review comment
     * @property {string|null} [commentId] Review commentId
     * @property {string|null} [deviceName] Review deviceName
     * @property {string|null} [replyText] Review replyText
     * @property {number|Long|null} [replyTimeStamp] Review replyTimeStamp
     * @property {IReviewAuthor|null} [author] Review author
     * @property {IUserProfile|null} [userProfile] Review userProfile
     * @property {IImage|null} [sentiment] Review sentiment
     * @property {number|null} [helpfulCount] Review helpfulCount
     * @property {number|Long|null} [thumbsUpCount] Review thumbsUpCount
     */

    /**
     * Constructs a new Review.
     * @exports Review
     * @classdesc Represents a Review.
     * @implements IReview
     * @constructor
     * @param {IReview=} [properties] Properties to set
     */
    function Review(properties) {
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * Review authorName.
     * @member {string} authorName
     * @memberof Review
     * @instance
     */
    Review.prototype.authorName = "";

    /**
     * Review url.
     * @member {string} url
     * @memberof Review
     * @instance
     */
    Review.prototype.url = "";

    /**
     * Review source.
     * @member {string} source
     * @memberof Review
     * @instance
     */
    Review.prototype.source = "";

    /**
     * Review version.
     * @member {string} version
     * @memberof Review
     * @instance
     */
    Review.prototype.version = "";

    /**
     * Review timestamp.
     * @member {number|Long} timestamp
     * @memberof Review
     * @instance
     */
    Review.prototype.timestamp = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

    /**
     * Review starRating.
     * @member {number} starRating
     * @memberof Review
     * @instance
     */
    Review.prototype.starRating = 0;

    /**
     * Review title.
     * @member {string} title
     * @memberof Review
     * @instance
     */
    Review.prototype.title = "";

    /**
     * Review comment.
     * @member {string} comment
     * @memberof Review
     * @instance
     */
    Review.prototype.comment = "";

    /**
     * Review commentId.
     * @member {string} commentId
     * @memberof Review
     * @instance
     */
    Review.prototype.commentId = "";

    /**
     * Review deviceName.
     * @member {string} deviceName
     * @memberof Review
     * @instance
     */
    Review.prototype.deviceName = "";

    /**
     * Review replyText.
     * @member {string} replyText
     * @memberof Review
     * @instance
     */
    Review.prototype.replyText = "";

    /**
     * Review replyTimeStamp.
     * @member {number|Long} replyTimeStamp
     * @memberof Review
     * @instance
     */
    Review.prototype.replyTimeStamp = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

    /**
     * Review author.
     * @member {IReviewAuthor|null|undefined} author
     * @memberof Review
     * @instance
     */
    Review.prototype.author = null;

    /**
     * Review userProfile.
     * @member {IUserProfile|null|undefined} userProfile
     * @memberof Review
     * @instance
     */
    Review.prototype.userProfile = null;

    /**
     * Review sentiment.
     * @member {IImage|null|undefined} sentiment
     * @memberof Review
     * @instance
     */
    Review.prototype.sentiment = null;

    /**
     * Review helpfulCount.
     * @member {number} helpfulCount
     * @memberof Review
     * @instance
     */
    Review.prototype.helpfulCount = 0;

    /**
     * Review thumbsUpCount.
     * @member {number|Long} thumbsUpCount
     * @memberof Review
     * @instance
     */
    Review.prototype.thumbsUpCount = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

    /**
     * Creates a new Review instance using the specified properties.
     * @function create
     * @memberof Review
     * @static
     * @param {IReview=} [properties] Properties to set
     * @returns {Review} Review instance
     */
    Review.create = function create(properties) {
        return new Review(properties);
    };

    /**
     * Encodes the specified Review message. Does not implicitly {@link Review.verify|verify} messages.
     * @function encode
     * @memberof Review
     * @static
     * @param {IReview} message Review message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    Review.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.authorName != null && Object.hasOwnProperty.call(message, "authorName"))
            writer.uint32(/* id 1, wireType 2 =*/10).string(message.authorName);
        if (message.url != null && Object.hasOwnProperty.call(message, "url"))
            writer.uint32(/* id 2, wireType 2 =*/18).string(message.url);
        if (message.source != null && Object.hasOwnProperty.call(message, "source"))
            writer.uint32(/* id 3, wireType 2 =*/26).string(message.source);
        if (message.version != null && Object.hasOwnProperty.call(message, "version"))
            writer.uint32(/* id 4, wireType 2 =*/34).string(message.version);
        if (message.timestamp != null && Object.hasOwnProperty.call(message, "timestamp"))
            writer.uint32(/* id 5, wireType 0 =*/40).int64(message.timestamp);
        if (message.starRating != null && Object.hasOwnProperty.call(message, "starRating"))
            writer.uint32(/* id 6, wireType 0 =*/48).int32(message.starRating);
        if (message.title != null && Object.hasOwnProperty.call(message, "title"))
            writer.uint32(/* id 7, wireType 2 =*/58).string(message.title);
        if (message.comment != null && Object.hasOwnProperty.call(message, "comment"))
            writer.uint32(/* id 8, wireType 2 =*/66).string(message.comment);
        if (message.commentId != null && Object.hasOwnProperty.call(message, "commentId"))
            writer.uint32(/* id 9, wireType 2 =*/74).string(message.commentId);
        if (message.deviceName != null && Object.hasOwnProperty.call(message, "deviceName"))
            writer.uint32(/* id 19, wireType 2 =*/154).string(message.deviceName);
        if (message.replyText != null && Object.hasOwnProperty.call(message, "replyText"))
            writer.uint32(/* id 29, wireType 2 =*/234).string(message.replyText);
        if (message.replyTimeStamp != null && Object.hasOwnProperty.call(message, "replyTimeStamp"))
            writer.uint32(/* id 30, wireType 0 =*/240).int64(message.replyTimeStamp);
        if (message.author != null && Object.hasOwnProperty.call(message, "author"))
            $root.ReviewAuthor.encode(message.author, writer.uint32(/* id 31, wireType 2 =*/250).fork()).ldelim();
        if (message.userProfile != null && Object.hasOwnProperty.call(message, "userProfile"))
            $root.UserProfile.encode(message.userProfile, writer.uint32(/* id 33, wireType 2 =*/266).fork()).ldelim();
        if (message.sentiment != null && Object.hasOwnProperty.call(message, "sentiment"))
            $root.Image.encode(message.sentiment, writer.uint32(/* id 34, wireType 2 =*/274).fork()).ldelim();
        if (message.helpfulCount != null && Object.hasOwnProperty.call(message, "helpfulCount"))
            writer.uint32(/* id 35, wireType 0 =*/280).int32(message.helpfulCount);
        if (message.thumbsUpCount != null && Object.hasOwnProperty.call(message, "thumbsUpCount"))
            writer.uint32(/* id 38, wireType 0 =*/304).int64(message.thumbsUpCount);
        return writer;
    };

    /**
     * Encodes the specified Review message, length delimited. Does not implicitly {@link Review.verify|verify} messages.
     * @function encodeDelimited
     * @memberof Review
     * @static
     * @param {IReview} message Review message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    Review.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a Review message from the specified reader or buffer.
     * @function decode
     * @memberof Review
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {Review} Review
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    Review.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Review();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.authorName = reader.string();
                break;
            case 2:
                message.url = reader.string();
                break;
            case 3:
                message.source = reader.string();
                break;
            case 4:
                message.version = reader.string();
                break;
            case 5:
                message.timestamp = reader.int64();
                break;
            case 6:
                message.starRating = reader.int32();
                break;
            case 7:
                message.title = reader.string();
                break;
            case 8:
                message.comment = reader.string();
                break;
            case 9:
                message.commentId = reader.string();
                break;
            case 19:
                message.deviceName = reader.string();
                break;
            case 29:
                message.replyText = reader.string();
                break;
            case 30:
                message.replyTimeStamp = reader.int64();
                break;
            case 31:
                message.author = $root.ReviewAuthor.decode(reader, reader.uint32());
                break;
            case 33:
                message.userProfile = $root.UserProfile.decode(reader, reader.uint32());
                break;
            case 34:
                message.sentiment = $root.Image.decode(reader, reader.uint32());
                break;
            case 35:
                message.helpfulCount = reader.int32();
                break;
            case 38:
                message.thumbsUpCount = reader.int64();
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a Review message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof Review
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {Review} Review
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    Review.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a Review message.
     * @function verify
     * @memberof Review
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    Review.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.authorName != null && message.hasOwnProperty("authorName"))
            if (!$util.isString(message.authorName))
                return "authorName: string expected";
        if (message.url != null && message.hasOwnProperty("url"))
            if (!$util.isString(message.url))
                return "url: string expected";
        if (message.source != null && message.hasOwnProperty("source"))
            if (!$util.isString(message.source))
                return "source: string expected";
        if (message.version != null && message.hasOwnProperty("version"))
            if (!$util.isString(message.version))
                return "version: string expected";
        if (message.timestamp != null && message.hasOwnProperty("timestamp"))
            if (!$util.isInteger(message.timestamp) && !(message.timestamp && $util.isInteger(message.timestamp.low) && $util.isInteger(message.timestamp.high)))
                return "timestamp: integer|Long expected";
        if (message.starRating != null && message.hasOwnProperty("starRating"))
            if (!$util.isInteger(message.starRating))
                return "starRating: integer expected";
        if (message.title != null && message.hasOwnProperty("title"))
            if (!$util.isString(message.title))
                return "title: string expected";
        if (message.comment != null && message.hasOwnProperty("comment"))
            if (!$util.isString(message.comment))
                return "comment: string expected";
        if (message.commentId != null && message.hasOwnProperty("commentId"))
            if (!$util.isString(message.commentId))
                return "commentId: string expected";
        if (message.deviceName != null && message.hasOwnProperty("deviceName"))
            if (!$util.isString(message.deviceName))
                return "deviceName: string expected";
        if (message.replyText != null && message.hasOwnProperty("replyText"))
            if (!$util.isString(message.replyText))
                return "replyText: string expected";
        if (message.replyTimeStamp != null && message.hasOwnProperty("replyTimeStamp"))
            if (!$util.isInteger(message.replyTimeStamp) && !(message.replyTimeStamp && $util.isInteger(message.replyTimeStamp.low) && $util.isInteger(message.replyTimeStamp.high)))
                return "replyTimeStamp: integer|Long expected";
        if (message.author != null && message.hasOwnProperty("author")) {
            var error = $root.ReviewAuthor.verify(message.author);
            if (error)
                return "author." + error;
        }
        if (message.userProfile != null && message.hasOwnProperty("userProfile")) {
            var error = $root.UserProfile.verify(message.userProfile);
            if (error)
                return "userProfile." + error;
        }
        if (message.sentiment != null && message.hasOwnProperty("sentiment")) {
            var error = $root.Image.verify(message.sentiment);
            if (error)
                return "sentiment." + error;
        }
        if (message.helpfulCount != null && message.hasOwnProperty("helpfulCount"))
            if (!$util.isInteger(message.helpfulCount))
                return "helpfulCount: integer expected";
        if (message.thumbsUpCount != null && message.hasOwnProperty("thumbsUpCount"))
            if (!$util.isInteger(message.thumbsUpCount) && !(message.thumbsUpCount && $util.isInteger(message.thumbsUpCount.low) && $util.isInteger(message.thumbsUpCount.high)))
                return "thumbsUpCount: integer|Long expected";
        return null;
    };

    /**
     * Creates a Review message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof Review
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {Review} Review
     */
    Review.fromObject = function fromObject(object) {
        if (object instanceof $root.Review)
            return object;
        var message = new $root.Review();
        if (object.authorName != null)
            message.authorName = String(object.authorName);
        if (object.url != null)
            message.url = String(object.url);
        if (object.source != null)
            message.source = String(object.source);
        if (object.version != null)
            message.version = String(object.version);
        if (object.timestamp != null)
            if ($util.Long)
                (message.timestamp = $util.Long.fromValue(object.timestamp)).unsigned = false;
            else if (typeof object.timestamp === "string")
                message.timestamp = parseInt(object.timestamp, 10);
            else if (typeof object.timestamp === "number")
                message.timestamp = object.timestamp;
            else if (typeof object.timestamp === "object")
                message.timestamp = new $util.LongBits(object.timestamp.low >>> 0, object.timestamp.high >>> 0).toNumber();
        if (object.starRating != null)
            message.starRating = object.starRating | 0;
        if (object.title != null)
            message.title = String(object.title);
        if (object.comment != null)
            message.comment = String(object.comment);
        if (object.commentId != null)
            message.commentId = String(object.commentId);
        if (object.deviceName != null)
            message.deviceName = String(object.deviceName);
        if (object.replyText != null)
            message.replyText = String(object.replyText);
        if (object.replyTimeStamp != null)
            if ($util.Long)
                (message.replyTimeStamp = $util.Long.fromValue(object.replyTimeStamp)).unsigned = false;
            else if (typeof object.replyTimeStamp === "string")
                message.replyTimeStamp = parseInt(object.replyTimeStamp, 10);
            else if (typeof object.replyTimeStamp === "number")
                message.replyTimeStamp = object.replyTimeStamp;
            else if (typeof object.replyTimeStamp === "object")
                message.replyTimeStamp = new $util.LongBits(object.replyTimeStamp.low >>> 0, object.replyTimeStamp.high >>> 0).toNumber();
        if (object.author != null) {
            if (typeof object.author !== "object")
                throw TypeError(".Review.author: object expected");
            message.author = $root.ReviewAuthor.fromObject(object.author);
        }
        if (object.userProfile != null) {
            if (typeof object.userProfile !== "object")
                throw TypeError(".Review.userProfile: object expected");
            message.userProfile = $root.UserProfile.fromObject(object.userProfile);
        }
        if (object.sentiment != null) {
            if (typeof object.sentiment !== "object")
                throw TypeError(".Review.sentiment: object expected");
            message.sentiment = $root.Image.fromObject(object.sentiment);
        }
        if (object.helpfulCount != null)
            message.helpfulCount = object.helpfulCount | 0;
        if (object.thumbsUpCount != null)
            if ($util.Long)
                (message.thumbsUpCount = $util.Long.fromValue(object.thumbsUpCount)).unsigned = false;
            else if (typeof object.thumbsUpCount === "string")
                message.thumbsUpCount = parseInt(object.thumbsUpCount, 10);
            else if (typeof object.thumbsUpCount === "number")
                message.thumbsUpCount = object.thumbsUpCount;
            else if (typeof object.thumbsUpCount === "object")
                message.thumbsUpCount = new $util.LongBits(object.thumbsUpCount.low >>> 0, object.thumbsUpCount.high >>> 0).toNumber();
        return message;
    };

    /**
     * Creates a plain object from a Review message. Also converts values to other types if specified.
     * @function toObject
     * @memberof Review
     * @static
     * @param {Review} message Review
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    Review.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        var object = {};
        if (options.defaults) {
            object.authorName = "";
            object.url = "";
            object.source = "";
            object.version = "";
            if ($util.Long) {
                var long = new $util.Long(0, 0, false);
                object.timestamp = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
            } else
                object.timestamp = options.longs === String ? "0" : 0;
            object.starRating = 0;
            object.title = "";
            object.comment = "";
            object.commentId = "";
            object.deviceName = "";
            object.replyText = "";
            if ($util.Long) {
                var long = new $util.Long(0, 0, false);
                object.replyTimeStamp = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
            } else
                object.replyTimeStamp = options.longs === String ? "0" : 0;
            object.author = null;
            object.userProfile = null;
            object.sentiment = null;
            object.helpfulCount = 0;
            if ($util.Long) {
                var long = new $util.Long(0, 0, false);
                object.thumbsUpCount = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
            } else
                object.thumbsUpCount = options.longs === String ? "0" : 0;
        }
        if (message.authorName != null && message.hasOwnProperty("authorName"))
            object.authorName = message.authorName;
        if (message.url != null && message.hasOwnProperty("url"))
            object.url = message.url;
        if (message.source != null && message.hasOwnProperty("source"))
            object.source = message.source;
        if (message.version != null && message.hasOwnProperty("version"))
            object.version = message.version;
        if (message.timestamp != null && message.hasOwnProperty("timestamp"))
            if (typeof message.timestamp === "number")
                object.timestamp = options.longs === String ? String(message.timestamp) : message.timestamp;
            else
                object.timestamp = options.longs === String ? $util.Long.prototype.toString.call(message.timestamp) : options.longs === Number ? new $util.LongBits(message.timestamp.low >>> 0, message.timestamp.high >>> 0).toNumber() : message.timestamp;
        if (message.starRating != null && message.hasOwnProperty("starRating"))
            object.starRating = message.starRating;
        if (message.title != null && message.hasOwnProperty("title"))
            object.title = message.title;
        if (message.comment != null && message.hasOwnProperty("comment"))
            object.comment = message.comment;
        if (message.commentId != null && message.hasOwnProperty("commentId"))
            object.commentId = message.commentId;
        if (message.deviceName != null && message.hasOwnProperty("deviceName"))
            object.deviceName = message.deviceName;
        if (message.replyText != null && message.hasOwnProperty("replyText"))
            object.replyText = message.replyText;
        if (message.replyTimeStamp != null && message.hasOwnProperty("replyTimeStamp"))
            if (typeof message.replyTimeStamp === "number")
                object.replyTimeStamp = options.longs === String ? String(message.replyTimeStamp) : message.replyTimeStamp;
            else
                object.replyTimeStamp = options.longs === String ? $util.Long.prototype.toString.call(message.replyTimeStamp) : options.longs === Number ? new $util.LongBits(message.replyTimeStamp.low >>> 0, message.replyTimeStamp.high >>> 0).toNumber() : message.replyTimeStamp;
        if (message.author != null && message.hasOwnProperty("author"))
            object.author = $root.ReviewAuthor.toObject(message.author, options);
        if (message.userProfile != null && message.hasOwnProperty("userProfile"))
            object.userProfile = $root.UserProfile.toObject(message.userProfile, options);
        if (message.sentiment != null && message.hasOwnProperty("sentiment"))
            object.sentiment = $root.Image.toObject(message.sentiment, options);
        if (message.helpfulCount != null && message.hasOwnProperty("helpfulCount"))
            object.helpfulCount = message.helpfulCount;
        if (message.thumbsUpCount != null && message.hasOwnProperty("thumbsUpCount"))
            if (typeof message.thumbsUpCount === "number")
                object.thumbsUpCount = options.longs === String ? String(message.thumbsUpCount) : message.thumbsUpCount;
            else
                object.thumbsUpCount = options.longs === String ? $util.Long.prototype.toString.call(message.thumbsUpCount) : options.longs === Number ? new $util.LongBits(message.thumbsUpCount.low >>> 0, message.thumbsUpCount.high >>> 0).toNumber() : message.thumbsUpCount;
        return object;
    };

    /**
     * Converts this Review to JSON.
     * @function toJSON
     * @memberof Review
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    Review.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return Review;
})();

$root.CriticReviewsResponse = (function() {

    /**
     * Properties of a CriticReviewsResponse.
     * @exports ICriticReviewsResponse
     * @interface ICriticReviewsResponse
     * @property {string|null} [title] CriticReviewsResponse title
     * @property {IImage|null} [image] CriticReviewsResponse image
     * @property {number|null} [totalNumReviews] CriticReviewsResponse totalNumReviews
     * @property {number|null} [percentFavorable] CriticReviewsResponse percentFavorable
     * @property {string|null} [sourceText] CriticReviewsResponse sourceText
     * @property {ILink|null} [source] CriticReviewsResponse source
     * @property {Array.<IReview>|null} [review] CriticReviewsResponse review
     */

    /**
     * Constructs a new CriticReviewsResponse.
     * @exports CriticReviewsResponse
     * @classdesc Represents a CriticReviewsResponse.
     * @implements ICriticReviewsResponse
     * @constructor
     * @param {ICriticReviewsResponse=} [properties] Properties to set
     */
    function CriticReviewsResponse(properties) {
        this.review = [];
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * CriticReviewsResponse title.
     * @member {string} title
     * @memberof CriticReviewsResponse
     * @instance
     */
    CriticReviewsResponse.prototype.title = "";

    /**
     * CriticReviewsResponse image.
     * @member {IImage|null|undefined} image
     * @memberof CriticReviewsResponse
     * @instance
     */
    CriticReviewsResponse.prototype.image = null;

    /**
     * CriticReviewsResponse totalNumReviews.
     * @member {number} totalNumReviews
     * @memberof CriticReviewsResponse
     * @instance
     */
    CriticReviewsResponse.prototype.totalNumReviews = 0;

    /**
     * CriticReviewsResponse percentFavorable.
     * @member {number} percentFavorable
     * @memberof CriticReviewsResponse
     * @instance
     */
    CriticReviewsResponse.prototype.percentFavorable = 0;

    /**
     * CriticReviewsResponse sourceText.
     * @member {string} sourceText
     * @memberof CriticReviewsResponse
     * @instance
     */
    CriticReviewsResponse.prototype.sourceText = "";

    /**
     * CriticReviewsResponse source.
     * @member {ILink|null|undefined} source
     * @memberof CriticReviewsResponse
     * @instance
     */
    CriticReviewsResponse.prototype.source = null;

    /**
     * CriticReviewsResponse review.
     * @member {Array.<IReview>} review
     * @memberof CriticReviewsResponse
     * @instance
     */
    CriticReviewsResponse.prototype.review = $util.emptyArray;

    /**
     * Creates a new CriticReviewsResponse instance using the specified properties.
     * @function create
     * @memberof CriticReviewsResponse
     * @static
     * @param {ICriticReviewsResponse=} [properties] Properties to set
     * @returns {CriticReviewsResponse} CriticReviewsResponse instance
     */
    CriticReviewsResponse.create = function create(properties) {
        return new CriticReviewsResponse(properties);
    };

    /**
     * Encodes the specified CriticReviewsResponse message. Does not implicitly {@link CriticReviewsResponse.verify|verify} messages.
     * @function encode
     * @memberof CriticReviewsResponse
     * @static
     * @param {ICriticReviewsResponse} message CriticReviewsResponse message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    CriticReviewsResponse.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.title != null && Object.hasOwnProperty.call(message, "title"))
            writer.uint32(/* id 1, wireType 2 =*/10).string(message.title);
        if (message.image != null && Object.hasOwnProperty.call(message, "image"))
            $root.Image.encode(message.image, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
        if (message.totalNumReviews != null && Object.hasOwnProperty.call(message, "totalNumReviews"))
            writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.totalNumReviews);
        if (message.percentFavorable != null && Object.hasOwnProperty.call(message, "percentFavorable"))
            writer.uint32(/* id 4, wireType 0 =*/32).uint32(message.percentFavorable);
        if (message.sourceText != null && Object.hasOwnProperty.call(message, "sourceText"))
            writer.uint32(/* id 5, wireType 2 =*/42).string(message.sourceText);
        if (message.source != null && Object.hasOwnProperty.call(message, "source"))
            $root.Link.encode(message.source, writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
        if (message.review != null && message.review.length)
            for (var i = 0; i < message.review.length; ++i)
                $root.Review.encode(message.review[i], writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
        return writer;
    };

    /**
     * Encodes the specified CriticReviewsResponse message, length delimited. Does not implicitly {@link CriticReviewsResponse.verify|verify} messages.
     * @function encodeDelimited
     * @memberof CriticReviewsResponse
     * @static
     * @param {ICriticReviewsResponse} message CriticReviewsResponse message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    CriticReviewsResponse.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a CriticReviewsResponse message from the specified reader or buffer.
     * @function decode
     * @memberof CriticReviewsResponse
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CriticReviewsResponse} CriticReviewsResponse
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CriticReviewsResponse.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CriticReviewsResponse();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.title = reader.string();
                break;
            case 2:
                message.image = $root.Image.decode(reader, reader.uint32());
                break;
            case 3:
                message.totalNumReviews = reader.uint32();
                break;
            case 4:
                message.percentFavorable = reader.uint32();
                break;
            case 5:
                message.sourceText = reader.string();
                break;
            case 6:
                message.source = $root.Link.decode(reader, reader.uint32());
                break;
            case 7:
                if (!(message.review && message.review.length))
                    message.review = [];
                message.review.push($root.Review.decode(reader, reader.uint32()));
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a CriticReviewsResponse message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof CriticReviewsResponse
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {CriticReviewsResponse} CriticReviewsResponse
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CriticReviewsResponse.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a CriticReviewsResponse message.
     * @function verify
     * @memberof CriticReviewsResponse
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    CriticReviewsResponse.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.title != null && message.hasOwnProperty("title"))
            if (!$util.isString(message.title))
                return "title: string expected";
        if (message.image != null && message.hasOwnProperty("image")) {
            var error = $root.Image.verify(message.image);
            if (error)
                return "image." + error;
        }
        if (message.totalNumReviews != null && message.hasOwnProperty("totalNumReviews"))
            if (!$util.isInteger(message.totalNumReviews))
                return "totalNumReviews: integer expected";
        if (message.percentFavorable != null && message.hasOwnProperty("percentFavorable"))
            if (!$util.isInteger(message.percentFavorable))
                return "percentFavorable: integer expected";
        if (message.sourceText != null && message.hasOwnProperty("sourceText"))
            if (!$util.isString(message.sourceText))
                return "sourceText: string expected";
        if (message.source != null && message.hasOwnProperty("source")) {
            var error = $root.Link.verify(message.source);
            if (error)
                return "source." + error;
        }
        if (message.review != null && message.hasOwnProperty("review")) {
            if (!Array.isArray(message.review))
                return "review: array expected";
            for (var i = 0; i < message.review.length; ++i) {
                var error = $root.Review.verify(message.review[i]);
                if (error)
                    return "review." + error;
            }
        }
        return null;
    };

    /**
     * Creates a CriticReviewsResponse message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof CriticReviewsResponse
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {CriticReviewsResponse} CriticReviewsResponse
     */
    CriticReviewsResponse.fromObject = function fromObject(object) {
        if (object instanceof $root.CriticReviewsResponse)
            return object;
        var message = new $root.CriticReviewsResponse();
        if (object.title != null)
            message.title = String(object.title);
        if (object.image != null) {
            if (typeof object.image !== "object")
                throw TypeError(".CriticReviewsResponse.image: object expected");
            message.image = $root.Image.fromObject(object.image);
        }
        if (object.totalNumReviews != null)
            message.totalNumReviews = object.totalNumReviews >>> 0;
        if (object.percentFavorable != null)
            message.percentFavorable = object.percentFavorable >>> 0;
        if (object.sourceText != null)
            message.sourceText = String(object.sourceText);
        if (object.source != null) {
            if (typeof object.source !== "object")
                throw TypeError(".CriticReviewsResponse.source: object expected");
            message.source = $root.Link.fromObject(object.source);
        }
        if (object.review) {
            if (!Array.isArray(object.review))
                throw TypeError(".CriticReviewsResponse.review: array expected");
            message.review = [];
            for (var i = 0; i < object.review.length; ++i) {
                if (typeof object.review[i] !== "object")
                    throw TypeError(".CriticReviewsResponse.review: object expected");
                message.review[i] = $root.Review.fromObject(object.review[i]);
            }
        }
        return message;
    };

    /**
     * Creates a plain object from a CriticReviewsResponse message. Also converts values to other types if specified.
     * @function toObject
     * @memberof CriticReviewsResponse
     * @static
     * @param {CriticReviewsResponse} message CriticReviewsResponse
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    CriticReviewsResponse.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        var object = {};
        if (options.arrays || options.defaults)
            object.review = [];
        if (options.defaults) {
            object.title = "";
            object.image = null;
            object.totalNumReviews = 0;
            object.percentFavorable = 0;
            object.sourceText = "";
            object.source = null;
        }
        if (message.title != null && message.hasOwnProperty("title"))
            object.title = message.title;
        if (message.image != null && message.hasOwnProperty("image"))
            object.image = $root.Image.toObject(message.image, options);
        if (message.totalNumReviews != null && message.hasOwnProperty("totalNumReviews"))
            object.totalNumReviews = message.totalNumReviews;
        if (message.percentFavorable != null && message.hasOwnProperty("percentFavorable"))
            object.percentFavorable = message.percentFavorable;
        if (message.sourceText != null && message.hasOwnProperty("sourceText"))
            object.sourceText = message.sourceText;
        if (message.source != null && message.hasOwnProperty("source"))
            object.source = $root.Link.toObject(message.source, options);
        if (message.review && message.review.length) {
            object.review = [];
            for (var j = 0; j < message.review.length; ++j)
                object.review[j] = $root.Review.toObject(message.review[j], options);
        }
        return object;
    };

    /**
     * Converts this CriticReviewsResponse to JSON.
     * @function toJSON
     * @memberof CriticReviewsResponse
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    CriticReviewsResponse.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return CriticReviewsResponse;
})();

$root.ReviewAuthor = (function() {

    /**
     * Properties of a ReviewAuthor.
     * @exports IReviewAuthor
     * @interface IReviewAuthor
     * @property {string|null} [name] ReviewAuthor name
     * @property {IImage|null} [avatar] ReviewAuthor avatar
     */

    /**
     * Constructs a new ReviewAuthor.
     * @exports ReviewAuthor
     * @classdesc Represents a ReviewAuthor.
     * @implements IReviewAuthor
     * @constructor
     * @param {IReviewAuthor=} [properties] Properties to set
     */
    function ReviewAuthor(properties) {
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * ReviewAuthor name.
     * @member {string} name
     * @memberof ReviewAuthor
     * @instance
     */
    ReviewAuthor.prototype.name = "";

    /**
     * ReviewAuthor avatar.
     * @member {IImage|null|undefined} avatar
     * @memberof ReviewAuthor
     * @instance
     */
    ReviewAuthor.prototype.avatar = null;

    /**
     * Creates a new ReviewAuthor instance using the specified properties.
     * @function create
     * @memberof ReviewAuthor
     * @static
     * @param {IReviewAuthor=} [properties] Properties to set
     * @returns {ReviewAuthor} ReviewAuthor instance
     */
    ReviewAuthor.create = function create(properties) {
        return new ReviewAuthor(properties);
    };

    /**
     * Encodes the specified ReviewAuthor message. Does not implicitly {@link ReviewAuthor.verify|verify} messages.
     * @function encode
     * @memberof ReviewAuthor
     * @static
     * @param {IReviewAuthor} message ReviewAuthor message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    ReviewAuthor.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.name != null && Object.hasOwnProperty.call(message, "name"))
            writer.uint32(/* id 2, wireType 2 =*/18).string(message.name);
        if (message.avatar != null && Object.hasOwnProperty.call(message, "avatar"))
            $root.Image.encode(message.avatar, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
        return writer;
    };

    /**
     * Encodes the specified ReviewAuthor message, length delimited. Does not implicitly {@link ReviewAuthor.verify|verify} messages.
     * @function encodeDelimited
     * @memberof ReviewAuthor
     * @static
     * @param {IReviewAuthor} message ReviewAuthor message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    ReviewAuthor.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a ReviewAuthor message from the specified reader or buffer.
     * @function decode
     * @memberof ReviewAuthor
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {ReviewAuthor} ReviewAuthor
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    ReviewAuthor.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ReviewAuthor();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            case 2:
                message.name = reader.string();
                break;
            case 5:
                message.avatar = $root.Image.decode(reader, reader.uint32());
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a ReviewAuthor message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof ReviewAuthor
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {ReviewAuthor} ReviewAuthor
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    ReviewAuthor.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a ReviewAuthor message.
     * @function verify
     * @memberof ReviewAuthor
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    ReviewAuthor.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.name != null && message.hasOwnProperty("name"))
            if (!$util.isString(message.name))
                return "name: string expected";
        if (message.avatar != null && message.hasOwnProperty("avatar")) {
            var error = $root.Image.verify(message.avatar);
            if (error)
                return "avatar." + error;
        }
        return null;
    };

    /**
     * Creates a ReviewAuthor message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof ReviewAuthor
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {ReviewAuthor} ReviewAuthor
     */
    ReviewAuthor.fromObject = function fromObject(object) {
        if (object instanceof $root.ReviewAuthor)
            return object;
        var message = new $root.ReviewAuthor();
        if (object.name != null)
            message.name = String(object.name);
        if (object.avatar != null) {
            if (typeof object.avatar !== "object")
                throw TypeError(".ReviewAuthor.avatar: object expected");
            message.avatar = $root.Image.fromObject(object.avatar);
        }
        return message;
    };

    /**
     * Creates a plain object from a ReviewAuthor message. Also converts values to other types if specified.
     * @function toObject
     * @memberof ReviewAuthor
     * @static
     * @param {ReviewAuthor} message ReviewAuthor
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    ReviewAuthor.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        var object = {};
        if (options.defaults) {
            object.name = "";
            object.avatar = null;
        }
        if (message.name != null && message.hasOwnProperty("name"))
            object.name = message.name;
        if (message.avatar != null && message.hasOwnProperty("avatar"))
            object.avatar = $root.Image.toObject(message.avatar, options);
        return object;
    };

    /**
     * Converts this ReviewAuthor to JSON.
     * @function toJSON
     * @memberof ReviewAuthor
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    ReviewAuthor.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return ReviewAuthor;
})();

$root.UserProfile = (function() {

    /**
     * Properties of a UserProfile.
     * @exports IUserProfile
     * @interface IUserProfile
     * @property {string|null} [profileId] UserProfile profileId
     * @property {string|null} [personId] UserProfile personId
     * @property {number|null} [profileType] UserProfile profileType
     * @property {number|null} [personType] UserProfile personType
     * @property {string|null} [name] UserProfile name
     * @property {Array.<IImage>|null} [image] UserProfile image
     * @property {string|null} [profileUrl] UserProfile profileUrl
     * @property {string|null} [profileDescription] UserProfile profileDescription
     */

    /**
     * Constructs a new UserProfile.
     * @exports UserProfile
     * @classdesc Represents a UserProfile.
     * @implements IUserProfile
     * @constructor
     * @param {IUserProfile=} [properties] Properties to set
     */
    function UserProfile(properties) {
        this.image = [];
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * UserProfile profileId.
     * @member {string} profileId
     * @memberof UserProfile
     * @instance
     */
    UserProfile.prototype.profileId = "";

    /**
     * UserProfile personId.
     * @member {string} personId
     * @memberof UserProfile
     * @instance
     */
    UserProfile.prototype.personId = "";

    /**
     * UserProfile profileType.
     * @member {number} profileType
     * @memberof UserProfile
     * @instance
     */
    UserProfile.prototype.profileType = 0;

    /**
     * UserProfile personType.
     * @member {number} personType
     * @memberof UserProfile
     * @instance
     */
    UserProfile.prototype.personType = 0;

    /**
     * UserProfile name.
     * @member {string} name
     * @memberof UserProfile
     * @instance
     */
    UserProfile.prototype.name = "";

    /**
     * UserProfile image.
     * @member {Array.<IImage>} image
     * @memberof UserProfile
     * @instance
     */
    UserProfile.prototype.image = $util.emptyArray;

    /**
     * UserProfile profileUrl.
     * @member {string} profileUrl
     * @memberof UserProfile
     * @instance
     */
    UserProfile.prototype.profileUrl = "";

    /**
     * UserProfile profileDescription.
     * @member {string} profileDescription
     * @memberof UserProfile
     * @instance
     */
    UserProfile.prototype.profileDescription = "";

    /**
     * Creates a new UserProfile instance using the specified properties.
     * @function create
     * @memberof UserProfile
     * @static
     * @param {IUserProfile=} [properties] Properties to set
     * @returns {UserProfile} UserProfile instance
     */
    UserProfile.create = function create(properties) {
        return new UserProfile(properties);
    };

    /**
     * Encodes the specified UserProfile message. Does not implicitly {@link UserProfile.verify|verify} messages.
     * @function encode
     * @memberof UserProfile
     * @static
     * @param {IUserProfile} message UserProfile message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    UserProfile.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.profileId != null && Object.hasOwnProperty.call(message, "profileId"))
            writer.uint32(/* id 1, wireType 2 =*/10).string(message.profileId);
        if (message.personId != null && Object.hasOwnProperty.call(message, "personId"))
            writer.uint32(/* id 2, wireType 2 =*/18).string(message.personId);
        if (message.profileType != null && Object.hasOwnProperty.call(message, "profileType"))
            writer.uint32(/* id 3, wireType 0 =*/24).int32(message.profileType);
        if (message.personType != null && Object.hasOwnProperty.call(message, "personType"))
            writer.uint32(/* id 4, wireType 0 =*/32).int32(message.personType);
        if (message.name != null && Object.hasOwnProperty.call(message, "name"))
            writer.uint32(/* id 5, wireType 2 =*/42).string(message.name);
        if (message.image != null && message.image.length)
            for (var i = 0; i < message.image.length; ++i)
                $root.Image.encode(message.image[i], writer.uint32(/* id 10, wireType 2 =*/82).fork()).ldelim();
        if (message.profileUrl != null && Object.hasOwnProperty.call(message, "profileUrl"))
            writer.uint32(/* id 19, wireType 2 =*/154).string(message.profileUrl);
        if (message.profileDescription != null && Object.hasOwnProperty.call(message, "profileDescription"))
            writer.uint32(/* id 22, wireType 2 =*/178).string(message.profileDescription);
        return writer;
    };

    /**
     * Encodes the specified UserProfile message, length delimited. Does not implicitly {@link UserProfile.verify|verify} messages.
     * @function encodeDelimited
     * @memberof UserProfile
     * @static
     * @param {IUserProfile} message UserProfile message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    UserProfile.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a UserProfile message from the specified reader or buffer.
     * @function decode
     * @memberof UserProfile
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {UserProfile} UserProfile
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    UserProfile.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.UserProfile();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.profileId = reader.string();
                break;
            case 2:
                message.personId = reader.string();
                break;
            case 3:
                message.profileType = reader.int32();
                break;
            case 4:
                message.personType = reader.int32();
                break;
            case 5:
                message.name = reader.string();
                break;
            case 10:
                if (!(message.image && message.image.length))
                    message.image = [];
                message.image.push($root.Image.decode(reader, reader.uint32()));
                break;
            case 19:
                message.profileUrl = reader.string();
                break;
            case 22:
                message.profileDescription = reader.string();
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a UserProfile message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof UserProfile
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {UserProfile} UserProfile
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    UserProfile.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a UserProfile message.
     * @function verify
     * @memberof UserProfile
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    UserProfile.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.profileId != null && message.hasOwnProperty("profileId"))
            if (!$util.isString(message.profileId))
                return "profileId: string expected";
        if (message.personId != null && message.hasOwnProperty("personId"))
            if (!$util.isString(message.personId))
                return "personId: string expected";
        if (message.profileType != null && message.hasOwnProperty("profileType"))
            if (!$util.isInteger(message.profileType))
                return "profileType: integer expected";
        if (message.personType != null && message.hasOwnProperty("personType"))
            if (!$util.isInteger(message.personType))
                return "personType: integer expected";
        if (message.name != null && message.hasOwnProperty("name"))
            if (!$util.isString(message.name))
                return "name: string expected";
        if (message.image != null && message.hasOwnProperty("image")) {
            if (!Array.isArray(message.image))
                return "image: array expected";
            for (var i = 0; i < message.image.length; ++i) {
                var error = $root.Image.verify(message.image[i]);
                if (error)
                    return "image." + error;
            }
        }
        if (message.profileUrl != null && message.hasOwnProperty("profileUrl"))
            if (!$util.isString(message.profileUrl))
                return "profileUrl: string expected";
        if (message.profileDescription != null && message.hasOwnProperty("profileDescription"))
            if (!$util.isString(message.profileDescription))
                return "profileDescription: string expected";
        return null;
    };

    /**
     * Creates a UserProfile message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof UserProfile
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {UserProfile} UserProfile
     */
    UserProfile.fromObject = function fromObject(object) {
        if (object instanceof $root.UserProfile)
            return object;
        var message = new $root.UserProfile();
        if (object.profileId != null)
            message.profileId = String(object.profileId);
        if (object.personId != null)
            message.personId = String(object.personId);
        if (object.profileType != null)
            message.profileType = object.profileType | 0;
        if (object.personType != null)
            message.personType = object.personType | 0;
        if (object.name != null)
            message.name = String(object.name);
        if (object.image) {
            if (!Array.isArray(object.image))
                throw TypeError(".UserProfile.image: array expected");
            message.image = [];
            for (var i = 0; i < object.image.length; ++i) {
                if (typeof object.image[i] !== "object")
                    throw TypeError(".UserProfile.image: object expected");
                message.image[i] = $root.Image.fromObject(object.image[i]);
            }
        }
        if (object.profileUrl != null)
            message.profileUrl = String(object.profileUrl);
        if (object.profileDescription != null)
            message.profileDescription = String(object.profileDescription);
        return message;
    };

    /**
     * Creates a plain object from a UserProfile message. Also converts values to other types if specified.
     * @function toObject
     * @memberof UserProfile
     * @static
     * @param {UserProfile} message UserProfile
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    UserProfile.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        var object = {};
        if (options.arrays || options.defaults)
            object.image = [];
        if (options.defaults) {
            object.profileId = "";
            object.personId = "";
            object.profileType = 0;
            object.personType = 0;
            object.name = "";
            object.profileUrl = "";
            object.profileDescription = "";
        }
        if (message.profileId != null && message.hasOwnProperty("profileId"))
            object.profileId = message.profileId;
        if (message.personId != null && message.hasOwnProperty("personId"))
            object.personId = message.personId;
        if (message.profileType != null && message.hasOwnProperty("profileType"))
            object.profileType = message.profileType;
        if (message.personType != null && message.hasOwnProperty("personType"))
            object.personType = message.personType;
        if (message.name != null && message.hasOwnProperty("name"))
            object.name = message.name;
        if (message.image && message.image.length) {
            object.image = [];
            for (var j = 0; j < message.image.length; ++j)
                object.image[j] = $root.Image.toObject(message.image[j], options);
        }
        if (message.profileUrl != null && message.hasOwnProperty("profileUrl"))
            object.profileUrl = message.profileUrl;
        if (message.profileDescription != null && message.hasOwnProperty("profileDescription"))
            object.profileDescription = message.profileDescription;
        return object;
    };

    /**
     * Converts this UserProfile to JSON.
     * @function toJSON
     * @memberof UserProfile
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    UserProfile.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return UserProfile;
})();

$root.ReviewResponse = (function() {

    /**
     * Properties of a ReviewResponse.
     * @exports IReviewResponse
     * @interface IReviewResponse
     * @property {IGetReviewsResponse|null} [userReviewsResponse] ReviewResponse userReviewsResponse
     * @property {string|null} [nextPageUrl] ReviewResponse nextPageUrl
     * @property {IReview|null} [userReview] ReviewResponse userReview
     * @property {string|null} [suggestionsListUrl] ReviewResponse suggestionsListUrl
     * @property {ICriticReviewsResponse|null} [criticReviewsResponse] ReviewResponse criticReviewsResponse
     */

    /**
     * Constructs a new ReviewResponse.
     * @exports ReviewResponse
     * @classdesc Represents a ReviewResponse.
     * @implements IReviewResponse
     * @constructor
     * @param {IReviewResponse=} [properties] Properties to set
     */
    function ReviewResponse(properties) {
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * ReviewResponse userReviewsResponse.
     * @member {IGetReviewsResponse|null|undefined} userReviewsResponse
     * @memberof ReviewResponse
     * @instance
     */
    ReviewResponse.prototype.userReviewsResponse = null;

    /**
     * ReviewResponse nextPageUrl.
     * @member {string} nextPageUrl
     * @memberof ReviewResponse
     * @instance
     */
    ReviewResponse.prototype.nextPageUrl = "";

    /**
     * ReviewResponse userReview.
     * @member {IReview|null|undefined} userReview
     * @memberof ReviewResponse
     * @instance
     */
    ReviewResponse.prototype.userReview = null;

    /**
     * ReviewResponse suggestionsListUrl.
     * @member {string} suggestionsListUrl
     * @memberof ReviewResponse
     * @instance
     */
    ReviewResponse.prototype.suggestionsListUrl = "";

    /**
     * ReviewResponse criticReviewsResponse.
     * @member {ICriticReviewsResponse|null|undefined} criticReviewsResponse
     * @memberof ReviewResponse
     * @instance
     */
    ReviewResponse.prototype.criticReviewsResponse = null;

    /**
     * Creates a new ReviewResponse instance using the specified properties.
     * @function create
     * @memberof ReviewResponse
     * @static
     * @param {IReviewResponse=} [properties] Properties to set
     * @returns {ReviewResponse} ReviewResponse instance
     */
    ReviewResponse.create = function create(properties) {
        return new ReviewResponse(properties);
    };

    /**
     * Encodes the specified ReviewResponse message. Does not implicitly {@link ReviewResponse.verify|verify} messages.
     * @function encode
     * @memberof ReviewResponse
     * @static
     * @param {IReviewResponse} message ReviewResponse message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    ReviewResponse.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.userReviewsResponse != null && Object.hasOwnProperty.call(message, "userReviewsResponse"))
            $root.GetReviewsResponse.encode(message.userReviewsResponse, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
        if (message.nextPageUrl != null && Object.hasOwnProperty.call(message, "nextPageUrl"))
            writer.uint32(/* id 2, wireType 2 =*/18).string(message.nextPageUrl);
        if (message.userReview != null && Object.hasOwnProperty.call(message, "userReview"))
            $root.Review.encode(message.userReview, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
        if (message.suggestionsListUrl != null && Object.hasOwnProperty.call(message, "suggestionsListUrl"))
            writer.uint32(/* id 4, wireType 2 =*/34).string(message.suggestionsListUrl);
        if (message.criticReviewsResponse != null && Object.hasOwnProperty.call(message, "criticReviewsResponse"))
            $root.CriticReviewsResponse.encode(message.criticReviewsResponse, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
        return writer;
    };

    /**
     * Encodes the specified ReviewResponse message, length delimited. Does not implicitly {@link ReviewResponse.verify|verify} messages.
     * @function encodeDelimited
     * @memberof ReviewResponse
     * @static
     * @param {IReviewResponse} message ReviewResponse message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    ReviewResponse.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a ReviewResponse message from the specified reader or buffer.
     * @function decode
     * @memberof ReviewResponse
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {ReviewResponse} ReviewResponse
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    ReviewResponse.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ReviewResponse();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.userReviewsResponse = $root.GetReviewsResponse.decode(reader, reader.uint32());
                break;
            case 2:
                message.nextPageUrl = reader.string();
                break;
            case 3:
                message.userReview = $root.Review.decode(reader, reader.uint32());
                break;
            case 4:
                message.suggestionsListUrl = reader.string();
                break;
            case 5:
                message.criticReviewsResponse = $root.CriticReviewsResponse.decode(reader, reader.uint32());
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a ReviewResponse message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof ReviewResponse
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {ReviewResponse} ReviewResponse
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    ReviewResponse.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a ReviewResponse message.
     * @function verify
     * @memberof ReviewResponse
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    ReviewResponse.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.userReviewsResponse != null && message.hasOwnProperty("userReviewsResponse")) {
            var error = $root.GetReviewsResponse.verify(message.userReviewsResponse);
            if (error)
                return "userReviewsResponse." + error;
        }
        if (message.nextPageUrl != null && message.hasOwnProperty("nextPageUrl"))
            if (!$util.isString(message.nextPageUrl))
                return "nextPageUrl: string expected";
        if (message.userReview != null && message.hasOwnProperty("userReview")) {
            var error = $root.Review.verify(message.userReview);
            if (error)
                return "userReview." + error;
        }
        if (message.suggestionsListUrl != null && message.hasOwnProperty("suggestionsListUrl"))
            if (!$util.isString(message.suggestionsListUrl))
                return "suggestionsListUrl: string expected";
        if (message.criticReviewsResponse != null && message.hasOwnProperty("criticReviewsResponse")) {
            var error = $root.CriticReviewsResponse.verify(message.criticReviewsResponse);
            if (error)
                return "criticReviewsResponse." + error;
        }
        return null;
    };

    /**
     * Creates a ReviewResponse message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof ReviewResponse
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {ReviewResponse} ReviewResponse
     */
    ReviewResponse.fromObject = function fromObject(object) {
        if (object instanceof $root.ReviewResponse)
            return object;
        var message = new $root.ReviewResponse();
        if (object.userReviewsResponse != null) {
            if (typeof object.userReviewsResponse !== "object")
                throw TypeError(".ReviewResponse.userReviewsResponse: object expected");
            message.userReviewsResponse = $root.GetReviewsResponse.fromObject(object.userReviewsResponse);
        }
        if (object.nextPageUrl != null)
            message.nextPageUrl = String(object.nextPageUrl);
        if (object.userReview != null) {
            if (typeof object.userReview !== "object")
                throw TypeError(".ReviewResponse.userReview: object expected");
            message.userReview = $root.Review.fromObject(object.userReview);
        }
        if (object.suggestionsListUrl != null)
            message.suggestionsListUrl = String(object.suggestionsListUrl);
        if (object.criticReviewsResponse != null) {
            if (typeof object.criticReviewsResponse !== "object")
                throw TypeError(".ReviewResponse.criticReviewsResponse: object expected");
            message.criticReviewsResponse = $root.CriticReviewsResponse.fromObject(object.criticReviewsResponse);
        }
        return message;
    };

    /**
     * Creates a plain object from a ReviewResponse message. Also converts values to other types if specified.
     * @function toObject
     * @memberof ReviewResponse
     * @static
     * @param {ReviewResponse} message ReviewResponse
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    ReviewResponse.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        var object = {};
        if (options.defaults) {
            object.userReviewsResponse = null;
            object.nextPageUrl = "";
            object.userReview = null;
            object.suggestionsListUrl = "";
            object.criticReviewsResponse = null;
        }
        if (message.userReviewsResponse != null && message.hasOwnProperty("userReviewsResponse"))
            object.userReviewsResponse = $root.GetReviewsResponse.toObject(message.userReviewsResponse, options);
        if (message.nextPageUrl != null && message.hasOwnProperty("nextPageUrl"))
            object.nextPageUrl = message.nextPageUrl;
        if (message.userReview != null && message.hasOwnProperty("userReview"))
            object.userReview = $root.Review.toObject(message.userReview, options);
        if (message.suggestionsListUrl != null && message.hasOwnProperty("suggestionsListUrl"))
            object.suggestionsListUrl = message.suggestionsListUrl;
        if (message.criticReviewsResponse != null && message.hasOwnProperty("criticReviewsResponse"))
            object.criticReviewsResponse = $root.CriticReviewsResponse.toObject(message.criticReviewsResponse, options);
        return object;
    };

    /**
     * Converts this ReviewResponse to JSON.
     * @function toJSON
     * @memberof ReviewResponse
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    ReviewResponse.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return ReviewResponse;
})();

$root.RelatedSearch = (function() {

    /**
     * Properties of a RelatedSearch.
     * @exports IRelatedSearch
     * @interface IRelatedSearch
     * @property {string|null} [searchUrl] RelatedSearch searchUrl
     * @property {string|null} [header] RelatedSearch header
     * @property {number|null} [backendId] RelatedSearch backendId
     * @property {number|null} [docType] RelatedSearch docType
     * @property {boolean|null} [current] RelatedSearch current
     */

    /**
     * Constructs a new RelatedSearch.
     * @exports RelatedSearch
     * @classdesc Represents a RelatedSearch.
     * @implements IRelatedSearch
     * @constructor
     * @param {IRelatedSearch=} [properties] Properties to set
     */
    function RelatedSearch(properties) {
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * RelatedSearch searchUrl.
     * @member {string} searchUrl
     * @memberof RelatedSearch
     * @instance
     */
    RelatedSearch.prototype.searchUrl = "";

    /**
     * RelatedSearch header.
     * @member {string} header
     * @memberof RelatedSearch
     * @instance
     */
    RelatedSearch.prototype.header = "";

    /**
     * RelatedSearch backendId.
     * @member {number} backendId
     * @memberof RelatedSearch
     * @instance
     */
    RelatedSearch.prototype.backendId = 0;

    /**
     * RelatedSearch docType.
     * @member {number} docType
     * @memberof RelatedSearch
     * @instance
     */
    RelatedSearch.prototype.docType = 1;

    /**
     * RelatedSearch current.
     * @member {boolean} current
     * @memberof RelatedSearch
     * @instance
     */
    RelatedSearch.prototype.current = false;

    /**
     * Creates a new RelatedSearch instance using the specified properties.
     * @function create
     * @memberof RelatedSearch
     * @static
     * @param {IRelatedSearch=} [properties] Properties to set
     * @returns {RelatedSearch} RelatedSearch instance
     */
    RelatedSearch.create = function create(properties) {
        return new RelatedSearch(properties);
    };

    /**
     * Encodes the specified RelatedSearch message. Does not implicitly {@link RelatedSearch.verify|verify} messages.
     * @function encode
     * @memberof RelatedSearch
     * @static
     * @param {IRelatedSearch} message RelatedSearch message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    RelatedSearch.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.searchUrl != null && Object.hasOwnProperty.call(message, "searchUrl"))
            writer.uint32(/* id 1, wireType 2 =*/10).string(message.searchUrl);
        if (message.header != null && Object.hasOwnProperty.call(message, "header"))
            writer.uint32(/* id 2, wireType 2 =*/18).string(message.header);
        if (message.backendId != null && Object.hasOwnProperty.call(message, "backendId"))
            writer.uint32(/* id 3, wireType 0 =*/24).int32(message.backendId);
        if (message.docType != null && Object.hasOwnProperty.call(message, "docType"))
            writer.uint32(/* id 4, wireType 0 =*/32).int32(message.docType);
        if (message.current != null && Object.hasOwnProperty.call(message, "current"))
            writer.uint32(/* id 5, wireType 0 =*/40).bool(message.current);
        return writer;
    };

    /**
     * Encodes the specified RelatedSearch message, length delimited. Does not implicitly {@link RelatedSearch.verify|verify} messages.
     * @function encodeDelimited
     * @memberof RelatedSearch
     * @static
     * @param {IRelatedSearch} message RelatedSearch message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    RelatedSearch.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a RelatedSearch message from the specified reader or buffer.
     * @function decode
     * @memberof RelatedSearch
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {RelatedSearch} RelatedSearch
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    RelatedSearch.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.RelatedSearch();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.searchUrl = reader.string();
                break;
            case 2:
                message.header = reader.string();
                break;
            case 3:
                message.backendId = reader.int32();
                break;
            case 4:
                message.docType = reader.int32();
                break;
            case 5:
                message.current = reader.bool();
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a RelatedSearch message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof RelatedSearch
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {RelatedSearch} RelatedSearch
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    RelatedSearch.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a RelatedSearch message.
     * @function verify
     * @memberof RelatedSearch
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    RelatedSearch.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.searchUrl != null && message.hasOwnProperty("searchUrl"))
            if (!$util.isString(message.searchUrl))
                return "searchUrl: string expected";
        if (message.header != null && message.hasOwnProperty("header"))
            if (!$util.isString(message.header))
                return "header: string expected";
        if (message.backendId != null && message.hasOwnProperty("backendId"))
            if (!$util.isInteger(message.backendId))
                return "backendId: integer expected";
        if (message.docType != null && message.hasOwnProperty("docType"))
            if (!$util.isInteger(message.docType))
                return "docType: integer expected";
        if (message.current != null && message.hasOwnProperty("current"))
            if (typeof message.current !== "boolean")
                return "current: boolean expected";
        return null;
    };

    /**
     * Creates a RelatedSearch message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof RelatedSearch
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {RelatedSearch} RelatedSearch
     */
    RelatedSearch.fromObject = function fromObject(object) {
        if (object instanceof $root.RelatedSearch)
            return object;
        var message = new $root.RelatedSearch();
        if (object.searchUrl != null)
            message.searchUrl = String(object.searchUrl);
        if (object.header != null)
            message.header = String(object.header);
        if (object.backendId != null)
            message.backendId = object.backendId | 0;
        if (object.docType != null)
            message.docType = object.docType | 0;
        if (object.current != null)
            message.current = Boolean(object.current);
        return message;
    };

    /**
     * Creates a plain object from a RelatedSearch message. Also converts values to other types if specified.
     * @function toObject
     * @memberof RelatedSearch
     * @static
     * @param {RelatedSearch} message RelatedSearch
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    RelatedSearch.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        var object = {};
        if (options.defaults) {
            object.searchUrl = "";
            object.header = "";
            object.backendId = 0;
            object.docType = 1;
            object.current = false;
        }
        if (message.searchUrl != null && message.hasOwnProperty("searchUrl"))
            object.searchUrl = message.searchUrl;
        if (message.header != null && message.hasOwnProperty("header"))
            object.header = message.header;
        if (message.backendId != null && message.hasOwnProperty("backendId"))
            object.backendId = message.backendId;
        if (message.docType != null && message.hasOwnProperty("docType"))
            object.docType = message.docType;
        if (message.current != null && message.hasOwnProperty("current"))
            object.current = message.current;
        return object;
    };

    /**
     * Converts this RelatedSearch to JSON.
     * @function toJSON
     * @memberof RelatedSearch
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    RelatedSearch.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return RelatedSearch;
})();

$root.SearchResponse = (function() {

    /**
     * Properties of a SearchResponse.
     * @exports ISearchResponse
     * @interface ISearchResponse
     * @property {string|null} [originalQuery] SearchResponse originalQuery
     * @property {string|null} [suggestedQuery] SearchResponse suggestedQuery
     * @property {boolean|null} [aggregateQuery] SearchResponse aggregateQuery
     * @property {Array.<IBucket>|null} [bucket] SearchResponse bucket
     * @property {Array.<IItem>|null} [item] SearchResponse item
     * @property {Array.<IRelatedSearch>|null} [relatedSearch] SearchResponse relatedSearch
     * @property {Uint8Array|null} [serverLogsCookie] SearchResponse serverLogsCookie
     * @property {boolean|null} [fullPageReplaced] SearchResponse fullPageReplaced
     * @property {boolean|null} [containsSnow] SearchResponse containsSnow
     * @property {string|null} [nextPageUrl] SearchResponse nextPageUrl
     */

    /**
     * Constructs a new SearchResponse.
     * @exports SearchResponse
     * @classdesc Represents a SearchResponse.
     * @implements ISearchResponse
     * @constructor
     * @param {ISearchResponse=} [properties] Properties to set
     */
    function SearchResponse(properties) {
        this.bucket = [];
        this.item = [];
        this.relatedSearch = [];
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * SearchResponse originalQuery.
     * @member {string} originalQuery
     * @memberof SearchResponse
     * @instance
     */
    SearchResponse.prototype.originalQuery = "";

    /**
     * SearchResponse suggestedQuery.
     * @member {string} suggestedQuery
     * @memberof SearchResponse
     * @instance
     */
    SearchResponse.prototype.suggestedQuery = "";

    /**
     * SearchResponse aggregateQuery.
     * @member {boolean} aggregateQuery
     * @memberof SearchResponse
     * @instance
     */
    SearchResponse.prototype.aggregateQuery = false;

    /**
     * SearchResponse bucket.
     * @member {Array.<IBucket>} bucket
     * @memberof SearchResponse
     * @instance
     */
    SearchResponse.prototype.bucket = $util.emptyArray;

    /**
     * SearchResponse item.
     * @member {Array.<IItem>} item
     * @memberof SearchResponse
     * @instance
     */
    SearchResponse.prototype.item = $util.emptyArray;

    /**
     * SearchResponse relatedSearch.
     * @member {Array.<IRelatedSearch>} relatedSearch
     * @memberof SearchResponse
     * @instance
     */
    SearchResponse.prototype.relatedSearch = $util.emptyArray;

    /**
     * SearchResponse serverLogsCookie.
     * @member {Uint8Array} serverLogsCookie
     * @memberof SearchResponse
     * @instance
     */
    SearchResponse.prototype.serverLogsCookie = $util.newBuffer([]);

    /**
     * SearchResponse fullPageReplaced.
     * @member {boolean} fullPageReplaced
     * @memberof SearchResponse
     * @instance
     */
    SearchResponse.prototype.fullPageReplaced = false;

    /**
     * SearchResponse containsSnow.
     * @member {boolean} containsSnow
     * @memberof SearchResponse
     * @instance
     */
    SearchResponse.prototype.containsSnow = false;

    /**
     * SearchResponse nextPageUrl.
     * @member {string} nextPageUrl
     * @memberof SearchResponse
     * @instance
     */
    SearchResponse.prototype.nextPageUrl = "";

    /**
     * Creates a new SearchResponse instance using the specified properties.
     * @function create
     * @memberof SearchResponse
     * @static
     * @param {ISearchResponse=} [properties] Properties to set
     * @returns {SearchResponse} SearchResponse instance
     */
    SearchResponse.create = function create(properties) {
        return new SearchResponse(properties);
    };

    /**
     * Encodes the specified SearchResponse message. Does not implicitly {@link SearchResponse.verify|verify} messages.
     * @function encode
     * @memberof SearchResponse
     * @static
     * @param {ISearchResponse} message SearchResponse message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    SearchResponse.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.originalQuery != null && Object.hasOwnProperty.call(message, "originalQuery"))
            writer.uint32(/* id 1, wireType 2 =*/10).string(message.originalQuery);
        if (message.suggestedQuery != null && Object.hasOwnProperty.call(message, "suggestedQuery"))
            writer.uint32(/* id 2, wireType 2 =*/18).string(message.suggestedQuery);
        if (message.aggregateQuery != null && Object.hasOwnProperty.call(message, "aggregateQuery"))
            writer.uint32(/* id 3, wireType 0 =*/24).bool(message.aggregateQuery);
        if (message.bucket != null && message.bucket.length)
            for (var i = 0; i < message.bucket.length; ++i)
                $root.Bucket.encode(message.bucket[i], writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
        if (message.item != null && message.item.length)
            for (var i = 0; i < message.item.length; ++i)
                $root.Item.encode(message.item[i], writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
        if (message.relatedSearch != null && message.relatedSearch.length)
            for (var i = 0; i < message.relatedSearch.length; ++i)
                $root.RelatedSearch.encode(message.relatedSearch[i], writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
        if (message.serverLogsCookie != null && Object.hasOwnProperty.call(message, "serverLogsCookie"))
            writer.uint32(/* id 7, wireType 2 =*/58).bytes(message.serverLogsCookie);
        if (message.fullPageReplaced != null && Object.hasOwnProperty.call(message, "fullPageReplaced"))
            writer.uint32(/* id 8, wireType 0 =*/64).bool(message.fullPageReplaced);
        if (message.containsSnow != null && Object.hasOwnProperty.call(message, "containsSnow"))
            writer.uint32(/* id 9, wireType 0 =*/72).bool(message.containsSnow);
        if (message.nextPageUrl != null && Object.hasOwnProperty.call(message, "nextPageUrl"))
            writer.uint32(/* id 10, wireType 2 =*/82).string(message.nextPageUrl);
        return writer;
    };

    /**
     * Encodes the specified SearchResponse message, length delimited. Does not implicitly {@link SearchResponse.verify|verify} messages.
     * @function encodeDelimited
     * @memberof SearchResponse
     * @static
     * @param {ISearchResponse} message SearchResponse message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    SearchResponse.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a SearchResponse message from the specified reader or buffer.
     * @function decode
     * @memberof SearchResponse
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {SearchResponse} SearchResponse
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    SearchResponse.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.SearchResponse();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.originalQuery = reader.string();
                break;
            case 2:
                message.suggestedQuery = reader.string();
                break;
            case 3:
                message.aggregateQuery = reader.bool();
                break;
            case 4:
                if (!(message.bucket && message.bucket.length))
                    message.bucket = [];
                message.bucket.push($root.Bucket.decode(reader, reader.uint32()));
                break;
            case 5:
                if (!(message.item && message.item.length))
                    message.item = [];
                message.item.push($root.Item.decode(reader, reader.uint32()));
                break;
            case 6:
                if (!(message.relatedSearch && message.relatedSearch.length))
                    message.relatedSearch = [];
                message.relatedSearch.push($root.RelatedSearch.decode(reader, reader.uint32()));
                break;
            case 7:
                message.serverLogsCookie = reader.bytes();
                break;
            case 8:
                message.fullPageReplaced = reader.bool();
                break;
            case 9:
                message.containsSnow = reader.bool();
                break;
            case 10:
                message.nextPageUrl = reader.string();
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a SearchResponse message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof SearchResponse
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {SearchResponse} SearchResponse
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    SearchResponse.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a SearchResponse message.
     * @function verify
     * @memberof SearchResponse
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    SearchResponse.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.originalQuery != null && message.hasOwnProperty("originalQuery"))
            if (!$util.isString(message.originalQuery))
                return "originalQuery: string expected";
        if (message.suggestedQuery != null && message.hasOwnProperty("suggestedQuery"))
            if (!$util.isString(message.suggestedQuery))
                return "suggestedQuery: string expected";
        if (message.aggregateQuery != null && message.hasOwnProperty("aggregateQuery"))
            if (typeof message.aggregateQuery !== "boolean")
                return "aggregateQuery: boolean expected";
        if (message.bucket != null && message.hasOwnProperty("bucket")) {
            if (!Array.isArray(message.bucket))
                return "bucket: array expected";
            for (var i = 0; i < message.bucket.length; ++i) {
                var error = $root.Bucket.verify(message.bucket[i]);
                if (error)
                    return "bucket." + error;
            }
        }
        if (message.item != null && message.hasOwnProperty("item")) {
            if (!Array.isArray(message.item))
                return "item: array expected";
            for (var i = 0; i < message.item.length; ++i) {
                var error = $root.Item.verify(message.item[i]);
                if (error)
                    return "item." + error;
            }
        }
        if (message.relatedSearch != null && message.hasOwnProperty("relatedSearch")) {
            if (!Array.isArray(message.relatedSearch))
                return "relatedSearch: array expected";
            for (var i = 0; i < message.relatedSearch.length; ++i) {
                var error = $root.RelatedSearch.verify(message.relatedSearch[i]);
                if (error)
                    return "relatedSearch." + error;
            }
        }
        if (message.serverLogsCookie != null && message.hasOwnProperty("serverLogsCookie"))
            if (!(message.serverLogsCookie && typeof message.serverLogsCookie.length === "number" || $util.isString(message.serverLogsCookie)))
                return "serverLogsCookie: buffer expected";
        if (message.fullPageReplaced != null && message.hasOwnProperty("fullPageReplaced"))
            if (typeof message.fullPageReplaced !== "boolean")
                return "fullPageReplaced: boolean expected";
        if (message.containsSnow != null && message.hasOwnProperty("containsSnow"))
            if (typeof message.containsSnow !== "boolean")
                return "containsSnow: boolean expected";
        if (message.nextPageUrl != null && message.hasOwnProperty("nextPageUrl"))
            if (!$util.isString(message.nextPageUrl))
                return "nextPageUrl: string expected";
        return null;
    };

    /**
     * Creates a SearchResponse message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof SearchResponse
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {SearchResponse} SearchResponse
     */
    SearchResponse.fromObject = function fromObject(object) {
        if (object instanceof $root.SearchResponse)
            return object;
        var message = new $root.SearchResponse();
        if (object.originalQuery != null)
            message.originalQuery = String(object.originalQuery);
        if (object.suggestedQuery != null)
            message.suggestedQuery = String(object.suggestedQuery);
        if (object.aggregateQuery != null)
            message.aggregateQuery = Boolean(object.aggregateQuery);
        if (object.bucket) {
            if (!Array.isArray(object.bucket))
                throw TypeError(".SearchResponse.bucket: array expected");
            message.bucket = [];
            for (var i = 0; i < object.bucket.length; ++i) {
                if (typeof object.bucket[i] !== "object")
                    throw TypeError(".SearchResponse.bucket: object expected");
                message.bucket[i] = $root.Bucket.fromObject(object.bucket[i]);
            }
        }
        if (object.item) {
            if (!Array.isArray(object.item))
                throw TypeError(".SearchResponse.item: array expected");
            message.item = [];
            for (var i = 0; i < object.item.length; ++i) {
                if (typeof object.item[i] !== "object")
                    throw TypeError(".SearchResponse.item: object expected");
                message.item[i] = $root.Item.fromObject(object.item[i]);
            }
        }
        if (object.relatedSearch) {
            if (!Array.isArray(object.relatedSearch))
                throw TypeError(".SearchResponse.relatedSearch: array expected");
            message.relatedSearch = [];
            for (var i = 0; i < object.relatedSearch.length; ++i) {
                if (typeof object.relatedSearch[i] !== "object")
                    throw TypeError(".SearchResponse.relatedSearch: object expected");
                message.relatedSearch[i] = $root.RelatedSearch.fromObject(object.relatedSearch[i]);
            }
        }
        if (object.serverLogsCookie != null)
            if (typeof object.serverLogsCookie === "string")
                $util.base64.decode(object.serverLogsCookie, message.serverLogsCookie = $util.newBuffer($util.base64.length(object.serverLogsCookie)), 0);
            else if (object.serverLogsCookie.length)
                message.serverLogsCookie = object.serverLogsCookie;
        if (object.fullPageReplaced != null)
            message.fullPageReplaced = Boolean(object.fullPageReplaced);
        if (object.containsSnow != null)
            message.containsSnow = Boolean(object.containsSnow);
        if (object.nextPageUrl != null)
            message.nextPageUrl = String(object.nextPageUrl);
        return message;
    };

    /**
     * Creates a plain object from a SearchResponse message. Also converts values to other types if specified.
     * @function toObject
     * @memberof SearchResponse
     * @static
     * @param {SearchResponse} message SearchResponse
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    SearchResponse.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        var object = {};
        if (options.arrays || options.defaults) {
            object.bucket = [];
            object.item = [];
            object.relatedSearch = [];
        }
        if (options.defaults) {
            object.originalQuery = "";
            object.suggestedQuery = "";
            object.aggregateQuery = false;
            if (options.bytes === String)
                object.serverLogsCookie = "";
            else {
                object.serverLogsCookie = [];
                if (options.bytes !== Array)
                    object.serverLogsCookie = $util.newBuffer(object.serverLogsCookie);
            }
            object.fullPageReplaced = false;
            object.containsSnow = false;
            object.nextPageUrl = "";
        }
        if (message.originalQuery != null && message.hasOwnProperty("originalQuery"))
            object.originalQuery = message.originalQuery;
        if (message.suggestedQuery != null && message.hasOwnProperty("suggestedQuery"))
            object.suggestedQuery = message.suggestedQuery;
        if (message.aggregateQuery != null && message.hasOwnProperty("aggregateQuery"))
            object.aggregateQuery = message.aggregateQuery;
        if (message.bucket && message.bucket.length) {
            object.bucket = [];
            for (var j = 0; j < message.bucket.length; ++j)
                object.bucket[j] = $root.Bucket.toObject(message.bucket[j], options);
        }
        if (message.item && message.item.length) {
            object.item = [];
            for (var j = 0; j < message.item.length; ++j)
                object.item[j] = $root.Item.toObject(message.item[j], options);
        }
        if (message.relatedSearch && message.relatedSearch.length) {
            object.relatedSearch = [];
            for (var j = 0; j < message.relatedSearch.length; ++j)
                object.relatedSearch[j] = $root.RelatedSearch.toObject(message.relatedSearch[j], options);
        }
        if (message.serverLogsCookie != null && message.hasOwnProperty("serverLogsCookie"))
            object.serverLogsCookie = options.bytes === String ? $util.base64.encode(message.serverLogsCookie, 0, message.serverLogsCookie.length) : options.bytes === Array ? Array.prototype.slice.call(message.serverLogsCookie) : message.serverLogsCookie;
        if (message.fullPageReplaced != null && message.hasOwnProperty("fullPageReplaced"))
            object.fullPageReplaced = message.fullPageReplaced;
        if (message.containsSnow != null && message.hasOwnProperty("containsSnow"))
            object.containsSnow = message.containsSnow;
        if (message.nextPageUrl != null && message.hasOwnProperty("nextPageUrl"))
            object.nextPageUrl = message.nextPageUrl;
        return object;
    };

    /**
     * Converts this SearchResponse to JSON.
     * @function toJSON
     * @memberof SearchResponse
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    SearchResponse.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return SearchResponse;
})();

$root.SearchSuggestResponse = (function() {

    /**
     * Properties of a SearchSuggestResponse.
     * @exports ISearchSuggestResponse
     * @interface ISearchSuggestResponse
     * @property {Array.<ISearchSuggestEntry>|null} [entry] SearchSuggestResponse entry
     */

    /**
     * Constructs a new SearchSuggestResponse.
     * @exports SearchSuggestResponse
     * @classdesc Represents a SearchSuggestResponse.
     * @implements ISearchSuggestResponse
     * @constructor
     * @param {ISearchSuggestResponse=} [properties] Properties to set
     */
    function SearchSuggestResponse(properties) {
        this.entry = [];
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * SearchSuggestResponse entry.
     * @member {Array.<ISearchSuggestEntry>} entry
     * @memberof SearchSuggestResponse
     * @instance
     */
    SearchSuggestResponse.prototype.entry = $util.emptyArray;

    /**
     * Creates a new SearchSuggestResponse instance using the specified properties.
     * @function create
     * @memberof SearchSuggestResponse
     * @static
     * @param {ISearchSuggestResponse=} [properties] Properties to set
     * @returns {SearchSuggestResponse} SearchSuggestResponse instance
     */
    SearchSuggestResponse.create = function create(properties) {
        return new SearchSuggestResponse(properties);
    };

    /**
     * Encodes the specified SearchSuggestResponse message. Does not implicitly {@link SearchSuggestResponse.verify|verify} messages.
     * @function encode
     * @memberof SearchSuggestResponse
     * @static
     * @param {ISearchSuggestResponse} message SearchSuggestResponse message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    SearchSuggestResponse.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.entry != null && message.entry.length)
            for (var i = 0; i < message.entry.length; ++i)
                $root.SearchSuggestEntry.encode(message.entry[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
        return writer;
    };

    /**
     * Encodes the specified SearchSuggestResponse message, length delimited. Does not implicitly {@link SearchSuggestResponse.verify|verify} messages.
     * @function encodeDelimited
     * @memberof SearchSuggestResponse
     * @static
     * @param {ISearchSuggestResponse} message SearchSuggestResponse message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    SearchSuggestResponse.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a SearchSuggestResponse message from the specified reader or buffer.
     * @function decode
     * @memberof SearchSuggestResponse
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {SearchSuggestResponse} SearchSuggestResponse
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    SearchSuggestResponse.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.SearchSuggestResponse();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                if (!(message.entry && message.entry.length))
                    message.entry = [];
                message.entry.push($root.SearchSuggestEntry.decode(reader, reader.uint32()));
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a SearchSuggestResponse message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof SearchSuggestResponse
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {SearchSuggestResponse} SearchSuggestResponse
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    SearchSuggestResponse.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a SearchSuggestResponse message.
     * @function verify
     * @memberof SearchSuggestResponse
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    SearchSuggestResponse.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.entry != null && message.hasOwnProperty("entry")) {
            if (!Array.isArray(message.entry))
                return "entry: array expected";
            for (var i = 0; i < message.entry.length; ++i) {
                var error = $root.SearchSuggestEntry.verify(message.entry[i]);
                if (error)
                    return "entry." + error;
            }
        }
        return null;
    };

    /**
     * Creates a SearchSuggestResponse message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof SearchSuggestResponse
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {SearchSuggestResponse} SearchSuggestResponse
     */
    SearchSuggestResponse.fromObject = function fromObject(object) {
        if (object instanceof $root.SearchSuggestResponse)
            return object;
        var message = new $root.SearchSuggestResponse();
        if (object.entry) {
            if (!Array.isArray(object.entry))
                throw TypeError(".SearchSuggestResponse.entry: array expected");
            message.entry = [];
            for (var i = 0; i < object.entry.length; ++i) {
                if (typeof object.entry[i] !== "object")
                    throw TypeError(".SearchSuggestResponse.entry: object expected");
                message.entry[i] = $root.SearchSuggestEntry.fromObject(object.entry[i]);
            }
        }
        return message;
    };

    /**
     * Creates a plain object from a SearchSuggestResponse message. Also converts values to other types if specified.
     * @function toObject
     * @memberof SearchSuggestResponse
     * @static
     * @param {SearchSuggestResponse} message SearchSuggestResponse
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    SearchSuggestResponse.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        var object = {};
        if (options.arrays || options.defaults)
            object.entry = [];
        if (message.entry && message.entry.length) {
            object.entry = [];
            for (var j = 0; j < message.entry.length; ++j)
                object.entry[j] = $root.SearchSuggestEntry.toObject(message.entry[j], options);
        }
        return object;
    };

    /**
     * Converts this SearchSuggestResponse to JSON.
     * @function toJSON
     * @memberof SearchSuggestResponse
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    SearchSuggestResponse.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return SearchSuggestResponse;
})();

$root.SearchSuggestEntry = (function() {

    /**
     * Properties of a SearchSuggestEntry.
     * @exports ISearchSuggestEntry
     * @interface ISearchSuggestEntry
     * @property {number|null} [type] SearchSuggestEntry type
     * @property {string|null} [suggestedQuery] SearchSuggestEntry suggestedQuery
     * @property {SearchSuggestEntry.IImageContainer|null} [imageContainer] SearchSuggestEntry imageContainer
     * @property {string|null} [title] SearchSuggestEntry title
     * @property {SearchSuggestEntry.IPackageNameContainer|null} [packageNameContainer] SearchSuggestEntry packageNameContainer
     */

    /**
     * Constructs a new SearchSuggestEntry.
     * @exports SearchSuggestEntry
     * @classdesc Represents a SearchSuggestEntry.
     * @implements ISearchSuggestEntry
     * @constructor
     * @param {ISearchSuggestEntry=} [properties] Properties to set
     */
    function SearchSuggestEntry(properties) {
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * SearchSuggestEntry type.
     * @member {number} type
     * @memberof SearchSuggestEntry
     * @instance
     */
    SearchSuggestEntry.prototype.type = 0;

    /**
     * SearchSuggestEntry suggestedQuery.
     * @member {string} suggestedQuery
     * @memberof SearchSuggestEntry
     * @instance
     */
    SearchSuggestEntry.prototype.suggestedQuery = "";

    /**
     * SearchSuggestEntry imageContainer.
     * @member {SearchSuggestEntry.IImageContainer|null|undefined} imageContainer
     * @memberof SearchSuggestEntry
     * @instance
     */
    SearchSuggestEntry.prototype.imageContainer = null;

    /**
     * SearchSuggestEntry title.
     * @member {string} title
     * @memberof SearchSuggestEntry
     * @instance
     */
    SearchSuggestEntry.prototype.title = "";

    /**
     * SearchSuggestEntry packageNameContainer.
     * @member {SearchSuggestEntry.IPackageNameContainer|null|undefined} packageNameContainer
     * @memberof SearchSuggestEntry
     * @instance
     */
    SearchSuggestEntry.prototype.packageNameContainer = null;

    /**
     * Creates a new SearchSuggestEntry instance using the specified properties.
     * @function create
     * @memberof SearchSuggestEntry
     * @static
     * @param {ISearchSuggestEntry=} [properties] Properties to set
     * @returns {SearchSuggestEntry} SearchSuggestEntry instance
     */
    SearchSuggestEntry.create = function create(properties) {
        return new SearchSuggestEntry(properties);
    };

    /**
     * Encodes the specified SearchSuggestEntry message. Does not implicitly {@link SearchSuggestEntry.verify|verify} messages.
     * @function encode
     * @memberof SearchSuggestEntry
     * @static
     * @param {ISearchSuggestEntry} message SearchSuggestEntry message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    SearchSuggestEntry.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.type != null && Object.hasOwnProperty.call(message, "type"))
            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.type);
        if (message.suggestedQuery != null && Object.hasOwnProperty.call(message, "suggestedQuery"))
            writer.uint32(/* id 2, wireType 2 =*/18).string(message.suggestedQuery);
        if (message.imageContainer != null && Object.hasOwnProperty.call(message, "imageContainer"))
            $root.SearchSuggestEntry.ImageContainer.encode(message.imageContainer, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
        if (message.title != null && Object.hasOwnProperty.call(message, "title"))
            writer.uint32(/* id 6, wireType 2 =*/50).string(message.title);
        if (message.packageNameContainer != null && Object.hasOwnProperty.call(message, "packageNameContainer"))
            $root.SearchSuggestEntry.PackageNameContainer.encode(message.packageNameContainer, writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();
        return writer;
    };

    /**
     * Encodes the specified SearchSuggestEntry message, length delimited. Does not implicitly {@link SearchSuggestEntry.verify|verify} messages.
     * @function encodeDelimited
     * @memberof SearchSuggestEntry
     * @static
     * @param {ISearchSuggestEntry} message SearchSuggestEntry message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    SearchSuggestEntry.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a SearchSuggestEntry message from the specified reader or buffer.
     * @function decode
     * @memberof SearchSuggestEntry
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {SearchSuggestEntry} SearchSuggestEntry
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    SearchSuggestEntry.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.SearchSuggestEntry();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.type = reader.int32();
                break;
            case 2:
                message.suggestedQuery = reader.string();
                break;
            case 5:
                message.imageContainer = $root.SearchSuggestEntry.ImageContainer.decode(reader, reader.uint32());
                break;
            case 6:
                message.title = reader.string();
                break;
            case 8:
                message.packageNameContainer = $root.SearchSuggestEntry.PackageNameContainer.decode(reader, reader.uint32());
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a SearchSuggestEntry message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof SearchSuggestEntry
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {SearchSuggestEntry} SearchSuggestEntry
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    SearchSuggestEntry.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a SearchSuggestEntry message.
     * @function verify
     * @memberof SearchSuggestEntry
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    SearchSuggestEntry.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.type != null && message.hasOwnProperty("type"))
            if (!$util.isInteger(message.type))
                return "type: integer expected";
        if (message.suggestedQuery != null && message.hasOwnProperty("suggestedQuery"))
            if (!$util.isString(message.suggestedQuery))
                return "suggestedQuery: string expected";
        if (message.imageContainer != null && message.hasOwnProperty("imageContainer")) {
            var error = $root.SearchSuggestEntry.ImageContainer.verify(message.imageContainer);
            if (error)
                return "imageContainer." + error;
        }
        if (message.title != null && message.hasOwnProperty("title"))
            if (!$util.isString(message.title))
                return "title: string expected";
        if (message.packageNameContainer != null && message.hasOwnProperty("packageNameContainer")) {
            var error = $root.SearchSuggestEntry.PackageNameContainer.verify(message.packageNameContainer);
            if (error)
                return "packageNameContainer." + error;
        }
        return null;
    };

    /**
     * Creates a SearchSuggestEntry message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof SearchSuggestEntry
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {SearchSuggestEntry} SearchSuggestEntry
     */
    SearchSuggestEntry.fromObject = function fromObject(object) {
        if (object instanceof $root.SearchSuggestEntry)
            return object;
        var message = new $root.SearchSuggestEntry();
        if (object.type != null)
            message.type = object.type | 0;
        if (object.suggestedQuery != null)
            message.suggestedQuery = String(object.suggestedQuery);
        if (object.imageContainer != null) {
            if (typeof object.imageContainer !== "object")
                throw TypeError(".SearchSuggestEntry.imageContainer: object expected");
            message.imageContainer = $root.SearchSuggestEntry.ImageContainer.fromObject(object.imageContainer);
        }
        if (object.title != null)
            message.title = String(object.title);
        if (object.packageNameContainer != null) {
            if (typeof object.packageNameContainer !== "object")
                throw TypeError(".SearchSuggestEntry.packageNameContainer: object expected");
            message.packageNameContainer = $root.SearchSuggestEntry.PackageNameContainer.fromObject(object.packageNameContainer);
        }
        return message;
    };

    /**
     * Creates a plain object from a SearchSuggestEntry message. Also converts values to other types if specified.
     * @function toObject
     * @memberof SearchSuggestEntry
     * @static
     * @param {SearchSuggestEntry} message SearchSuggestEntry
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    SearchSuggestEntry.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        var object = {};
        if (options.defaults) {
            object.type = 0;
            object.suggestedQuery = "";
            object.imageContainer = null;
            object.title = "";
            object.packageNameContainer = null;
        }
        if (message.type != null && message.hasOwnProperty("type"))
            object.type = message.type;
        if (message.suggestedQuery != null && message.hasOwnProperty("suggestedQuery"))
            object.suggestedQuery = message.suggestedQuery;
        if (message.imageContainer != null && message.hasOwnProperty("imageContainer"))
            object.imageContainer = $root.SearchSuggestEntry.ImageContainer.toObject(message.imageContainer, options);
        if (message.title != null && message.hasOwnProperty("title"))
            object.title = message.title;
        if (message.packageNameContainer != null && message.hasOwnProperty("packageNameContainer"))
            object.packageNameContainer = $root.SearchSuggestEntry.PackageNameContainer.toObject(message.packageNameContainer, options);
        return object;
    };

    /**
     * Converts this SearchSuggestEntry to JSON.
     * @function toJSON
     * @memberof SearchSuggestEntry
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    SearchSuggestEntry.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    SearchSuggestEntry.ImageContainer = (function() {

        /**
         * Properties of an ImageContainer.
         * @memberof SearchSuggestEntry
         * @interface IImageContainer
         * @property {string|null} [imageUrl] ImageContainer imageUrl
         */

        /**
         * Constructs a new ImageContainer.
         * @memberof SearchSuggestEntry
         * @classdesc Represents an ImageContainer.
         * @implements IImageContainer
         * @constructor
         * @param {SearchSuggestEntry.IImageContainer=} [properties] Properties to set
         */
        function ImageContainer(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ImageContainer imageUrl.
         * @member {string} imageUrl
         * @memberof SearchSuggestEntry.ImageContainer
         * @instance
         */
        ImageContainer.prototype.imageUrl = "";

        /**
         * Creates a new ImageContainer instance using the specified properties.
         * @function create
         * @memberof SearchSuggestEntry.ImageContainer
         * @static
         * @param {SearchSuggestEntry.IImageContainer=} [properties] Properties to set
         * @returns {SearchSuggestEntry.ImageContainer} ImageContainer instance
         */
        ImageContainer.create = function create(properties) {
            return new ImageContainer(properties);
        };

        /**
         * Encodes the specified ImageContainer message. Does not implicitly {@link SearchSuggestEntry.ImageContainer.verify|verify} messages.
         * @function encode
         * @memberof SearchSuggestEntry.ImageContainer
         * @static
         * @param {SearchSuggestEntry.IImageContainer} message ImageContainer message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ImageContainer.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.imageUrl != null && Object.hasOwnProperty.call(message, "imageUrl"))
                writer.uint32(/* id 5, wireType 2 =*/42).string(message.imageUrl);
            return writer;
        };

        /**
         * Encodes the specified ImageContainer message, length delimited. Does not implicitly {@link SearchSuggestEntry.ImageContainer.verify|verify} messages.
         * @function encodeDelimited
         * @memberof SearchSuggestEntry.ImageContainer
         * @static
         * @param {SearchSuggestEntry.IImageContainer} message ImageContainer message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ImageContainer.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an ImageContainer message from the specified reader or buffer.
         * @function decode
         * @memberof SearchSuggestEntry.ImageContainer
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {SearchSuggestEntry.ImageContainer} ImageContainer
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ImageContainer.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.SearchSuggestEntry.ImageContainer();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 5:
                    message.imageUrl = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an ImageContainer message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof SearchSuggestEntry.ImageContainer
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {SearchSuggestEntry.ImageContainer} ImageContainer
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ImageContainer.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an ImageContainer message.
         * @function verify
         * @memberof SearchSuggestEntry.ImageContainer
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ImageContainer.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.imageUrl != null && message.hasOwnProperty("imageUrl"))
                if (!$util.isString(message.imageUrl))
                    return "imageUrl: string expected";
            return null;
        };

        /**
         * Creates an ImageContainer message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof SearchSuggestEntry.ImageContainer
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {SearchSuggestEntry.ImageContainer} ImageContainer
         */
        ImageContainer.fromObject = function fromObject(object) {
            if (object instanceof $root.SearchSuggestEntry.ImageContainer)
                return object;
            var message = new $root.SearchSuggestEntry.ImageContainer();
            if (object.imageUrl != null)
                message.imageUrl = String(object.imageUrl);
            return message;
        };

        /**
         * Creates a plain object from an ImageContainer message. Also converts values to other types if specified.
         * @function toObject
         * @memberof SearchSuggestEntry.ImageContainer
         * @static
         * @param {SearchSuggestEntry.ImageContainer} message ImageContainer
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ImageContainer.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.imageUrl = "";
            if (message.imageUrl != null && message.hasOwnProperty("imageUrl"))
                object.imageUrl = message.imageUrl;
            return object;
        };

        /**
         * Converts this ImageContainer to JSON.
         * @function toJSON
         * @memberof SearchSuggestEntry.ImageContainer
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ImageContainer.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ImageContainer;
    })();

    SearchSuggestEntry.PackageNameContainer = (function() {

        /**
         * Properties of a PackageNameContainer.
         * @memberof SearchSuggestEntry
         * @interface IPackageNameContainer
         * @property {string|null} [packageName] PackageNameContainer packageName
         */

        /**
         * Constructs a new PackageNameContainer.
         * @memberof SearchSuggestEntry
         * @classdesc Represents a PackageNameContainer.
         * @implements IPackageNameContainer
         * @constructor
         * @param {SearchSuggestEntry.IPackageNameContainer=} [properties] Properties to set
         */
        function PackageNameContainer(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * PackageNameContainer packageName.
         * @member {string} packageName
         * @memberof SearchSuggestEntry.PackageNameContainer
         * @instance
         */
        PackageNameContainer.prototype.packageName = "";

        /**
         * Creates a new PackageNameContainer instance using the specified properties.
         * @function create
         * @memberof SearchSuggestEntry.PackageNameContainer
         * @static
         * @param {SearchSuggestEntry.IPackageNameContainer=} [properties] Properties to set
         * @returns {SearchSuggestEntry.PackageNameContainer} PackageNameContainer instance
         */
        PackageNameContainer.create = function create(properties) {
            return new PackageNameContainer(properties);
        };

        /**
         * Encodes the specified PackageNameContainer message. Does not implicitly {@link SearchSuggestEntry.PackageNameContainer.verify|verify} messages.
         * @function encode
         * @memberof SearchSuggestEntry.PackageNameContainer
         * @static
         * @param {SearchSuggestEntry.IPackageNameContainer} message PackageNameContainer message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PackageNameContainer.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.packageName != null && Object.hasOwnProperty.call(message, "packageName"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.packageName);
            return writer;
        };

        /**
         * Encodes the specified PackageNameContainer message, length delimited. Does not implicitly {@link SearchSuggestEntry.PackageNameContainer.verify|verify} messages.
         * @function encodeDelimited
         * @memberof SearchSuggestEntry.PackageNameContainer
         * @static
         * @param {SearchSuggestEntry.IPackageNameContainer} message PackageNameContainer message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PackageNameContainer.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a PackageNameContainer message from the specified reader or buffer.
         * @function decode
         * @memberof SearchSuggestEntry.PackageNameContainer
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {SearchSuggestEntry.PackageNameContainer} PackageNameContainer
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PackageNameContainer.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.SearchSuggestEntry.PackageNameContainer();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.packageName = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a PackageNameContainer message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof SearchSuggestEntry.PackageNameContainer
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {SearchSuggestEntry.PackageNameContainer} PackageNameContainer
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PackageNameContainer.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a PackageNameContainer message.
         * @function verify
         * @memberof SearchSuggestEntry.PackageNameContainer
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PackageNameContainer.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.packageName != null && message.hasOwnProperty("packageName"))
                if (!$util.isString(message.packageName))
                    return "packageName: string expected";
            return null;
        };

        /**
         * Creates a PackageNameContainer message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof SearchSuggestEntry.PackageNameContainer
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {SearchSuggestEntry.PackageNameContainer} PackageNameContainer
         */
        PackageNameContainer.fromObject = function fromObject(object) {
            if (object instanceof $root.SearchSuggestEntry.PackageNameContainer)
                return object;
            var message = new $root.SearchSuggestEntry.PackageNameContainer();
            if (object.packageName != null)
                message.packageName = String(object.packageName);
            return message;
        };

        /**
         * Creates a plain object from a PackageNameContainer message. Also converts values to other types if specified.
         * @function toObject
         * @memberof SearchSuggestEntry.PackageNameContainer
         * @static
         * @param {SearchSuggestEntry.PackageNameContainer} message PackageNameContainer
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PackageNameContainer.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.packageName = "";
            if (message.packageName != null && message.hasOwnProperty("packageName"))
                object.packageName = message.packageName;
            return object;
        };

        /**
         * Converts this PackageNameContainer to JSON.
         * @function toJSON
         * @memberof SearchSuggestEntry.PackageNameContainer
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PackageNameContainer.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return PackageNameContainer;
    })();

    return SearchSuggestEntry;
})();

$root.TestingProgramResponse = (function() {

    /**
     * Properties of a TestingProgramResponse.
     * @exports ITestingProgramResponse
     * @interface ITestingProgramResponse
     * @property {ITestingProgramResult|null} [result] TestingProgramResponse result
     */

    /**
     * Constructs a new TestingProgramResponse.
     * @exports TestingProgramResponse
     * @classdesc Represents a TestingProgramResponse.
     * @implements ITestingProgramResponse
     * @constructor
     * @param {ITestingProgramResponse=} [properties] Properties to set
     */
    function TestingProgramResponse(properties) {
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * TestingProgramResponse result.
     * @member {ITestingProgramResult|null|undefined} result
     * @memberof TestingProgramResponse
     * @instance
     */
    TestingProgramResponse.prototype.result = null;

    /**
     * Creates a new TestingProgramResponse instance using the specified properties.
     * @function create
     * @memberof TestingProgramResponse
     * @static
     * @param {ITestingProgramResponse=} [properties] Properties to set
     * @returns {TestingProgramResponse} TestingProgramResponse instance
     */
    TestingProgramResponse.create = function create(properties) {
        return new TestingProgramResponse(properties);
    };

    /**
     * Encodes the specified TestingProgramResponse message. Does not implicitly {@link TestingProgramResponse.verify|verify} messages.
     * @function encode
     * @memberof TestingProgramResponse
     * @static
     * @param {ITestingProgramResponse} message TestingProgramResponse message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    TestingProgramResponse.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.result != null && Object.hasOwnProperty.call(message, "result"))
            $root.TestingProgramResult.encode(message.result, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
        return writer;
    };

    /**
     * Encodes the specified TestingProgramResponse message, length delimited. Does not implicitly {@link TestingProgramResponse.verify|verify} messages.
     * @function encodeDelimited
     * @memberof TestingProgramResponse
     * @static
     * @param {ITestingProgramResponse} message TestingProgramResponse message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    TestingProgramResponse.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a TestingProgramResponse message from the specified reader or buffer.
     * @function decode
     * @memberof TestingProgramResponse
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {TestingProgramResponse} TestingProgramResponse
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    TestingProgramResponse.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.TestingProgramResponse();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            case 2:
                message.result = $root.TestingProgramResult.decode(reader, reader.uint32());
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a TestingProgramResponse message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof TestingProgramResponse
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {TestingProgramResponse} TestingProgramResponse
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    TestingProgramResponse.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a TestingProgramResponse message.
     * @function verify
     * @memberof TestingProgramResponse
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    TestingProgramResponse.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.result != null && message.hasOwnProperty("result")) {
            var error = $root.TestingProgramResult.verify(message.result);
            if (error)
                return "result." + error;
        }
        return null;
    };

    /**
     * Creates a TestingProgramResponse message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof TestingProgramResponse
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {TestingProgramResponse} TestingProgramResponse
     */
    TestingProgramResponse.fromObject = function fromObject(object) {
        if (object instanceof $root.TestingProgramResponse)
            return object;
        var message = new $root.TestingProgramResponse();
        if (object.result != null) {
            if (typeof object.result !== "object")
                throw TypeError(".TestingProgramResponse.result: object expected");
            message.result = $root.TestingProgramResult.fromObject(object.result);
        }
        return message;
    };

    /**
     * Creates a plain object from a TestingProgramResponse message. Also converts values to other types if specified.
     * @function toObject
     * @memberof TestingProgramResponse
     * @static
     * @param {TestingProgramResponse} message TestingProgramResponse
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    TestingProgramResponse.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        var object = {};
        if (options.defaults)
            object.result = null;
        if (message.result != null && message.hasOwnProperty("result"))
            object.result = $root.TestingProgramResult.toObject(message.result, options);
        return object;
    };

    /**
     * Converts this TestingProgramResponse to JSON.
     * @function toJSON
     * @memberof TestingProgramResponse
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    TestingProgramResponse.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return TestingProgramResponse;
})();

$root.TestingProgramResult = (function() {

    /**
     * Properties of a TestingProgramResult.
     * @exports ITestingProgramResult
     * @interface ITestingProgramResult
     * @property {ITestingProgramDetails|null} [details] TestingProgramResult details
     */

    /**
     * Constructs a new TestingProgramResult.
     * @exports TestingProgramResult
     * @classdesc Represents a TestingProgramResult.
     * @implements ITestingProgramResult
     * @constructor
     * @param {ITestingProgramResult=} [properties] Properties to set
     */
    function TestingProgramResult(properties) {
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * TestingProgramResult details.
     * @member {ITestingProgramDetails|null|undefined} details
     * @memberof TestingProgramResult
     * @instance
     */
    TestingProgramResult.prototype.details = null;

    /**
     * Creates a new TestingProgramResult instance using the specified properties.
     * @function create
     * @memberof TestingProgramResult
     * @static
     * @param {ITestingProgramResult=} [properties] Properties to set
     * @returns {TestingProgramResult} TestingProgramResult instance
     */
    TestingProgramResult.create = function create(properties) {
        return new TestingProgramResult(properties);
    };

    /**
     * Encodes the specified TestingProgramResult message. Does not implicitly {@link TestingProgramResult.verify|verify} messages.
     * @function encode
     * @memberof TestingProgramResult
     * @static
     * @param {ITestingProgramResult} message TestingProgramResult message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    TestingProgramResult.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.details != null && Object.hasOwnProperty.call(message, "details"))
            $root.TestingProgramDetails.encode(message.details, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
        return writer;
    };

    /**
     * Encodes the specified TestingProgramResult message, length delimited. Does not implicitly {@link TestingProgramResult.verify|verify} messages.
     * @function encodeDelimited
     * @memberof TestingProgramResult
     * @static
     * @param {ITestingProgramResult} message TestingProgramResult message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    TestingProgramResult.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a TestingProgramResult message from the specified reader or buffer.
     * @function decode
     * @memberof TestingProgramResult
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {TestingProgramResult} TestingProgramResult
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    TestingProgramResult.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.TestingProgramResult();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            case 4:
                message.details = $root.TestingProgramDetails.decode(reader, reader.uint32());
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a TestingProgramResult message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof TestingProgramResult
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {TestingProgramResult} TestingProgramResult
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    TestingProgramResult.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a TestingProgramResult message.
     * @function verify
     * @memberof TestingProgramResult
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    TestingProgramResult.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.details != null && message.hasOwnProperty("details")) {
            var error = $root.TestingProgramDetails.verify(message.details);
            if (error)
                return "details." + error;
        }
        return null;
    };

    /**
     * Creates a TestingProgramResult message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof TestingProgramResult
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {TestingProgramResult} TestingProgramResult
     */
    TestingProgramResult.fromObject = function fromObject(object) {
        if (object instanceof $root.TestingProgramResult)
            return object;
        var message = new $root.TestingProgramResult();
        if (object.details != null) {
            if (typeof object.details !== "object")
                throw TypeError(".TestingProgramResult.details: object expected");
            message.details = $root.TestingProgramDetails.fromObject(object.details);
        }
        return message;
    };

    /**
     * Creates a plain object from a TestingProgramResult message. Also converts values to other types if specified.
     * @function toObject
     * @memberof TestingProgramResult
     * @static
     * @param {TestingProgramResult} message TestingProgramResult
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    TestingProgramResult.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        var object = {};
        if (options.defaults)
            object.details = null;
        if (message.details != null && message.hasOwnProperty("details"))
            object.details = $root.TestingProgramDetails.toObject(message.details, options);
        return object;
    };

    /**
     * Converts this TestingProgramResult to JSON.
     * @function toJSON
     * @memberof TestingProgramResult
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    TestingProgramResult.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return TestingProgramResult;
})();

$root.TestingProgramDetails = (function() {

    /**
     * Properties of a TestingProgramDetails.
     * @exports ITestingProgramDetails
     * @interface ITestingProgramDetails
     * @property {boolean|null} [subscribed] TestingProgramDetails subscribed
     * @property {number|Long|null} [id] TestingProgramDetails id
     * @property {boolean|null} [unsubscribed] TestingProgramDetails unsubscribed
     */

    /**
     * Constructs a new TestingProgramDetails.
     * @exports TestingProgramDetails
     * @classdesc Represents a TestingProgramDetails.
     * @implements ITestingProgramDetails
     * @constructor
     * @param {ITestingProgramDetails=} [properties] Properties to set
     */
    function TestingProgramDetails(properties) {
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * TestingProgramDetails subscribed.
     * @member {boolean} subscribed
     * @memberof TestingProgramDetails
     * @instance
     */
    TestingProgramDetails.prototype.subscribed = false;

    /**
     * TestingProgramDetails id.
     * @member {number|Long} id
     * @memberof TestingProgramDetails
     * @instance
     */
    TestingProgramDetails.prototype.id = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

    /**
     * TestingProgramDetails unsubscribed.
     * @member {boolean} unsubscribed
     * @memberof TestingProgramDetails
     * @instance
     */
    TestingProgramDetails.prototype.unsubscribed = false;

    /**
     * Creates a new TestingProgramDetails instance using the specified properties.
     * @function create
     * @memberof TestingProgramDetails
     * @static
     * @param {ITestingProgramDetails=} [properties] Properties to set
     * @returns {TestingProgramDetails} TestingProgramDetails instance
     */
    TestingProgramDetails.create = function create(properties) {
        return new TestingProgramDetails(properties);
    };

    /**
     * Encodes the specified TestingProgramDetails message. Does not implicitly {@link TestingProgramDetails.verify|verify} messages.
     * @function encode
     * @memberof TestingProgramDetails
     * @static
     * @param {ITestingProgramDetails} message TestingProgramDetails message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    TestingProgramDetails.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.subscribed != null && Object.hasOwnProperty.call(message, "subscribed"))
            writer.uint32(/* id 2, wireType 0 =*/16).bool(message.subscribed);
        if (message.id != null && Object.hasOwnProperty.call(message, "id"))
            writer.uint32(/* id 3, wireType 0 =*/24).int64(message.id);
        if (message.unsubscribed != null && Object.hasOwnProperty.call(message, "unsubscribed"))
            writer.uint32(/* id 4, wireType 0 =*/32).bool(message.unsubscribed);
        return writer;
    };

    /**
     * Encodes the specified TestingProgramDetails message, length delimited. Does not implicitly {@link TestingProgramDetails.verify|verify} messages.
     * @function encodeDelimited
     * @memberof TestingProgramDetails
     * @static
     * @param {ITestingProgramDetails} message TestingProgramDetails message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    TestingProgramDetails.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a TestingProgramDetails message from the specified reader or buffer.
     * @function decode
     * @memberof TestingProgramDetails
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {TestingProgramDetails} TestingProgramDetails
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    TestingProgramDetails.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.TestingProgramDetails();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            case 2:
                message.subscribed = reader.bool();
                break;
            case 3:
                message.id = reader.int64();
                break;
            case 4:
                message.unsubscribed = reader.bool();
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a TestingProgramDetails message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof TestingProgramDetails
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {TestingProgramDetails} TestingProgramDetails
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    TestingProgramDetails.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a TestingProgramDetails message.
     * @function verify
     * @memberof TestingProgramDetails
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    TestingProgramDetails.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.subscribed != null && message.hasOwnProperty("subscribed"))
            if (typeof message.subscribed !== "boolean")
                return "subscribed: boolean expected";
        if (message.id != null && message.hasOwnProperty("id"))
            if (!$util.isInteger(message.id) && !(message.id && $util.isInteger(message.id.low) && $util.isInteger(message.id.high)))
                return "id: integer|Long expected";
        if (message.unsubscribed != null && message.hasOwnProperty("unsubscribed"))
            if (typeof message.unsubscribed !== "boolean")
                return "unsubscribed: boolean expected";
        return null;
    };

    /**
     * Creates a TestingProgramDetails message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof TestingProgramDetails
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {TestingProgramDetails} TestingProgramDetails
     */
    TestingProgramDetails.fromObject = function fromObject(object) {
        if (object instanceof $root.TestingProgramDetails)
            return object;
        var message = new $root.TestingProgramDetails();
        if (object.subscribed != null)
            message.subscribed = Boolean(object.subscribed);
        if (object.id != null)
            if ($util.Long)
                (message.id = $util.Long.fromValue(object.id)).unsigned = false;
            else if (typeof object.id === "string")
                message.id = parseInt(object.id, 10);
            else if (typeof object.id === "number")
                message.id = object.id;
            else if (typeof object.id === "object")
                message.id = new $util.LongBits(object.id.low >>> 0, object.id.high >>> 0).toNumber();
        if (object.unsubscribed != null)
            message.unsubscribed = Boolean(object.unsubscribed);
        return message;
    };

    /**
     * Creates a plain object from a TestingProgramDetails message. Also converts values to other types if specified.
     * @function toObject
     * @memberof TestingProgramDetails
     * @static
     * @param {TestingProgramDetails} message TestingProgramDetails
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    TestingProgramDetails.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        var object = {};
        if (options.defaults) {
            object.subscribed = false;
            if ($util.Long) {
                var long = new $util.Long(0, 0, false);
                object.id = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
            } else
                object.id = options.longs === String ? "0" : 0;
            object.unsubscribed = false;
        }
        if (message.subscribed != null && message.hasOwnProperty("subscribed"))
            object.subscribed = message.subscribed;
        if (message.id != null && message.hasOwnProperty("id"))
            if (typeof message.id === "number")
                object.id = options.longs === String ? String(message.id) : message.id;
            else
                object.id = options.longs === String ? $util.Long.prototype.toString.call(message.id) : options.longs === Number ? new $util.LongBits(message.id.low >>> 0, message.id.high >>> 0).toNumber() : message.id;
        if (message.unsubscribed != null && message.hasOwnProperty("unsubscribed"))
            object.unsubscribed = message.unsubscribed;
        return object;
    };

    /**
     * Converts this TestingProgramDetails to JSON.
     * @function toJSON
     * @memberof TestingProgramDetails
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    TestingProgramDetails.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return TestingProgramDetails;
})();

$root.LogRequest = (function() {

    /**
     * Properties of a LogRequest.
     * @exports ILogRequest
     * @interface ILogRequest
     * @property {number|Long|null} [timestamp] LogRequest timestamp
     * @property {string|null} [downloadConfirmationQuery] LogRequest downloadConfirmationQuery
     */

    /**
     * Constructs a new LogRequest.
     * @exports LogRequest
     * @classdesc Represents a LogRequest.
     * @implements ILogRequest
     * @constructor
     * @param {ILogRequest=} [properties] Properties to set
     */
    function LogRequest(properties) {
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * LogRequest timestamp.
     * @member {number|Long} timestamp
     * @memberof LogRequest
     * @instance
     */
    LogRequest.prototype.timestamp = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

    /**
     * LogRequest downloadConfirmationQuery.
     * @member {string} downloadConfirmationQuery
     * @memberof LogRequest
     * @instance
     */
    LogRequest.prototype.downloadConfirmationQuery = "";

    /**
     * Creates a new LogRequest instance using the specified properties.
     * @function create
     * @memberof LogRequest
     * @static
     * @param {ILogRequest=} [properties] Properties to set
     * @returns {LogRequest} LogRequest instance
     */
    LogRequest.create = function create(properties) {
        return new LogRequest(properties);
    };

    /**
     * Encodes the specified LogRequest message. Does not implicitly {@link LogRequest.verify|verify} messages.
     * @function encode
     * @memberof LogRequest
     * @static
     * @param {ILogRequest} message LogRequest message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    LogRequest.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.timestamp != null && Object.hasOwnProperty.call(message, "timestamp"))
            writer.uint32(/* id 1, wireType 0 =*/8).int64(message.timestamp);
        if (message.downloadConfirmationQuery != null && Object.hasOwnProperty.call(message, "downloadConfirmationQuery"))
            writer.uint32(/* id 2, wireType 2 =*/18).string(message.downloadConfirmationQuery);
        return writer;
    };

    /**
     * Encodes the specified LogRequest message, length delimited. Does not implicitly {@link LogRequest.verify|verify} messages.
     * @function encodeDelimited
     * @memberof LogRequest
     * @static
     * @param {ILogRequest} message LogRequest message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    LogRequest.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a LogRequest message from the specified reader or buffer.
     * @function decode
     * @memberof LogRequest
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {LogRequest} LogRequest
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    LogRequest.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.LogRequest();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.timestamp = reader.int64();
                break;
            case 2:
                message.downloadConfirmationQuery = reader.string();
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a LogRequest message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof LogRequest
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {LogRequest} LogRequest
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    LogRequest.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a LogRequest message.
     * @function verify
     * @memberof LogRequest
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    LogRequest.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.timestamp != null && message.hasOwnProperty("timestamp"))
            if (!$util.isInteger(message.timestamp) && !(message.timestamp && $util.isInteger(message.timestamp.low) && $util.isInteger(message.timestamp.high)))
                return "timestamp: integer|Long expected";
        if (message.downloadConfirmationQuery != null && message.hasOwnProperty("downloadConfirmationQuery"))
            if (!$util.isString(message.downloadConfirmationQuery))
                return "downloadConfirmationQuery: string expected";
        return null;
    };

    /**
     * Creates a LogRequest message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof LogRequest
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {LogRequest} LogRequest
     */
    LogRequest.fromObject = function fromObject(object) {
        if (object instanceof $root.LogRequest)
            return object;
        var message = new $root.LogRequest();
        if (object.timestamp != null)
            if ($util.Long)
                (message.timestamp = $util.Long.fromValue(object.timestamp)).unsigned = false;
            else if (typeof object.timestamp === "string")
                message.timestamp = parseInt(object.timestamp, 10);
            else if (typeof object.timestamp === "number")
                message.timestamp = object.timestamp;
            else if (typeof object.timestamp === "object")
                message.timestamp = new $util.LongBits(object.timestamp.low >>> 0, object.timestamp.high >>> 0).toNumber();
        if (object.downloadConfirmationQuery != null)
            message.downloadConfirmationQuery = String(object.downloadConfirmationQuery);
        return message;
    };

    /**
     * Creates a plain object from a LogRequest message. Also converts values to other types if specified.
     * @function toObject
     * @memberof LogRequest
     * @static
     * @param {LogRequest} message LogRequest
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    LogRequest.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        var object = {};
        if (options.defaults) {
            if ($util.Long) {
                var long = new $util.Long(0, 0, false);
                object.timestamp = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
            } else
                object.timestamp = options.longs === String ? "0" : 0;
            object.downloadConfirmationQuery = "";
        }
        if (message.timestamp != null && message.hasOwnProperty("timestamp"))
            if (typeof message.timestamp === "number")
                object.timestamp = options.longs === String ? String(message.timestamp) : message.timestamp;
            else
                object.timestamp = options.longs === String ? $util.Long.prototype.toString.call(message.timestamp) : options.longs === Number ? new $util.LongBits(message.timestamp.low >>> 0, message.timestamp.high >>> 0).toNumber() : message.timestamp;
        if (message.downloadConfirmationQuery != null && message.hasOwnProperty("downloadConfirmationQuery"))
            object.downloadConfirmationQuery = message.downloadConfirmationQuery;
        return object;
    };

    /**
     * Converts this LogRequest to JSON.
     * @function toJSON
     * @memberof LogRequest
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    LogRequest.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return LogRequest;
})();

$root.TestingProgramRequest = (function() {

    /**
     * Properties of a TestingProgramRequest.
     * @exports ITestingProgramRequest
     * @interface ITestingProgramRequest
     * @property {string|null} [packageName] TestingProgramRequest packageName
     * @property {boolean|null} [subscribe] TestingProgramRequest subscribe
     */

    /**
     * Constructs a new TestingProgramRequest.
     * @exports TestingProgramRequest
     * @classdesc Represents a TestingProgramRequest.
     * @implements ITestingProgramRequest
     * @constructor
     * @param {ITestingProgramRequest=} [properties] Properties to set
     */
    function TestingProgramRequest(properties) {
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * TestingProgramRequest packageName.
     * @member {string} packageName
     * @memberof TestingProgramRequest
     * @instance
     */
    TestingProgramRequest.prototype.packageName = "";

    /**
     * TestingProgramRequest subscribe.
     * @member {boolean} subscribe
     * @memberof TestingProgramRequest
     * @instance
     */
    TestingProgramRequest.prototype.subscribe = false;

    /**
     * Creates a new TestingProgramRequest instance using the specified properties.
     * @function create
     * @memberof TestingProgramRequest
     * @static
     * @param {ITestingProgramRequest=} [properties] Properties to set
     * @returns {TestingProgramRequest} TestingProgramRequest instance
     */
    TestingProgramRequest.create = function create(properties) {
        return new TestingProgramRequest(properties);
    };

    /**
     * Encodes the specified TestingProgramRequest message. Does not implicitly {@link TestingProgramRequest.verify|verify} messages.
     * @function encode
     * @memberof TestingProgramRequest
     * @static
     * @param {ITestingProgramRequest} message TestingProgramRequest message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    TestingProgramRequest.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.packageName != null && Object.hasOwnProperty.call(message, "packageName"))
            writer.uint32(/* id 1, wireType 2 =*/10).string(message.packageName);
        if (message.subscribe != null && Object.hasOwnProperty.call(message, "subscribe"))
            writer.uint32(/* id 2, wireType 0 =*/16).bool(message.subscribe);
        return writer;
    };

    /**
     * Encodes the specified TestingProgramRequest message, length delimited. Does not implicitly {@link TestingProgramRequest.verify|verify} messages.
     * @function encodeDelimited
     * @memberof TestingProgramRequest
     * @static
     * @param {ITestingProgramRequest} message TestingProgramRequest message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    TestingProgramRequest.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a TestingProgramRequest message from the specified reader or buffer.
     * @function decode
     * @memberof TestingProgramRequest
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {TestingProgramRequest} TestingProgramRequest
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    TestingProgramRequest.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.TestingProgramRequest();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.packageName = reader.string();
                break;
            case 2:
                message.subscribe = reader.bool();
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a TestingProgramRequest message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof TestingProgramRequest
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {TestingProgramRequest} TestingProgramRequest
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    TestingProgramRequest.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a TestingProgramRequest message.
     * @function verify
     * @memberof TestingProgramRequest
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    TestingProgramRequest.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.packageName != null && message.hasOwnProperty("packageName"))
            if (!$util.isString(message.packageName))
                return "packageName: string expected";
        if (message.subscribe != null && message.hasOwnProperty("subscribe"))
            if (typeof message.subscribe !== "boolean")
                return "subscribe: boolean expected";
        return null;
    };

    /**
     * Creates a TestingProgramRequest message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof TestingProgramRequest
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {TestingProgramRequest} TestingProgramRequest
     */
    TestingProgramRequest.fromObject = function fromObject(object) {
        if (object instanceof $root.TestingProgramRequest)
            return object;
        var message = new $root.TestingProgramRequest();
        if (object.packageName != null)
            message.packageName = String(object.packageName);
        if (object.subscribe != null)
            message.subscribe = Boolean(object.subscribe);
        return message;
    };

    /**
     * Creates a plain object from a TestingProgramRequest message. Also converts values to other types if specified.
     * @function toObject
     * @memberof TestingProgramRequest
     * @static
     * @param {TestingProgramRequest} message TestingProgramRequest
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    TestingProgramRequest.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        var object = {};
        if (options.defaults) {
            object.packageName = "";
            object.subscribe = false;
        }
        if (message.packageName != null && message.hasOwnProperty("packageName"))
            object.packageName = message.packageName;
        if (message.subscribe != null && message.hasOwnProperty("subscribe"))
            object.subscribe = message.subscribe;
        return object;
    };

    /**
     * Converts this TestingProgramRequest to JSON.
     * @function toJSON
     * @memberof TestingProgramRequest
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    TestingProgramRequest.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return TestingProgramRequest;
})();

$root.UploadDeviceConfigRequest = (function() {

    /**
     * Properties of an UploadDeviceConfigRequest.
     * @exports IUploadDeviceConfigRequest
     * @interface IUploadDeviceConfigRequest
     * @property {IDeviceConfigurationProto|null} [deviceConfiguration] UploadDeviceConfigRequest deviceConfiguration
     * @property {string|null} [manufacturer] UploadDeviceConfigRequest manufacturer
     * @property {string|null} [gcmRegistrationId] UploadDeviceConfigRequest gcmRegistrationId
     */

    /**
     * Constructs a new UploadDeviceConfigRequest.
     * @exports UploadDeviceConfigRequest
     * @classdesc Represents an UploadDeviceConfigRequest.
     * @implements IUploadDeviceConfigRequest
     * @constructor
     * @param {IUploadDeviceConfigRequest=} [properties] Properties to set
     */
    function UploadDeviceConfigRequest(properties) {
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * UploadDeviceConfigRequest deviceConfiguration.
     * @member {IDeviceConfigurationProto|null|undefined} deviceConfiguration
     * @memberof UploadDeviceConfigRequest
     * @instance
     */
    UploadDeviceConfigRequest.prototype.deviceConfiguration = null;

    /**
     * UploadDeviceConfigRequest manufacturer.
     * @member {string} manufacturer
     * @memberof UploadDeviceConfigRequest
     * @instance
     */
    UploadDeviceConfigRequest.prototype.manufacturer = "";

    /**
     * UploadDeviceConfigRequest gcmRegistrationId.
     * @member {string} gcmRegistrationId
     * @memberof UploadDeviceConfigRequest
     * @instance
     */
    UploadDeviceConfigRequest.prototype.gcmRegistrationId = "";

    /**
     * Creates a new UploadDeviceConfigRequest instance using the specified properties.
     * @function create
     * @memberof UploadDeviceConfigRequest
     * @static
     * @param {IUploadDeviceConfigRequest=} [properties] Properties to set
     * @returns {UploadDeviceConfigRequest} UploadDeviceConfigRequest instance
     */
    UploadDeviceConfigRequest.create = function create(properties) {
        return new UploadDeviceConfigRequest(properties);
    };

    /**
     * Encodes the specified UploadDeviceConfigRequest message. Does not implicitly {@link UploadDeviceConfigRequest.verify|verify} messages.
     * @function encode
     * @memberof UploadDeviceConfigRequest
     * @static
     * @param {IUploadDeviceConfigRequest} message UploadDeviceConfigRequest message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    UploadDeviceConfigRequest.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.deviceConfiguration != null && Object.hasOwnProperty.call(message, "deviceConfiguration"))
            $root.DeviceConfigurationProto.encode(message.deviceConfiguration, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
        if (message.manufacturer != null && Object.hasOwnProperty.call(message, "manufacturer"))
            writer.uint32(/* id 2, wireType 2 =*/18).string(message.manufacturer);
        if (message.gcmRegistrationId != null && Object.hasOwnProperty.call(message, "gcmRegistrationId"))
            writer.uint32(/* id 3, wireType 2 =*/26).string(message.gcmRegistrationId);
        return writer;
    };

    /**
     * Encodes the specified UploadDeviceConfigRequest message, length delimited. Does not implicitly {@link UploadDeviceConfigRequest.verify|verify} messages.
     * @function encodeDelimited
     * @memberof UploadDeviceConfigRequest
     * @static
     * @param {IUploadDeviceConfigRequest} message UploadDeviceConfigRequest message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    UploadDeviceConfigRequest.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes an UploadDeviceConfigRequest message from the specified reader or buffer.
     * @function decode
     * @memberof UploadDeviceConfigRequest
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {UploadDeviceConfigRequest} UploadDeviceConfigRequest
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    UploadDeviceConfigRequest.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.UploadDeviceConfigRequest();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.deviceConfiguration = $root.DeviceConfigurationProto.decode(reader, reader.uint32());
                break;
            case 2:
                message.manufacturer = reader.string();
                break;
            case 3:
                message.gcmRegistrationId = reader.string();
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes an UploadDeviceConfigRequest message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof UploadDeviceConfigRequest
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {UploadDeviceConfigRequest} UploadDeviceConfigRequest
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    UploadDeviceConfigRequest.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies an UploadDeviceConfigRequest message.
     * @function verify
     * @memberof UploadDeviceConfigRequest
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    UploadDeviceConfigRequest.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.deviceConfiguration != null && message.hasOwnProperty("deviceConfiguration")) {
            var error = $root.DeviceConfigurationProto.verify(message.deviceConfiguration);
            if (error)
                return "deviceConfiguration." + error;
        }
        if (message.manufacturer != null && message.hasOwnProperty("manufacturer"))
            if (!$util.isString(message.manufacturer))
                return "manufacturer: string expected";
        if (message.gcmRegistrationId != null && message.hasOwnProperty("gcmRegistrationId"))
            if (!$util.isString(message.gcmRegistrationId))
                return "gcmRegistrationId: string expected";
        return null;
    };

    /**
     * Creates an UploadDeviceConfigRequest message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof UploadDeviceConfigRequest
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {UploadDeviceConfigRequest} UploadDeviceConfigRequest
     */
    UploadDeviceConfigRequest.fromObject = function fromObject(object) {
        if (object instanceof $root.UploadDeviceConfigRequest)
            return object;
        var message = new $root.UploadDeviceConfigRequest();
        if (object.deviceConfiguration != null) {
            if (typeof object.deviceConfiguration !== "object")
                throw TypeError(".UploadDeviceConfigRequest.deviceConfiguration: object expected");
            message.deviceConfiguration = $root.DeviceConfigurationProto.fromObject(object.deviceConfiguration);
        }
        if (object.manufacturer != null)
            message.manufacturer = String(object.manufacturer);
        if (object.gcmRegistrationId != null)
            message.gcmRegistrationId = String(object.gcmRegistrationId);
        return message;
    };

    /**
     * Creates a plain object from an UploadDeviceConfigRequest message. Also converts values to other types if specified.
     * @function toObject
     * @memberof UploadDeviceConfigRequest
     * @static
     * @param {UploadDeviceConfigRequest} message UploadDeviceConfigRequest
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    UploadDeviceConfigRequest.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        var object = {};
        if (options.defaults) {
            object.deviceConfiguration = null;
            object.manufacturer = "";
            object.gcmRegistrationId = "";
        }
        if (message.deviceConfiguration != null && message.hasOwnProperty("deviceConfiguration"))
            object.deviceConfiguration = $root.DeviceConfigurationProto.toObject(message.deviceConfiguration, options);
        if (message.manufacturer != null && message.hasOwnProperty("manufacturer"))
            object.manufacturer = message.manufacturer;
        if (message.gcmRegistrationId != null && message.hasOwnProperty("gcmRegistrationId"))
            object.gcmRegistrationId = message.gcmRegistrationId;
        return object;
    };

    /**
     * Converts this UploadDeviceConfigRequest to JSON.
     * @function toJSON
     * @memberof UploadDeviceConfigRequest
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    UploadDeviceConfigRequest.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return UploadDeviceConfigRequest;
})();

$root.UploadDeviceConfigResponse = (function() {

    /**
     * Properties of an UploadDeviceConfigResponse.
     * @exports IUploadDeviceConfigResponse
     * @interface IUploadDeviceConfigResponse
     * @property {string|null} [uploadDeviceConfigToken] UploadDeviceConfigResponse uploadDeviceConfigToken
     */

    /**
     * Constructs a new UploadDeviceConfigResponse.
     * @exports UploadDeviceConfigResponse
     * @classdesc Represents an UploadDeviceConfigResponse.
     * @implements IUploadDeviceConfigResponse
     * @constructor
     * @param {IUploadDeviceConfigResponse=} [properties] Properties to set
     */
    function UploadDeviceConfigResponse(properties) {
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * UploadDeviceConfigResponse uploadDeviceConfigToken.
     * @member {string} uploadDeviceConfigToken
     * @memberof UploadDeviceConfigResponse
     * @instance
     */
    UploadDeviceConfigResponse.prototype.uploadDeviceConfigToken = "";

    /**
     * Creates a new UploadDeviceConfigResponse instance using the specified properties.
     * @function create
     * @memberof UploadDeviceConfigResponse
     * @static
     * @param {IUploadDeviceConfigResponse=} [properties] Properties to set
     * @returns {UploadDeviceConfigResponse} UploadDeviceConfigResponse instance
     */
    UploadDeviceConfigResponse.create = function create(properties) {
        return new UploadDeviceConfigResponse(properties);
    };

    /**
     * Encodes the specified UploadDeviceConfigResponse message. Does not implicitly {@link UploadDeviceConfigResponse.verify|verify} messages.
     * @function encode
     * @memberof UploadDeviceConfigResponse
     * @static
     * @param {IUploadDeviceConfigResponse} message UploadDeviceConfigResponse message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    UploadDeviceConfigResponse.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.uploadDeviceConfigToken != null && Object.hasOwnProperty.call(message, "uploadDeviceConfigToken"))
            writer.uint32(/* id 1, wireType 2 =*/10).string(message.uploadDeviceConfigToken);
        return writer;
    };

    /**
     * Encodes the specified UploadDeviceConfigResponse message, length delimited. Does not implicitly {@link UploadDeviceConfigResponse.verify|verify} messages.
     * @function encodeDelimited
     * @memberof UploadDeviceConfigResponse
     * @static
     * @param {IUploadDeviceConfigResponse} message UploadDeviceConfigResponse message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    UploadDeviceConfigResponse.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes an UploadDeviceConfigResponse message from the specified reader or buffer.
     * @function decode
     * @memberof UploadDeviceConfigResponse
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {UploadDeviceConfigResponse} UploadDeviceConfigResponse
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    UploadDeviceConfigResponse.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.UploadDeviceConfigResponse();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.uploadDeviceConfigToken = reader.string();
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes an UploadDeviceConfigResponse message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof UploadDeviceConfigResponse
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {UploadDeviceConfigResponse} UploadDeviceConfigResponse
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    UploadDeviceConfigResponse.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies an UploadDeviceConfigResponse message.
     * @function verify
     * @memberof UploadDeviceConfigResponse
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    UploadDeviceConfigResponse.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.uploadDeviceConfigToken != null && message.hasOwnProperty("uploadDeviceConfigToken"))
            if (!$util.isString(message.uploadDeviceConfigToken))
                return "uploadDeviceConfigToken: string expected";
        return null;
    };

    /**
     * Creates an UploadDeviceConfigResponse message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof UploadDeviceConfigResponse
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {UploadDeviceConfigResponse} UploadDeviceConfigResponse
     */
    UploadDeviceConfigResponse.fromObject = function fromObject(object) {
        if (object instanceof $root.UploadDeviceConfigResponse)
            return object;
        var message = new $root.UploadDeviceConfigResponse();
        if (object.uploadDeviceConfigToken != null)
            message.uploadDeviceConfigToken = String(object.uploadDeviceConfigToken);
        return message;
    };

    /**
     * Creates a plain object from an UploadDeviceConfigResponse message. Also converts values to other types if specified.
     * @function toObject
     * @memberof UploadDeviceConfigResponse
     * @static
     * @param {UploadDeviceConfigResponse} message UploadDeviceConfigResponse
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    UploadDeviceConfigResponse.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        var object = {};
        if (options.defaults)
            object.uploadDeviceConfigToken = "";
        if (message.uploadDeviceConfigToken != null && message.hasOwnProperty("uploadDeviceConfigToken"))
            object.uploadDeviceConfigToken = message.uploadDeviceConfigToken;
        return object;
    };

    /**
     * Converts this UploadDeviceConfigResponse to JSON.
     * @function toJSON
     * @memberof UploadDeviceConfigResponse
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    UploadDeviceConfigResponse.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return UploadDeviceConfigResponse;
})();

$root.AndroidCheckinRequest = (function() {

    /**
     * Properties of an AndroidCheckinRequest.
     * @exports IAndroidCheckinRequest
     * @interface IAndroidCheckinRequest
     * @property {string|null} [imei] AndroidCheckinRequest imei
     * @property {number|Long|null} [id] AndroidCheckinRequest id
     * @property {string|null} [digest] AndroidCheckinRequest digest
     * @property {IAndroidCheckinProto|null} [checkin] AndroidCheckinRequest checkin
     * @property {string|null} [desiredBuild] AndroidCheckinRequest desiredBuild
     * @property {string|null} [locale] AndroidCheckinRequest locale
     * @property {number|Long|null} [loggingId] AndroidCheckinRequest loggingId
     * @property {string|null} [marketCheckin] AndroidCheckinRequest marketCheckin
     * @property {Array.<string>|null} [macAddr] AndroidCheckinRequest macAddr
     * @property {string|null} [meid] AndroidCheckinRequest meid
     * @property {Array.<string>|null} [accountCookie] AndroidCheckinRequest accountCookie
     * @property {string|null} [timeZone] AndroidCheckinRequest timeZone
     * @property {number|Long|null} [securityToken] AndroidCheckinRequest securityToken
     * @property {number|null} [version] AndroidCheckinRequest version
     * @property {Array.<string>|null} [otaCert] AndroidCheckinRequest otaCert
     * @property {string|null} [serialNumber] AndroidCheckinRequest serialNumber
     * @property {string|null} [esn] AndroidCheckinRequest esn
     * @property {IDeviceConfigurationProto|null} [deviceConfiguration] AndroidCheckinRequest deviceConfiguration
     * @property {Array.<string>|null} [macAddrType] AndroidCheckinRequest macAddrType
     * @property {number|null} [fragment] AndroidCheckinRequest fragment
     * @property {string|null} [userName] AndroidCheckinRequest userName
     * @property {number|null} [userSerialNumber] AndroidCheckinRequest userSerialNumber
     */

    /**
     * Constructs a new AndroidCheckinRequest.
     * @exports AndroidCheckinRequest
     * @classdesc Represents an AndroidCheckinRequest.
     * @implements IAndroidCheckinRequest
     * @constructor
     * @param {IAndroidCheckinRequest=} [properties] Properties to set
     */
    function AndroidCheckinRequest(properties) {
        this.macAddr = [];
        this.accountCookie = [];
        this.otaCert = [];
        this.macAddrType = [];
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * AndroidCheckinRequest imei.
     * @member {string} imei
     * @memberof AndroidCheckinRequest
     * @instance
     */
    AndroidCheckinRequest.prototype.imei = "";

    /**
     * AndroidCheckinRequest id.
     * @member {number|Long} id
     * @memberof AndroidCheckinRequest
     * @instance
     */
    AndroidCheckinRequest.prototype.id = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

    /**
     * AndroidCheckinRequest digest.
     * @member {string} digest
     * @memberof AndroidCheckinRequest
     * @instance
     */
    AndroidCheckinRequest.prototype.digest = "";

    /**
     * AndroidCheckinRequest checkin.
     * @member {IAndroidCheckinProto|null|undefined} checkin
     * @memberof AndroidCheckinRequest
     * @instance
     */
    AndroidCheckinRequest.prototype.checkin = null;

    /**
     * AndroidCheckinRequest desiredBuild.
     * @member {string} desiredBuild
     * @memberof AndroidCheckinRequest
     * @instance
     */
    AndroidCheckinRequest.prototype.desiredBuild = "";

    /**
     * AndroidCheckinRequest locale.
     * @member {string} locale
     * @memberof AndroidCheckinRequest
     * @instance
     */
    AndroidCheckinRequest.prototype.locale = "";

    /**
     * AndroidCheckinRequest loggingId.
     * @member {number|Long} loggingId
     * @memberof AndroidCheckinRequest
     * @instance
     */
    AndroidCheckinRequest.prototype.loggingId = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

    /**
     * AndroidCheckinRequest marketCheckin.
     * @member {string} marketCheckin
     * @memberof AndroidCheckinRequest
     * @instance
     */
    AndroidCheckinRequest.prototype.marketCheckin = "";

    /**
     * AndroidCheckinRequest macAddr.
     * @member {Array.<string>} macAddr
     * @memberof AndroidCheckinRequest
     * @instance
     */
    AndroidCheckinRequest.prototype.macAddr = $util.emptyArray;

    /**
     * AndroidCheckinRequest meid.
     * @member {string} meid
     * @memberof AndroidCheckinRequest
     * @instance
     */
    AndroidCheckinRequest.prototype.meid = "";

    /**
     * AndroidCheckinRequest accountCookie.
     * @member {Array.<string>} accountCookie
     * @memberof AndroidCheckinRequest
     * @instance
     */
    AndroidCheckinRequest.prototype.accountCookie = $util.emptyArray;

    /**
     * AndroidCheckinRequest timeZone.
     * @member {string} timeZone
     * @memberof AndroidCheckinRequest
     * @instance
     */
    AndroidCheckinRequest.prototype.timeZone = "";

    /**
     * AndroidCheckinRequest securityToken.
     * @member {number|Long} securityToken
     * @memberof AndroidCheckinRequest
     * @instance
     */
    AndroidCheckinRequest.prototype.securityToken = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

    /**
     * AndroidCheckinRequest version.
     * @member {number} version
     * @memberof AndroidCheckinRequest
     * @instance
     */
    AndroidCheckinRequest.prototype.version = 0;

    /**
     * AndroidCheckinRequest otaCert.
     * @member {Array.<string>} otaCert
     * @memberof AndroidCheckinRequest
     * @instance
     */
    AndroidCheckinRequest.prototype.otaCert = $util.emptyArray;

    /**
     * AndroidCheckinRequest serialNumber.
     * @member {string} serialNumber
     * @memberof AndroidCheckinRequest
     * @instance
     */
    AndroidCheckinRequest.prototype.serialNumber = "";

    /**
     * AndroidCheckinRequest esn.
     * @member {string} esn
     * @memberof AndroidCheckinRequest
     * @instance
     */
    AndroidCheckinRequest.prototype.esn = "";

    /**
     * AndroidCheckinRequest deviceConfiguration.
     * @member {IDeviceConfigurationProto|null|undefined} deviceConfiguration
     * @memberof AndroidCheckinRequest
     * @instance
     */
    AndroidCheckinRequest.prototype.deviceConfiguration = null;

    /**
     * AndroidCheckinRequest macAddrType.
     * @member {Array.<string>} macAddrType
     * @memberof AndroidCheckinRequest
     * @instance
     */
    AndroidCheckinRequest.prototype.macAddrType = $util.emptyArray;

    /**
     * AndroidCheckinRequest fragment.
     * @member {number} fragment
     * @memberof AndroidCheckinRequest
     * @instance
     */
    AndroidCheckinRequest.prototype.fragment = 0;

    /**
     * AndroidCheckinRequest userName.
     * @member {string} userName
     * @memberof AndroidCheckinRequest
     * @instance
     */
    AndroidCheckinRequest.prototype.userName = "";

    /**
     * AndroidCheckinRequest userSerialNumber.
     * @member {number} userSerialNumber
     * @memberof AndroidCheckinRequest
     * @instance
     */
    AndroidCheckinRequest.prototype.userSerialNumber = 0;

    /**
     * Creates a new AndroidCheckinRequest instance using the specified properties.
     * @function create
     * @memberof AndroidCheckinRequest
     * @static
     * @param {IAndroidCheckinRequest=} [properties] Properties to set
     * @returns {AndroidCheckinRequest} AndroidCheckinRequest instance
     */
    AndroidCheckinRequest.create = function create(properties) {
        return new AndroidCheckinRequest(properties);
    };

    /**
     * Encodes the specified AndroidCheckinRequest message. Does not implicitly {@link AndroidCheckinRequest.verify|verify} messages.
     * @function encode
     * @memberof AndroidCheckinRequest
     * @static
     * @param {IAndroidCheckinRequest} message AndroidCheckinRequest message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    AndroidCheckinRequest.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.imei != null && Object.hasOwnProperty.call(message, "imei"))
            writer.uint32(/* id 1, wireType 2 =*/10).string(message.imei);
        if (message.id != null && Object.hasOwnProperty.call(message, "id"))
            writer.uint32(/* id 2, wireType 0 =*/16).int64(message.id);
        if (message.digest != null && Object.hasOwnProperty.call(message, "digest"))
            writer.uint32(/* id 3, wireType 2 =*/26).string(message.digest);
        if (message.checkin != null && Object.hasOwnProperty.call(message, "checkin"))
            $root.AndroidCheckinProto.encode(message.checkin, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
        if (message.desiredBuild != null && Object.hasOwnProperty.call(message, "desiredBuild"))
            writer.uint32(/* id 5, wireType 2 =*/42).string(message.desiredBuild);
        if (message.locale != null && Object.hasOwnProperty.call(message, "locale"))
            writer.uint32(/* id 6, wireType 2 =*/50).string(message.locale);
        if (message.loggingId != null && Object.hasOwnProperty.call(message, "loggingId"))
            writer.uint32(/* id 7, wireType 0 =*/56).int64(message.loggingId);
        if (message.marketCheckin != null && Object.hasOwnProperty.call(message, "marketCheckin"))
            writer.uint32(/* id 8, wireType 2 =*/66).string(message.marketCheckin);
        if (message.macAddr != null && message.macAddr.length)
            for (var i = 0; i < message.macAddr.length; ++i)
                writer.uint32(/* id 9, wireType 2 =*/74).string(message.macAddr[i]);
        if (message.meid != null && Object.hasOwnProperty.call(message, "meid"))
            writer.uint32(/* id 10, wireType 2 =*/82).string(message.meid);
        if (message.accountCookie != null && message.accountCookie.length)
            for (var i = 0; i < message.accountCookie.length; ++i)
                writer.uint32(/* id 11, wireType 2 =*/90).string(message.accountCookie[i]);
        if (message.timeZone != null && Object.hasOwnProperty.call(message, "timeZone"))
            writer.uint32(/* id 12, wireType 2 =*/98).string(message.timeZone);
        if (message.securityToken != null && Object.hasOwnProperty.call(message, "securityToken"))
            writer.uint32(/* id 13, wireType 1 =*/105).fixed64(message.securityToken);
        if (message.version != null && Object.hasOwnProperty.call(message, "version"))
            writer.uint32(/* id 14, wireType 0 =*/112).int32(message.version);
        if (message.otaCert != null && message.otaCert.length)
            for (var i = 0; i < message.otaCert.length; ++i)
                writer.uint32(/* id 15, wireType 2 =*/122).string(message.otaCert[i]);
        if (message.serialNumber != null && Object.hasOwnProperty.call(message, "serialNumber"))
            writer.uint32(/* id 16, wireType 2 =*/130).string(message.serialNumber);
        if (message.esn != null && Object.hasOwnProperty.call(message, "esn"))
            writer.uint32(/* id 17, wireType 2 =*/138).string(message.esn);
        if (message.deviceConfiguration != null && Object.hasOwnProperty.call(message, "deviceConfiguration"))
            $root.DeviceConfigurationProto.encode(message.deviceConfiguration, writer.uint32(/* id 18, wireType 2 =*/146).fork()).ldelim();
        if (message.macAddrType != null && message.macAddrType.length)
            for (var i = 0; i < message.macAddrType.length; ++i)
                writer.uint32(/* id 19, wireType 2 =*/154).string(message.macAddrType[i]);
        if (message.fragment != null && Object.hasOwnProperty.call(message, "fragment"))
            writer.uint32(/* id 20, wireType 0 =*/160).int32(message.fragment);
        if (message.userName != null && Object.hasOwnProperty.call(message, "userName"))
            writer.uint32(/* id 21, wireType 2 =*/170).string(message.userName);
        if (message.userSerialNumber != null && Object.hasOwnProperty.call(message, "userSerialNumber"))
            writer.uint32(/* id 22, wireType 0 =*/176).int32(message.userSerialNumber);
        return writer;
    };

    /**
     * Encodes the specified AndroidCheckinRequest message, length delimited. Does not implicitly {@link AndroidCheckinRequest.verify|verify} messages.
     * @function encodeDelimited
     * @memberof AndroidCheckinRequest
     * @static
     * @param {IAndroidCheckinRequest} message AndroidCheckinRequest message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    AndroidCheckinRequest.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes an AndroidCheckinRequest message from the specified reader or buffer.
     * @function decode
     * @memberof AndroidCheckinRequest
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {AndroidCheckinRequest} AndroidCheckinRequest
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    AndroidCheckinRequest.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.AndroidCheckinRequest();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.imei = reader.string();
                break;
            case 2:
                message.id = reader.int64();
                break;
            case 3:
                message.digest = reader.string();
                break;
            case 4:
                message.checkin = $root.AndroidCheckinProto.decode(reader, reader.uint32());
                break;
            case 5:
                message.desiredBuild = reader.string();
                break;
            case 6:
                message.locale = reader.string();
                break;
            case 7:
                message.loggingId = reader.int64();
                break;
            case 8:
                message.marketCheckin = reader.string();
                break;
            case 9:
                if (!(message.macAddr && message.macAddr.length))
                    message.macAddr = [];
                message.macAddr.push(reader.string());
                break;
            case 10:
                message.meid = reader.string();
                break;
            case 11:
                if (!(message.accountCookie && message.accountCookie.length))
                    message.accountCookie = [];
                message.accountCookie.push(reader.string());
                break;
            case 12:
                message.timeZone = reader.string();
                break;
            case 13:
                message.securityToken = reader.fixed64();
                break;
            case 14:
                message.version = reader.int32();
                break;
            case 15:
                if (!(message.otaCert && message.otaCert.length))
                    message.otaCert = [];
                message.otaCert.push(reader.string());
                break;
            case 16:
                message.serialNumber = reader.string();
                break;
            case 17:
                message.esn = reader.string();
                break;
            case 18:
                message.deviceConfiguration = $root.DeviceConfigurationProto.decode(reader, reader.uint32());
                break;
            case 19:
                if (!(message.macAddrType && message.macAddrType.length))
                    message.macAddrType = [];
                message.macAddrType.push(reader.string());
                break;
            case 20:
                message.fragment = reader.int32();
                break;
            case 21:
                message.userName = reader.string();
                break;
            case 22:
                message.userSerialNumber = reader.int32();
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes an AndroidCheckinRequest message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof AndroidCheckinRequest
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {AndroidCheckinRequest} AndroidCheckinRequest
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    AndroidCheckinRequest.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies an AndroidCheckinRequest message.
     * @function verify
     * @memberof AndroidCheckinRequest
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    AndroidCheckinRequest.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.imei != null && message.hasOwnProperty("imei"))
            if (!$util.isString(message.imei))
                return "imei: string expected";
        if (message.id != null && message.hasOwnProperty("id"))
            if (!$util.isInteger(message.id) && !(message.id && $util.isInteger(message.id.low) && $util.isInteger(message.id.high)))
                return "id: integer|Long expected";
        if (message.digest != null && message.hasOwnProperty("digest"))
            if (!$util.isString(message.digest))
                return "digest: string expected";
        if (message.checkin != null && message.hasOwnProperty("checkin")) {
            var error = $root.AndroidCheckinProto.verify(message.checkin);
            if (error)
                return "checkin." + error;
        }
        if (message.desiredBuild != null && message.hasOwnProperty("desiredBuild"))
            if (!$util.isString(message.desiredBuild))
                return "desiredBuild: string expected";
        if (message.locale != null && message.hasOwnProperty("locale"))
            if (!$util.isString(message.locale))
                return "locale: string expected";
        if (message.loggingId != null && message.hasOwnProperty("loggingId"))
            if (!$util.isInteger(message.loggingId) && !(message.loggingId && $util.isInteger(message.loggingId.low) && $util.isInteger(message.loggingId.high)))
                return "loggingId: integer|Long expected";
        if (message.marketCheckin != null && message.hasOwnProperty("marketCheckin"))
            if (!$util.isString(message.marketCheckin))
                return "marketCheckin: string expected";
        if (message.macAddr != null && message.hasOwnProperty("macAddr")) {
            if (!Array.isArray(message.macAddr))
                return "macAddr: array expected";
            for (var i = 0; i < message.macAddr.length; ++i)
                if (!$util.isString(message.macAddr[i]))
                    return "macAddr: string[] expected";
        }
        if (message.meid != null && message.hasOwnProperty("meid"))
            if (!$util.isString(message.meid))
                return "meid: string expected";
        if (message.accountCookie != null && message.hasOwnProperty("accountCookie")) {
            if (!Array.isArray(message.accountCookie))
                return "accountCookie: array expected";
            for (var i = 0; i < message.accountCookie.length; ++i)
                if (!$util.isString(message.accountCookie[i]))
                    return "accountCookie: string[] expected";
        }
        if (message.timeZone != null && message.hasOwnProperty("timeZone"))
            if (!$util.isString(message.timeZone))
                return "timeZone: string expected";
        if (message.securityToken != null && message.hasOwnProperty("securityToken"))
            if (!$util.isInteger(message.securityToken) && !(message.securityToken && $util.isInteger(message.securityToken.low) && $util.isInteger(message.securityToken.high)))
                return "securityToken: integer|Long expected";
        if (message.version != null && message.hasOwnProperty("version"))
            if (!$util.isInteger(message.version))
                return "version: integer expected";
        if (message.otaCert != null && message.hasOwnProperty("otaCert")) {
            if (!Array.isArray(message.otaCert))
                return "otaCert: array expected";
            for (var i = 0; i < message.otaCert.length; ++i)
                if (!$util.isString(message.otaCert[i]))
                    return "otaCert: string[] expected";
        }
        if (message.serialNumber != null && message.hasOwnProperty("serialNumber"))
            if (!$util.isString(message.serialNumber))
                return "serialNumber: string expected";
        if (message.esn != null && message.hasOwnProperty("esn"))
            if (!$util.isString(message.esn))
                return "esn: string expected";
        if (message.deviceConfiguration != null && message.hasOwnProperty("deviceConfiguration")) {
            var error = $root.DeviceConfigurationProto.verify(message.deviceConfiguration);
            if (error)
                return "deviceConfiguration." + error;
        }
        if (message.macAddrType != null && message.hasOwnProperty("macAddrType")) {
            if (!Array.isArray(message.macAddrType))
                return "macAddrType: array expected";
            for (var i = 0; i < message.macAddrType.length; ++i)
                if (!$util.isString(message.macAddrType[i]))
                    return "macAddrType: string[] expected";
        }
        if (message.fragment != null && message.hasOwnProperty("fragment"))
            if (!$util.isInteger(message.fragment))
                return "fragment: integer expected";
        if (message.userName != null && message.hasOwnProperty("userName"))
            if (!$util.isString(message.userName))
                return "userName: string expected";
        if (message.userSerialNumber != null && message.hasOwnProperty("userSerialNumber"))
            if (!$util.isInteger(message.userSerialNumber))
                return "userSerialNumber: integer expected";
        return null;
    };

    /**
     * Creates an AndroidCheckinRequest message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof AndroidCheckinRequest
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {AndroidCheckinRequest} AndroidCheckinRequest
     */
    AndroidCheckinRequest.fromObject = function fromObject(object) {
        if (object instanceof $root.AndroidCheckinRequest)
            return object;
        var message = new $root.AndroidCheckinRequest();
        if (object.imei != null)
            message.imei = String(object.imei);
        if (object.id != null)
            if ($util.Long)
                (message.id = $util.Long.fromValue(object.id)).unsigned = false;
            else if (typeof object.id === "string")
                message.id = parseInt(object.id, 10);
            else if (typeof object.id === "number")
                message.id = object.id;
            else if (typeof object.id === "object")
                message.id = new $util.LongBits(object.id.low >>> 0, object.id.high >>> 0).toNumber();
        if (object.digest != null)
            message.digest = String(object.digest);
        if (object.checkin != null) {
            if (typeof object.checkin !== "object")
                throw TypeError(".AndroidCheckinRequest.checkin: object expected");
            message.checkin = $root.AndroidCheckinProto.fromObject(object.checkin);
        }
        if (object.desiredBuild != null)
            message.desiredBuild = String(object.desiredBuild);
        if (object.locale != null)
            message.locale = String(object.locale);
        if (object.loggingId != null)
            if ($util.Long)
                (message.loggingId = $util.Long.fromValue(object.loggingId)).unsigned = false;
            else if (typeof object.loggingId === "string")
                message.loggingId = parseInt(object.loggingId, 10);
            else if (typeof object.loggingId === "number")
                message.loggingId = object.loggingId;
            else if (typeof object.loggingId === "object")
                message.loggingId = new $util.LongBits(object.loggingId.low >>> 0, object.loggingId.high >>> 0).toNumber();
        if (object.marketCheckin != null)
            message.marketCheckin = String(object.marketCheckin);
        if (object.macAddr) {
            if (!Array.isArray(object.macAddr))
                throw TypeError(".AndroidCheckinRequest.macAddr: array expected");
            message.macAddr = [];
            for (var i = 0; i < object.macAddr.length; ++i)
                message.macAddr[i] = String(object.macAddr[i]);
        }
        if (object.meid != null)
            message.meid = String(object.meid);
        if (object.accountCookie) {
            if (!Array.isArray(object.accountCookie))
                throw TypeError(".AndroidCheckinRequest.accountCookie: array expected");
            message.accountCookie = [];
            for (var i = 0; i < object.accountCookie.length; ++i)
                message.accountCookie[i] = String(object.accountCookie[i]);
        }
        if (object.timeZone != null)
            message.timeZone = String(object.timeZone);
        if (object.securityToken != null)
            if ($util.Long)
                (message.securityToken = $util.Long.fromValue(object.securityToken)).unsigned = false;
            else if (typeof object.securityToken === "string")
                message.securityToken = parseInt(object.securityToken, 10);
            else if (typeof object.securityToken === "number")
                message.securityToken = object.securityToken;
            else if (typeof object.securityToken === "object")
                message.securityToken = new $util.LongBits(object.securityToken.low >>> 0, object.securityToken.high >>> 0).toNumber();
        if (object.version != null)
            message.version = object.version | 0;
        if (object.otaCert) {
            if (!Array.isArray(object.otaCert))
                throw TypeError(".AndroidCheckinRequest.otaCert: array expected");
            message.otaCert = [];
            for (var i = 0; i < object.otaCert.length; ++i)
                message.otaCert[i] = String(object.otaCert[i]);
        }
        if (object.serialNumber != null)
            message.serialNumber = String(object.serialNumber);
        if (object.esn != null)
            message.esn = String(object.esn);
        if (object.deviceConfiguration != null) {
            if (typeof object.deviceConfiguration !== "object")
                throw TypeError(".AndroidCheckinRequest.deviceConfiguration: object expected");
            message.deviceConfiguration = $root.DeviceConfigurationProto.fromObject(object.deviceConfiguration);
        }
        if (object.macAddrType) {
            if (!Array.isArray(object.macAddrType))
                throw TypeError(".AndroidCheckinRequest.macAddrType: array expected");
            message.macAddrType = [];
            for (var i = 0; i < object.macAddrType.length; ++i)
                message.macAddrType[i] = String(object.macAddrType[i]);
        }
        if (object.fragment != null)
            message.fragment = object.fragment | 0;
        if (object.userName != null)
            message.userName = String(object.userName);
        if (object.userSerialNumber != null)
            message.userSerialNumber = object.userSerialNumber | 0;
        return message;
    };

    /**
     * Creates a plain object from an AndroidCheckinRequest message. Also converts values to other types if specified.
     * @function toObject
     * @memberof AndroidCheckinRequest
     * @static
     * @param {AndroidCheckinRequest} message AndroidCheckinRequest
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    AndroidCheckinRequest.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        var object = {};
        if (options.arrays || options.defaults) {
            object.macAddr = [];
            object.accountCookie = [];
            object.otaCert = [];
            object.macAddrType = [];
        }
        if (options.defaults) {
            object.imei = "";
            if ($util.Long) {
                var long = new $util.Long(0, 0, false);
                object.id = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
            } else
                object.id = options.longs === String ? "0" : 0;
            object.digest = "";
            object.checkin = null;
            object.desiredBuild = "";
            object.locale = "";
            if ($util.Long) {
                var long = new $util.Long(0, 0, false);
                object.loggingId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
            } else
                object.loggingId = options.longs === String ? "0" : 0;
            object.marketCheckin = "";
            object.meid = "";
            object.timeZone = "";
            if ($util.Long) {
                var long = new $util.Long(0, 0, false);
                object.securityToken = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
            } else
                object.securityToken = options.longs === String ? "0" : 0;
            object.version = 0;
            object.serialNumber = "";
            object.esn = "";
            object.deviceConfiguration = null;
            object.fragment = 0;
            object.userName = "";
            object.userSerialNumber = 0;
        }
        if (message.imei != null && message.hasOwnProperty("imei"))
            object.imei = message.imei;
        if (message.id != null && message.hasOwnProperty("id"))
            if (typeof message.id === "number")
                object.id = options.longs === String ? String(message.id) : message.id;
            else
                object.id = options.longs === String ? $util.Long.prototype.toString.call(message.id) : options.longs === Number ? new $util.LongBits(message.id.low >>> 0, message.id.high >>> 0).toNumber() : message.id;
        if (message.digest != null && message.hasOwnProperty("digest"))
            object.digest = message.digest;
        if (message.checkin != null && message.hasOwnProperty("checkin"))
            object.checkin = $root.AndroidCheckinProto.toObject(message.checkin, options);
        if (message.desiredBuild != null && message.hasOwnProperty("desiredBuild"))
            object.desiredBuild = message.desiredBuild;
        if (message.locale != null && message.hasOwnProperty("locale"))
            object.locale = message.locale;
        if (message.loggingId != null && message.hasOwnProperty("loggingId"))
            if (typeof message.loggingId === "number")
                object.loggingId = options.longs === String ? String(message.loggingId) : message.loggingId;
            else
                object.loggingId = options.longs === String ? $util.Long.prototype.toString.call(message.loggingId) : options.longs === Number ? new $util.LongBits(message.loggingId.low >>> 0, message.loggingId.high >>> 0).toNumber() : message.loggingId;
        if (message.marketCheckin != null && message.hasOwnProperty("marketCheckin"))
            object.marketCheckin = message.marketCheckin;
        if (message.macAddr && message.macAddr.length) {
            object.macAddr = [];
            for (var j = 0; j < message.macAddr.length; ++j)
                object.macAddr[j] = message.macAddr[j];
        }
        if (message.meid != null && message.hasOwnProperty("meid"))
            object.meid = message.meid;
        if (message.accountCookie && message.accountCookie.length) {
            object.accountCookie = [];
            for (var j = 0; j < message.accountCookie.length; ++j)
                object.accountCookie[j] = message.accountCookie[j];
        }
        if (message.timeZone != null && message.hasOwnProperty("timeZone"))
            object.timeZone = message.timeZone;
        if (message.securityToken != null && message.hasOwnProperty("securityToken"))
            if (typeof message.securityToken === "number")
                object.securityToken = options.longs === String ? String(message.securityToken) : message.securityToken;
            else
                object.securityToken = options.longs === String ? $util.Long.prototype.toString.call(message.securityToken) : options.longs === Number ? new $util.LongBits(message.securityToken.low >>> 0, message.securityToken.high >>> 0).toNumber() : message.securityToken;
        if (message.version != null && message.hasOwnProperty("version"))
            object.version = message.version;
        if (message.otaCert && message.otaCert.length) {
            object.otaCert = [];
            for (var j = 0; j < message.otaCert.length; ++j)
                object.otaCert[j] = message.otaCert[j];
        }
        if (message.serialNumber != null && message.hasOwnProperty("serialNumber"))
            object.serialNumber = message.serialNumber;
        if (message.esn != null && message.hasOwnProperty("esn"))
            object.esn = message.esn;
        if (message.deviceConfiguration != null && message.hasOwnProperty("deviceConfiguration"))
            object.deviceConfiguration = $root.DeviceConfigurationProto.toObject(message.deviceConfiguration, options);
        if (message.macAddrType && message.macAddrType.length) {
            object.macAddrType = [];
            for (var j = 0; j < message.macAddrType.length; ++j)
                object.macAddrType[j] = message.macAddrType[j];
        }
        if (message.fragment != null && message.hasOwnProperty("fragment"))
            object.fragment = message.fragment;
        if (message.userName != null && message.hasOwnProperty("userName"))
            object.userName = message.userName;
        if (message.userSerialNumber != null && message.hasOwnProperty("userSerialNumber"))
            object.userSerialNumber = message.userSerialNumber;
        return object;
    };

    /**
     * Converts this AndroidCheckinRequest to JSON.
     * @function toJSON
     * @memberof AndroidCheckinRequest
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    AndroidCheckinRequest.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return AndroidCheckinRequest;
})();

$root.AndroidCheckinResponse = (function() {

    /**
     * Properties of an AndroidCheckinResponse.
     * @exports IAndroidCheckinResponse
     * @interface IAndroidCheckinResponse
     * @property {boolean|null} [statsOk] AndroidCheckinResponse statsOk
     * @property {Array.<IAndroidIntentProto>|null} [intent] AndroidCheckinResponse intent
     * @property {number|Long|null} [timeMsec] AndroidCheckinResponse timeMsec
     * @property {string|null} [digest] AndroidCheckinResponse digest
     * @property {Array.<IGservicesSetting>|null} [setting] AndroidCheckinResponse setting
     * @property {boolean|null} [marketOk] AndroidCheckinResponse marketOk
     * @property {number|Long|null} [androidId] AndroidCheckinResponse androidId
     * @property {number|Long|null} [securityToken] AndroidCheckinResponse securityToken
     * @property {boolean|null} [settingsDiff] AndroidCheckinResponse settingsDiff
     * @property {Array.<string>|null} [deleteSetting] AndroidCheckinResponse deleteSetting
     * @property {string|null} [deviceCheckinConsistencyToken] AndroidCheckinResponse deviceCheckinConsistencyToken
     */

    /**
     * Constructs a new AndroidCheckinResponse.
     * @exports AndroidCheckinResponse
     * @classdesc Represents an AndroidCheckinResponse.
     * @implements IAndroidCheckinResponse
     * @constructor
     * @param {IAndroidCheckinResponse=} [properties] Properties to set
     */
    function AndroidCheckinResponse(properties) {
        this.intent = [];
        this.setting = [];
        this.deleteSetting = [];
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * AndroidCheckinResponse statsOk.
     * @member {boolean} statsOk
     * @memberof AndroidCheckinResponse
     * @instance
     */
    AndroidCheckinResponse.prototype.statsOk = false;

    /**
     * AndroidCheckinResponse intent.
     * @member {Array.<IAndroidIntentProto>} intent
     * @memberof AndroidCheckinResponse
     * @instance
     */
    AndroidCheckinResponse.prototype.intent = $util.emptyArray;

    /**
     * AndroidCheckinResponse timeMsec.
     * @member {number|Long} timeMsec
     * @memberof AndroidCheckinResponse
     * @instance
     */
    AndroidCheckinResponse.prototype.timeMsec = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

    /**
     * AndroidCheckinResponse digest.
     * @member {string} digest
     * @memberof AndroidCheckinResponse
     * @instance
     */
    AndroidCheckinResponse.prototype.digest = "";

    /**
     * AndroidCheckinResponse setting.
     * @member {Array.<IGservicesSetting>} setting
     * @memberof AndroidCheckinResponse
     * @instance
     */
    AndroidCheckinResponse.prototype.setting = $util.emptyArray;

    /**
     * AndroidCheckinResponse marketOk.
     * @member {boolean} marketOk
     * @memberof AndroidCheckinResponse
     * @instance
     */
    AndroidCheckinResponse.prototype.marketOk = false;

    /**
     * AndroidCheckinResponse androidId.
     * @member {number|Long} androidId
     * @memberof AndroidCheckinResponse
     * @instance
     */
    AndroidCheckinResponse.prototype.androidId = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

    /**
     * AndroidCheckinResponse securityToken.
     * @member {number|Long} securityToken
     * @memberof AndroidCheckinResponse
     * @instance
     */
    AndroidCheckinResponse.prototype.securityToken = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

    /**
     * AndroidCheckinResponse settingsDiff.
     * @member {boolean} settingsDiff
     * @memberof AndroidCheckinResponse
     * @instance
     */
    AndroidCheckinResponse.prototype.settingsDiff = false;

    /**
     * AndroidCheckinResponse deleteSetting.
     * @member {Array.<string>} deleteSetting
     * @memberof AndroidCheckinResponse
     * @instance
     */
    AndroidCheckinResponse.prototype.deleteSetting = $util.emptyArray;

    /**
     * AndroidCheckinResponse deviceCheckinConsistencyToken.
     * @member {string} deviceCheckinConsistencyToken
     * @memberof AndroidCheckinResponse
     * @instance
     */
    AndroidCheckinResponse.prototype.deviceCheckinConsistencyToken = "";

    /**
     * Creates a new AndroidCheckinResponse instance using the specified properties.
     * @function create
     * @memberof AndroidCheckinResponse
     * @static
     * @param {IAndroidCheckinResponse=} [properties] Properties to set
     * @returns {AndroidCheckinResponse} AndroidCheckinResponse instance
     */
    AndroidCheckinResponse.create = function create(properties) {
        return new AndroidCheckinResponse(properties);
    };

    /**
     * Encodes the specified AndroidCheckinResponse message. Does not implicitly {@link AndroidCheckinResponse.verify|verify} messages.
     * @function encode
     * @memberof AndroidCheckinResponse
     * @static
     * @param {IAndroidCheckinResponse} message AndroidCheckinResponse message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    AndroidCheckinResponse.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.statsOk != null && Object.hasOwnProperty.call(message, "statsOk"))
            writer.uint32(/* id 1, wireType 0 =*/8).bool(message.statsOk);
        if (message.intent != null && message.intent.length)
            for (var i = 0; i < message.intent.length; ++i)
                $root.AndroidIntentProto.encode(message.intent[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
        if (message.timeMsec != null && Object.hasOwnProperty.call(message, "timeMsec"))
            writer.uint32(/* id 3, wireType 0 =*/24).int64(message.timeMsec);
        if (message.digest != null && Object.hasOwnProperty.call(message, "digest"))
            writer.uint32(/* id 4, wireType 2 =*/34).string(message.digest);
        if (message.setting != null && message.setting.length)
            for (var i = 0; i < message.setting.length; ++i)
                $root.GservicesSetting.encode(message.setting[i], writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
        if (message.marketOk != null && Object.hasOwnProperty.call(message, "marketOk"))
            writer.uint32(/* id 6, wireType 0 =*/48).bool(message.marketOk);
        if (message.androidId != null && Object.hasOwnProperty.call(message, "androidId"))
            writer.uint32(/* id 7, wireType 1 =*/57).fixed64(message.androidId);
        if (message.securityToken != null && Object.hasOwnProperty.call(message, "securityToken"))
            writer.uint32(/* id 8, wireType 1 =*/65).fixed64(message.securityToken);
        if (message.settingsDiff != null && Object.hasOwnProperty.call(message, "settingsDiff"))
            writer.uint32(/* id 9, wireType 0 =*/72).bool(message.settingsDiff);
        if (message.deleteSetting != null && message.deleteSetting.length)
            for (var i = 0; i < message.deleteSetting.length; ++i)
                writer.uint32(/* id 10, wireType 2 =*/82).string(message.deleteSetting[i]);
        if (message.deviceCheckinConsistencyToken != null && Object.hasOwnProperty.call(message, "deviceCheckinConsistencyToken"))
            writer.uint32(/* id 12, wireType 2 =*/98).string(message.deviceCheckinConsistencyToken);
        return writer;
    };

    /**
     * Encodes the specified AndroidCheckinResponse message, length delimited. Does not implicitly {@link AndroidCheckinResponse.verify|verify} messages.
     * @function encodeDelimited
     * @memberof AndroidCheckinResponse
     * @static
     * @param {IAndroidCheckinResponse} message AndroidCheckinResponse message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    AndroidCheckinResponse.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes an AndroidCheckinResponse message from the specified reader or buffer.
     * @function decode
     * @memberof AndroidCheckinResponse
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {AndroidCheckinResponse} AndroidCheckinResponse
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    AndroidCheckinResponse.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.AndroidCheckinResponse();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.statsOk = reader.bool();
                break;
            case 2:
                if (!(message.intent && message.intent.length))
                    message.intent = [];
                message.intent.push($root.AndroidIntentProto.decode(reader, reader.uint32()));
                break;
            case 3:
                message.timeMsec = reader.int64();
                break;
            case 4:
                message.digest = reader.string();
                break;
            case 5:
                if (!(message.setting && message.setting.length))
                    message.setting = [];
                message.setting.push($root.GservicesSetting.decode(reader, reader.uint32()));
                break;
            case 6:
                message.marketOk = reader.bool();
                break;
            case 7:
                message.androidId = reader.fixed64();
                break;
            case 8:
                message.securityToken = reader.fixed64();
                break;
            case 9:
                message.settingsDiff = reader.bool();
                break;
            case 10:
                if (!(message.deleteSetting && message.deleteSetting.length))
                    message.deleteSetting = [];
                message.deleteSetting.push(reader.string());
                break;
            case 12:
                message.deviceCheckinConsistencyToken = reader.string();
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes an AndroidCheckinResponse message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof AndroidCheckinResponse
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {AndroidCheckinResponse} AndroidCheckinResponse
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    AndroidCheckinResponse.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies an AndroidCheckinResponse message.
     * @function verify
     * @memberof AndroidCheckinResponse
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    AndroidCheckinResponse.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.statsOk != null && message.hasOwnProperty("statsOk"))
            if (typeof message.statsOk !== "boolean")
                return "statsOk: boolean expected";
        if (message.intent != null && message.hasOwnProperty("intent")) {
            if (!Array.isArray(message.intent))
                return "intent: array expected";
            for (var i = 0; i < message.intent.length; ++i) {
                var error = $root.AndroidIntentProto.verify(message.intent[i]);
                if (error)
                    return "intent." + error;
            }
        }
        if (message.timeMsec != null && message.hasOwnProperty("timeMsec"))
            if (!$util.isInteger(message.timeMsec) && !(message.timeMsec && $util.isInteger(message.timeMsec.low) && $util.isInteger(message.timeMsec.high)))
                return "timeMsec: integer|Long expected";
        if (message.digest != null && message.hasOwnProperty("digest"))
            if (!$util.isString(message.digest))
                return "digest: string expected";
        if (message.setting != null && message.hasOwnProperty("setting")) {
            if (!Array.isArray(message.setting))
                return "setting: array expected";
            for (var i = 0; i < message.setting.length; ++i) {
                var error = $root.GservicesSetting.verify(message.setting[i]);
                if (error)
                    return "setting." + error;
            }
        }
        if (message.marketOk != null && message.hasOwnProperty("marketOk"))
            if (typeof message.marketOk !== "boolean")
                return "marketOk: boolean expected";
        if (message.androidId != null && message.hasOwnProperty("androidId"))
            if (!$util.isInteger(message.androidId) && !(message.androidId && $util.isInteger(message.androidId.low) && $util.isInteger(message.androidId.high)))
                return "androidId: integer|Long expected";
        if (message.securityToken != null && message.hasOwnProperty("securityToken"))
            if (!$util.isInteger(message.securityToken) && !(message.securityToken && $util.isInteger(message.securityToken.low) && $util.isInteger(message.securityToken.high)))
                return "securityToken: integer|Long expected";
        if (message.settingsDiff != null && message.hasOwnProperty("settingsDiff"))
            if (typeof message.settingsDiff !== "boolean")
                return "settingsDiff: boolean expected";
        if (message.deleteSetting != null && message.hasOwnProperty("deleteSetting")) {
            if (!Array.isArray(message.deleteSetting))
                return "deleteSetting: array expected";
            for (var i = 0; i < message.deleteSetting.length; ++i)
                if (!$util.isString(message.deleteSetting[i]))
                    return "deleteSetting: string[] expected";
        }
        if (message.deviceCheckinConsistencyToken != null && message.hasOwnProperty("deviceCheckinConsistencyToken"))
            if (!$util.isString(message.deviceCheckinConsistencyToken))
                return "deviceCheckinConsistencyToken: string expected";
        return null;
    };

    /**
     * Creates an AndroidCheckinResponse message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof AndroidCheckinResponse
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {AndroidCheckinResponse} AndroidCheckinResponse
     */
    AndroidCheckinResponse.fromObject = function fromObject(object) {
        if (object instanceof $root.AndroidCheckinResponse)
            return object;
        var message = new $root.AndroidCheckinResponse();
        if (object.statsOk != null)
            message.statsOk = Boolean(object.statsOk);
        if (object.intent) {
            if (!Array.isArray(object.intent))
                throw TypeError(".AndroidCheckinResponse.intent: array expected");
            message.intent = [];
            for (var i = 0; i < object.intent.length; ++i) {
                if (typeof object.intent[i] !== "object")
                    throw TypeError(".AndroidCheckinResponse.intent: object expected");
                message.intent[i] = $root.AndroidIntentProto.fromObject(object.intent[i]);
            }
        }
        if (object.timeMsec != null)
            if ($util.Long)
                (message.timeMsec = $util.Long.fromValue(object.timeMsec)).unsigned = false;
            else if (typeof object.timeMsec === "string")
                message.timeMsec = parseInt(object.timeMsec, 10);
            else if (typeof object.timeMsec === "number")
                message.timeMsec = object.timeMsec;
            else if (typeof object.timeMsec === "object")
                message.timeMsec = new $util.LongBits(object.timeMsec.low >>> 0, object.timeMsec.high >>> 0).toNumber();
        if (object.digest != null)
            message.digest = String(object.digest);
        if (object.setting) {
            if (!Array.isArray(object.setting))
                throw TypeError(".AndroidCheckinResponse.setting: array expected");
            message.setting = [];
            for (var i = 0; i < object.setting.length; ++i) {
                if (typeof object.setting[i] !== "object")
                    throw TypeError(".AndroidCheckinResponse.setting: object expected");
                message.setting[i] = $root.GservicesSetting.fromObject(object.setting[i]);
            }
        }
        if (object.marketOk != null)
            message.marketOk = Boolean(object.marketOk);
        if (object.androidId != null)
            if ($util.Long)
                (message.androidId = $util.Long.fromValue(object.androidId)).unsigned = false;
            else if (typeof object.androidId === "string")
                message.androidId = parseInt(object.androidId, 10);
            else if (typeof object.androidId === "number")
                message.androidId = object.androidId;
            else if (typeof object.androidId === "object")
                message.androidId = new $util.LongBits(object.androidId.low >>> 0, object.androidId.high >>> 0).toNumber();
        if (object.securityToken != null)
            if ($util.Long)
                (message.securityToken = $util.Long.fromValue(object.securityToken)).unsigned = false;
            else if (typeof object.securityToken === "string")
                message.securityToken = parseInt(object.securityToken, 10);
            else if (typeof object.securityToken === "number")
                message.securityToken = object.securityToken;
            else if (typeof object.securityToken === "object")
                message.securityToken = new $util.LongBits(object.securityToken.low >>> 0, object.securityToken.high >>> 0).toNumber();
        if (object.settingsDiff != null)
            message.settingsDiff = Boolean(object.settingsDiff);
        if (object.deleteSetting) {
            if (!Array.isArray(object.deleteSetting))
                throw TypeError(".AndroidCheckinResponse.deleteSetting: array expected");
            message.deleteSetting = [];
            for (var i = 0; i < object.deleteSetting.length; ++i)
                message.deleteSetting[i] = String(object.deleteSetting[i]);
        }
        if (object.deviceCheckinConsistencyToken != null)
            message.deviceCheckinConsistencyToken = String(object.deviceCheckinConsistencyToken);
        return message;
    };

    /**
     * Creates a plain object from an AndroidCheckinResponse message. Also converts values to other types if specified.
     * @function toObject
     * @memberof AndroidCheckinResponse
     * @static
     * @param {AndroidCheckinResponse} message AndroidCheckinResponse
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    AndroidCheckinResponse.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        var object = {};
        if (options.arrays || options.defaults) {
            object.intent = [];
            object.setting = [];
            object.deleteSetting = [];
        }
        if (options.defaults) {
            object.statsOk = false;
            if ($util.Long) {
                var long = new $util.Long(0, 0, false);
                object.timeMsec = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
            } else
                object.timeMsec = options.longs === String ? "0" : 0;
            object.digest = "";
            object.marketOk = false;
            if ($util.Long) {
                var long = new $util.Long(0, 0, false);
                object.androidId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
            } else
                object.androidId = options.longs === String ? "0" : 0;
            if ($util.Long) {
                var long = new $util.Long(0, 0, false);
                object.securityToken = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
            } else
                object.securityToken = options.longs === String ? "0" : 0;
            object.settingsDiff = false;
            object.deviceCheckinConsistencyToken = "";
        }
        if (message.statsOk != null && message.hasOwnProperty("statsOk"))
            object.statsOk = message.statsOk;
        if (message.intent && message.intent.length) {
            object.intent = [];
            for (var j = 0; j < message.intent.length; ++j)
                object.intent[j] = $root.AndroidIntentProto.toObject(message.intent[j], options);
        }
        if (message.timeMsec != null && message.hasOwnProperty("timeMsec"))
            if (typeof message.timeMsec === "number")
                object.timeMsec = options.longs === String ? String(message.timeMsec) : message.timeMsec;
            else
                object.timeMsec = options.longs === String ? $util.Long.prototype.toString.call(message.timeMsec) : options.longs === Number ? new $util.LongBits(message.timeMsec.low >>> 0, message.timeMsec.high >>> 0).toNumber() : message.timeMsec;
        if (message.digest != null && message.hasOwnProperty("digest"))
            object.digest = message.digest;
        if (message.setting && message.setting.length) {
            object.setting = [];
            for (var j = 0; j < message.setting.length; ++j)
                object.setting[j] = $root.GservicesSetting.toObject(message.setting[j], options);
        }
        if (message.marketOk != null && message.hasOwnProperty("marketOk"))
            object.marketOk = message.marketOk;
        if (message.androidId != null && message.hasOwnProperty("androidId"))
            if (typeof message.androidId === "number")
                object.androidId = options.longs === String ? String(message.androidId) : message.androidId;
            else
                object.androidId = options.longs === String ? $util.Long.prototype.toString.call(message.androidId) : options.longs === Number ? new $util.LongBits(message.androidId.low >>> 0, message.androidId.high >>> 0).toNumber() : message.androidId;
        if (message.securityToken != null && message.hasOwnProperty("securityToken"))
            if (typeof message.securityToken === "number")
                object.securityToken = options.longs === String ? String(message.securityToken) : message.securityToken;
            else
                object.securityToken = options.longs === String ? $util.Long.prototype.toString.call(message.securityToken) : options.longs === Number ? new $util.LongBits(message.securityToken.low >>> 0, message.securityToken.high >>> 0).toNumber() : message.securityToken;
        if (message.settingsDiff != null && message.hasOwnProperty("settingsDiff"))
            object.settingsDiff = message.settingsDiff;
        if (message.deleteSetting && message.deleteSetting.length) {
            object.deleteSetting = [];
            for (var j = 0; j < message.deleteSetting.length; ++j)
                object.deleteSetting[j] = message.deleteSetting[j];
        }
        if (message.deviceCheckinConsistencyToken != null && message.hasOwnProperty("deviceCheckinConsistencyToken"))
            object.deviceCheckinConsistencyToken = message.deviceCheckinConsistencyToken;
        return object;
    };

    /**
     * Converts this AndroidCheckinResponse to JSON.
     * @function toJSON
     * @memberof AndroidCheckinResponse
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    AndroidCheckinResponse.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return AndroidCheckinResponse;
})();

$root.GservicesSetting = (function() {

    /**
     * Properties of a GservicesSetting.
     * @exports IGservicesSetting
     * @interface IGservicesSetting
     * @property {Uint8Array|null} [name] GservicesSetting name
     * @property {Uint8Array|null} [value] GservicesSetting value
     */

    /**
     * Constructs a new GservicesSetting.
     * @exports GservicesSetting
     * @classdesc Represents a GservicesSetting.
     * @implements IGservicesSetting
     * @constructor
     * @param {IGservicesSetting=} [properties] Properties to set
     */
    function GservicesSetting(properties) {
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * GservicesSetting name.
     * @member {Uint8Array} name
     * @memberof GservicesSetting
     * @instance
     */
    GservicesSetting.prototype.name = $util.newBuffer([]);

    /**
     * GservicesSetting value.
     * @member {Uint8Array} value
     * @memberof GservicesSetting
     * @instance
     */
    GservicesSetting.prototype.value = $util.newBuffer([]);

    /**
     * Creates a new GservicesSetting instance using the specified properties.
     * @function create
     * @memberof GservicesSetting
     * @static
     * @param {IGservicesSetting=} [properties] Properties to set
     * @returns {GservicesSetting} GservicesSetting instance
     */
    GservicesSetting.create = function create(properties) {
        return new GservicesSetting(properties);
    };

    /**
     * Encodes the specified GservicesSetting message. Does not implicitly {@link GservicesSetting.verify|verify} messages.
     * @function encode
     * @memberof GservicesSetting
     * @static
     * @param {IGservicesSetting} message GservicesSetting message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    GservicesSetting.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.name != null && Object.hasOwnProperty.call(message, "name"))
            writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.name);
        if (message.value != null && Object.hasOwnProperty.call(message, "value"))
            writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.value);
        return writer;
    };

    /**
     * Encodes the specified GservicesSetting message, length delimited. Does not implicitly {@link GservicesSetting.verify|verify} messages.
     * @function encodeDelimited
     * @memberof GservicesSetting
     * @static
     * @param {IGservicesSetting} message GservicesSetting message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    GservicesSetting.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a GservicesSetting message from the specified reader or buffer.
     * @function decode
     * @memberof GservicesSetting
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {GservicesSetting} GservicesSetting
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    GservicesSetting.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.GservicesSetting();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.name = reader.bytes();
                break;
            case 2:
                message.value = reader.bytes();
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a GservicesSetting message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof GservicesSetting
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {GservicesSetting} GservicesSetting
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    GservicesSetting.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a GservicesSetting message.
     * @function verify
     * @memberof GservicesSetting
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    GservicesSetting.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.name != null && message.hasOwnProperty("name"))
            if (!(message.name && typeof message.name.length === "number" || $util.isString(message.name)))
                return "name: buffer expected";
        if (message.value != null && message.hasOwnProperty("value"))
            if (!(message.value && typeof message.value.length === "number" || $util.isString(message.value)))
                return "value: buffer expected";
        return null;
    };

    /**
     * Creates a GservicesSetting message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof GservicesSetting
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {GservicesSetting} GservicesSetting
     */
    GservicesSetting.fromObject = function fromObject(object) {
        if (object instanceof $root.GservicesSetting)
            return object;
        var message = new $root.GservicesSetting();
        if (object.name != null)
            if (typeof object.name === "string")
                $util.base64.decode(object.name, message.name = $util.newBuffer($util.base64.length(object.name)), 0);
            else if (object.name.length)
                message.name = object.name;
        if (object.value != null)
            if (typeof object.value === "string")
                $util.base64.decode(object.value, message.value = $util.newBuffer($util.base64.length(object.value)), 0);
            else if (object.value.length)
                message.value = object.value;
        return message;
    };

    /**
     * Creates a plain object from a GservicesSetting message. Also converts values to other types if specified.
     * @function toObject
     * @memberof GservicesSetting
     * @static
     * @param {GservicesSetting} message GservicesSetting
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    GservicesSetting.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        var object = {};
        if (options.defaults) {
            if (options.bytes === String)
                object.name = "";
            else {
                object.name = [];
                if (options.bytes !== Array)
                    object.name = $util.newBuffer(object.name);
            }
            if (options.bytes === String)
                object.value = "";
            else {
                object.value = [];
                if (options.bytes !== Array)
                    object.value = $util.newBuffer(object.value);
            }
        }
        if (message.name != null && message.hasOwnProperty("name"))
            object.name = options.bytes === String ? $util.base64.encode(message.name, 0, message.name.length) : options.bytes === Array ? Array.prototype.slice.call(message.name) : message.name;
        if (message.value != null && message.hasOwnProperty("value"))
            object.value = options.bytes === String ? $util.base64.encode(message.value, 0, message.value.length) : options.bytes === Array ? Array.prototype.slice.call(message.value) : message.value;
        return object;
    };

    /**
     * Converts this GservicesSetting to JSON.
     * @function toJSON
     * @memberof GservicesSetting
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    GservicesSetting.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return GservicesSetting;
})();

$root.AndroidBuildProto = (function() {

    /**
     * Properties of an AndroidBuildProto.
     * @exports IAndroidBuildProto
     * @interface IAndroidBuildProto
     * @property {string|null} [id] AndroidBuildProto id
     * @property {string|null} [product] AndroidBuildProto product
     * @property {string|null} [carrier] AndroidBuildProto carrier
     * @property {string|null} [radio] AndroidBuildProto radio
     * @property {string|null} [bootloader] AndroidBuildProto bootloader
     * @property {string|null} [client] AndroidBuildProto client
     * @property {number|Long|null} [timestamp] AndroidBuildProto timestamp
     * @property {number|null} [googleServices] AndroidBuildProto googleServices
     * @property {string|null} [device] AndroidBuildProto device
     * @property {number|null} [sdkVersion] AndroidBuildProto sdkVersion
     * @property {string|null} [model] AndroidBuildProto model
     * @property {string|null} [manufacturer] AndroidBuildProto manufacturer
     * @property {string|null} [buildProduct] AndroidBuildProto buildProduct
     * @property {boolean|null} [otaInstalled] AndroidBuildProto otaInstalled
     */

    /**
     * Constructs a new AndroidBuildProto.
     * @exports AndroidBuildProto
     * @classdesc Represents an AndroidBuildProto.
     * @implements IAndroidBuildProto
     * @constructor
     * @param {IAndroidBuildProto=} [properties] Properties to set
     */
    function AndroidBuildProto(properties) {
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * AndroidBuildProto id.
     * @member {string} id
     * @memberof AndroidBuildProto
     * @instance
     */
    AndroidBuildProto.prototype.id = "";

    /**
     * AndroidBuildProto product.
     * @member {string} product
     * @memberof AndroidBuildProto
     * @instance
     */
    AndroidBuildProto.prototype.product = "";

    /**
     * AndroidBuildProto carrier.
     * @member {string} carrier
     * @memberof AndroidBuildProto
     * @instance
     */
    AndroidBuildProto.prototype.carrier = "";

    /**
     * AndroidBuildProto radio.
     * @member {string} radio
     * @memberof AndroidBuildProto
     * @instance
     */
    AndroidBuildProto.prototype.radio = "";

    /**
     * AndroidBuildProto bootloader.
     * @member {string} bootloader
     * @memberof AndroidBuildProto
     * @instance
     */
    AndroidBuildProto.prototype.bootloader = "";

    /**
     * AndroidBuildProto client.
     * @member {string} client
     * @memberof AndroidBuildProto
     * @instance
     */
    AndroidBuildProto.prototype.client = "";

    /**
     * AndroidBuildProto timestamp.
     * @member {number|Long} timestamp
     * @memberof AndroidBuildProto
     * @instance
     */
    AndroidBuildProto.prototype.timestamp = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

    /**
     * AndroidBuildProto googleServices.
     * @member {number} googleServices
     * @memberof AndroidBuildProto
     * @instance
     */
    AndroidBuildProto.prototype.googleServices = 0;

    /**
     * AndroidBuildProto device.
     * @member {string} device
     * @memberof AndroidBuildProto
     * @instance
     */
    AndroidBuildProto.prototype.device = "";

    /**
     * AndroidBuildProto sdkVersion.
     * @member {number} sdkVersion
     * @memberof AndroidBuildProto
     * @instance
     */
    AndroidBuildProto.prototype.sdkVersion = 0;

    /**
     * AndroidBuildProto model.
     * @member {string} model
     * @memberof AndroidBuildProto
     * @instance
     */
    AndroidBuildProto.prototype.model = "";

    /**
     * AndroidBuildProto manufacturer.
     * @member {string} manufacturer
     * @memberof AndroidBuildProto
     * @instance
     */
    AndroidBuildProto.prototype.manufacturer = "";

    /**
     * AndroidBuildProto buildProduct.
     * @member {string} buildProduct
     * @memberof AndroidBuildProto
     * @instance
     */
    AndroidBuildProto.prototype.buildProduct = "";

    /**
     * AndroidBuildProto otaInstalled.
     * @member {boolean} otaInstalled
     * @memberof AndroidBuildProto
     * @instance
     */
    AndroidBuildProto.prototype.otaInstalled = false;

    /**
     * Creates a new AndroidBuildProto instance using the specified properties.
     * @function create
     * @memberof AndroidBuildProto
     * @static
     * @param {IAndroidBuildProto=} [properties] Properties to set
     * @returns {AndroidBuildProto} AndroidBuildProto instance
     */
    AndroidBuildProto.create = function create(properties) {
        return new AndroidBuildProto(properties);
    };

    /**
     * Encodes the specified AndroidBuildProto message. Does not implicitly {@link AndroidBuildProto.verify|verify} messages.
     * @function encode
     * @memberof AndroidBuildProto
     * @static
     * @param {IAndroidBuildProto} message AndroidBuildProto message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    AndroidBuildProto.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.id != null && Object.hasOwnProperty.call(message, "id"))
            writer.uint32(/* id 1, wireType 2 =*/10).string(message.id);
        if (message.product != null && Object.hasOwnProperty.call(message, "product"))
            writer.uint32(/* id 2, wireType 2 =*/18).string(message.product);
        if (message.carrier != null && Object.hasOwnProperty.call(message, "carrier"))
            writer.uint32(/* id 3, wireType 2 =*/26).string(message.carrier);
        if (message.radio != null && Object.hasOwnProperty.call(message, "radio"))
            writer.uint32(/* id 4, wireType 2 =*/34).string(message.radio);
        if (message.bootloader != null && Object.hasOwnProperty.call(message, "bootloader"))
            writer.uint32(/* id 5, wireType 2 =*/42).string(message.bootloader);
        if (message.client != null && Object.hasOwnProperty.call(message, "client"))
            writer.uint32(/* id 6, wireType 2 =*/50).string(message.client);
        if (message.timestamp != null && Object.hasOwnProperty.call(message, "timestamp"))
            writer.uint32(/* id 7, wireType 0 =*/56).int64(message.timestamp);
        if (message.googleServices != null && Object.hasOwnProperty.call(message, "googleServices"))
            writer.uint32(/* id 8, wireType 0 =*/64).int32(message.googleServices);
        if (message.device != null && Object.hasOwnProperty.call(message, "device"))
            writer.uint32(/* id 9, wireType 2 =*/74).string(message.device);
        if (message.sdkVersion != null && Object.hasOwnProperty.call(message, "sdkVersion"))
            writer.uint32(/* id 10, wireType 0 =*/80).int32(message.sdkVersion);
        if (message.model != null && Object.hasOwnProperty.call(message, "model"))
            writer.uint32(/* id 11, wireType 2 =*/90).string(message.model);
        if (message.manufacturer != null && Object.hasOwnProperty.call(message, "manufacturer"))
            writer.uint32(/* id 12, wireType 2 =*/98).string(message.manufacturer);
        if (message.buildProduct != null && Object.hasOwnProperty.call(message, "buildProduct"))
            writer.uint32(/* id 13, wireType 2 =*/106).string(message.buildProduct);
        if (message.otaInstalled != null && Object.hasOwnProperty.call(message, "otaInstalled"))
            writer.uint32(/* id 14, wireType 0 =*/112).bool(message.otaInstalled);
        return writer;
    };

    /**
     * Encodes the specified AndroidBuildProto message, length delimited. Does not implicitly {@link AndroidBuildProto.verify|verify} messages.
     * @function encodeDelimited
     * @memberof AndroidBuildProto
     * @static
     * @param {IAndroidBuildProto} message AndroidBuildProto message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    AndroidBuildProto.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes an AndroidBuildProto message from the specified reader or buffer.
     * @function decode
     * @memberof AndroidBuildProto
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {AndroidBuildProto} AndroidBuildProto
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    AndroidBuildProto.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.AndroidBuildProto();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.id = reader.string();
                break;
            case 2:
                message.product = reader.string();
                break;
            case 3:
                message.carrier = reader.string();
                break;
            case 4:
                message.radio = reader.string();
                break;
            case 5:
                message.bootloader = reader.string();
                break;
            case 6:
                message.client = reader.string();
                break;
            case 7:
                message.timestamp = reader.int64();
                break;
            case 8:
                message.googleServices = reader.int32();
                break;
            case 9:
                message.device = reader.string();
                break;
            case 10:
                message.sdkVersion = reader.int32();
                break;
            case 11:
                message.model = reader.string();
                break;
            case 12:
                message.manufacturer = reader.string();
                break;
            case 13:
                message.buildProduct = reader.string();
                break;
            case 14:
                message.otaInstalled = reader.bool();
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes an AndroidBuildProto message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof AndroidBuildProto
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {AndroidBuildProto} AndroidBuildProto
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    AndroidBuildProto.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies an AndroidBuildProto message.
     * @function verify
     * @memberof AndroidBuildProto
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    AndroidBuildProto.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.id != null && message.hasOwnProperty("id"))
            if (!$util.isString(message.id))
                return "id: string expected";
        if (message.product != null && message.hasOwnProperty("product"))
            if (!$util.isString(message.product))
                return "product: string expected";
        if (message.carrier != null && message.hasOwnProperty("carrier"))
            if (!$util.isString(message.carrier))
                return "carrier: string expected";
        if (message.radio != null && message.hasOwnProperty("radio"))
            if (!$util.isString(message.radio))
                return "radio: string expected";
        if (message.bootloader != null && message.hasOwnProperty("bootloader"))
            if (!$util.isString(message.bootloader))
                return "bootloader: string expected";
        if (message.client != null && message.hasOwnProperty("client"))
            if (!$util.isString(message.client))
                return "client: string expected";
        if (message.timestamp != null && message.hasOwnProperty("timestamp"))
            if (!$util.isInteger(message.timestamp) && !(message.timestamp && $util.isInteger(message.timestamp.low) && $util.isInteger(message.timestamp.high)))
                return "timestamp: integer|Long expected";
        if (message.googleServices != null && message.hasOwnProperty("googleServices"))
            if (!$util.isInteger(message.googleServices))
                return "googleServices: integer expected";
        if (message.device != null && message.hasOwnProperty("device"))
            if (!$util.isString(message.device))
                return "device: string expected";
        if (message.sdkVersion != null && message.hasOwnProperty("sdkVersion"))
            if (!$util.isInteger(message.sdkVersion))
                return "sdkVersion: integer expected";
        if (message.model != null && message.hasOwnProperty("model"))
            if (!$util.isString(message.model))
                return "model: string expected";
        if (message.manufacturer != null && message.hasOwnProperty("manufacturer"))
            if (!$util.isString(message.manufacturer))
                return "manufacturer: string expected";
        if (message.buildProduct != null && message.hasOwnProperty("buildProduct"))
            if (!$util.isString(message.buildProduct))
                return "buildProduct: string expected";
        if (message.otaInstalled != null && message.hasOwnProperty("otaInstalled"))
            if (typeof message.otaInstalled !== "boolean")
                return "otaInstalled: boolean expected";
        return null;
    };

    /**
     * Creates an AndroidBuildProto message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof AndroidBuildProto
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {AndroidBuildProto} AndroidBuildProto
     */
    AndroidBuildProto.fromObject = function fromObject(object) {
        if (object instanceof $root.AndroidBuildProto)
            return object;
        var message = new $root.AndroidBuildProto();
        if (object.id != null)
            message.id = String(object.id);
        if (object.product != null)
            message.product = String(object.product);
        if (object.carrier != null)
            message.carrier = String(object.carrier);
        if (object.radio != null)
            message.radio = String(object.radio);
        if (object.bootloader != null)
            message.bootloader = String(object.bootloader);
        if (object.client != null)
            message.client = String(object.client);
        if (object.timestamp != null)
            if ($util.Long)
                (message.timestamp = $util.Long.fromValue(object.timestamp)).unsigned = false;
            else if (typeof object.timestamp === "string")
                message.timestamp = parseInt(object.timestamp, 10);
            else if (typeof object.timestamp === "number")
                message.timestamp = object.timestamp;
            else if (typeof object.timestamp === "object")
                message.timestamp = new $util.LongBits(object.timestamp.low >>> 0, object.timestamp.high >>> 0).toNumber();
        if (object.googleServices != null)
            message.googleServices = object.googleServices | 0;
        if (object.device != null)
            message.device = String(object.device);
        if (object.sdkVersion != null)
            message.sdkVersion = object.sdkVersion | 0;
        if (object.model != null)
            message.model = String(object.model);
        if (object.manufacturer != null)
            message.manufacturer = String(object.manufacturer);
        if (object.buildProduct != null)
            message.buildProduct = String(object.buildProduct);
        if (object.otaInstalled != null)
            message.otaInstalled = Boolean(object.otaInstalled);
        return message;
    };

    /**
     * Creates a plain object from an AndroidBuildProto message. Also converts values to other types if specified.
     * @function toObject
     * @memberof AndroidBuildProto
     * @static
     * @param {AndroidBuildProto} message AndroidBuildProto
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    AndroidBuildProto.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        var object = {};
        if (options.defaults) {
            object.id = "";
            object.product = "";
            object.carrier = "";
            object.radio = "";
            object.bootloader = "";
            object.client = "";
            if ($util.Long) {
                var long = new $util.Long(0, 0, false);
                object.timestamp = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
            } else
                object.timestamp = options.longs === String ? "0" : 0;
            object.googleServices = 0;
            object.device = "";
            object.sdkVersion = 0;
            object.model = "";
            object.manufacturer = "";
            object.buildProduct = "";
            object.otaInstalled = false;
        }
        if (message.id != null && message.hasOwnProperty("id"))
            object.id = message.id;
        if (message.product != null && message.hasOwnProperty("product"))
            object.product = message.product;
        if (message.carrier != null && message.hasOwnProperty("carrier"))
            object.carrier = message.carrier;
        if (message.radio != null && message.hasOwnProperty("radio"))
            object.radio = message.radio;
        if (message.bootloader != null && message.hasOwnProperty("bootloader"))
            object.bootloader = message.bootloader;
        if (message.client != null && message.hasOwnProperty("client"))
            object.client = message.client;
        if (message.timestamp != null && message.hasOwnProperty("timestamp"))
            if (typeof message.timestamp === "number")
                object.timestamp = options.longs === String ? String(message.timestamp) : message.timestamp;
            else
                object.timestamp = options.longs === String ? $util.Long.prototype.toString.call(message.timestamp) : options.longs === Number ? new $util.LongBits(message.timestamp.low >>> 0, message.timestamp.high >>> 0).toNumber() : message.timestamp;
        if (message.googleServices != null && message.hasOwnProperty("googleServices"))
            object.googleServices = message.googleServices;
        if (message.device != null && message.hasOwnProperty("device"))
            object.device = message.device;
        if (message.sdkVersion != null && message.hasOwnProperty("sdkVersion"))
            object.sdkVersion = message.sdkVersion;
        if (message.model != null && message.hasOwnProperty("model"))
            object.model = message.model;
        if (message.manufacturer != null && message.hasOwnProperty("manufacturer"))
            object.manufacturer = message.manufacturer;
        if (message.buildProduct != null && message.hasOwnProperty("buildProduct"))
            object.buildProduct = message.buildProduct;
        if (message.otaInstalled != null && message.hasOwnProperty("otaInstalled"))
            object.otaInstalled = message.otaInstalled;
        return object;
    };

    /**
     * Converts this AndroidBuildProto to JSON.
     * @function toJSON
     * @memberof AndroidBuildProto
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    AndroidBuildProto.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return AndroidBuildProto;
})();

$root.AndroidCheckinProto = (function() {

    /**
     * Properties of an AndroidCheckinProto.
     * @exports IAndroidCheckinProto
     * @interface IAndroidCheckinProto
     * @property {IAndroidBuildProto|null} [build] AndroidCheckinProto build
     * @property {number|Long|null} [lastCheckinMsec] AndroidCheckinProto lastCheckinMsec
     * @property {Array.<IAndroidEventProto>|null} [event] AndroidCheckinProto event
     * @property {Array.<IAndroidStatisticProto>|null} [stat] AndroidCheckinProto stat
     * @property {Array.<string>|null} [requestedGroup] AndroidCheckinProto requestedGroup
     * @property {string|null} [cellOperator] AndroidCheckinProto cellOperator
     * @property {string|null} [simOperator] AndroidCheckinProto simOperator
     * @property {string|null} [roaming] AndroidCheckinProto roaming
     * @property {number|null} [userNumber] AndroidCheckinProto userNumber
     */

    /**
     * Constructs a new AndroidCheckinProto.
     * @exports AndroidCheckinProto
     * @classdesc Represents an AndroidCheckinProto.
     * @implements IAndroidCheckinProto
     * @constructor
     * @param {IAndroidCheckinProto=} [properties] Properties to set
     */
    function AndroidCheckinProto(properties) {
        this.event = [];
        this.stat = [];
        this.requestedGroup = [];
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * AndroidCheckinProto build.
     * @member {IAndroidBuildProto|null|undefined} build
     * @memberof AndroidCheckinProto
     * @instance
     */
    AndroidCheckinProto.prototype.build = null;

    /**
     * AndroidCheckinProto lastCheckinMsec.
     * @member {number|Long} lastCheckinMsec
     * @memberof AndroidCheckinProto
     * @instance
     */
    AndroidCheckinProto.prototype.lastCheckinMsec = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

    /**
     * AndroidCheckinProto event.
     * @member {Array.<IAndroidEventProto>} event
     * @memberof AndroidCheckinProto
     * @instance
     */
    AndroidCheckinProto.prototype.event = $util.emptyArray;

    /**
     * AndroidCheckinProto stat.
     * @member {Array.<IAndroidStatisticProto>} stat
     * @memberof AndroidCheckinProto
     * @instance
     */
    AndroidCheckinProto.prototype.stat = $util.emptyArray;

    /**
     * AndroidCheckinProto requestedGroup.
     * @member {Array.<string>} requestedGroup
     * @memberof AndroidCheckinProto
     * @instance
     */
    AndroidCheckinProto.prototype.requestedGroup = $util.emptyArray;

    /**
     * AndroidCheckinProto cellOperator.
     * @member {string} cellOperator
     * @memberof AndroidCheckinProto
     * @instance
     */
    AndroidCheckinProto.prototype.cellOperator = "";

    /**
     * AndroidCheckinProto simOperator.
     * @member {string} simOperator
     * @memberof AndroidCheckinProto
     * @instance
     */
    AndroidCheckinProto.prototype.simOperator = "";

    /**
     * AndroidCheckinProto roaming.
     * @member {string} roaming
     * @memberof AndroidCheckinProto
     * @instance
     */
    AndroidCheckinProto.prototype.roaming = "";

    /**
     * AndroidCheckinProto userNumber.
     * @member {number} userNumber
     * @memberof AndroidCheckinProto
     * @instance
     */
    AndroidCheckinProto.prototype.userNumber = 0;

    /**
     * Creates a new AndroidCheckinProto instance using the specified properties.
     * @function create
     * @memberof AndroidCheckinProto
     * @static
     * @param {IAndroidCheckinProto=} [properties] Properties to set
     * @returns {AndroidCheckinProto} AndroidCheckinProto instance
     */
    AndroidCheckinProto.create = function create(properties) {
        return new AndroidCheckinProto(properties);
    };

    /**
     * Encodes the specified AndroidCheckinProto message. Does not implicitly {@link AndroidCheckinProto.verify|verify} messages.
     * @function encode
     * @memberof AndroidCheckinProto
     * @static
     * @param {IAndroidCheckinProto} message AndroidCheckinProto message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    AndroidCheckinProto.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.build != null && Object.hasOwnProperty.call(message, "build"))
            $root.AndroidBuildProto.encode(message.build, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
        if (message.lastCheckinMsec != null && Object.hasOwnProperty.call(message, "lastCheckinMsec"))
            writer.uint32(/* id 2, wireType 0 =*/16).int64(message.lastCheckinMsec);
        if (message.event != null && message.event.length)
            for (var i = 0; i < message.event.length; ++i)
                $root.AndroidEventProto.encode(message.event[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
        if (message.stat != null && message.stat.length)
            for (var i = 0; i < message.stat.length; ++i)
                $root.AndroidStatisticProto.encode(message.stat[i], writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
        if (message.requestedGroup != null && message.requestedGroup.length)
            for (var i = 0; i < message.requestedGroup.length; ++i)
                writer.uint32(/* id 5, wireType 2 =*/42).string(message.requestedGroup[i]);
        if (message.cellOperator != null && Object.hasOwnProperty.call(message, "cellOperator"))
            writer.uint32(/* id 6, wireType 2 =*/50).string(message.cellOperator);
        if (message.simOperator != null && Object.hasOwnProperty.call(message, "simOperator"))
            writer.uint32(/* id 7, wireType 2 =*/58).string(message.simOperator);
        if (message.roaming != null && Object.hasOwnProperty.call(message, "roaming"))
            writer.uint32(/* id 8, wireType 2 =*/66).string(message.roaming);
        if (message.userNumber != null && Object.hasOwnProperty.call(message, "userNumber"))
            writer.uint32(/* id 9, wireType 0 =*/72).int32(message.userNumber);
        return writer;
    };

    /**
     * Encodes the specified AndroidCheckinProto message, length delimited. Does not implicitly {@link AndroidCheckinProto.verify|verify} messages.
     * @function encodeDelimited
     * @memberof AndroidCheckinProto
     * @static
     * @param {IAndroidCheckinProto} message AndroidCheckinProto message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    AndroidCheckinProto.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes an AndroidCheckinProto message from the specified reader or buffer.
     * @function decode
     * @memberof AndroidCheckinProto
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {AndroidCheckinProto} AndroidCheckinProto
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    AndroidCheckinProto.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.AndroidCheckinProto();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.build = $root.AndroidBuildProto.decode(reader, reader.uint32());
                break;
            case 2:
                message.lastCheckinMsec = reader.int64();
                break;
            case 3:
                if (!(message.event && message.event.length))
                    message.event = [];
                message.event.push($root.AndroidEventProto.decode(reader, reader.uint32()));
                break;
            case 4:
                if (!(message.stat && message.stat.length))
                    message.stat = [];
                message.stat.push($root.AndroidStatisticProto.decode(reader, reader.uint32()));
                break;
            case 5:
                if (!(message.requestedGroup && message.requestedGroup.length))
                    message.requestedGroup = [];
                message.requestedGroup.push(reader.string());
                break;
            case 6:
                message.cellOperator = reader.string();
                break;
            case 7:
                message.simOperator = reader.string();
                break;
            case 8:
                message.roaming = reader.string();
                break;
            case 9:
                message.userNumber = reader.int32();
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes an AndroidCheckinProto message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof AndroidCheckinProto
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {AndroidCheckinProto} AndroidCheckinProto
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    AndroidCheckinProto.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies an AndroidCheckinProto message.
     * @function verify
     * @memberof AndroidCheckinProto
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    AndroidCheckinProto.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.build != null && message.hasOwnProperty("build")) {
            var error = $root.AndroidBuildProto.verify(message.build);
            if (error)
                return "build." + error;
        }
        if (message.lastCheckinMsec != null && message.hasOwnProperty("lastCheckinMsec"))
            if (!$util.isInteger(message.lastCheckinMsec) && !(message.lastCheckinMsec && $util.isInteger(message.lastCheckinMsec.low) && $util.isInteger(message.lastCheckinMsec.high)))
                return "lastCheckinMsec: integer|Long expected";
        if (message.event != null && message.hasOwnProperty("event")) {
            if (!Array.isArray(message.event))
                return "event: array expected";
            for (var i = 0; i < message.event.length; ++i) {
                var error = $root.AndroidEventProto.verify(message.event[i]);
                if (error)
                    return "event." + error;
            }
        }
        if (message.stat != null && message.hasOwnProperty("stat")) {
            if (!Array.isArray(message.stat))
                return "stat: array expected";
            for (var i = 0; i < message.stat.length; ++i) {
                var error = $root.AndroidStatisticProto.verify(message.stat[i]);
                if (error)
                    return "stat." + error;
            }
        }
        if (message.requestedGroup != null && message.hasOwnProperty("requestedGroup")) {
            if (!Array.isArray(message.requestedGroup))
                return "requestedGroup: array expected";
            for (var i = 0; i < message.requestedGroup.length; ++i)
                if (!$util.isString(message.requestedGroup[i]))
                    return "requestedGroup: string[] expected";
        }
        if (message.cellOperator != null && message.hasOwnProperty("cellOperator"))
            if (!$util.isString(message.cellOperator))
                return "cellOperator: string expected";
        if (message.simOperator != null && message.hasOwnProperty("simOperator"))
            if (!$util.isString(message.simOperator))
                return "simOperator: string expected";
        if (message.roaming != null && message.hasOwnProperty("roaming"))
            if (!$util.isString(message.roaming))
                return "roaming: string expected";
        if (message.userNumber != null && message.hasOwnProperty("userNumber"))
            if (!$util.isInteger(message.userNumber))
                return "userNumber: integer expected";
        return null;
    };

    /**
     * Creates an AndroidCheckinProto message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof AndroidCheckinProto
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {AndroidCheckinProto} AndroidCheckinProto
     */
    AndroidCheckinProto.fromObject = function fromObject(object) {
        if (object instanceof $root.AndroidCheckinProto)
            return object;
        var message = new $root.AndroidCheckinProto();
        if (object.build != null) {
            if (typeof object.build !== "object")
                throw TypeError(".AndroidCheckinProto.build: object expected");
            message.build = $root.AndroidBuildProto.fromObject(object.build);
        }
        if (object.lastCheckinMsec != null)
            if ($util.Long)
                (message.lastCheckinMsec = $util.Long.fromValue(object.lastCheckinMsec)).unsigned = false;
            else if (typeof object.lastCheckinMsec === "string")
                message.lastCheckinMsec = parseInt(object.lastCheckinMsec, 10);
            else if (typeof object.lastCheckinMsec === "number")
                message.lastCheckinMsec = object.lastCheckinMsec;
            else if (typeof object.lastCheckinMsec === "object")
                message.lastCheckinMsec = new $util.LongBits(object.lastCheckinMsec.low >>> 0, object.lastCheckinMsec.high >>> 0).toNumber();
        if (object.event) {
            if (!Array.isArray(object.event))
                throw TypeError(".AndroidCheckinProto.event: array expected");
            message.event = [];
            for (var i = 0; i < object.event.length; ++i) {
                if (typeof object.event[i] !== "object")
                    throw TypeError(".AndroidCheckinProto.event: object expected");
                message.event[i] = $root.AndroidEventProto.fromObject(object.event[i]);
            }
        }
        if (object.stat) {
            if (!Array.isArray(object.stat))
                throw TypeError(".AndroidCheckinProto.stat: array expected");
            message.stat = [];
            for (var i = 0; i < object.stat.length; ++i) {
                if (typeof object.stat[i] !== "object")
                    throw TypeError(".AndroidCheckinProto.stat: object expected");
                message.stat[i] = $root.AndroidStatisticProto.fromObject(object.stat[i]);
            }
        }
        if (object.requestedGroup) {
            if (!Array.isArray(object.requestedGroup))
                throw TypeError(".AndroidCheckinProto.requestedGroup: array expected");
            message.requestedGroup = [];
            for (var i = 0; i < object.requestedGroup.length; ++i)
                message.requestedGroup[i] = String(object.requestedGroup[i]);
        }
        if (object.cellOperator != null)
            message.cellOperator = String(object.cellOperator);
        if (object.simOperator != null)
            message.simOperator = String(object.simOperator);
        if (object.roaming != null)
            message.roaming = String(object.roaming);
        if (object.userNumber != null)
            message.userNumber = object.userNumber | 0;
        return message;
    };

    /**
     * Creates a plain object from an AndroidCheckinProto message. Also converts values to other types if specified.
     * @function toObject
     * @memberof AndroidCheckinProto
     * @static
     * @param {AndroidCheckinProto} message AndroidCheckinProto
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    AndroidCheckinProto.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        var object = {};
        if (options.arrays || options.defaults) {
            object.event = [];
            object.stat = [];
            object.requestedGroup = [];
        }
        if (options.defaults) {
            object.build = null;
            if ($util.Long) {
                var long = new $util.Long(0, 0, false);
                object.lastCheckinMsec = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
            } else
                object.lastCheckinMsec = options.longs === String ? "0" : 0;
            object.cellOperator = "";
            object.simOperator = "";
            object.roaming = "";
            object.userNumber = 0;
        }
        if (message.build != null && message.hasOwnProperty("build"))
            object.build = $root.AndroidBuildProto.toObject(message.build, options);
        if (message.lastCheckinMsec != null && message.hasOwnProperty("lastCheckinMsec"))
            if (typeof message.lastCheckinMsec === "number")
                object.lastCheckinMsec = options.longs === String ? String(message.lastCheckinMsec) : message.lastCheckinMsec;
            else
                object.lastCheckinMsec = options.longs === String ? $util.Long.prototype.toString.call(message.lastCheckinMsec) : options.longs === Number ? new $util.LongBits(message.lastCheckinMsec.low >>> 0, message.lastCheckinMsec.high >>> 0).toNumber() : message.lastCheckinMsec;
        if (message.event && message.event.length) {
            object.event = [];
            for (var j = 0; j < message.event.length; ++j)
                object.event[j] = $root.AndroidEventProto.toObject(message.event[j], options);
        }
        if (message.stat && message.stat.length) {
            object.stat = [];
            for (var j = 0; j < message.stat.length; ++j)
                object.stat[j] = $root.AndroidStatisticProto.toObject(message.stat[j], options);
        }
        if (message.requestedGroup && message.requestedGroup.length) {
            object.requestedGroup = [];
            for (var j = 0; j < message.requestedGroup.length; ++j)
                object.requestedGroup[j] = message.requestedGroup[j];
        }
        if (message.cellOperator != null && message.hasOwnProperty("cellOperator"))
            object.cellOperator = message.cellOperator;
        if (message.simOperator != null && message.hasOwnProperty("simOperator"))
            object.simOperator = message.simOperator;
        if (message.roaming != null && message.hasOwnProperty("roaming"))
            object.roaming = message.roaming;
        if (message.userNumber != null && message.hasOwnProperty("userNumber"))
            object.userNumber = message.userNumber;
        return object;
    };

    /**
     * Converts this AndroidCheckinProto to JSON.
     * @function toJSON
     * @memberof AndroidCheckinProto
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    AndroidCheckinProto.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return AndroidCheckinProto;
})();

$root.AndroidEventProto = (function() {

    /**
     * Properties of an AndroidEventProto.
     * @exports IAndroidEventProto
     * @interface IAndroidEventProto
     * @property {string|null} [tag] AndroidEventProto tag
     * @property {string|null} [value] AndroidEventProto value
     * @property {number|Long|null} [timeMsec] AndroidEventProto timeMsec
     */

    /**
     * Constructs a new AndroidEventProto.
     * @exports AndroidEventProto
     * @classdesc Represents an AndroidEventProto.
     * @implements IAndroidEventProto
     * @constructor
     * @param {IAndroidEventProto=} [properties] Properties to set
     */
    function AndroidEventProto(properties) {
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * AndroidEventProto tag.
     * @member {string} tag
     * @memberof AndroidEventProto
     * @instance
     */
    AndroidEventProto.prototype.tag = "";

    /**
     * AndroidEventProto value.
     * @member {string} value
     * @memberof AndroidEventProto
     * @instance
     */
    AndroidEventProto.prototype.value = "";

    /**
     * AndroidEventProto timeMsec.
     * @member {number|Long} timeMsec
     * @memberof AndroidEventProto
     * @instance
     */
    AndroidEventProto.prototype.timeMsec = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

    /**
     * Creates a new AndroidEventProto instance using the specified properties.
     * @function create
     * @memberof AndroidEventProto
     * @static
     * @param {IAndroidEventProto=} [properties] Properties to set
     * @returns {AndroidEventProto} AndroidEventProto instance
     */
    AndroidEventProto.create = function create(properties) {
        return new AndroidEventProto(properties);
    };

    /**
     * Encodes the specified AndroidEventProto message. Does not implicitly {@link AndroidEventProto.verify|verify} messages.
     * @function encode
     * @memberof AndroidEventProto
     * @static
     * @param {IAndroidEventProto} message AndroidEventProto message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    AndroidEventProto.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.tag != null && Object.hasOwnProperty.call(message, "tag"))
            writer.uint32(/* id 1, wireType 2 =*/10).string(message.tag);
        if (message.value != null && Object.hasOwnProperty.call(message, "value"))
            writer.uint32(/* id 2, wireType 2 =*/18).string(message.value);
        if (message.timeMsec != null && Object.hasOwnProperty.call(message, "timeMsec"))
            writer.uint32(/* id 3, wireType 0 =*/24).int64(message.timeMsec);
        return writer;
    };

    /**
     * Encodes the specified AndroidEventProto message, length delimited. Does not implicitly {@link AndroidEventProto.verify|verify} messages.
     * @function encodeDelimited
     * @memberof AndroidEventProto
     * @static
     * @param {IAndroidEventProto} message AndroidEventProto message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    AndroidEventProto.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes an AndroidEventProto message from the specified reader or buffer.
     * @function decode
     * @memberof AndroidEventProto
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {AndroidEventProto} AndroidEventProto
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    AndroidEventProto.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.AndroidEventProto();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.tag = reader.string();
                break;
            case 2:
                message.value = reader.string();
                break;
            case 3:
                message.timeMsec = reader.int64();
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes an AndroidEventProto message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof AndroidEventProto
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {AndroidEventProto} AndroidEventProto
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    AndroidEventProto.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies an AndroidEventProto message.
     * @function verify
     * @memberof AndroidEventProto
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    AndroidEventProto.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.tag != null && message.hasOwnProperty("tag"))
            if (!$util.isString(message.tag))
                return "tag: string expected";
        if (message.value != null && message.hasOwnProperty("value"))
            if (!$util.isString(message.value))
                return "value: string expected";
        if (message.timeMsec != null && message.hasOwnProperty("timeMsec"))
            if (!$util.isInteger(message.timeMsec) && !(message.timeMsec && $util.isInteger(message.timeMsec.low) && $util.isInteger(message.timeMsec.high)))
                return "timeMsec: integer|Long expected";
        return null;
    };

    /**
     * Creates an AndroidEventProto message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof AndroidEventProto
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {AndroidEventProto} AndroidEventProto
     */
    AndroidEventProto.fromObject = function fromObject(object) {
        if (object instanceof $root.AndroidEventProto)
            return object;
        var message = new $root.AndroidEventProto();
        if (object.tag != null)
            message.tag = String(object.tag);
        if (object.value != null)
            message.value = String(object.value);
        if (object.timeMsec != null)
            if ($util.Long)
                (message.timeMsec = $util.Long.fromValue(object.timeMsec)).unsigned = false;
            else if (typeof object.timeMsec === "string")
                message.timeMsec = parseInt(object.timeMsec, 10);
            else if (typeof object.timeMsec === "number")
                message.timeMsec = object.timeMsec;
            else if (typeof object.timeMsec === "object")
                message.timeMsec = new $util.LongBits(object.timeMsec.low >>> 0, object.timeMsec.high >>> 0).toNumber();
        return message;
    };

    /**
     * Creates a plain object from an AndroidEventProto message. Also converts values to other types if specified.
     * @function toObject
     * @memberof AndroidEventProto
     * @static
     * @param {AndroidEventProto} message AndroidEventProto
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    AndroidEventProto.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        var object = {};
        if (options.defaults) {
            object.tag = "";
            object.value = "";
            if ($util.Long) {
                var long = new $util.Long(0, 0, false);
                object.timeMsec = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
            } else
                object.timeMsec = options.longs === String ? "0" : 0;
        }
        if (message.tag != null && message.hasOwnProperty("tag"))
            object.tag = message.tag;
        if (message.value != null && message.hasOwnProperty("value"))
            object.value = message.value;
        if (message.timeMsec != null && message.hasOwnProperty("timeMsec"))
            if (typeof message.timeMsec === "number")
                object.timeMsec = options.longs === String ? String(message.timeMsec) : message.timeMsec;
            else
                object.timeMsec = options.longs === String ? $util.Long.prototype.toString.call(message.timeMsec) : options.longs === Number ? new $util.LongBits(message.timeMsec.low >>> 0, message.timeMsec.high >>> 0).toNumber() : message.timeMsec;
        return object;
    };

    /**
     * Converts this AndroidEventProto to JSON.
     * @function toJSON
     * @memberof AndroidEventProto
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    AndroidEventProto.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return AndroidEventProto;
})();

$root.AndroidIntentProto = (function() {

    /**
     * Properties of an AndroidIntentProto.
     * @exports IAndroidIntentProto
     * @interface IAndroidIntentProto
     * @property {string|null} [action] AndroidIntentProto action
     * @property {string|null} [dataUri] AndroidIntentProto dataUri
     * @property {string|null} [mimeType] AndroidIntentProto mimeType
     * @property {string|null} [javaClass] AndroidIntentProto javaClass
     * @property {Array.<AndroidIntentProto.IExtra>|null} [extra] AndroidIntentProto extra
     */

    /**
     * Constructs a new AndroidIntentProto.
     * @exports AndroidIntentProto
     * @classdesc Represents an AndroidIntentProto.
     * @implements IAndroidIntentProto
     * @constructor
     * @param {IAndroidIntentProto=} [properties] Properties to set
     */
    function AndroidIntentProto(properties) {
        this.extra = [];
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * AndroidIntentProto action.
     * @member {string} action
     * @memberof AndroidIntentProto
     * @instance
     */
    AndroidIntentProto.prototype.action = "";

    /**
     * AndroidIntentProto dataUri.
     * @member {string} dataUri
     * @memberof AndroidIntentProto
     * @instance
     */
    AndroidIntentProto.prototype.dataUri = "";

    /**
     * AndroidIntentProto mimeType.
     * @member {string} mimeType
     * @memberof AndroidIntentProto
     * @instance
     */
    AndroidIntentProto.prototype.mimeType = "";

    /**
     * AndroidIntentProto javaClass.
     * @member {string} javaClass
     * @memberof AndroidIntentProto
     * @instance
     */
    AndroidIntentProto.prototype.javaClass = "";

    /**
     * AndroidIntentProto extra.
     * @member {Array.<AndroidIntentProto.IExtra>} extra
     * @memberof AndroidIntentProto
     * @instance
     */
    AndroidIntentProto.prototype.extra = $util.emptyArray;

    /**
     * Creates a new AndroidIntentProto instance using the specified properties.
     * @function create
     * @memberof AndroidIntentProto
     * @static
     * @param {IAndroidIntentProto=} [properties] Properties to set
     * @returns {AndroidIntentProto} AndroidIntentProto instance
     */
    AndroidIntentProto.create = function create(properties) {
        return new AndroidIntentProto(properties);
    };

    /**
     * Encodes the specified AndroidIntentProto message. Does not implicitly {@link AndroidIntentProto.verify|verify} messages.
     * @function encode
     * @memberof AndroidIntentProto
     * @static
     * @param {IAndroidIntentProto} message AndroidIntentProto message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    AndroidIntentProto.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.action != null && Object.hasOwnProperty.call(message, "action"))
            writer.uint32(/* id 1, wireType 2 =*/10).string(message.action);
        if (message.dataUri != null && Object.hasOwnProperty.call(message, "dataUri"))
            writer.uint32(/* id 2, wireType 2 =*/18).string(message.dataUri);
        if (message.mimeType != null && Object.hasOwnProperty.call(message, "mimeType"))
            writer.uint32(/* id 3, wireType 2 =*/26).string(message.mimeType);
        if (message.javaClass != null && Object.hasOwnProperty.call(message, "javaClass"))
            writer.uint32(/* id 4, wireType 2 =*/34).string(message.javaClass);
        if (message.extra != null && message.extra.length)
            for (var i = 0; i < message.extra.length; ++i)
                $root.AndroidIntentProto.Extra.encode(message.extra[i], writer.uint32(/* id 5, wireType 3 =*/43)).uint32(/* id 5, wireType 4 =*/44);
        return writer;
    };

    /**
     * Encodes the specified AndroidIntentProto message, length delimited. Does not implicitly {@link AndroidIntentProto.verify|verify} messages.
     * @function encodeDelimited
     * @memberof AndroidIntentProto
     * @static
     * @param {IAndroidIntentProto} message AndroidIntentProto message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    AndroidIntentProto.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes an AndroidIntentProto message from the specified reader or buffer.
     * @function decode
     * @memberof AndroidIntentProto
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {AndroidIntentProto} AndroidIntentProto
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    AndroidIntentProto.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.AndroidIntentProto();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.action = reader.string();
                break;
            case 2:
                message.dataUri = reader.string();
                break;
            case 3:
                message.mimeType = reader.string();
                break;
            case 4:
                message.javaClass = reader.string();
                break;
            case 5:
                if (!(message.extra && message.extra.length))
                    message.extra = [];
                message.extra.push($root.AndroidIntentProto.Extra.decode(reader));
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes an AndroidIntentProto message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof AndroidIntentProto
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {AndroidIntentProto} AndroidIntentProto
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    AndroidIntentProto.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies an AndroidIntentProto message.
     * @function verify
     * @memberof AndroidIntentProto
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    AndroidIntentProto.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.action != null && message.hasOwnProperty("action"))
            if (!$util.isString(message.action))
                return "action: string expected";
        if (message.dataUri != null && message.hasOwnProperty("dataUri"))
            if (!$util.isString(message.dataUri))
                return "dataUri: string expected";
        if (message.mimeType != null && message.hasOwnProperty("mimeType"))
            if (!$util.isString(message.mimeType))
                return "mimeType: string expected";
        if (message.javaClass != null && message.hasOwnProperty("javaClass"))
            if (!$util.isString(message.javaClass))
                return "javaClass: string expected";
        if (message.extra != null && message.hasOwnProperty("extra")) {
            if (!Array.isArray(message.extra))
                return "extra: array expected";
            for (var i = 0; i < message.extra.length; ++i) {
                var error = $root.AndroidIntentProto.Extra.verify(message.extra[i]);
                if (error)
                    return "extra." + error;
            }
        }
        return null;
    };

    /**
     * Creates an AndroidIntentProto message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof AndroidIntentProto
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {AndroidIntentProto} AndroidIntentProto
     */
    AndroidIntentProto.fromObject = function fromObject(object) {
        if (object instanceof $root.AndroidIntentProto)
            return object;
        var message = new $root.AndroidIntentProto();
        if (object.action != null)
            message.action = String(object.action);
        if (object.dataUri != null)
            message.dataUri = String(object.dataUri);
        if (object.mimeType != null)
            message.mimeType = String(object.mimeType);
        if (object.javaClass != null)
            message.javaClass = String(object.javaClass);
        if (object.extra) {
            if (!Array.isArray(object.extra))
                throw TypeError(".AndroidIntentProto.extra: array expected");
            message.extra = [];
            for (var i = 0; i < object.extra.length; ++i) {
                if (typeof object.extra[i] !== "object")
                    throw TypeError(".AndroidIntentProto.extra: object expected");
                message.extra[i] = $root.AndroidIntentProto.Extra.fromObject(object.extra[i]);
            }
        }
        return message;
    };

    /**
     * Creates a plain object from an AndroidIntentProto message. Also converts values to other types if specified.
     * @function toObject
     * @memberof AndroidIntentProto
     * @static
     * @param {AndroidIntentProto} message AndroidIntentProto
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    AndroidIntentProto.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        var object = {};
        if (options.arrays || options.defaults)
            object.extra = [];
        if (options.defaults) {
            object.action = "";
            object.dataUri = "";
            object.mimeType = "";
            object.javaClass = "";
        }
        if (message.action != null && message.hasOwnProperty("action"))
            object.action = message.action;
        if (message.dataUri != null && message.hasOwnProperty("dataUri"))
            object.dataUri = message.dataUri;
        if (message.mimeType != null && message.hasOwnProperty("mimeType"))
            object.mimeType = message.mimeType;
        if (message.javaClass != null && message.hasOwnProperty("javaClass"))
            object.javaClass = message.javaClass;
        if (message.extra && message.extra.length) {
            object.extra = [];
            for (var j = 0; j < message.extra.length; ++j)
                object.extra[j] = $root.AndroidIntentProto.Extra.toObject(message.extra[j], options);
        }
        return object;
    };

    /**
     * Converts this AndroidIntentProto to JSON.
     * @function toJSON
     * @memberof AndroidIntentProto
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    AndroidIntentProto.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    AndroidIntentProto.Extra = (function() {

        /**
         * Properties of an Extra.
         * @memberof AndroidIntentProto
         * @interface IExtra
         * @property {string|null} [name] Extra name
         * @property {string|null} [value] Extra value
         */

        /**
         * Constructs a new Extra.
         * @memberof AndroidIntentProto
         * @classdesc Represents an Extra.
         * @implements IExtra
         * @constructor
         * @param {AndroidIntentProto.IExtra=} [properties] Properties to set
         */
        function Extra(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Extra name.
         * @member {string} name
         * @memberof AndroidIntentProto.Extra
         * @instance
         */
        Extra.prototype.name = "";

        /**
         * Extra value.
         * @member {string} value
         * @memberof AndroidIntentProto.Extra
         * @instance
         */
        Extra.prototype.value = "";

        /**
         * Creates a new Extra instance using the specified properties.
         * @function create
         * @memberof AndroidIntentProto.Extra
         * @static
         * @param {AndroidIntentProto.IExtra=} [properties] Properties to set
         * @returns {AndroidIntentProto.Extra} Extra instance
         */
        Extra.create = function create(properties) {
            return new Extra(properties);
        };

        /**
         * Encodes the specified Extra message. Does not implicitly {@link AndroidIntentProto.Extra.verify|verify} messages.
         * @function encode
         * @memberof AndroidIntentProto.Extra
         * @static
         * @param {AndroidIntentProto.IExtra} message Extra message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Extra.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                writer.uint32(/* id 6, wireType 2 =*/50).string(message.name);
            if (message.value != null && Object.hasOwnProperty.call(message, "value"))
                writer.uint32(/* id 7, wireType 2 =*/58).string(message.value);
            return writer;
        };

        /**
         * Encodes the specified Extra message, length delimited. Does not implicitly {@link AndroidIntentProto.Extra.verify|verify} messages.
         * @function encodeDelimited
         * @memberof AndroidIntentProto.Extra
         * @static
         * @param {AndroidIntentProto.IExtra} message Extra message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Extra.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an Extra message from the specified reader or buffer.
         * @function decode
         * @memberof AndroidIntentProto.Extra
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {AndroidIntentProto.Extra} Extra
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Extra.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.AndroidIntentProto.Extra();
            while (reader.pos < end) {
                var tag = reader.uint32();
                if ((tag & 7) === 4)
                    break;
                switch (tag >>> 3) {
                case 6:
                    message.name = reader.string();
                    break;
                case 7:
                    message.value = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an Extra message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof AndroidIntentProto.Extra
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {AndroidIntentProto.Extra} Extra
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Extra.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an Extra message.
         * @function verify
         * @memberof AndroidIntentProto.Extra
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Extra.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.name != null && message.hasOwnProperty("name"))
                if (!$util.isString(message.name))
                    return "name: string expected";
            if (message.value != null && message.hasOwnProperty("value"))
                if (!$util.isString(message.value))
                    return "value: string expected";
            return null;
        };

        /**
         * Creates an Extra message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof AndroidIntentProto.Extra
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {AndroidIntentProto.Extra} Extra
         */
        Extra.fromObject = function fromObject(object) {
            if (object instanceof $root.AndroidIntentProto.Extra)
                return object;
            var message = new $root.AndroidIntentProto.Extra();
            if (object.name != null)
                message.name = String(object.name);
            if (object.value != null)
                message.value = String(object.value);
            return message;
        };

        /**
         * Creates a plain object from an Extra message. Also converts values to other types if specified.
         * @function toObject
         * @memberof AndroidIntentProto.Extra
         * @static
         * @param {AndroidIntentProto.Extra} message Extra
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Extra.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.name = "";
                object.value = "";
            }
            if (message.name != null && message.hasOwnProperty("name"))
                object.name = message.name;
            if (message.value != null && message.hasOwnProperty("value"))
                object.value = message.value;
            return object;
        };

        /**
         * Converts this Extra to JSON.
         * @function toJSON
         * @memberof AndroidIntentProto.Extra
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Extra.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Extra;
    })();

    return AndroidIntentProto;
})();

$root.AndroidStatisticProto = (function() {

    /**
     * Properties of an AndroidStatisticProto.
     * @exports IAndroidStatisticProto
     * @interface IAndroidStatisticProto
     * @property {string|null} [tag] AndroidStatisticProto tag
     * @property {number|null} [count] AndroidStatisticProto count
     * @property {number|null} [sum] AndroidStatisticProto sum
     */

    /**
     * Constructs a new AndroidStatisticProto.
     * @exports AndroidStatisticProto
     * @classdesc Represents an AndroidStatisticProto.
     * @implements IAndroidStatisticProto
     * @constructor
     * @param {IAndroidStatisticProto=} [properties] Properties to set
     */
    function AndroidStatisticProto(properties) {
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * AndroidStatisticProto tag.
     * @member {string} tag
     * @memberof AndroidStatisticProto
     * @instance
     */
    AndroidStatisticProto.prototype.tag = "";

    /**
     * AndroidStatisticProto count.
     * @member {number} count
     * @memberof AndroidStatisticProto
     * @instance
     */
    AndroidStatisticProto.prototype.count = 0;

    /**
     * AndroidStatisticProto sum.
     * @member {number} sum
     * @memberof AndroidStatisticProto
     * @instance
     */
    AndroidStatisticProto.prototype.sum = 0;

    /**
     * Creates a new AndroidStatisticProto instance using the specified properties.
     * @function create
     * @memberof AndroidStatisticProto
     * @static
     * @param {IAndroidStatisticProto=} [properties] Properties to set
     * @returns {AndroidStatisticProto} AndroidStatisticProto instance
     */
    AndroidStatisticProto.create = function create(properties) {
        return new AndroidStatisticProto(properties);
    };

    /**
     * Encodes the specified AndroidStatisticProto message. Does not implicitly {@link AndroidStatisticProto.verify|verify} messages.
     * @function encode
     * @memberof AndroidStatisticProto
     * @static
     * @param {IAndroidStatisticProto} message AndroidStatisticProto message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    AndroidStatisticProto.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.tag != null && Object.hasOwnProperty.call(message, "tag"))
            writer.uint32(/* id 1, wireType 2 =*/10).string(message.tag);
        if (message.count != null && Object.hasOwnProperty.call(message, "count"))
            writer.uint32(/* id 2, wireType 0 =*/16).int32(message.count);
        if (message.sum != null && Object.hasOwnProperty.call(message, "sum"))
            writer.uint32(/* id 3, wireType 5 =*/29).float(message.sum);
        return writer;
    };

    /**
     * Encodes the specified AndroidStatisticProto message, length delimited. Does not implicitly {@link AndroidStatisticProto.verify|verify} messages.
     * @function encodeDelimited
     * @memberof AndroidStatisticProto
     * @static
     * @param {IAndroidStatisticProto} message AndroidStatisticProto message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    AndroidStatisticProto.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes an AndroidStatisticProto message from the specified reader or buffer.
     * @function decode
     * @memberof AndroidStatisticProto
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {AndroidStatisticProto} AndroidStatisticProto
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    AndroidStatisticProto.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.AndroidStatisticProto();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.tag = reader.string();
                break;
            case 2:
                message.count = reader.int32();
                break;
            case 3:
                message.sum = reader.float();
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes an AndroidStatisticProto message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof AndroidStatisticProto
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {AndroidStatisticProto} AndroidStatisticProto
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    AndroidStatisticProto.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies an AndroidStatisticProto message.
     * @function verify
     * @memberof AndroidStatisticProto
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    AndroidStatisticProto.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.tag != null && message.hasOwnProperty("tag"))
            if (!$util.isString(message.tag))
                return "tag: string expected";
        if (message.count != null && message.hasOwnProperty("count"))
            if (!$util.isInteger(message.count))
                return "count: integer expected";
        if (message.sum != null && message.hasOwnProperty("sum"))
            if (typeof message.sum !== "number")
                return "sum: number expected";
        return null;
    };

    /**
     * Creates an AndroidStatisticProto message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof AndroidStatisticProto
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {AndroidStatisticProto} AndroidStatisticProto
     */
    AndroidStatisticProto.fromObject = function fromObject(object) {
        if (object instanceof $root.AndroidStatisticProto)
            return object;
        var message = new $root.AndroidStatisticProto();
        if (object.tag != null)
            message.tag = String(object.tag);
        if (object.count != null)
            message.count = object.count | 0;
        if (object.sum != null)
            message.sum = Number(object.sum);
        return message;
    };

    /**
     * Creates a plain object from an AndroidStatisticProto message. Also converts values to other types if specified.
     * @function toObject
     * @memberof AndroidStatisticProto
     * @static
     * @param {AndroidStatisticProto} message AndroidStatisticProto
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    AndroidStatisticProto.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        var object = {};
        if (options.defaults) {
            object.tag = "";
            object.count = 0;
            object.sum = 0;
        }
        if (message.tag != null && message.hasOwnProperty("tag"))
            object.tag = message.tag;
        if (message.count != null && message.hasOwnProperty("count"))
            object.count = message.count;
        if (message.sum != null && message.hasOwnProperty("sum"))
            object.sum = options.json && !isFinite(message.sum) ? String(message.sum) : message.sum;
        return object;
    };

    /**
     * Converts this AndroidStatisticProto to JSON.
     * @function toJSON
     * @memberof AndroidStatisticProto
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    AndroidStatisticProto.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return AndroidStatisticProto;
})();

$root.ClientLibraryState = (function() {

    /**
     * Properties of a ClientLibraryState.
     * @exports IClientLibraryState
     * @interface IClientLibraryState
     * @property {number|null} [corpus] ClientLibraryState corpus
     * @property {Uint8Array|null} [serverToken] ClientLibraryState serverToken
     * @property {number|Long|null} [hashCodeSum] ClientLibraryState hashCodeSum
     * @property {number|null} [librarySize] ClientLibraryState librarySize
     * @property {string|null} [libraryId] ClientLibraryState libraryId
     */

    /**
     * Constructs a new ClientLibraryState.
     * @exports ClientLibraryState
     * @classdesc Represents a ClientLibraryState.
     * @implements IClientLibraryState
     * @constructor
     * @param {IClientLibraryState=} [properties] Properties to set
     */
    function ClientLibraryState(properties) {
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * ClientLibraryState corpus.
     * @member {number} corpus
     * @memberof ClientLibraryState
     * @instance
     */
    ClientLibraryState.prototype.corpus = 0;

    /**
     * ClientLibraryState serverToken.
     * @member {Uint8Array} serverToken
     * @memberof ClientLibraryState
     * @instance
     */
    ClientLibraryState.prototype.serverToken = $util.newBuffer([]);

    /**
     * ClientLibraryState hashCodeSum.
     * @member {number|Long} hashCodeSum
     * @memberof ClientLibraryState
     * @instance
     */
    ClientLibraryState.prototype.hashCodeSum = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

    /**
     * ClientLibraryState librarySize.
     * @member {number} librarySize
     * @memberof ClientLibraryState
     * @instance
     */
    ClientLibraryState.prototype.librarySize = 0;

    /**
     * ClientLibraryState libraryId.
     * @member {string} libraryId
     * @memberof ClientLibraryState
     * @instance
     */
    ClientLibraryState.prototype.libraryId = "";

    /**
     * Creates a new ClientLibraryState instance using the specified properties.
     * @function create
     * @memberof ClientLibraryState
     * @static
     * @param {IClientLibraryState=} [properties] Properties to set
     * @returns {ClientLibraryState} ClientLibraryState instance
     */
    ClientLibraryState.create = function create(properties) {
        return new ClientLibraryState(properties);
    };

    /**
     * Encodes the specified ClientLibraryState message. Does not implicitly {@link ClientLibraryState.verify|verify} messages.
     * @function encode
     * @memberof ClientLibraryState
     * @static
     * @param {IClientLibraryState} message ClientLibraryState message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    ClientLibraryState.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.corpus != null && Object.hasOwnProperty.call(message, "corpus"))
            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.corpus);
        if (message.serverToken != null && Object.hasOwnProperty.call(message, "serverToken"))
            writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.serverToken);
        if (message.hashCodeSum != null && Object.hasOwnProperty.call(message, "hashCodeSum"))
            writer.uint32(/* id 3, wireType 0 =*/24).int64(message.hashCodeSum);
        if (message.librarySize != null && Object.hasOwnProperty.call(message, "librarySize"))
            writer.uint32(/* id 4, wireType 0 =*/32).int32(message.librarySize);
        if (message.libraryId != null && Object.hasOwnProperty.call(message, "libraryId"))
            writer.uint32(/* id 5, wireType 2 =*/42).string(message.libraryId);
        return writer;
    };

    /**
     * Encodes the specified ClientLibraryState message, length delimited. Does not implicitly {@link ClientLibraryState.verify|verify} messages.
     * @function encodeDelimited
     * @memberof ClientLibraryState
     * @static
     * @param {IClientLibraryState} message ClientLibraryState message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    ClientLibraryState.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a ClientLibraryState message from the specified reader or buffer.
     * @function decode
     * @memberof ClientLibraryState
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {ClientLibraryState} ClientLibraryState
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    ClientLibraryState.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ClientLibraryState();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.corpus = reader.int32();
                break;
            case 2:
                message.serverToken = reader.bytes();
                break;
            case 3:
                message.hashCodeSum = reader.int64();
                break;
            case 4:
                message.librarySize = reader.int32();
                break;
            case 5:
                message.libraryId = reader.string();
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a ClientLibraryState message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof ClientLibraryState
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {ClientLibraryState} ClientLibraryState
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    ClientLibraryState.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a ClientLibraryState message.
     * @function verify
     * @memberof ClientLibraryState
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    ClientLibraryState.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.corpus != null && message.hasOwnProperty("corpus"))
            if (!$util.isInteger(message.corpus))
                return "corpus: integer expected";
        if (message.serverToken != null && message.hasOwnProperty("serverToken"))
            if (!(message.serverToken && typeof message.serverToken.length === "number" || $util.isString(message.serverToken)))
                return "serverToken: buffer expected";
        if (message.hashCodeSum != null && message.hasOwnProperty("hashCodeSum"))
            if (!$util.isInteger(message.hashCodeSum) && !(message.hashCodeSum && $util.isInteger(message.hashCodeSum.low) && $util.isInteger(message.hashCodeSum.high)))
                return "hashCodeSum: integer|Long expected";
        if (message.librarySize != null && message.hasOwnProperty("librarySize"))
            if (!$util.isInteger(message.librarySize))
                return "librarySize: integer expected";
        if (message.libraryId != null && message.hasOwnProperty("libraryId"))
            if (!$util.isString(message.libraryId))
                return "libraryId: string expected";
        return null;
    };

    /**
     * Creates a ClientLibraryState message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof ClientLibraryState
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {ClientLibraryState} ClientLibraryState
     */
    ClientLibraryState.fromObject = function fromObject(object) {
        if (object instanceof $root.ClientLibraryState)
            return object;
        var message = new $root.ClientLibraryState();
        if (object.corpus != null)
            message.corpus = object.corpus | 0;
        if (object.serverToken != null)
            if (typeof object.serverToken === "string")
                $util.base64.decode(object.serverToken, message.serverToken = $util.newBuffer($util.base64.length(object.serverToken)), 0);
            else if (object.serverToken.length)
                message.serverToken = object.serverToken;
        if (object.hashCodeSum != null)
            if ($util.Long)
                (message.hashCodeSum = $util.Long.fromValue(object.hashCodeSum)).unsigned = false;
            else if (typeof object.hashCodeSum === "string")
                message.hashCodeSum = parseInt(object.hashCodeSum, 10);
            else if (typeof object.hashCodeSum === "number")
                message.hashCodeSum = object.hashCodeSum;
            else if (typeof object.hashCodeSum === "object")
                message.hashCodeSum = new $util.LongBits(object.hashCodeSum.low >>> 0, object.hashCodeSum.high >>> 0).toNumber();
        if (object.librarySize != null)
            message.librarySize = object.librarySize | 0;
        if (object.libraryId != null)
            message.libraryId = String(object.libraryId);
        return message;
    };

    /**
     * Creates a plain object from a ClientLibraryState message. Also converts values to other types if specified.
     * @function toObject
     * @memberof ClientLibraryState
     * @static
     * @param {ClientLibraryState} message ClientLibraryState
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    ClientLibraryState.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        var object = {};
        if (options.defaults) {
            object.corpus = 0;
            if (options.bytes === String)
                object.serverToken = "";
            else {
                object.serverToken = [];
                if (options.bytes !== Array)
                    object.serverToken = $util.newBuffer(object.serverToken);
            }
            if ($util.Long) {
                var long = new $util.Long(0, 0, false);
                object.hashCodeSum = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
            } else
                object.hashCodeSum = options.longs === String ? "0" : 0;
            object.librarySize = 0;
            object.libraryId = "";
        }
        if (message.corpus != null && message.hasOwnProperty("corpus"))
            object.corpus = message.corpus;
        if (message.serverToken != null && message.hasOwnProperty("serverToken"))
            object.serverToken = options.bytes === String ? $util.base64.encode(message.serverToken, 0, message.serverToken.length) : options.bytes === Array ? Array.prototype.slice.call(message.serverToken) : message.serverToken;
        if (message.hashCodeSum != null && message.hasOwnProperty("hashCodeSum"))
            if (typeof message.hashCodeSum === "number")
                object.hashCodeSum = options.longs === String ? String(message.hashCodeSum) : message.hashCodeSum;
            else
                object.hashCodeSum = options.longs === String ? $util.Long.prototype.toString.call(message.hashCodeSum) : options.longs === Number ? new $util.LongBits(message.hashCodeSum.low >>> 0, message.hashCodeSum.high >>> 0).toNumber() : message.hashCodeSum;
        if (message.librarySize != null && message.hasOwnProperty("librarySize"))
            object.librarySize = message.librarySize;
        if (message.libraryId != null && message.hasOwnProperty("libraryId"))
            object.libraryId = message.libraryId;
        return object;
    };

    /**
     * Converts this ClientLibraryState to JSON.
     * @function toJSON
     * @memberof ClientLibraryState
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    ClientLibraryState.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return ClientLibraryState;
})();

$root.AndroidDataUsageProto = (function() {

    /**
     * Properties of an AndroidDataUsageProto.
     * @exports IAndroidDataUsageProto
     * @interface IAndroidDataUsageProto
     * @property {number|null} [version] AndroidDataUsageProto version
     * @property {number|Long|null} [currentReportMsec] AndroidDataUsageProto currentReportMsec
     * @property {Array.<IKeyToPackageNameMapping>|null} [keyToPackageNameMapping] AndroidDataUsageProto keyToPackageNameMapping
     * @property {Array.<IPayloadLevelAppStat>|null} [payloadLevelAppStat] AndroidDataUsageProto payloadLevelAppStat
     * @property {Array.<IIpLayerNetworkStat>|null} [ipLayerNetworkStat] AndroidDataUsageProto ipLayerNetworkStat
     */

    /**
     * Constructs a new AndroidDataUsageProto.
     * @exports AndroidDataUsageProto
     * @classdesc Represents an AndroidDataUsageProto.
     * @implements IAndroidDataUsageProto
     * @constructor
     * @param {IAndroidDataUsageProto=} [properties] Properties to set
     */
    function AndroidDataUsageProto(properties) {
        this.keyToPackageNameMapping = [];
        this.payloadLevelAppStat = [];
        this.ipLayerNetworkStat = [];
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * AndroidDataUsageProto version.
     * @member {number} version
     * @memberof AndroidDataUsageProto
     * @instance
     */
    AndroidDataUsageProto.prototype.version = 0;

    /**
     * AndroidDataUsageProto currentReportMsec.
     * @member {number|Long} currentReportMsec
     * @memberof AndroidDataUsageProto
     * @instance
     */
    AndroidDataUsageProto.prototype.currentReportMsec = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

    /**
     * AndroidDataUsageProto keyToPackageNameMapping.
     * @member {Array.<IKeyToPackageNameMapping>} keyToPackageNameMapping
     * @memberof AndroidDataUsageProto
     * @instance
     */
    AndroidDataUsageProto.prototype.keyToPackageNameMapping = $util.emptyArray;

    /**
     * AndroidDataUsageProto payloadLevelAppStat.
     * @member {Array.<IPayloadLevelAppStat>} payloadLevelAppStat
     * @memberof AndroidDataUsageProto
     * @instance
     */
    AndroidDataUsageProto.prototype.payloadLevelAppStat = $util.emptyArray;

    /**
     * AndroidDataUsageProto ipLayerNetworkStat.
     * @member {Array.<IIpLayerNetworkStat>} ipLayerNetworkStat
     * @memberof AndroidDataUsageProto
     * @instance
     */
    AndroidDataUsageProto.prototype.ipLayerNetworkStat = $util.emptyArray;

    /**
     * Creates a new AndroidDataUsageProto instance using the specified properties.
     * @function create
     * @memberof AndroidDataUsageProto
     * @static
     * @param {IAndroidDataUsageProto=} [properties] Properties to set
     * @returns {AndroidDataUsageProto} AndroidDataUsageProto instance
     */
    AndroidDataUsageProto.create = function create(properties) {
        return new AndroidDataUsageProto(properties);
    };

    /**
     * Encodes the specified AndroidDataUsageProto message. Does not implicitly {@link AndroidDataUsageProto.verify|verify} messages.
     * @function encode
     * @memberof AndroidDataUsageProto
     * @static
     * @param {IAndroidDataUsageProto} message AndroidDataUsageProto message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    AndroidDataUsageProto.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.version != null && Object.hasOwnProperty.call(message, "version"))
            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.version);
        if (message.currentReportMsec != null && Object.hasOwnProperty.call(message, "currentReportMsec"))
            writer.uint32(/* id 2, wireType 0 =*/16).int64(message.currentReportMsec);
        if (message.keyToPackageNameMapping != null && message.keyToPackageNameMapping.length)
            for (var i = 0; i < message.keyToPackageNameMapping.length; ++i)
                $root.KeyToPackageNameMapping.encode(message.keyToPackageNameMapping[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
        if (message.payloadLevelAppStat != null && message.payloadLevelAppStat.length)
            for (var i = 0; i < message.payloadLevelAppStat.length; ++i)
                $root.PayloadLevelAppStat.encode(message.payloadLevelAppStat[i], writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
        if (message.ipLayerNetworkStat != null && message.ipLayerNetworkStat.length)
            for (var i = 0; i < message.ipLayerNetworkStat.length; ++i)
                $root.IpLayerNetworkStat.encode(message.ipLayerNetworkStat[i], writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
        return writer;
    };

    /**
     * Encodes the specified AndroidDataUsageProto message, length delimited. Does not implicitly {@link AndroidDataUsageProto.verify|verify} messages.
     * @function encodeDelimited
     * @memberof AndroidDataUsageProto
     * @static
     * @param {IAndroidDataUsageProto} message AndroidDataUsageProto message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    AndroidDataUsageProto.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes an AndroidDataUsageProto message from the specified reader or buffer.
     * @function decode
     * @memberof AndroidDataUsageProto
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {AndroidDataUsageProto} AndroidDataUsageProto
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    AndroidDataUsageProto.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.AndroidDataUsageProto();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.version = reader.int32();
                break;
            case 2:
                message.currentReportMsec = reader.int64();
                break;
            case 3:
                if (!(message.keyToPackageNameMapping && message.keyToPackageNameMapping.length))
                    message.keyToPackageNameMapping = [];
                message.keyToPackageNameMapping.push($root.KeyToPackageNameMapping.decode(reader, reader.uint32()));
                break;
            case 4:
                if (!(message.payloadLevelAppStat && message.payloadLevelAppStat.length))
                    message.payloadLevelAppStat = [];
                message.payloadLevelAppStat.push($root.PayloadLevelAppStat.decode(reader, reader.uint32()));
                break;
            case 5:
                if (!(message.ipLayerNetworkStat && message.ipLayerNetworkStat.length))
                    message.ipLayerNetworkStat = [];
                message.ipLayerNetworkStat.push($root.IpLayerNetworkStat.decode(reader, reader.uint32()));
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes an AndroidDataUsageProto message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof AndroidDataUsageProto
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {AndroidDataUsageProto} AndroidDataUsageProto
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    AndroidDataUsageProto.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies an AndroidDataUsageProto message.
     * @function verify
     * @memberof AndroidDataUsageProto
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    AndroidDataUsageProto.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.version != null && message.hasOwnProperty("version"))
            if (!$util.isInteger(message.version))
                return "version: integer expected";
        if (message.currentReportMsec != null && message.hasOwnProperty("currentReportMsec"))
            if (!$util.isInteger(message.currentReportMsec) && !(message.currentReportMsec && $util.isInteger(message.currentReportMsec.low) && $util.isInteger(message.currentReportMsec.high)))
                return "currentReportMsec: integer|Long expected";
        if (message.keyToPackageNameMapping != null && message.hasOwnProperty("keyToPackageNameMapping")) {
            if (!Array.isArray(message.keyToPackageNameMapping))
                return "keyToPackageNameMapping: array expected";
            for (var i = 0; i < message.keyToPackageNameMapping.length; ++i) {
                var error = $root.KeyToPackageNameMapping.verify(message.keyToPackageNameMapping[i]);
                if (error)
                    return "keyToPackageNameMapping." + error;
            }
        }
        if (message.payloadLevelAppStat != null && message.hasOwnProperty("payloadLevelAppStat")) {
            if (!Array.isArray(message.payloadLevelAppStat))
                return "payloadLevelAppStat: array expected";
            for (var i = 0; i < message.payloadLevelAppStat.length; ++i) {
                var error = $root.PayloadLevelAppStat.verify(message.payloadLevelAppStat[i]);
                if (error)
                    return "payloadLevelAppStat." + error;
            }
        }
        if (message.ipLayerNetworkStat != null && message.hasOwnProperty("ipLayerNetworkStat")) {
            if (!Array.isArray(message.ipLayerNetworkStat))
                return "ipLayerNetworkStat: array expected";
            for (var i = 0; i < message.ipLayerNetworkStat.length; ++i) {
                var error = $root.IpLayerNetworkStat.verify(message.ipLayerNetworkStat[i]);
                if (error)
                    return "ipLayerNetworkStat." + error;
            }
        }
        return null;
    };

    /**
     * Creates an AndroidDataUsageProto message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof AndroidDataUsageProto
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {AndroidDataUsageProto} AndroidDataUsageProto
     */
    AndroidDataUsageProto.fromObject = function fromObject(object) {
        if (object instanceof $root.AndroidDataUsageProto)
            return object;
        var message = new $root.AndroidDataUsageProto();
        if (object.version != null)
            message.version = object.version | 0;
        if (object.currentReportMsec != null)
            if ($util.Long)
                (message.currentReportMsec = $util.Long.fromValue(object.currentReportMsec)).unsigned = false;
            else if (typeof object.currentReportMsec === "string")
                message.currentReportMsec = parseInt(object.currentReportMsec, 10);
            else if (typeof object.currentReportMsec === "number")
                message.currentReportMsec = object.currentReportMsec;
            else if (typeof object.currentReportMsec === "object")
                message.currentReportMsec = new $util.LongBits(object.currentReportMsec.low >>> 0, object.currentReportMsec.high >>> 0).toNumber();
        if (object.keyToPackageNameMapping) {
            if (!Array.isArray(object.keyToPackageNameMapping))
                throw TypeError(".AndroidDataUsageProto.keyToPackageNameMapping: array expected");
            message.keyToPackageNameMapping = [];
            for (var i = 0; i < object.keyToPackageNameMapping.length; ++i) {
                if (typeof object.keyToPackageNameMapping[i] !== "object")
                    throw TypeError(".AndroidDataUsageProto.keyToPackageNameMapping: object expected");
                message.keyToPackageNameMapping[i] = $root.KeyToPackageNameMapping.fromObject(object.keyToPackageNameMapping[i]);
            }
        }
        if (object.payloadLevelAppStat) {
            if (!Array.isArray(object.payloadLevelAppStat))
                throw TypeError(".AndroidDataUsageProto.payloadLevelAppStat: array expected");
            message.payloadLevelAppStat = [];
            for (var i = 0; i < object.payloadLevelAppStat.length; ++i) {
                if (typeof object.payloadLevelAppStat[i] !== "object")
                    throw TypeError(".AndroidDataUsageProto.payloadLevelAppStat: object expected");
                message.payloadLevelAppStat[i] = $root.PayloadLevelAppStat.fromObject(object.payloadLevelAppStat[i]);
            }
        }
        if (object.ipLayerNetworkStat) {
            if (!Array.isArray(object.ipLayerNetworkStat))
                throw TypeError(".AndroidDataUsageProto.ipLayerNetworkStat: array expected");
            message.ipLayerNetworkStat = [];
            for (var i = 0; i < object.ipLayerNetworkStat.length; ++i) {
                if (typeof object.ipLayerNetworkStat[i] !== "object")
                    throw TypeError(".AndroidDataUsageProto.ipLayerNetworkStat: object expected");
                message.ipLayerNetworkStat[i] = $root.IpLayerNetworkStat.fromObject(object.ipLayerNetworkStat[i]);
            }
        }
        return message;
    };

    /**
     * Creates a plain object from an AndroidDataUsageProto message. Also converts values to other types if specified.
     * @function toObject
     * @memberof AndroidDataUsageProto
     * @static
     * @param {AndroidDataUsageProto} message AndroidDataUsageProto
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    AndroidDataUsageProto.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        var object = {};
        if (options.arrays || options.defaults) {
            object.keyToPackageNameMapping = [];
            object.payloadLevelAppStat = [];
            object.ipLayerNetworkStat = [];
        }
        if (options.defaults) {
            object.version = 0;
            if ($util.Long) {
                var long = new $util.Long(0, 0, false);
                object.currentReportMsec = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
            } else
                object.currentReportMsec = options.longs === String ? "0" : 0;
        }
        if (message.version != null && message.hasOwnProperty("version"))
            object.version = message.version;
        if (message.currentReportMsec != null && message.hasOwnProperty("currentReportMsec"))
            if (typeof message.currentReportMsec === "number")
                object.currentReportMsec = options.longs === String ? String(message.currentReportMsec) : message.currentReportMsec;
            else
                object.currentReportMsec = options.longs === String ? $util.Long.prototype.toString.call(message.currentReportMsec) : options.longs === Number ? new $util.LongBits(message.currentReportMsec.low >>> 0, message.currentReportMsec.high >>> 0).toNumber() : message.currentReportMsec;
        if (message.keyToPackageNameMapping && message.keyToPackageNameMapping.length) {
            object.keyToPackageNameMapping = [];
            for (var j = 0; j < message.keyToPackageNameMapping.length; ++j)
                object.keyToPackageNameMapping[j] = $root.KeyToPackageNameMapping.toObject(message.keyToPackageNameMapping[j], options);
        }
        if (message.payloadLevelAppStat && message.payloadLevelAppStat.length) {
            object.payloadLevelAppStat = [];
            for (var j = 0; j < message.payloadLevelAppStat.length; ++j)
                object.payloadLevelAppStat[j] = $root.PayloadLevelAppStat.toObject(message.payloadLevelAppStat[j], options);
        }
        if (message.ipLayerNetworkStat && message.ipLayerNetworkStat.length) {
            object.ipLayerNetworkStat = [];
            for (var j = 0; j < message.ipLayerNetworkStat.length; ++j)
                object.ipLayerNetworkStat[j] = $root.IpLayerNetworkStat.toObject(message.ipLayerNetworkStat[j], options);
        }
        return object;
    };

    /**
     * Converts this AndroidDataUsageProto to JSON.
     * @function toJSON
     * @memberof AndroidDataUsageProto
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    AndroidDataUsageProto.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return AndroidDataUsageProto;
})();

$root.AndroidUsageStatsReport = (function() {

    /**
     * Properties of an AndroidUsageStatsReport.
     * @exports IAndroidUsageStatsReport
     * @interface IAndroidUsageStatsReport
     * @property {number|Long|null} [androidId] AndroidUsageStatsReport androidId
     * @property {number|Long|null} [loggingId] AndroidUsageStatsReport loggingId
     * @property {IUsageStatsExtensionProto|null} [usageStats] AndroidUsageStatsReport usageStats
     */

    /**
     * Constructs a new AndroidUsageStatsReport.
     * @exports AndroidUsageStatsReport
     * @classdesc Represents an AndroidUsageStatsReport.
     * @implements IAndroidUsageStatsReport
     * @constructor
     * @param {IAndroidUsageStatsReport=} [properties] Properties to set
     */
    function AndroidUsageStatsReport(properties) {
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * AndroidUsageStatsReport androidId.
     * @member {number|Long} androidId
     * @memberof AndroidUsageStatsReport
     * @instance
     */
    AndroidUsageStatsReport.prototype.androidId = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

    /**
     * AndroidUsageStatsReport loggingId.
     * @member {number|Long} loggingId
     * @memberof AndroidUsageStatsReport
     * @instance
     */
    AndroidUsageStatsReport.prototype.loggingId = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

    /**
     * AndroidUsageStatsReport usageStats.
     * @member {IUsageStatsExtensionProto|null|undefined} usageStats
     * @memberof AndroidUsageStatsReport
     * @instance
     */
    AndroidUsageStatsReport.prototype.usageStats = null;

    /**
     * Creates a new AndroidUsageStatsReport instance using the specified properties.
     * @function create
     * @memberof AndroidUsageStatsReport
     * @static
     * @param {IAndroidUsageStatsReport=} [properties] Properties to set
     * @returns {AndroidUsageStatsReport} AndroidUsageStatsReport instance
     */
    AndroidUsageStatsReport.create = function create(properties) {
        return new AndroidUsageStatsReport(properties);
    };

    /**
     * Encodes the specified AndroidUsageStatsReport message. Does not implicitly {@link AndroidUsageStatsReport.verify|verify} messages.
     * @function encode
     * @memberof AndroidUsageStatsReport
     * @static
     * @param {IAndroidUsageStatsReport} message AndroidUsageStatsReport message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    AndroidUsageStatsReport.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.androidId != null && Object.hasOwnProperty.call(message, "androidId"))
            writer.uint32(/* id 1, wireType 0 =*/8).int64(message.androidId);
        if (message.loggingId != null && Object.hasOwnProperty.call(message, "loggingId"))
            writer.uint32(/* id 2, wireType 0 =*/16).int64(message.loggingId);
        if (message.usageStats != null && Object.hasOwnProperty.call(message, "usageStats"))
            $root.UsageStatsExtensionProto.encode(message.usageStats, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
        return writer;
    };

    /**
     * Encodes the specified AndroidUsageStatsReport message, length delimited. Does not implicitly {@link AndroidUsageStatsReport.verify|verify} messages.
     * @function encodeDelimited
     * @memberof AndroidUsageStatsReport
     * @static
     * @param {IAndroidUsageStatsReport} message AndroidUsageStatsReport message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    AndroidUsageStatsReport.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes an AndroidUsageStatsReport message from the specified reader or buffer.
     * @function decode
     * @memberof AndroidUsageStatsReport
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {AndroidUsageStatsReport} AndroidUsageStatsReport
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    AndroidUsageStatsReport.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.AndroidUsageStatsReport();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.androidId = reader.int64();
                break;
            case 2:
                message.loggingId = reader.int64();
                break;
            case 3:
                message.usageStats = $root.UsageStatsExtensionProto.decode(reader, reader.uint32());
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes an AndroidUsageStatsReport message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof AndroidUsageStatsReport
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {AndroidUsageStatsReport} AndroidUsageStatsReport
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    AndroidUsageStatsReport.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies an AndroidUsageStatsReport message.
     * @function verify
     * @memberof AndroidUsageStatsReport
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    AndroidUsageStatsReport.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.androidId != null && message.hasOwnProperty("androidId"))
            if (!$util.isInteger(message.androidId) && !(message.androidId && $util.isInteger(message.androidId.low) && $util.isInteger(message.androidId.high)))
                return "androidId: integer|Long expected";
        if (message.loggingId != null && message.hasOwnProperty("loggingId"))
            if (!$util.isInteger(message.loggingId) && !(message.loggingId && $util.isInteger(message.loggingId.low) && $util.isInteger(message.loggingId.high)))
                return "loggingId: integer|Long expected";
        if (message.usageStats != null && message.hasOwnProperty("usageStats")) {
            var error = $root.UsageStatsExtensionProto.verify(message.usageStats);
            if (error)
                return "usageStats." + error;
        }
        return null;
    };

    /**
     * Creates an AndroidUsageStatsReport message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof AndroidUsageStatsReport
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {AndroidUsageStatsReport} AndroidUsageStatsReport
     */
    AndroidUsageStatsReport.fromObject = function fromObject(object) {
        if (object instanceof $root.AndroidUsageStatsReport)
            return object;
        var message = new $root.AndroidUsageStatsReport();
        if (object.androidId != null)
            if ($util.Long)
                (message.androidId = $util.Long.fromValue(object.androidId)).unsigned = false;
            else if (typeof object.androidId === "string")
                message.androidId = parseInt(object.androidId, 10);
            else if (typeof object.androidId === "number")
                message.androidId = object.androidId;
            else if (typeof object.androidId === "object")
                message.androidId = new $util.LongBits(object.androidId.low >>> 0, object.androidId.high >>> 0).toNumber();
        if (object.loggingId != null)
            if ($util.Long)
                (message.loggingId = $util.Long.fromValue(object.loggingId)).unsigned = false;
            else if (typeof object.loggingId === "string")
                message.loggingId = parseInt(object.loggingId, 10);
            else if (typeof object.loggingId === "number")
                message.loggingId = object.loggingId;
            else if (typeof object.loggingId === "object")
                message.loggingId = new $util.LongBits(object.loggingId.low >>> 0, object.loggingId.high >>> 0).toNumber();
        if (object.usageStats != null) {
            if (typeof object.usageStats !== "object")
                throw TypeError(".AndroidUsageStatsReport.usageStats: object expected");
            message.usageStats = $root.UsageStatsExtensionProto.fromObject(object.usageStats);
        }
        return message;
    };

    /**
     * Creates a plain object from an AndroidUsageStatsReport message. Also converts values to other types if specified.
     * @function toObject
     * @memberof AndroidUsageStatsReport
     * @static
     * @param {AndroidUsageStatsReport} message AndroidUsageStatsReport
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    AndroidUsageStatsReport.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        var object = {};
        if (options.defaults) {
            if ($util.Long) {
                var long = new $util.Long(0, 0, false);
                object.androidId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
            } else
                object.androidId = options.longs === String ? "0" : 0;
            if ($util.Long) {
                var long = new $util.Long(0, 0, false);
                object.loggingId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
            } else
                object.loggingId = options.longs === String ? "0" : 0;
            object.usageStats = null;
        }
        if (message.androidId != null && message.hasOwnProperty("androidId"))
            if (typeof message.androidId === "number")
                object.androidId = options.longs === String ? String(message.androidId) : message.androidId;
            else
                object.androidId = options.longs === String ? $util.Long.prototype.toString.call(message.androidId) : options.longs === Number ? new $util.LongBits(message.androidId.low >>> 0, message.androidId.high >>> 0).toNumber() : message.androidId;
        if (message.loggingId != null && message.hasOwnProperty("loggingId"))
            if (typeof message.loggingId === "number")
                object.loggingId = options.longs === String ? String(message.loggingId) : message.loggingId;
            else
                object.loggingId = options.longs === String ? $util.Long.prototype.toString.call(message.loggingId) : options.longs === Number ? new $util.LongBits(message.loggingId.low >>> 0, message.loggingId.high >>> 0).toNumber() : message.loggingId;
        if (message.usageStats != null && message.hasOwnProperty("usageStats"))
            object.usageStats = $root.UsageStatsExtensionProto.toObject(message.usageStats, options);
        return object;
    };

    /**
     * Converts this AndroidUsageStatsReport to JSON.
     * @function toJSON
     * @memberof AndroidUsageStatsReport
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    AndroidUsageStatsReport.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return AndroidUsageStatsReport;
})();

$root.AppBucket = (function() {

    /**
     * Properties of an AppBucket.
     * @exports IAppBucket
     * @interface IAppBucket
     * @property {number|Long|null} [bucketStartMsec] AppBucket bucketStartMsec
     * @property {number|Long|null} [bucketDurationMsec] AppBucket bucketDurationMsec
     * @property {Array.<IStatCounters>|null} [statCounters] AppBucket statCounters
     * @property {number|Long|null} [operationCount] AppBucket operationCount
     */

    /**
     * Constructs a new AppBucket.
     * @exports AppBucket
     * @classdesc Represents an AppBucket.
     * @implements IAppBucket
     * @constructor
     * @param {IAppBucket=} [properties] Properties to set
     */
    function AppBucket(properties) {
        this.statCounters = [];
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * AppBucket bucketStartMsec.
     * @member {number|Long} bucketStartMsec
     * @memberof AppBucket
     * @instance
     */
    AppBucket.prototype.bucketStartMsec = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

    /**
     * AppBucket bucketDurationMsec.
     * @member {number|Long} bucketDurationMsec
     * @memberof AppBucket
     * @instance
     */
    AppBucket.prototype.bucketDurationMsec = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

    /**
     * AppBucket statCounters.
     * @member {Array.<IStatCounters>} statCounters
     * @memberof AppBucket
     * @instance
     */
    AppBucket.prototype.statCounters = $util.emptyArray;

    /**
     * AppBucket operationCount.
     * @member {number|Long} operationCount
     * @memberof AppBucket
     * @instance
     */
    AppBucket.prototype.operationCount = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

    /**
     * Creates a new AppBucket instance using the specified properties.
     * @function create
     * @memberof AppBucket
     * @static
     * @param {IAppBucket=} [properties] Properties to set
     * @returns {AppBucket} AppBucket instance
     */
    AppBucket.create = function create(properties) {
        return new AppBucket(properties);
    };

    /**
     * Encodes the specified AppBucket message. Does not implicitly {@link AppBucket.verify|verify} messages.
     * @function encode
     * @memberof AppBucket
     * @static
     * @param {IAppBucket} message AppBucket message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    AppBucket.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.bucketStartMsec != null && Object.hasOwnProperty.call(message, "bucketStartMsec"))
            writer.uint32(/* id 1, wireType 0 =*/8).int64(message.bucketStartMsec);
        if (message.bucketDurationMsec != null && Object.hasOwnProperty.call(message, "bucketDurationMsec"))
            writer.uint32(/* id 2, wireType 0 =*/16).int64(message.bucketDurationMsec);
        if (message.statCounters != null && message.statCounters.length)
            for (var i = 0; i < message.statCounters.length; ++i)
                $root.StatCounters.encode(message.statCounters[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
        if (message.operationCount != null && Object.hasOwnProperty.call(message, "operationCount"))
            writer.uint32(/* id 4, wireType 0 =*/32).int64(message.operationCount);
        return writer;
    };

    /**
     * Encodes the specified AppBucket message, length delimited. Does not implicitly {@link AppBucket.verify|verify} messages.
     * @function encodeDelimited
     * @memberof AppBucket
     * @static
     * @param {IAppBucket} message AppBucket message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    AppBucket.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes an AppBucket message from the specified reader or buffer.
     * @function decode
     * @memberof AppBucket
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {AppBucket} AppBucket
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    AppBucket.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.AppBucket();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.bucketStartMsec = reader.int64();
                break;
            case 2:
                message.bucketDurationMsec = reader.int64();
                break;
            case 3:
                if (!(message.statCounters && message.statCounters.length))
                    message.statCounters = [];
                message.statCounters.push($root.StatCounters.decode(reader, reader.uint32()));
                break;
            case 4:
                message.operationCount = reader.int64();
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes an AppBucket message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof AppBucket
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {AppBucket} AppBucket
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    AppBucket.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies an AppBucket message.
     * @function verify
     * @memberof AppBucket
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    AppBucket.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.bucketStartMsec != null && message.hasOwnProperty("bucketStartMsec"))
            if (!$util.isInteger(message.bucketStartMsec) && !(message.bucketStartMsec && $util.isInteger(message.bucketStartMsec.low) && $util.isInteger(message.bucketStartMsec.high)))
                return "bucketStartMsec: integer|Long expected";
        if (message.bucketDurationMsec != null && message.hasOwnProperty("bucketDurationMsec"))
            if (!$util.isInteger(message.bucketDurationMsec) && !(message.bucketDurationMsec && $util.isInteger(message.bucketDurationMsec.low) && $util.isInteger(message.bucketDurationMsec.high)))
                return "bucketDurationMsec: integer|Long expected";
        if (message.statCounters != null && message.hasOwnProperty("statCounters")) {
            if (!Array.isArray(message.statCounters))
                return "statCounters: array expected";
            for (var i = 0; i < message.statCounters.length; ++i) {
                var error = $root.StatCounters.verify(message.statCounters[i]);
                if (error)
                    return "statCounters." + error;
            }
        }
        if (message.operationCount != null && message.hasOwnProperty("operationCount"))
            if (!$util.isInteger(message.operationCount) && !(message.operationCount && $util.isInteger(message.operationCount.low) && $util.isInteger(message.operationCount.high)))
                return "operationCount: integer|Long expected";
        return null;
    };

    /**
     * Creates an AppBucket message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof AppBucket
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {AppBucket} AppBucket
     */
    AppBucket.fromObject = function fromObject(object) {
        if (object instanceof $root.AppBucket)
            return object;
        var message = new $root.AppBucket();
        if (object.bucketStartMsec != null)
            if ($util.Long)
                (message.bucketStartMsec = $util.Long.fromValue(object.bucketStartMsec)).unsigned = false;
            else if (typeof object.bucketStartMsec === "string")
                message.bucketStartMsec = parseInt(object.bucketStartMsec, 10);
            else if (typeof object.bucketStartMsec === "number")
                message.bucketStartMsec = object.bucketStartMsec;
            else if (typeof object.bucketStartMsec === "object")
                message.bucketStartMsec = new $util.LongBits(object.bucketStartMsec.low >>> 0, object.bucketStartMsec.high >>> 0).toNumber();
        if (object.bucketDurationMsec != null)
            if ($util.Long)
                (message.bucketDurationMsec = $util.Long.fromValue(object.bucketDurationMsec)).unsigned = false;
            else if (typeof object.bucketDurationMsec === "string")
                message.bucketDurationMsec = parseInt(object.bucketDurationMsec, 10);
            else if (typeof object.bucketDurationMsec === "number")
                message.bucketDurationMsec = object.bucketDurationMsec;
            else if (typeof object.bucketDurationMsec === "object")
                message.bucketDurationMsec = new $util.LongBits(object.bucketDurationMsec.low >>> 0, object.bucketDurationMsec.high >>> 0).toNumber();
        if (object.statCounters) {
            if (!Array.isArray(object.statCounters))
                throw TypeError(".AppBucket.statCounters: array expected");
            message.statCounters = [];
            for (var i = 0; i < object.statCounters.length; ++i) {
                if (typeof object.statCounters[i] !== "object")
                    throw TypeError(".AppBucket.statCounters: object expected");
                message.statCounters[i] = $root.StatCounters.fromObject(object.statCounters[i]);
            }
        }
        if (object.operationCount != null)
            if ($util.Long)
                (message.operationCount = $util.Long.fromValue(object.operationCount)).unsigned = false;
            else if (typeof object.operationCount === "string")
                message.operationCount = parseInt(object.operationCount, 10);
            else if (typeof object.operationCount === "number")
                message.operationCount = object.operationCount;
            else if (typeof object.operationCount === "object")
                message.operationCount = new $util.LongBits(object.operationCount.low >>> 0, object.operationCount.high >>> 0).toNumber();
        return message;
    };

    /**
     * Creates a plain object from an AppBucket message. Also converts values to other types if specified.
     * @function toObject
     * @memberof AppBucket
     * @static
     * @param {AppBucket} message AppBucket
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    AppBucket.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        var object = {};
        if (options.arrays || options.defaults)
            object.statCounters = [];
        if (options.defaults) {
            if ($util.Long) {
                var long = new $util.Long(0, 0, false);
                object.bucketStartMsec = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
            } else
                object.bucketStartMsec = options.longs === String ? "0" : 0;
            if ($util.Long) {
                var long = new $util.Long(0, 0, false);
                object.bucketDurationMsec = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
            } else
                object.bucketDurationMsec = options.longs === String ? "0" : 0;
            if ($util.Long) {
                var long = new $util.Long(0, 0, false);
                object.operationCount = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
            } else
                object.operationCount = options.longs === String ? "0" : 0;
        }
        if (message.bucketStartMsec != null && message.hasOwnProperty("bucketStartMsec"))
            if (typeof message.bucketStartMsec === "number")
                object.bucketStartMsec = options.longs === String ? String(message.bucketStartMsec) : message.bucketStartMsec;
            else
                object.bucketStartMsec = options.longs === String ? $util.Long.prototype.toString.call(message.bucketStartMsec) : options.longs === Number ? new $util.LongBits(message.bucketStartMsec.low >>> 0, message.bucketStartMsec.high >>> 0).toNumber() : message.bucketStartMsec;
        if (message.bucketDurationMsec != null && message.hasOwnProperty("bucketDurationMsec"))
            if (typeof message.bucketDurationMsec === "number")
                object.bucketDurationMsec = options.longs === String ? String(message.bucketDurationMsec) : message.bucketDurationMsec;
            else
                object.bucketDurationMsec = options.longs === String ? $util.Long.prototype.toString.call(message.bucketDurationMsec) : options.longs === Number ? new $util.LongBits(message.bucketDurationMsec.low >>> 0, message.bucketDurationMsec.high >>> 0).toNumber() : message.bucketDurationMsec;
        if (message.statCounters && message.statCounters.length) {
            object.statCounters = [];
            for (var j = 0; j < message.statCounters.length; ++j)
                object.statCounters[j] = $root.StatCounters.toObject(message.statCounters[j], options);
        }
        if (message.operationCount != null && message.hasOwnProperty("operationCount"))
            if (typeof message.operationCount === "number")
                object.operationCount = options.longs === String ? String(message.operationCount) : message.operationCount;
            else
                object.operationCount = options.longs === String ? $util.Long.prototype.toString.call(message.operationCount) : options.longs === Number ? new $util.LongBits(message.operationCount.low >>> 0, message.operationCount.high >>> 0).toNumber() : message.operationCount;
        return object;
    };

    /**
     * Converts this AppBucket to JSON.
     * @function toJSON
     * @memberof AppBucket
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    AppBucket.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return AppBucket;
})();

$root.CounterData = (function() {

    /**
     * Properties of a CounterData.
     * @exports ICounterData
     * @interface ICounterData
     * @property {number|Long|null} [bytes] CounterData bytes
     * @property {number|Long|null} [packets] CounterData packets
     */

    /**
     * Constructs a new CounterData.
     * @exports CounterData
     * @classdesc Represents a CounterData.
     * @implements ICounterData
     * @constructor
     * @param {ICounterData=} [properties] Properties to set
     */
    function CounterData(properties) {
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * CounterData bytes.
     * @member {number|Long} bytes
     * @memberof CounterData
     * @instance
     */
    CounterData.prototype.bytes = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

    /**
     * CounterData packets.
     * @member {number|Long} packets
     * @memberof CounterData
     * @instance
     */
    CounterData.prototype.packets = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

    /**
     * Creates a new CounterData instance using the specified properties.
     * @function create
     * @memberof CounterData
     * @static
     * @param {ICounterData=} [properties] Properties to set
     * @returns {CounterData} CounterData instance
     */
    CounterData.create = function create(properties) {
        return new CounterData(properties);
    };

    /**
     * Encodes the specified CounterData message. Does not implicitly {@link CounterData.verify|verify} messages.
     * @function encode
     * @memberof CounterData
     * @static
     * @param {ICounterData} message CounterData message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    CounterData.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.bytes != null && Object.hasOwnProperty.call(message, "bytes"))
            writer.uint32(/* id 1, wireType 0 =*/8).int64(message.bytes);
        if (message.packets != null && Object.hasOwnProperty.call(message, "packets"))
            writer.uint32(/* id 2, wireType 0 =*/16).int64(message.packets);
        return writer;
    };

    /**
     * Encodes the specified CounterData message, length delimited. Does not implicitly {@link CounterData.verify|verify} messages.
     * @function encodeDelimited
     * @memberof CounterData
     * @static
     * @param {ICounterData} message CounterData message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    CounterData.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a CounterData message from the specified reader or buffer.
     * @function decode
     * @memberof CounterData
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CounterData} CounterData
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CounterData.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CounterData();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.bytes = reader.int64();
                break;
            case 2:
                message.packets = reader.int64();
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a CounterData message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof CounterData
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {CounterData} CounterData
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CounterData.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a CounterData message.
     * @function verify
     * @memberof CounterData
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    CounterData.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.bytes != null && message.hasOwnProperty("bytes"))
            if (!$util.isInteger(message.bytes) && !(message.bytes && $util.isInteger(message.bytes.low) && $util.isInteger(message.bytes.high)))
                return "bytes: integer|Long expected";
        if (message.packets != null && message.hasOwnProperty("packets"))
            if (!$util.isInteger(message.packets) && !(message.packets && $util.isInteger(message.packets.low) && $util.isInteger(message.packets.high)))
                return "packets: integer|Long expected";
        return null;
    };

    /**
     * Creates a CounterData message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof CounterData
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {CounterData} CounterData
     */
    CounterData.fromObject = function fromObject(object) {
        if (object instanceof $root.CounterData)
            return object;
        var message = new $root.CounterData();
        if (object.bytes != null)
            if ($util.Long)
                (message.bytes = $util.Long.fromValue(object.bytes)).unsigned = false;
            else if (typeof object.bytes === "string")
                message.bytes = parseInt(object.bytes, 10);
            else if (typeof object.bytes === "number")
                message.bytes = object.bytes;
            else if (typeof object.bytes === "object")
                message.bytes = new $util.LongBits(object.bytes.low >>> 0, object.bytes.high >>> 0).toNumber();
        if (object.packets != null)
            if ($util.Long)
                (message.packets = $util.Long.fromValue(object.packets)).unsigned = false;
            else if (typeof object.packets === "string")
                message.packets = parseInt(object.packets, 10);
            else if (typeof object.packets === "number")
                message.packets = object.packets;
            else if (typeof object.packets === "object")
                message.packets = new $util.LongBits(object.packets.low >>> 0, object.packets.high >>> 0).toNumber();
        return message;
    };

    /**
     * Creates a plain object from a CounterData message. Also converts values to other types if specified.
     * @function toObject
     * @memberof CounterData
     * @static
     * @param {CounterData} message CounterData
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    CounterData.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        var object = {};
        if (options.defaults) {
            if ($util.Long) {
                var long = new $util.Long(0, 0, false);
                object.bytes = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
            } else
                object.bytes = options.longs === String ? "0" : 0;
            if ($util.Long) {
                var long = new $util.Long(0, 0, false);
                object.packets = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
            } else
                object.packets = options.longs === String ? "0" : 0;
        }
        if (message.bytes != null && message.hasOwnProperty("bytes"))
            if (typeof message.bytes === "number")
                object.bytes = options.longs === String ? String(message.bytes) : message.bytes;
            else
                object.bytes = options.longs === String ? $util.Long.prototype.toString.call(message.bytes) : options.longs === Number ? new $util.LongBits(message.bytes.low >>> 0, message.bytes.high >>> 0).toNumber() : message.bytes;
        if (message.packets != null && message.hasOwnProperty("packets"))
            if (typeof message.packets === "number")
                object.packets = options.longs === String ? String(message.packets) : message.packets;
            else
                object.packets = options.longs === String ? $util.Long.prototype.toString.call(message.packets) : options.longs === Number ? new $util.LongBits(message.packets.low >>> 0, message.packets.high >>> 0).toNumber() : message.packets;
        return object;
    };

    /**
     * Converts this CounterData to JSON.
     * @function toJSON
     * @memberof CounterData
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    CounterData.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return CounterData;
})();

$root.IpLayerAppStat = (function() {

    /**
     * Properties of an IpLayerAppStat.
     * @exports IIpLayerAppStat
     * @interface IIpLayerAppStat
     * @property {number|null} [packageKey] IpLayerAppStat packageKey
     * @property {number|null} [applicationTag] IpLayerAppStat applicationTag
     * @property {Array.<IAppBucket>|null} [ipLayerAppBucket] IpLayerAppStat ipLayerAppBucket
     */

    /**
     * Constructs a new IpLayerAppStat.
     * @exports IpLayerAppStat
     * @classdesc Represents an IpLayerAppStat.
     * @implements IIpLayerAppStat
     * @constructor
     * @param {IIpLayerAppStat=} [properties] Properties to set
     */
    function IpLayerAppStat(properties) {
        this.ipLayerAppBucket = [];
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * IpLayerAppStat packageKey.
     * @member {number} packageKey
     * @memberof IpLayerAppStat
     * @instance
     */
    IpLayerAppStat.prototype.packageKey = 0;

    /**
     * IpLayerAppStat applicationTag.
     * @member {number} applicationTag
     * @memberof IpLayerAppStat
     * @instance
     */
    IpLayerAppStat.prototype.applicationTag = 0;

    /**
     * IpLayerAppStat ipLayerAppBucket.
     * @member {Array.<IAppBucket>} ipLayerAppBucket
     * @memberof IpLayerAppStat
     * @instance
     */
    IpLayerAppStat.prototype.ipLayerAppBucket = $util.emptyArray;

    /**
     * Creates a new IpLayerAppStat instance using the specified properties.
     * @function create
     * @memberof IpLayerAppStat
     * @static
     * @param {IIpLayerAppStat=} [properties] Properties to set
     * @returns {IpLayerAppStat} IpLayerAppStat instance
     */
    IpLayerAppStat.create = function create(properties) {
        return new IpLayerAppStat(properties);
    };

    /**
     * Encodes the specified IpLayerAppStat message. Does not implicitly {@link IpLayerAppStat.verify|verify} messages.
     * @function encode
     * @memberof IpLayerAppStat
     * @static
     * @param {IIpLayerAppStat} message IpLayerAppStat message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    IpLayerAppStat.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.packageKey != null && Object.hasOwnProperty.call(message, "packageKey"))
            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.packageKey);
        if (message.applicationTag != null && Object.hasOwnProperty.call(message, "applicationTag"))
            writer.uint32(/* id 2, wireType 0 =*/16).int32(message.applicationTag);
        if (message.ipLayerAppBucket != null && message.ipLayerAppBucket.length)
            for (var i = 0; i < message.ipLayerAppBucket.length; ++i)
                $root.AppBucket.encode(message.ipLayerAppBucket[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
        return writer;
    };

    /**
     * Encodes the specified IpLayerAppStat message, length delimited. Does not implicitly {@link IpLayerAppStat.verify|verify} messages.
     * @function encodeDelimited
     * @memberof IpLayerAppStat
     * @static
     * @param {IIpLayerAppStat} message IpLayerAppStat message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    IpLayerAppStat.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes an IpLayerAppStat message from the specified reader or buffer.
     * @function decode
     * @memberof IpLayerAppStat
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {IpLayerAppStat} IpLayerAppStat
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    IpLayerAppStat.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.IpLayerAppStat();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.packageKey = reader.int32();
                break;
            case 2:
                message.applicationTag = reader.int32();
                break;
            case 3:
                if (!(message.ipLayerAppBucket && message.ipLayerAppBucket.length))
                    message.ipLayerAppBucket = [];
                message.ipLayerAppBucket.push($root.AppBucket.decode(reader, reader.uint32()));
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes an IpLayerAppStat message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof IpLayerAppStat
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {IpLayerAppStat} IpLayerAppStat
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    IpLayerAppStat.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies an IpLayerAppStat message.
     * @function verify
     * @memberof IpLayerAppStat
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    IpLayerAppStat.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.packageKey != null && message.hasOwnProperty("packageKey"))
            if (!$util.isInteger(message.packageKey))
                return "packageKey: integer expected";
        if (message.applicationTag != null && message.hasOwnProperty("applicationTag"))
            if (!$util.isInteger(message.applicationTag))
                return "applicationTag: integer expected";
        if (message.ipLayerAppBucket != null && message.hasOwnProperty("ipLayerAppBucket")) {
            if (!Array.isArray(message.ipLayerAppBucket))
                return "ipLayerAppBucket: array expected";
            for (var i = 0; i < message.ipLayerAppBucket.length; ++i) {
                var error = $root.AppBucket.verify(message.ipLayerAppBucket[i]);
                if (error)
                    return "ipLayerAppBucket." + error;
            }
        }
        return null;
    };

    /**
     * Creates an IpLayerAppStat message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof IpLayerAppStat
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {IpLayerAppStat} IpLayerAppStat
     */
    IpLayerAppStat.fromObject = function fromObject(object) {
        if (object instanceof $root.IpLayerAppStat)
            return object;
        var message = new $root.IpLayerAppStat();
        if (object.packageKey != null)
            message.packageKey = object.packageKey | 0;
        if (object.applicationTag != null)
            message.applicationTag = object.applicationTag | 0;
        if (object.ipLayerAppBucket) {
            if (!Array.isArray(object.ipLayerAppBucket))
                throw TypeError(".IpLayerAppStat.ipLayerAppBucket: array expected");
            message.ipLayerAppBucket = [];
            for (var i = 0; i < object.ipLayerAppBucket.length; ++i) {
                if (typeof object.ipLayerAppBucket[i] !== "object")
                    throw TypeError(".IpLayerAppStat.ipLayerAppBucket: object expected");
                message.ipLayerAppBucket[i] = $root.AppBucket.fromObject(object.ipLayerAppBucket[i]);
            }
        }
        return message;
    };

    /**
     * Creates a plain object from an IpLayerAppStat message. Also converts values to other types if specified.
     * @function toObject
     * @memberof IpLayerAppStat
     * @static
     * @param {IpLayerAppStat} message IpLayerAppStat
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    IpLayerAppStat.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        var object = {};
        if (options.arrays || options.defaults)
            object.ipLayerAppBucket = [];
        if (options.defaults) {
            object.packageKey = 0;
            object.applicationTag = 0;
        }
        if (message.packageKey != null && message.hasOwnProperty("packageKey"))
            object.packageKey = message.packageKey;
        if (message.applicationTag != null && message.hasOwnProperty("applicationTag"))
            object.applicationTag = message.applicationTag;
        if (message.ipLayerAppBucket && message.ipLayerAppBucket.length) {
            object.ipLayerAppBucket = [];
            for (var j = 0; j < message.ipLayerAppBucket.length; ++j)
                object.ipLayerAppBucket[j] = $root.AppBucket.toObject(message.ipLayerAppBucket[j], options);
        }
        return object;
    };

    /**
     * Converts this IpLayerAppStat to JSON.
     * @function toJSON
     * @memberof IpLayerAppStat
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    IpLayerAppStat.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return IpLayerAppStat;
})();

$root.IpLayerNetworkBucket = (function() {

    /**
     * Properties of an IpLayerNetworkBucket.
     * @exports IIpLayerNetworkBucket
     * @interface IIpLayerNetworkBucket
     * @property {number|Long|null} [bucketStartMsec] IpLayerNetworkBucket bucketStartMsec
     * @property {number|Long|null} [bucketDurationMsec] IpLayerNetworkBucket bucketDurationMsec
     * @property {Array.<IStatCounters>|null} [statCounters] IpLayerNetworkBucket statCounters
     * @property {number|Long|null} [networkActiveDuration] IpLayerNetworkBucket networkActiveDuration
     */

    /**
     * Constructs a new IpLayerNetworkBucket.
     * @exports IpLayerNetworkBucket
     * @classdesc Represents an IpLayerNetworkBucket.
     * @implements IIpLayerNetworkBucket
     * @constructor
     * @param {IIpLayerNetworkBucket=} [properties] Properties to set
     */
    function IpLayerNetworkBucket(properties) {
        this.statCounters = [];
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * IpLayerNetworkBucket bucketStartMsec.
     * @member {number|Long} bucketStartMsec
     * @memberof IpLayerNetworkBucket
     * @instance
     */
    IpLayerNetworkBucket.prototype.bucketStartMsec = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

    /**
     * IpLayerNetworkBucket bucketDurationMsec.
     * @member {number|Long} bucketDurationMsec
     * @memberof IpLayerNetworkBucket
     * @instance
     */
    IpLayerNetworkBucket.prototype.bucketDurationMsec = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

    /**
     * IpLayerNetworkBucket statCounters.
     * @member {Array.<IStatCounters>} statCounters
     * @memberof IpLayerNetworkBucket
     * @instance
     */
    IpLayerNetworkBucket.prototype.statCounters = $util.emptyArray;

    /**
     * IpLayerNetworkBucket networkActiveDuration.
     * @member {number|Long} networkActiveDuration
     * @memberof IpLayerNetworkBucket
     * @instance
     */
    IpLayerNetworkBucket.prototype.networkActiveDuration = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

    /**
     * Creates a new IpLayerNetworkBucket instance using the specified properties.
     * @function create
     * @memberof IpLayerNetworkBucket
     * @static
     * @param {IIpLayerNetworkBucket=} [properties] Properties to set
     * @returns {IpLayerNetworkBucket} IpLayerNetworkBucket instance
     */
    IpLayerNetworkBucket.create = function create(properties) {
        return new IpLayerNetworkBucket(properties);
    };

    /**
     * Encodes the specified IpLayerNetworkBucket message. Does not implicitly {@link IpLayerNetworkBucket.verify|verify} messages.
     * @function encode
     * @memberof IpLayerNetworkBucket
     * @static
     * @param {IIpLayerNetworkBucket} message IpLayerNetworkBucket message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    IpLayerNetworkBucket.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.bucketStartMsec != null && Object.hasOwnProperty.call(message, "bucketStartMsec"))
            writer.uint32(/* id 1, wireType 0 =*/8).int64(message.bucketStartMsec);
        if (message.bucketDurationMsec != null && Object.hasOwnProperty.call(message, "bucketDurationMsec"))
            writer.uint32(/* id 2, wireType 0 =*/16).int64(message.bucketDurationMsec);
        if (message.statCounters != null && message.statCounters.length)
            for (var i = 0; i < message.statCounters.length; ++i)
                $root.StatCounters.encode(message.statCounters[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
        if (message.networkActiveDuration != null && Object.hasOwnProperty.call(message, "networkActiveDuration"))
            writer.uint32(/* id 4, wireType 0 =*/32).int64(message.networkActiveDuration);
        return writer;
    };

    /**
     * Encodes the specified IpLayerNetworkBucket message, length delimited. Does not implicitly {@link IpLayerNetworkBucket.verify|verify} messages.
     * @function encodeDelimited
     * @memberof IpLayerNetworkBucket
     * @static
     * @param {IIpLayerNetworkBucket} message IpLayerNetworkBucket message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    IpLayerNetworkBucket.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes an IpLayerNetworkBucket message from the specified reader or buffer.
     * @function decode
     * @memberof IpLayerNetworkBucket
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {IpLayerNetworkBucket} IpLayerNetworkBucket
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    IpLayerNetworkBucket.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.IpLayerNetworkBucket();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.bucketStartMsec = reader.int64();
                break;
            case 2:
                message.bucketDurationMsec = reader.int64();
                break;
            case 3:
                if (!(message.statCounters && message.statCounters.length))
                    message.statCounters = [];
                message.statCounters.push($root.StatCounters.decode(reader, reader.uint32()));
                break;
            case 4:
                message.networkActiveDuration = reader.int64();
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes an IpLayerNetworkBucket message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof IpLayerNetworkBucket
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {IpLayerNetworkBucket} IpLayerNetworkBucket
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    IpLayerNetworkBucket.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies an IpLayerNetworkBucket message.
     * @function verify
     * @memberof IpLayerNetworkBucket
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    IpLayerNetworkBucket.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.bucketStartMsec != null && message.hasOwnProperty("bucketStartMsec"))
            if (!$util.isInteger(message.bucketStartMsec) && !(message.bucketStartMsec && $util.isInteger(message.bucketStartMsec.low) && $util.isInteger(message.bucketStartMsec.high)))
                return "bucketStartMsec: integer|Long expected";
        if (message.bucketDurationMsec != null && message.hasOwnProperty("bucketDurationMsec"))
            if (!$util.isInteger(message.bucketDurationMsec) && !(message.bucketDurationMsec && $util.isInteger(message.bucketDurationMsec.low) && $util.isInteger(message.bucketDurationMsec.high)))
                return "bucketDurationMsec: integer|Long expected";
        if (message.statCounters != null && message.hasOwnProperty("statCounters")) {
            if (!Array.isArray(message.statCounters))
                return "statCounters: array expected";
            for (var i = 0; i < message.statCounters.length; ++i) {
                var error = $root.StatCounters.verify(message.statCounters[i]);
                if (error)
                    return "statCounters." + error;
            }
        }
        if (message.networkActiveDuration != null && message.hasOwnProperty("networkActiveDuration"))
            if (!$util.isInteger(message.networkActiveDuration) && !(message.networkActiveDuration && $util.isInteger(message.networkActiveDuration.low) && $util.isInteger(message.networkActiveDuration.high)))
                return "networkActiveDuration: integer|Long expected";
        return null;
    };

    /**
     * Creates an IpLayerNetworkBucket message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof IpLayerNetworkBucket
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {IpLayerNetworkBucket} IpLayerNetworkBucket
     */
    IpLayerNetworkBucket.fromObject = function fromObject(object) {
        if (object instanceof $root.IpLayerNetworkBucket)
            return object;
        var message = new $root.IpLayerNetworkBucket();
        if (object.bucketStartMsec != null)
            if ($util.Long)
                (message.bucketStartMsec = $util.Long.fromValue(object.bucketStartMsec)).unsigned = false;
            else if (typeof object.bucketStartMsec === "string")
                message.bucketStartMsec = parseInt(object.bucketStartMsec, 10);
            else if (typeof object.bucketStartMsec === "number")
                message.bucketStartMsec = object.bucketStartMsec;
            else if (typeof object.bucketStartMsec === "object")
                message.bucketStartMsec = new $util.LongBits(object.bucketStartMsec.low >>> 0, object.bucketStartMsec.high >>> 0).toNumber();
        if (object.bucketDurationMsec != null)
            if ($util.Long)
                (message.bucketDurationMsec = $util.Long.fromValue(object.bucketDurationMsec)).unsigned = false;
            else if (typeof object.bucketDurationMsec === "string")
                message.bucketDurationMsec = parseInt(object.bucketDurationMsec, 10);
            else if (typeof object.bucketDurationMsec === "number")
                message.bucketDurationMsec = object.bucketDurationMsec;
            else if (typeof object.bucketDurationMsec === "object")
                message.bucketDurationMsec = new $util.LongBits(object.bucketDurationMsec.low >>> 0, object.bucketDurationMsec.high >>> 0).toNumber();
        if (object.statCounters) {
            if (!Array.isArray(object.statCounters))
                throw TypeError(".IpLayerNetworkBucket.statCounters: array expected");
            message.statCounters = [];
            for (var i = 0; i < object.statCounters.length; ++i) {
                if (typeof object.statCounters[i] !== "object")
                    throw TypeError(".IpLayerNetworkBucket.statCounters: object expected");
                message.statCounters[i] = $root.StatCounters.fromObject(object.statCounters[i]);
            }
        }
        if (object.networkActiveDuration != null)
            if ($util.Long)
                (message.networkActiveDuration = $util.Long.fromValue(object.networkActiveDuration)).unsigned = false;
            else if (typeof object.networkActiveDuration === "string")
                message.networkActiveDuration = parseInt(object.networkActiveDuration, 10);
            else if (typeof object.networkActiveDuration === "number")
                message.networkActiveDuration = object.networkActiveDuration;
            else if (typeof object.networkActiveDuration === "object")
                message.networkActiveDuration = new $util.LongBits(object.networkActiveDuration.low >>> 0, object.networkActiveDuration.high >>> 0).toNumber();
        return message;
    };

    /**
     * Creates a plain object from an IpLayerNetworkBucket message. Also converts values to other types if specified.
     * @function toObject
     * @memberof IpLayerNetworkBucket
     * @static
     * @param {IpLayerNetworkBucket} message IpLayerNetworkBucket
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    IpLayerNetworkBucket.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        var object = {};
        if (options.arrays || options.defaults)
            object.statCounters = [];
        if (options.defaults) {
            if ($util.Long) {
                var long = new $util.Long(0, 0, false);
                object.bucketStartMsec = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
            } else
                object.bucketStartMsec = options.longs === String ? "0" : 0;
            if ($util.Long) {
                var long = new $util.Long(0, 0, false);
                object.bucketDurationMsec = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
            } else
                object.bucketDurationMsec = options.longs === String ? "0" : 0;
            if ($util.Long) {
                var long = new $util.Long(0, 0, false);
                object.networkActiveDuration = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
            } else
                object.networkActiveDuration = options.longs === String ? "0" : 0;
        }
        if (message.bucketStartMsec != null && message.hasOwnProperty("bucketStartMsec"))
            if (typeof message.bucketStartMsec === "number")
                object.bucketStartMsec = options.longs === String ? String(message.bucketStartMsec) : message.bucketStartMsec;
            else
                object.bucketStartMsec = options.longs === String ? $util.Long.prototype.toString.call(message.bucketStartMsec) : options.longs === Number ? new $util.LongBits(message.bucketStartMsec.low >>> 0, message.bucketStartMsec.high >>> 0).toNumber() : message.bucketStartMsec;
        if (message.bucketDurationMsec != null && message.hasOwnProperty("bucketDurationMsec"))
            if (typeof message.bucketDurationMsec === "number")
                object.bucketDurationMsec = options.longs === String ? String(message.bucketDurationMsec) : message.bucketDurationMsec;
            else
                object.bucketDurationMsec = options.longs === String ? $util.Long.prototype.toString.call(message.bucketDurationMsec) : options.longs === Number ? new $util.LongBits(message.bucketDurationMsec.low >>> 0, message.bucketDurationMsec.high >>> 0).toNumber() : message.bucketDurationMsec;
        if (message.statCounters && message.statCounters.length) {
            object.statCounters = [];
            for (var j = 0; j < message.statCounters.length; ++j)
                object.statCounters[j] = $root.StatCounters.toObject(message.statCounters[j], options);
        }
        if (message.networkActiveDuration != null && message.hasOwnProperty("networkActiveDuration"))
            if (typeof message.networkActiveDuration === "number")
                object.networkActiveDuration = options.longs === String ? String(message.networkActiveDuration) : message.networkActiveDuration;
            else
                object.networkActiveDuration = options.longs === String ? $util.Long.prototype.toString.call(message.networkActiveDuration) : options.longs === Number ? new $util.LongBits(message.networkActiveDuration.low >>> 0, message.networkActiveDuration.high >>> 0).toNumber() : message.networkActiveDuration;
        return object;
    };

    /**
     * Converts this IpLayerNetworkBucket to JSON.
     * @function toJSON
     * @memberof IpLayerNetworkBucket
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    IpLayerNetworkBucket.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return IpLayerNetworkBucket;
})();

$root.IpLayerNetworkStat = (function() {

    /**
     * Properties of an IpLayerNetworkStat.
     * @exports IIpLayerNetworkStat
     * @interface IIpLayerNetworkStat
     * @property {string|null} [networkDetails] IpLayerNetworkStat networkDetails
     * @property {number|null} [type] IpLayerNetworkStat type
     * @property {Array.<IIpLayerNetworkBucket>|null} [ipLayerNetworkBucket] IpLayerNetworkStat ipLayerNetworkBucket
     * @property {Array.<IIpLayerAppStat>|null} [ipLayerAppStat] IpLayerNetworkStat ipLayerAppStat
     */

    /**
     * Constructs a new IpLayerNetworkStat.
     * @exports IpLayerNetworkStat
     * @classdesc Represents an IpLayerNetworkStat.
     * @implements IIpLayerNetworkStat
     * @constructor
     * @param {IIpLayerNetworkStat=} [properties] Properties to set
     */
    function IpLayerNetworkStat(properties) {
        this.ipLayerNetworkBucket = [];
        this.ipLayerAppStat = [];
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * IpLayerNetworkStat networkDetails.
     * @member {string} networkDetails
     * @memberof IpLayerNetworkStat
     * @instance
     */
    IpLayerNetworkStat.prototype.networkDetails = "";

    /**
     * IpLayerNetworkStat type.
     * @member {number} type
     * @memberof IpLayerNetworkStat
     * @instance
     */
    IpLayerNetworkStat.prototype.type = 0;

    /**
     * IpLayerNetworkStat ipLayerNetworkBucket.
     * @member {Array.<IIpLayerNetworkBucket>} ipLayerNetworkBucket
     * @memberof IpLayerNetworkStat
     * @instance
     */
    IpLayerNetworkStat.prototype.ipLayerNetworkBucket = $util.emptyArray;

    /**
     * IpLayerNetworkStat ipLayerAppStat.
     * @member {Array.<IIpLayerAppStat>} ipLayerAppStat
     * @memberof IpLayerNetworkStat
     * @instance
     */
    IpLayerNetworkStat.prototype.ipLayerAppStat = $util.emptyArray;

    /**
     * Creates a new IpLayerNetworkStat instance using the specified properties.
     * @function create
     * @memberof IpLayerNetworkStat
     * @static
     * @param {IIpLayerNetworkStat=} [properties] Properties to set
     * @returns {IpLayerNetworkStat} IpLayerNetworkStat instance
     */
    IpLayerNetworkStat.create = function create(properties) {
        return new IpLayerNetworkStat(properties);
    };

    /**
     * Encodes the specified IpLayerNetworkStat message. Does not implicitly {@link IpLayerNetworkStat.verify|verify} messages.
     * @function encode
     * @memberof IpLayerNetworkStat
     * @static
     * @param {IIpLayerNetworkStat} message IpLayerNetworkStat message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    IpLayerNetworkStat.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.networkDetails != null && Object.hasOwnProperty.call(message, "networkDetails"))
            writer.uint32(/* id 1, wireType 2 =*/10).string(message.networkDetails);
        if (message.type != null && Object.hasOwnProperty.call(message, "type"))
            writer.uint32(/* id 2, wireType 0 =*/16).int32(message.type);
        if (message.ipLayerNetworkBucket != null && message.ipLayerNetworkBucket.length)
            for (var i = 0; i < message.ipLayerNetworkBucket.length; ++i)
                $root.IpLayerNetworkBucket.encode(message.ipLayerNetworkBucket[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
        if (message.ipLayerAppStat != null && message.ipLayerAppStat.length)
            for (var i = 0; i < message.ipLayerAppStat.length; ++i)
                $root.IpLayerAppStat.encode(message.ipLayerAppStat[i], writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
        return writer;
    };

    /**
     * Encodes the specified IpLayerNetworkStat message, length delimited. Does not implicitly {@link IpLayerNetworkStat.verify|verify} messages.
     * @function encodeDelimited
     * @memberof IpLayerNetworkStat
     * @static
     * @param {IIpLayerNetworkStat} message IpLayerNetworkStat message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    IpLayerNetworkStat.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes an IpLayerNetworkStat message from the specified reader or buffer.
     * @function decode
     * @memberof IpLayerNetworkStat
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {IpLayerNetworkStat} IpLayerNetworkStat
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    IpLayerNetworkStat.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.IpLayerNetworkStat();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.networkDetails = reader.string();
                break;
            case 2:
                message.type = reader.int32();
                break;
            case 3:
                if (!(message.ipLayerNetworkBucket && message.ipLayerNetworkBucket.length))
                    message.ipLayerNetworkBucket = [];
                message.ipLayerNetworkBucket.push($root.IpLayerNetworkBucket.decode(reader, reader.uint32()));
                break;
            case 4:
                if (!(message.ipLayerAppStat && message.ipLayerAppStat.length))
                    message.ipLayerAppStat = [];
                message.ipLayerAppStat.push($root.IpLayerAppStat.decode(reader, reader.uint32()));
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes an IpLayerNetworkStat message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof IpLayerNetworkStat
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {IpLayerNetworkStat} IpLayerNetworkStat
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    IpLayerNetworkStat.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies an IpLayerNetworkStat message.
     * @function verify
     * @memberof IpLayerNetworkStat
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    IpLayerNetworkStat.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.networkDetails != null && message.hasOwnProperty("networkDetails"))
            if (!$util.isString(message.networkDetails))
                return "networkDetails: string expected";
        if (message.type != null && message.hasOwnProperty("type"))
            if (!$util.isInteger(message.type))
                return "type: integer expected";
        if (message.ipLayerNetworkBucket != null && message.hasOwnProperty("ipLayerNetworkBucket")) {
            if (!Array.isArray(message.ipLayerNetworkBucket))
                return "ipLayerNetworkBucket: array expected";
            for (var i = 0; i < message.ipLayerNetworkBucket.length; ++i) {
                var error = $root.IpLayerNetworkBucket.verify(message.ipLayerNetworkBucket[i]);
                if (error)
                    return "ipLayerNetworkBucket." + error;
            }
        }
        if (message.ipLayerAppStat != null && message.hasOwnProperty("ipLayerAppStat")) {
            if (!Array.isArray(message.ipLayerAppStat))
                return "ipLayerAppStat: array expected";
            for (var i = 0; i < message.ipLayerAppStat.length; ++i) {
                var error = $root.IpLayerAppStat.verify(message.ipLayerAppStat[i]);
                if (error)
                    return "ipLayerAppStat." + error;
            }
        }
        return null;
    };

    /**
     * Creates an IpLayerNetworkStat message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof IpLayerNetworkStat
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {IpLayerNetworkStat} IpLayerNetworkStat
     */
    IpLayerNetworkStat.fromObject = function fromObject(object) {
        if (object instanceof $root.IpLayerNetworkStat)
            return object;
        var message = new $root.IpLayerNetworkStat();
        if (object.networkDetails != null)
            message.networkDetails = String(object.networkDetails);
        if (object.type != null)
            message.type = object.type | 0;
        if (object.ipLayerNetworkBucket) {
            if (!Array.isArray(object.ipLayerNetworkBucket))
                throw TypeError(".IpLayerNetworkStat.ipLayerNetworkBucket: array expected");
            message.ipLayerNetworkBucket = [];
            for (var i = 0; i < object.ipLayerNetworkBucket.length; ++i) {
                if (typeof object.ipLayerNetworkBucket[i] !== "object")
                    throw TypeError(".IpLayerNetworkStat.ipLayerNetworkBucket: object expected");
                message.ipLayerNetworkBucket[i] = $root.IpLayerNetworkBucket.fromObject(object.ipLayerNetworkBucket[i]);
            }
        }
        if (object.ipLayerAppStat) {
            if (!Array.isArray(object.ipLayerAppStat))
                throw TypeError(".IpLayerNetworkStat.ipLayerAppStat: array expected");
            message.ipLayerAppStat = [];
            for (var i = 0; i < object.ipLayerAppStat.length; ++i) {
                if (typeof object.ipLayerAppStat[i] !== "object")
                    throw TypeError(".IpLayerNetworkStat.ipLayerAppStat: object expected");
                message.ipLayerAppStat[i] = $root.IpLayerAppStat.fromObject(object.ipLayerAppStat[i]);
            }
        }
        return message;
    };

    /**
     * Creates a plain object from an IpLayerNetworkStat message. Also converts values to other types if specified.
     * @function toObject
     * @memberof IpLayerNetworkStat
     * @static
     * @param {IpLayerNetworkStat} message IpLayerNetworkStat
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    IpLayerNetworkStat.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        var object = {};
        if (options.arrays || options.defaults) {
            object.ipLayerNetworkBucket = [];
            object.ipLayerAppStat = [];
        }
        if (options.defaults) {
            object.networkDetails = "";
            object.type = 0;
        }
        if (message.networkDetails != null && message.hasOwnProperty("networkDetails"))
            object.networkDetails = message.networkDetails;
        if (message.type != null && message.hasOwnProperty("type"))
            object.type = message.type;
        if (message.ipLayerNetworkBucket && message.ipLayerNetworkBucket.length) {
            object.ipLayerNetworkBucket = [];
            for (var j = 0; j < message.ipLayerNetworkBucket.length; ++j)
                object.ipLayerNetworkBucket[j] = $root.IpLayerNetworkBucket.toObject(message.ipLayerNetworkBucket[j], options);
        }
        if (message.ipLayerAppStat && message.ipLayerAppStat.length) {
            object.ipLayerAppStat = [];
            for (var j = 0; j < message.ipLayerAppStat.length; ++j)
                object.ipLayerAppStat[j] = $root.IpLayerAppStat.toObject(message.ipLayerAppStat[j], options);
        }
        return object;
    };

    /**
     * Converts this IpLayerNetworkStat to JSON.
     * @function toJSON
     * @memberof IpLayerNetworkStat
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    IpLayerNetworkStat.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return IpLayerNetworkStat;
})();

$root.KeyToPackageNameMapping = (function() {

    /**
     * Properties of a KeyToPackageNameMapping.
     * @exports IKeyToPackageNameMapping
     * @interface IKeyToPackageNameMapping
     * @property {number|null} [packageKey] KeyToPackageNameMapping packageKey
     * @property {string|null} [uidName] KeyToPackageNameMapping uidName
     * @property {Array.<IPackageInfo>|null} [sharedPackage] KeyToPackageNameMapping sharedPackage
     */

    /**
     * Constructs a new KeyToPackageNameMapping.
     * @exports KeyToPackageNameMapping
     * @classdesc Represents a KeyToPackageNameMapping.
     * @implements IKeyToPackageNameMapping
     * @constructor
     * @param {IKeyToPackageNameMapping=} [properties] Properties to set
     */
    function KeyToPackageNameMapping(properties) {
        this.sharedPackage = [];
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * KeyToPackageNameMapping packageKey.
     * @member {number} packageKey
     * @memberof KeyToPackageNameMapping
     * @instance
     */
    KeyToPackageNameMapping.prototype.packageKey = 0;

    /**
     * KeyToPackageNameMapping uidName.
     * @member {string} uidName
     * @memberof KeyToPackageNameMapping
     * @instance
     */
    KeyToPackageNameMapping.prototype.uidName = "";

    /**
     * KeyToPackageNameMapping sharedPackage.
     * @member {Array.<IPackageInfo>} sharedPackage
     * @memberof KeyToPackageNameMapping
     * @instance
     */
    KeyToPackageNameMapping.prototype.sharedPackage = $util.emptyArray;

    /**
     * Creates a new KeyToPackageNameMapping instance using the specified properties.
     * @function create
     * @memberof KeyToPackageNameMapping
     * @static
     * @param {IKeyToPackageNameMapping=} [properties] Properties to set
     * @returns {KeyToPackageNameMapping} KeyToPackageNameMapping instance
     */
    KeyToPackageNameMapping.create = function create(properties) {
        return new KeyToPackageNameMapping(properties);
    };

    /**
     * Encodes the specified KeyToPackageNameMapping message. Does not implicitly {@link KeyToPackageNameMapping.verify|verify} messages.
     * @function encode
     * @memberof KeyToPackageNameMapping
     * @static
     * @param {IKeyToPackageNameMapping} message KeyToPackageNameMapping message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    KeyToPackageNameMapping.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.packageKey != null && Object.hasOwnProperty.call(message, "packageKey"))
            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.packageKey);
        if (message.uidName != null && Object.hasOwnProperty.call(message, "uidName"))
            writer.uint32(/* id 2, wireType 2 =*/18).string(message.uidName);
        if (message.sharedPackage != null && message.sharedPackage.length)
            for (var i = 0; i < message.sharedPackage.length; ++i)
                $root.PackageInfo.encode(message.sharedPackage[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
        return writer;
    };

    /**
     * Encodes the specified KeyToPackageNameMapping message, length delimited. Does not implicitly {@link KeyToPackageNameMapping.verify|verify} messages.
     * @function encodeDelimited
     * @memberof KeyToPackageNameMapping
     * @static
     * @param {IKeyToPackageNameMapping} message KeyToPackageNameMapping message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    KeyToPackageNameMapping.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a KeyToPackageNameMapping message from the specified reader or buffer.
     * @function decode
     * @memberof KeyToPackageNameMapping
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {KeyToPackageNameMapping} KeyToPackageNameMapping
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    KeyToPackageNameMapping.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.KeyToPackageNameMapping();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.packageKey = reader.int32();
                break;
            case 2:
                message.uidName = reader.string();
                break;
            case 3:
                if (!(message.sharedPackage && message.sharedPackage.length))
                    message.sharedPackage = [];
                message.sharedPackage.push($root.PackageInfo.decode(reader, reader.uint32()));
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a KeyToPackageNameMapping message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof KeyToPackageNameMapping
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {KeyToPackageNameMapping} KeyToPackageNameMapping
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    KeyToPackageNameMapping.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a KeyToPackageNameMapping message.
     * @function verify
     * @memberof KeyToPackageNameMapping
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    KeyToPackageNameMapping.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.packageKey != null && message.hasOwnProperty("packageKey"))
            if (!$util.isInteger(message.packageKey))
                return "packageKey: integer expected";
        if (message.uidName != null && message.hasOwnProperty("uidName"))
            if (!$util.isString(message.uidName))
                return "uidName: string expected";
        if (message.sharedPackage != null && message.hasOwnProperty("sharedPackage")) {
            if (!Array.isArray(message.sharedPackage))
                return "sharedPackage: array expected";
            for (var i = 0; i < message.sharedPackage.length; ++i) {
                var error = $root.PackageInfo.verify(message.sharedPackage[i]);
                if (error)
                    return "sharedPackage." + error;
            }
        }
        return null;
    };

    /**
     * Creates a KeyToPackageNameMapping message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof KeyToPackageNameMapping
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {KeyToPackageNameMapping} KeyToPackageNameMapping
     */
    KeyToPackageNameMapping.fromObject = function fromObject(object) {
        if (object instanceof $root.KeyToPackageNameMapping)
            return object;
        var message = new $root.KeyToPackageNameMapping();
        if (object.packageKey != null)
            message.packageKey = object.packageKey | 0;
        if (object.uidName != null)
            message.uidName = String(object.uidName);
        if (object.sharedPackage) {
            if (!Array.isArray(object.sharedPackage))
                throw TypeError(".KeyToPackageNameMapping.sharedPackage: array expected");
            message.sharedPackage = [];
            for (var i = 0; i < object.sharedPackage.length; ++i) {
                if (typeof object.sharedPackage[i] !== "object")
                    throw TypeError(".KeyToPackageNameMapping.sharedPackage: object expected");
                message.sharedPackage[i] = $root.PackageInfo.fromObject(object.sharedPackage[i]);
            }
        }
        return message;
    };

    /**
     * Creates a plain object from a KeyToPackageNameMapping message. Also converts values to other types if specified.
     * @function toObject
     * @memberof KeyToPackageNameMapping
     * @static
     * @param {KeyToPackageNameMapping} message KeyToPackageNameMapping
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    KeyToPackageNameMapping.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        var object = {};
        if (options.arrays || options.defaults)
            object.sharedPackage = [];
        if (options.defaults) {
            object.packageKey = 0;
            object.uidName = "";
        }
        if (message.packageKey != null && message.hasOwnProperty("packageKey"))
            object.packageKey = message.packageKey;
        if (message.uidName != null && message.hasOwnProperty("uidName"))
            object.uidName = message.uidName;
        if (message.sharedPackage && message.sharedPackage.length) {
            object.sharedPackage = [];
            for (var j = 0; j < message.sharedPackage.length; ++j)
                object.sharedPackage[j] = $root.PackageInfo.toObject(message.sharedPackage[j], options);
        }
        return object;
    };

    /**
     * Converts this KeyToPackageNameMapping to JSON.
     * @function toJSON
     * @memberof KeyToPackageNameMapping
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    KeyToPackageNameMapping.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return KeyToPackageNameMapping;
})();

$root.PackageInfo = (function() {

    /**
     * Properties of a PackageInfo.
     * @exports IPackageInfo
     * @interface IPackageInfo
     * @property {string|null} [pkgName] PackageInfo pkgName
     * @property {number|null} [versionCode] PackageInfo versionCode
     */

    /**
     * Constructs a new PackageInfo.
     * @exports PackageInfo
     * @classdesc Represents a PackageInfo.
     * @implements IPackageInfo
     * @constructor
     * @param {IPackageInfo=} [properties] Properties to set
     */
    function PackageInfo(properties) {
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * PackageInfo pkgName.
     * @member {string} pkgName
     * @memberof PackageInfo
     * @instance
     */
    PackageInfo.prototype.pkgName = "";

    /**
     * PackageInfo versionCode.
     * @member {number} versionCode
     * @memberof PackageInfo
     * @instance
     */
    PackageInfo.prototype.versionCode = 0;

    /**
     * Creates a new PackageInfo instance using the specified properties.
     * @function create
     * @memberof PackageInfo
     * @static
     * @param {IPackageInfo=} [properties] Properties to set
     * @returns {PackageInfo} PackageInfo instance
     */
    PackageInfo.create = function create(properties) {
        return new PackageInfo(properties);
    };

    /**
     * Encodes the specified PackageInfo message. Does not implicitly {@link PackageInfo.verify|verify} messages.
     * @function encode
     * @memberof PackageInfo
     * @static
     * @param {IPackageInfo} message PackageInfo message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    PackageInfo.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.pkgName != null && Object.hasOwnProperty.call(message, "pkgName"))
            writer.uint32(/* id 1, wireType 2 =*/10).string(message.pkgName);
        if (message.versionCode != null && Object.hasOwnProperty.call(message, "versionCode"))
            writer.uint32(/* id 2, wireType 0 =*/16).int32(message.versionCode);
        return writer;
    };

    /**
     * Encodes the specified PackageInfo message, length delimited. Does not implicitly {@link PackageInfo.verify|verify} messages.
     * @function encodeDelimited
     * @memberof PackageInfo
     * @static
     * @param {IPackageInfo} message PackageInfo message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    PackageInfo.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a PackageInfo message from the specified reader or buffer.
     * @function decode
     * @memberof PackageInfo
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {PackageInfo} PackageInfo
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    PackageInfo.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.PackageInfo();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.pkgName = reader.string();
                break;
            case 2:
                message.versionCode = reader.int32();
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a PackageInfo message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof PackageInfo
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {PackageInfo} PackageInfo
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    PackageInfo.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a PackageInfo message.
     * @function verify
     * @memberof PackageInfo
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    PackageInfo.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.pkgName != null && message.hasOwnProperty("pkgName"))
            if (!$util.isString(message.pkgName))
                return "pkgName: string expected";
        if (message.versionCode != null && message.hasOwnProperty("versionCode"))
            if (!$util.isInteger(message.versionCode))
                return "versionCode: integer expected";
        return null;
    };

    /**
     * Creates a PackageInfo message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof PackageInfo
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {PackageInfo} PackageInfo
     */
    PackageInfo.fromObject = function fromObject(object) {
        if (object instanceof $root.PackageInfo)
            return object;
        var message = new $root.PackageInfo();
        if (object.pkgName != null)
            message.pkgName = String(object.pkgName);
        if (object.versionCode != null)
            message.versionCode = object.versionCode | 0;
        return message;
    };

    /**
     * Creates a plain object from a PackageInfo message. Also converts values to other types if specified.
     * @function toObject
     * @memberof PackageInfo
     * @static
     * @param {PackageInfo} message PackageInfo
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    PackageInfo.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        var object = {};
        if (options.defaults) {
            object.pkgName = "";
            object.versionCode = 0;
        }
        if (message.pkgName != null && message.hasOwnProperty("pkgName"))
            object.pkgName = message.pkgName;
        if (message.versionCode != null && message.hasOwnProperty("versionCode"))
            object.versionCode = message.versionCode;
        return object;
    };

    /**
     * Converts this PackageInfo to JSON.
     * @function toJSON
     * @memberof PackageInfo
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    PackageInfo.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return PackageInfo;
})();

$root.PayloadLevelAppStat = (function() {

    /**
     * Properties of a PayloadLevelAppStat.
     * @exports IPayloadLevelAppStat
     * @interface IPayloadLevelAppStat
     * @property {number|null} [packageKey] PayloadLevelAppStat packageKey
     * @property {number|null} [applicationTag] PayloadLevelAppStat applicationTag
     * @property {Array.<IAppBucket>|null} [payloadLevelAppBucket] PayloadLevelAppStat payloadLevelAppBucket
     */

    /**
     * Constructs a new PayloadLevelAppStat.
     * @exports PayloadLevelAppStat
     * @classdesc Represents a PayloadLevelAppStat.
     * @implements IPayloadLevelAppStat
     * @constructor
     * @param {IPayloadLevelAppStat=} [properties] Properties to set
     */
    function PayloadLevelAppStat(properties) {
        this.payloadLevelAppBucket = [];
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * PayloadLevelAppStat packageKey.
     * @member {number} packageKey
     * @memberof PayloadLevelAppStat
     * @instance
     */
    PayloadLevelAppStat.prototype.packageKey = 0;

    /**
     * PayloadLevelAppStat applicationTag.
     * @member {number} applicationTag
     * @memberof PayloadLevelAppStat
     * @instance
     */
    PayloadLevelAppStat.prototype.applicationTag = 0;

    /**
     * PayloadLevelAppStat payloadLevelAppBucket.
     * @member {Array.<IAppBucket>} payloadLevelAppBucket
     * @memberof PayloadLevelAppStat
     * @instance
     */
    PayloadLevelAppStat.prototype.payloadLevelAppBucket = $util.emptyArray;

    /**
     * Creates a new PayloadLevelAppStat instance using the specified properties.
     * @function create
     * @memberof PayloadLevelAppStat
     * @static
     * @param {IPayloadLevelAppStat=} [properties] Properties to set
     * @returns {PayloadLevelAppStat} PayloadLevelAppStat instance
     */
    PayloadLevelAppStat.create = function create(properties) {
        return new PayloadLevelAppStat(properties);
    };

    /**
     * Encodes the specified PayloadLevelAppStat message. Does not implicitly {@link PayloadLevelAppStat.verify|verify} messages.
     * @function encode
     * @memberof PayloadLevelAppStat
     * @static
     * @param {IPayloadLevelAppStat} message PayloadLevelAppStat message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    PayloadLevelAppStat.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.packageKey != null && Object.hasOwnProperty.call(message, "packageKey"))
            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.packageKey);
        if (message.applicationTag != null && Object.hasOwnProperty.call(message, "applicationTag"))
            writer.uint32(/* id 2, wireType 0 =*/16).int32(message.applicationTag);
        if (message.payloadLevelAppBucket != null && message.payloadLevelAppBucket.length)
            for (var i = 0; i < message.payloadLevelAppBucket.length; ++i)
                $root.AppBucket.encode(message.payloadLevelAppBucket[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
        return writer;
    };

    /**
     * Encodes the specified PayloadLevelAppStat message, length delimited. Does not implicitly {@link PayloadLevelAppStat.verify|verify} messages.
     * @function encodeDelimited
     * @memberof PayloadLevelAppStat
     * @static
     * @param {IPayloadLevelAppStat} message PayloadLevelAppStat message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    PayloadLevelAppStat.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a PayloadLevelAppStat message from the specified reader or buffer.
     * @function decode
     * @memberof PayloadLevelAppStat
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {PayloadLevelAppStat} PayloadLevelAppStat
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    PayloadLevelAppStat.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.PayloadLevelAppStat();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.packageKey = reader.int32();
                break;
            case 2:
                message.applicationTag = reader.int32();
                break;
            case 3:
                if (!(message.payloadLevelAppBucket && message.payloadLevelAppBucket.length))
                    message.payloadLevelAppBucket = [];
                message.payloadLevelAppBucket.push($root.AppBucket.decode(reader, reader.uint32()));
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a PayloadLevelAppStat message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof PayloadLevelAppStat
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {PayloadLevelAppStat} PayloadLevelAppStat
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    PayloadLevelAppStat.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a PayloadLevelAppStat message.
     * @function verify
     * @memberof PayloadLevelAppStat
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    PayloadLevelAppStat.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.packageKey != null && message.hasOwnProperty("packageKey"))
            if (!$util.isInteger(message.packageKey))
                return "packageKey: integer expected";
        if (message.applicationTag != null && message.hasOwnProperty("applicationTag"))
            if (!$util.isInteger(message.applicationTag))
                return "applicationTag: integer expected";
        if (message.payloadLevelAppBucket != null && message.hasOwnProperty("payloadLevelAppBucket")) {
            if (!Array.isArray(message.payloadLevelAppBucket))
                return "payloadLevelAppBucket: array expected";
            for (var i = 0; i < message.payloadLevelAppBucket.length; ++i) {
                var error = $root.AppBucket.verify(message.payloadLevelAppBucket[i]);
                if (error)
                    return "payloadLevelAppBucket." + error;
            }
        }
        return null;
    };

    /**
     * Creates a PayloadLevelAppStat message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof PayloadLevelAppStat
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {PayloadLevelAppStat} PayloadLevelAppStat
     */
    PayloadLevelAppStat.fromObject = function fromObject(object) {
        if (object instanceof $root.PayloadLevelAppStat)
            return object;
        var message = new $root.PayloadLevelAppStat();
        if (object.packageKey != null)
            message.packageKey = object.packageKey | 0;
        if (object.applicationTag != null)
            message.applicationTag = object.applicationTag | 0;
        if (object.payloadLevelAppBucket) {
            if (!Array.isArray(object.payloadLevelAppBucket))
                throw TypeError(".PayloadLevelAppStat.payloadLevelAppBucket: array expected");
            message.payloadLevelAppBucket = [];
            for (var i = 0; i < object.payloadLevelAppBucket.length; ++i) {
                if (typeof object.payloadLevelAppBucket[i] !== "object")
                    throw TypeError(".PayloadLevelAppStat.payloadLevelAppBucket: object expected");
                message.payloadLevelAppBucket[i] = $root.AppBucket.fromObject(object.payloadLevelAppBucket[i]);
            }
        }
        return message;
    };

    /**
     * Creates a plain object from a PayloadLevelAppStat message. Also converts values to other types if specified.
     * @function toObject
     * @memberof PayloadLevelAppStat
     * @static
     * @param {PayloadLevelAppStat} message PayloadLevelAppStat
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    PayloadLevelAppStat.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        var object = {};
        if (options.arrays || options.defaults)
            object.payloadLevelAppBucket = [];
        if (options.defaults) {
            object.packageKey = 0;
            object.applicationTag = 0;
        }
        if (message.packageKey != null && message.hasOwnProperty("packageKey"))
            object.packageKey = message.packageKey;
        if (message.applicationTag != null && message.hasOwnProperty("applicationTag"))
            object.applicationTag = message.applicationTag;
        if (message.payloadLevelAppBucket && message.payloadLevelAppBucket.length) {
            object.payloadLevelAppBucket = [];
            for (var j = 0; j < message.payloadLevelAppBucket.length; ++j)
                object.payloadLevelAppBucket[j] = $root.AppBucket.toObject(message.payloadLevelAppBucket[j], options);
        }
        return object;
    };

    /**
     * Converts this PayloadLevelAppStat to JSON.
     * @function toJSON
     * @memberof PayloadLevelAppStat
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    PayloadLevelAppStat.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return PayloadLevelAppStat;
})();

$root.StatCounters = (function() {

    /**
     * Properties of a StatCounters.
     * @exports IStatCounters
     * @interface IStatCounters
     * @property {number|null} [networkProto] StatCounters networkProto
     * @property {number|null} [direction] StatCounters direction
     * @property {ICounterData|null} [counterData] StatCounters counterData
     * @property {number|null} [fgBg] StatCounters fgBg
     */

    /**
     * Constructs a new StatCounters.
     * @exports StatCounters
     * @classdesc Represents a StatCounters.
     * @implements IStatCounters
     * @constructor
     * @param {IStatCounters=} [properties] Properties to set
     */
    function StatCounters(properties) {
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * StatCounters networkProto.
     * @member {number} networkProto
     * @memberof StatCounters
     * @instance
     */
    StatCounters.prototype.networkProto = 0;

    /**
     * StatCounters direction.
     * @member {number} direction
     * @memberof StatCounters
     * @instance
     */
    StatCounters.prototype.direction = 0;

    /**
     * StatCounters counterData.
     * @member {ICounterData|null|undefined} counterData
     * @memberof StatCounters
     * @instance
     */
    StatCounters.prototype.counterData = null;

    /**
     * StatCounters fgBg.
     * @member {number} fgBg
     * @memberof StatCounters
     * @instance
     */
    StatCounters.prototype.fgBg = 0;

    /**
     * Creates a new StatCounters instance using the specified properties.
     * @function create
     * @memberof StatCounters
     * @static
     * @param {IStatCounters=} [properties] Properties to set
     * @returns {StatCounters} StatCounters instance
     */
    StatCounters.create = function create(properties) {
        return new StatCounters(properties);
    };

    /**
     * Encodes the specified StatCounters message. Does not implicitly {@link StatCounters.verify|verify} messages.
     * @function encode
     * @memberof StatCounters
     * @static
     * @param {IStatCounters} message StatCounters message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    StatCounters.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.networkProto != null && Object.hasOwnProperty.call(message, "networkProto"))
            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.networkProto);
        if (message.direction != null && Object.hasOwnProperty.call(message, "direction"))
            writer.uint32(/* id 2, wireType 0 =*/16).int32(message.direction);
        if (message.counterData != null && Object.hasOwnProperty.call(message, "counterData"))
            $root.CounterData.encode(message.counterData, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
        if (message.fgBg != null && Object.hasOwnProperty.call(message, "fgBg"))
            writer.uint32(/* id 4, wireType 0 =*/32).int32(message.fgBg);
        return writer;
    };

    /**
     * Encodes the specified StatCounters message, length delimited. Does not implicitly {@link StatCounters.verify|verify} messages.
     * @function encodeDelimited
     * @memberof StatCounters
     * @static
     * @param {IStatCounters} message StatCounters message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    StatCounters.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a StatCounters message from the specified reader or buffer.
     * @function decode
     * @memberof StatCounters
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {StatCounters} StatCounters
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    StatCounters.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.StatCounters();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.networkProto = reader.int32();
                break;
            case 2:
                message.direction = reader.int32();
                break;
            case 3:
                message.counterData = $root.CounterData.decode(reader, reader.uint32());
                break;
            case 4:
                message.fgBg = reader.int32();
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a StatCounters message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof StatCounters
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {StatCounters} StatCounters
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    StatCounters.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a StatCounters message.
     * @function verify
     * @memberof StatCounters
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    StatCounters.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.networkProto != null && message.hasOwnProperty("networkProto"))
            if (!$util.isInteger(message.networkProto))
                return "networkProto: integer expected";
        if (message.direction != null && message.hasOwnProperty("direction"))
            if (!$util.isInteger(message.direction))
                return "direction: integer expected";
        if (message.counterData != null && message.hasOwnProperty("counterData")) {
            var error = $root.CounterData.verify(message.counterData);
            if (error)
                return "counterData." + error;
        }
        if (message.fgBg != null && message.hasOwnProperty("fgBg"))
            if (!$util.isInteger(message.fgBg))
                return "fgBg: integer expected";
        return null;
    };

    /**
     * Creates a StatCounters message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof StatCounters
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {StatCounters} StatCounters
     */
    StatCounters.fromObject = function fromObject(object) {
        if (object instanceof $root.StatCounters)
            return object;
        var message = new $root.StatCounters();
        if (object.networkProto != null)
            message.networkProto = object.networkProto | 0;
        if (object.direction != null)
            message.direction = object.direction | 0;
        if (object.counterData != null) {
            if (typeof object.counterData !== "object")
                throw TypeError(".StatCounters.counterData: object expected");
            message.counterData = $root.CounterData.fromObject(object.counterData);
        }
        if (object.fgBg != null)
            message.fgBg = object.fgBg | 0;
        return message;
    };

    /**
     * Creates a plain object from a StatCounters message. Also converts values to other types if specified.
     * @function toObject
     * @memberof StatCounters
     * @static
     * @param {StatCounters} message StatCounters
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    StatCounters.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        var object = {};
        if (options.defaults) {
            object.networkProto = 0;
            object.direction = 0;
            object.counterData = null;
            object.fgBg = 0;
        }
        if (message.networkProto != null && message.hasOwnProperty("networkProto"))
            object.networkProto = message.networkProto;
        if (message.direction != null && message.hasOwnProperty("direction"))
            object.direction = message.direction;
        if (message.counterData != null && message.hasOwnProperty("counterData"))
            object.counterData = $root.CounterData.toObject(message.counterData, options);
        if (message.fgBg != null && message.hasOwnProperty("fgBg"))
            object.fgBg = message.fgBg;
        return object;
    };

    /**
     * Converts this StatCounters to JSON.
     * @function toJSON
     * @memberof StatCounters
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    StatCounters.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return StatCounters;
})();

$root.UsageStatsExtensionProto = (function() {

    /**
     * Properties of a UsageStatsExtensionProto.
     * @exports IUsageStatsExtensionProto
     * @interface IUsageStatsExtensionProto
     * @property {IAndroidDataUsageProto|null} [dataUsage] UsageStatsExtensionProto dataUsage
     */

    /**
     * Constructs a new UsageStatsExtensionProto.
     * @exports UsageStatsExtensionProto
     * @classdesc Represents a UsageStatsExtensionProto.
     * @implements IUsageStatsExtensionProto
     * @constructor
     * @param {IUsageStatsExtensionProto=} [properties] Properties to set
     */
    function UsageStatsExtensionProto(properties) {
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * UsageStatsExtensionProto dataUsage.
     * @member {IAndroidDataUsageProto|null|undefined} dataUsage
     * @memberof UsageStatsExtensionProto
     * @instance
     */
    UsageStatsExtensionProto.prototype.dataUsage = null;

    /**
     * Creates a new UsageStatsExtensionProto instance using the specified properties.
     * @function create
     * @memberof UsageStatsExtensionProto
     * @static
     * @param {IUsageStatsExtensionProto=} [properties] Properties to set
     * @returns {UsageStatsExtensionProto} UsageStatsExtensionProto instance
     */
    UsageStatsExtensionProto.create = function create(properties) {
        return new UsageStatsExtensionProto(properties);
    };

    /**
     * Encodes the specified UsageStatsExtensionProto message. Does not implicitly {@link UsageStatsExtensionProto.verify|verify} messages.
     * @function encode
     * @memberof UsageStatsExtensionProto
     * @static
     * @param {IUsageStatsExtensionProto} message UsageStatsExtensionProto message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    UsageStatsExtensionProto.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.dataUsage != null && Object.hasOwnProperty.call(message, "dataUsage"))
            $root.AndroidDataUsageProto.encode(message.dataUsage, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
        return writer;
    };

    /**
     * Encodes the specified UsageStatsExtensionProto message, length delimited. Does not implicitly {@link UsageStatsExtensionProto.verify|verify} messages.
     * @function encodeDelimited
     * @memberof UsageStatsExtensionProto
     * @static
     * @param {IUsageStatsExtensionProto} message UsageStatsExtensionProto message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    UsageStatsExtensionProto.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a UsageStatsExtensionProto message from the specified reader or buffer.
     * @function decode
     * @memberof UsageStatsExtensionProto
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {UsageStatsExtensionProto} UsageStatsExtensionProto
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    UsageStatsExtensionProto.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.UsageStatsExtensionProto();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.dataUsage = $root.AndroidDataUsageProto.decode(reader, reader.uint32());
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a UsageStatsExtensionProto message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof UsageStatsExtensionProto
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {UsageStatsExtensionProto} UsageStatsExtensionProto
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    UsageStatsExtensionProto.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a UsageStatsExtensionProto message.
     * @function verify
     * @memberof UsageStatsExtensionProto
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    UsageStatsExtensionProto.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.dataUsage != null && message.hasOwnProperty("dataUsage")) {
            var error = $root.AndroidDataUsageProto.verify(message.dataUsage);
            if (error)
                return "dataUsage." + error;
        }
        return null;
    };

    /**
     * Creates a UsageStatsExtensionProto message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof UsageStatsExtensionProto
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {UsageStatsExtensionProto} UsageStatsExtensionProto
     */
    UsageStatsExtensionProto.fromObject = function fromObject(object) {
        if (object instanceof $root.UsageStatsExtensionProto)
            return object;
        var message = new $root.UsageStatsExtensionProto();
        if (object.dataUsage != null) {
            if (typeof object.dataUsage !== "object")
                throw TypeError(".UsageStatsExtensionProto.dataUsage: object expected");
            message.dataUsage = $root.AndroidDataUsageProto.fromObject(object.dataUsage);
        }
        return message;
    };

    /**
     * Creates a plain object from a UsageStatsExtensionProto message. Also converts values to other types if specified.
     * @function toObject
     * @memberof UsageStatsExtensionProto
     * @static
     * @param {UsageStatsExtensionProto} message UsageStatsExtensionProto
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    UsageStatsExtensionProto.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        var object = {};
        if (options.defaults)
            object.dataUsage = null;
        if (message.dataUsage != null && message.hasOwnProperty("dataUsage"))
            object.dataUsage = $root.AndroidDataUsageProto.toObject(message.dataUsage, options);
        return object;
    };

    /**
     * Converts this UsageStatsExtensionProto to JSON.
     * @function toJSON
     * @memberof UsageStatsExtensionProto
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    UsageStatsExtensionProto.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return UsageStatsExtensionProto;
})();

$root.ModifyLibraryRequest = (function() {

    /**
     * Properties of a ModifyLibraryRequest.
     * @exports IModifyLibraryRequest
     * @interface IModifyLibraryRequest
     * @property {string|null} [libraryId] ModifyLibraryRequest libraryId
     * @property {Array.<string>|null} [addPackageName] ModifyLibraryRequest addPackageName
     * @property {Array.<string>|null} [removePackageName] ModifyLibraryRequest removePackageName
     */

    /**
     * Constructs a new ModifyLibraryRequest.
     * @exports ModifyLibraryRequest
     * @classdesc Represents a ModifyLibraryRequest.
     * @implements IModifyLibraryRequest
     * @constructor
     * @param {IModifyLibraryRequest=} [properties] Properties to set
     */
    function ModifyLibraryRequest(properties) {
        this.addPackageName = [];
        this.removePackageName = [];
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * ModifyLibraryRequest libraryId.
     * @member {string} libraryId
     * @memberof ModifyLibraryRequest
     * @instance
     */
    ModifyLibraryRequest.prototype.libraryId = "";

    /**
     * ModifyLibraryRequest addPackageName.
     * @member {Array.<string>} addPackageName
     * @memberof ModifyLibraryRequest
     * @instance
     */
    ModifyLibraryRequest.prototype.addPackageName = $util.emptyArray;

    /**
     * ModifyLibraryRequest removePackageName.
     * @member {Array.<string>} removePackageName
     * @memberof ModifyLibraryRequest
     * @instance
     */
    ModifyLibraryRequest.prototype.removePackageName = $util.emptyArray;

    /**
     * Creates a new ModifyLibraryRequest instance using the specified properties.
     * @function create
     * @memberof ModifyLibraryRequest
     * @static
     * @param {IModifyLibraryRequest=} [properties] Properties to set
     * @returns {ModifyLibraryRequest} ModifyLibraryRequest instance
     */
    ModifyLibraryRequest.create = function create(properties) {
        return new ModifyLibraryRequest(properties);
    };

    /**
     * Encodes the specified ModifyLibraryRequest message. Does not implicitly {@link ModifyLibraryRequest.verify|verify} messages.
     * @function encode
     * @memberof ModifyLibraryRequest
     * @static
     * @param {IModifyLibraryRequest} message ModifyLibraryRequest message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    ModifyLibraryRequest.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.libraryId != null && Object.hasOwnProperty.call(message, "libraryId"))
            writer.uint32(/* id 1, wireType 2 =*/10).string(message.libraryId);
        if (message.addPackageName != null && message.addPackageName.length)
            for (var i = 0; i < message.addPackageName.length; ++i)
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.addPackageName[i]);
        if (message.removePackageName != null && message.removePackageName.length)
            for (var i = 0; i < message.removePackageName.length; ++i)
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.removePackageName[i]);
        return writer;
    };

    /**
     * Encodes the specified ModifyLibraryRequest message, length delimited. Does not implicitly {@link ModifyLibraryRequest.verify|verify} messages.
     * @function encodeDelimited
     * @memberof ModifyLibraryRequest
     * @static
     * @param {IModifyLibraryRequest} message ModifyLibraryRequest message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    ModifyLibraryRequest.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a ModifyLibraryRequest message from the specified reader or buffer.
     * @function decode
     * @memberof ModifyLibraryRequest
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {ModifyLibraryRequest} ModifyLibraryRequest
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    ModifyLibraryRequest.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ModifyLibraryRequest();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.libraryId = reader.string();
                break;
            case 2:
                if (!(message.addPackageName && message.addPackageName.length))
                    message.addPackageName = [];
                message.addPackageName.push(reader.string());
                break;
            case 3:
                if (!(message.removePackageName && message.removePackageName.length))
                    message.removePackageName = [];
                message.removePackageName.push(reader.string());
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a ModifyLibraryRequest message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof ModifyLibraryRequest
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {ModifyLibraryRequest} ModifyLibraryRequest
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    ModifyLibraryRequest.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a ModifyLibraryRequest message.
     * @function verify
     * @memberof ModifyLibraryRequest
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    ModifyLibraryRequest.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.libraryId != null && message.hasOwnProperty("libraryId"))
            if (!$util.isString(message.libraryId))
                return "libraryId: string expected";
        if (message.addPackageName != null && message.hasOwnProperty("addPackageName")) {
            if (!Array.isArray(message.addPackageName))
                return "addPackageName: array expected";
            for (var i = 0; i < message.addPackageName.length; ++i)
                if (!$util.isString(message.addPackageName[i]))
                    return "addPackageName: string[] expected";
        }
        if (message.removePackageName != null && message.hasOwnProperty("removePackageName")) {
            if (!Array.isArray(message.removePackageName))
                return "removePackageName: array expected";
            for (var i = 0; i < message.removePackageName.length; ++i)
                if (!$util.isString(message.removePackageName[i]))
                    return "removePackageName: string[] expected";
        }
        return null;
    };

    /**
     * Creates a ModifyLibraryRequest message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof ModifyLibraryRequest
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {ModifyLibraryRequest} ModifyLibraryRequest
     */
    ModifyLibraryRequest.fromObject = function fromObject(object) {
        if (object instanceof $root.ModifyLibraryRequest)
            return object;
        var message = new $root.ModifyLibraryRequest();
        if (object.libraryId != null)
            message.libraryId = String(object.libraryId);
        if (object.addPackageName) {
            if (!Array.isArray(object.addPackageName))
                throw TypeError(".ModifyLibraryRequest.addPackageName: array expected");
            message.addPackageName = [];
            for (var i = 0; i < object.addPackageName.length; ++i)
                message.addPackageName[i] = String(object.addPackageName[i]);
        }
        if (object.removePackageName) {
            if (!Array.isArray(object.removePackageName))
                throw TypeError(".ModifyLibraryRequest.removePackageName: array expected");
            message.removePackageName = [];
            for (var i = 0; i < object.removePackageName.length; ++i)
                message.removePackageName[i] = String(object.removePackageName[i]);
        }
        return message;
    };

    /**
     * Creates a plain object from a ModifyLibraryRequest message. Also converts values to other types if specified.
     * @function toObject
     * @memberof ModifyLibraryRequest
     * @static
     * @param {ModifyLibraryRequest} message ModifyLibraryRequest
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    ModifyLibraryRequest.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        var object = {};
        if (options.arrays || options.defaults) {
            object.addPackageName = [];
            object.removePackageName = [];
        }
        if (options.defaults)
            object.libraryId = "";
        if (message.libraryId != null && message.hasOwnProperty("libraryId"))
            object.libraryId = message.libraryId;
        if (message.addPackageName && message.addPackageName.length) {
            object.addPackageName = [];
            for (var j = 0; j < message.addPackageName.length; ++j)
                object.addPackageName[j] = message.addPackageName[j];
        }
        if (message.removePackageName && message.removePackageName.length) {
            object.removePackageName = [];
            for (var j = 0; j < message.removePackageName.length; ++j)
                object.removePackageName[j] = message.removePackageName[j];
        }
        return object;
    };

    /**
     * Converts this ModifyLibraryRequest to JSON.
     * @function toJSON
     * @memberof ModifyLibraryRequest
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    ModifyLibraryRequest.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return ModifyLibraryRequest;
})();

module.exports = $root;
